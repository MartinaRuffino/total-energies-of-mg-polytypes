*This tar file contains the fortran sources to the slatsm library, a
 collection of general-purpose math, variable and string manipulation
 routines developed or adapted by Mark van Schilfgaarde.

*email: Mark.vanSchilfgaarde@asu.edu

*The following decompresses the archive, if not already done:
    uudecode tarfile.encode
    rm -f -r ./slatsm
    gunzip -c SLATSM.version-number.tar.gz | tar xvf -

*The following directory should be present:
 slatsm/startup has several files to help get started.
 slatsm/tests   has drivers to check various routines.
 slatsm/BLAS    holds the source code to a subset of the BLAS
                (Basic Linear Algebra) routines; see www.netlib.org
                and in particular http://www.netlib.org/atlas/
 slatsm/LAPACK  holds the source code to a subset of the LAPACK math
                routines; see www.netlib.org
 libfftw.a      FFT library (see http://www.fftw.org)
                This is not a requirement, but it is strongly advised
                that the user start with an already installed FFT
                library; see step 1 in installation instructions below.

--------
INSTALLATION
--------

Starting with version 36, the installation procedure employs the GNU
configuration package (configuration script `configure', described
below) and is similar to standard installations of GNU software,
except in some respects described below.

For common machines, just invoking one of
   env CC-C-compiler FC=fortran-compiler  LIBLOC=libraries  ./configure
or just
   env FC=fortran-compiler  LIBLOC=libraries MACHINE=machine-mnemonic ./configure
should work properly.  

The 'machine mnemonic' is a shorthand label that identifies both the OS and
a default compiler.    The default mnemonic is 'VANILLA' but you will get
vanilla flags, such as -O.  Better to identify the appropriate mnemonic.
To get a list of the ones `configure' knows about, invoke
      startup/Makemakefile --show
`Makemakefile' is the script that keeps track mnemonics and associated flags.

To see if the mnemonic you chose will work, e.g. INTEL_IFORT, invoke
startup/Makemakefile and specify the compiler like this:
    env FC=ifort  startup/Makemakefile INTEL_IFORT --check
Finally to see the switches and libraries it will use, do:
    env FC=ifort  startup/Makemakefile INTEL_IFORT --defs

If the above invocation of `configure' doesn't work, try steps 1-3 below.

1. Determining machine configuration.
   The gnu software project specifies the machine architecture in the
   standard GNU form:
      CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
   You can get resolve this information using gnu script `configure.guess'
   In the top-level directory, type
      startup/config.guess 
   `config.guess' should generate exactly one line of standard output
   that specifies the machine architecture in the standard GNU form:
   If not, get a more recent version from GNU, or modify it yourself.

2.  This information is not required to install this library.
   `config.guess' tells you about the hardware configuration and OS,
   but says nothing about installed software (compilers) or libraries
   You supply this information in a condensed form by specifying a
   the `machine mnemonic,' which is a shorthand for a combination of
   machine hardware and compiler that `configure' needs to work.
   `configure' does need a machine mnemonic to work.

   Also you are advised to set the FC (and/or CC) environment variables to
   the compiler name(s), particularly if you are using a non-native
   fortran (and/or C) compiler. If you do not `configure' will try to
   find mnemonic for you, which comes with a default set of compiler.
   But it's better that you select them yourself.

    Do this, and Makemakefile will print a mnemonic if it knows about your machine:
       startup/Makemakefile `startup/config.guess`  --check
    On a DEC alpha, this returns LINUXA; on an Intel machine this returns LINUXI.
    The gnu fortran compiler will be used.
       env FC=fort startup/Makemakefile `startup/config.guess`  --check
    This will return 'LINUXF' on a DEC alpha running linux, with 'fort' installed.
       env FC=ifort startup/Makemakefile `startup/config.guess`  --check
    On an Intel, it will 'INTEL_IFORT'

  * Note : another way to get this package's idea of the appropriate mnemonic is to invoke
       startup/machine-mnemonic `startup/config.guess`
    or just 
       startup/machine-mnemonic
    If you know your compiler (say `fort') supply that information as well:
     startup/machine-mnemonic -FC=fort

    Once you've decided on a mnemonic, check whether
    `Makemakefile' recognizes the  configuration you've selected.
        startup/Makemakefile MNEMONIC --check
    or better still, if you know your fortran and/or C compiler names,
       env FC=fort CC=cc startup/Makemakefile LINUXF --check
    Adding the fortran (and C specifications) causes the script to verify
    that the compiler you use is consistent with with the mnemonic.

    Makemakefile will just return the mnemonic if it has no problem.

 ** PROBLEMS with mnemonic selection.  It is possible that you are using an
    inappropriate compiler, e.g. an Intel compiler on a DEC alpha: 
       env FC=ifc startup/Makemakefile LINUXF --check
    Or, it may be that Makemakefile needs to be updated for an
    architecture it doesn't know about.  Your choices at this stage are
      1. use the VANILLA mnemonic (which is very tolerant)
         It means you may have to some additional editing of the Makefile
         `configure' creates.
      2. Add a new mnemonic to Makemakefile 

   	 If you create your own mnemonic, Makemakefile should be able
   	 to identify the of the fortran and C compilers from the mnemonic
   	    (edit section # --- Default compilers ...)
   	 Set the C compiler flags
   	    (edit section # --------------- C compiler and flags ...)
   	 Set Fortran compiler flags and the linker name
   	    (edit section # --------------- fortran compiler and flags,)
   
   	 Example: for INTEL_IFC, Makemakefile generates this compiler-specific output
   	 	# ... C compiler and flags
   	 	CC = icc
   	 	CFLAGS =  -DINTEL_IFC -O
   	 	#CFLAGS =  -DINTEL_IFC -g
   	 	# ... Fortran compiler and flags, and linker ... for the INTEL IA32
   	 	FC = ifc
   	 	LK = ifc
   	 	FFLAGS = -O3 -cm -axW -WB
   	 	FFLAGS_LESS = -O2 -cm -WB
   	 	FFLAGS_LESS2 = -O1 -cm -WB
   	 	FFLAGS_NONE = -g -cm -WB
   	 	#FFLAGS =      -g -cm -WB
   	 	#FFLAGS_LESS = -g -cm -WB
   	 	#FFLAGS_LESS2 = -g -cm -WB
   	 	#FFLAGS_NONE = -g -cm -WB

 ** Some other known problems you may encounter:

 a. On the DEC alpha running DEC unix, do not invoke configure running
    shell /bin/sh -- it is buggy.  Use ksh, csh or tcsh.

 b. The Sun C preprocessor uses some nonstandard syntax.  If you are
    installing on a Sun, copy `configure.sun'to `configure'.

 c. The gnu F95 compiler gfortran has some bugs.  
    In particular in cannot handle r1mach.f.  As a workaround
    When invoking 'make', make will abort when compiling this routine.
    To eliminate the problem, compile with 
      g77 -c r1mach.o
      ar rv slatsm.a r1mach.o
    and re-invoke make.

 d. Failure to find an appropriate machine architecture.
    See step 1 above.

 e. The C or fortran compiler isn't in your path.  

3. Decide on what special math libraries you have installed on your
   machine that handle BLAS or LAPACK functions.  Some suggestions are
   offered by invoking 
      startup/Makemakefile --show
   Some of of `standard' ones, such as libdxml.a on the DEC alpha, are
   checked for automatically anyway.

   Starting with v39, the slatsm library has a front end for computing
   fast fourier transforms, fftz3.f.  There is an excellent
   public-domain FFT package, which it is strongly recommended you
   install; see http://www.fftw.org.  `configure' assumes by default
   that library libfftw.a is available, and the path to libfftw.a is
   included explicitly in the environment variable LIBLOC or that it
   will be found via compiler switch -lfftw.  While the slatsm library
   compiles without problems whether or not it finds libfftw.a, any
   package that attempts to link fftz3 will fail without it.  If for
   some reason you choose not to installation fftw, invoke the
   `configure' script with switch "--enable-fftw=no" .  A generic
   fortran fft code is supplied, but it is not particularly efficient.

   Set the LIBLOC environment variable to the libraries you will use.


... At this point, it is assumed you have a machine mnemonic anda compiler identified.


4. Invoke `./configure'. Before doing so, it's best to set
   environment variables FC, LIBLOC, and MACHINE, or pass them to configure, e.g
     env FC=fort MACHINE=LINUXF ./configure
   `configure' will attempt to automatically assess parameters you didn't supply
    to determine the mnemonic, and fortran and C compilers.

   At this point, it is assumed that Makemakefile can either determine
   the machine mnemonic from the environment variables you've
   specified, or you've specified a valied machine mnemonic yourself
   by setting the environment variable MACHINE.  

   You are also advised to inspect file `config.notes'

** `configure' may fail because Makamekfile can't identify or rejects
   a machine mnemonic, or of for some other reason. See step 2 if
   you have problems.

  *The standard distribution assumes that you have the BLAS and
   LAPACK library routines already installed somewhere.  If you do
   not, you must tell the install program `configure' to install with
   the source code supplied with this package, as described below.
   If an efficient BLAS library is not installed on your machine, you
   are encouraged to compile and install the public domain atlas
   library which you can get from http://www.netlib.org/atlas/.  Atlas
   contains an efficient BLAS3 library.  For the DEC alpha, a very fast
   dgemm is available; see
   ftp://www.netstat /= jp/pub/Linux/Linux-Alpha-JP/BLAS/
   (some version of this is installed automatically here).
   
   if you do not have BLAS or LAPACK installed in other libraries,
   invoke configure with some or all of these switches:
      ./configure --enable-blas --enable-blas3 --enable-lapack
   `configure' will copy the relevant files from the BLAS and LAPACK
   directories and the source code will be compiled and included as
   part of the Makefile.  `configure' will produce a warning message
   in either of these cases:

     You instruct it to include one of these packages, but the
     installed libraries you specify or that it finds apparently
     contain it already.
   
     You do not instruct it to include one of these packages, but the
     installed libraries cannot successfully link a test program with
     the libraries.

   If you get a message after running `configure', you may
   run it again with a different combination of --enable.

   `configure' should create the following:

   Make.inc            contains information about compiler switches
                       and the location of various libraries and executables.

   Make.init           An initialization Makefile (see step 7 below)

   Make.patch          machine-specific compilation rules.

   Makefile            A Makefile for the slatsm library.  should be 
                       machine-independent (except for what files you put
                       into the archive can depend on machine)

  *At this point, you may wish to alter the compiler switches.
   `configure' picked a set based on the machine configuration,
   and all the Makefiles use compiler switches in file 'Make.inc'.

  *If you have special libraries such as the atlas library, take some
   care about how arrange the LIBLOC libraries.  For example, using
   the Portland group pgf90 compiler on an Intel box running linux, with
   the ATLAS library (http://www.netlib.org/atlas/), use, e.g.
      env FC=pgf90 LIBLOC='-latlas -llapack -latlas -lblas' ./configure
   so that lapack routines also link in the fast atlas library.

  *configure may add some fortran codes, mainly copying them from BLAS
   or LAPACK libraries (and one or two other other special cases)
   that enlarges the list of files relative to the standard distribution.

 **Some problems you may encounter:

e. Failure to find correct C main entry point name: The slatsm library
   and other packages that call it typically use a C entry point as
   the main entry point, so that the packages can take advantages of
   C-specific functions (command-line arguments, getting environment
   variables, returning an number to the shell).

   The C-fortran correspondences (which `configure' SHOULD be able 
   determine automatically) are (see fmain.c)

   CMAIN           is the name of the entry point function, e.g. CMAIN=main

   ... the following describe how fortran function names are mangled
   FC_UNDERSCORE   if 0, means fortran appends no underscore to a function
                   if 1, means fortran appends an underscore to a function
                   if 2, means fortran appends two underscores to function names that already contain underscores

   FC_UPPERCASE    if 1, means fortran converts a function name to upper case


   ... The following are used for extracting command-line arguments from fortran
       There are two function calls fmain.c supplies for the command-line argument:
       nargc()        returns the number of arguments
       gtargc(iarg,s) returns particular argument iarg in string s.


   NOPASSEDARGS=#  if #=0 then argc, argv are passed to program entry point CMAIN
                   Functions nargc and gtargc just return data from supplied argc, argv.

                   if #=1 then argc, argv are not passed to program entry point CMAIN
                   and in an initialization step fmain.c uses the function calls to
                   extract the information and store it locally.
                   fmain then functions in the same way as NOPASSEDARGS = 0.

   ... the following three tokens are used when NOPASSEDARGS=1
   NARGFCALL=fn    name of function call that returns # arguments
                   It need not be supplied; however, 
                   nargc() always returns 0.

   ADD_TO_NARGFCALL=strn  (optionally used in conjunction with NARGFCALL=fn)
                   number-of-arguments = fn + strn
                   Designed for implementations that return something different from # args, e.g.
                   # args = iargc() + 1

   ARGFCALL=fn     name of function call that returns one entry in argv
                   It need not be supplied; however, gtargc is then not defined.


   If `configure' fails to find the name for the entry point (CMAIN),
   you must determine it yourself and add a line in "configure" that
   defines the correct name.  This can be done as follows: First write
   a fortran program that looks like this:
         call nosuchfunction
         end
   The purpose is to see the error printed when a nonexistent function is
   called.  Compile the program using the fortran compiler that "configure"
   had identified for your system (read the printed output from running 
   "configure" in order to find which compiler this is).  The resulting error
   message should contain a line similar to:
   "Error in function: main: (etc.) "
   The "main" may have some combination of capitalization and prepended or
   appended underscores.  This string (without the colon) is the C main 
   entry point that you must define.  Open "configure" and search for the 
   line that reads "Begin commenting for manual definition of C main"
   Place a "#" at the beginning of each subsequent line until you reach
   the line that reads "End commenting for manual definition of C main".
   On the next line, add a line that looks like this:
   export ac_cv_fc_main=<correct C main name>
   If, for instance, you found the correct name to be MAIN_, then you should
   add a line that reads:
   export ac_cv_fc_main=MAIN_
   Save the changes to "configure" and run configure as normal.
   
6. Remove file slatsm.a

7. Invoke 
     make -f Make.init 
   Fortran files `*.f' must be created using the ccomp utility.
   Original source files are are kept in `*.for' ; 
   Make.init uses the ccomp utility to convert them to machine-specific `*.f'
   It also may do other architecture-specific initialization.
   Original `.for' files are never altered.

   CAUTION:  old scripts, such as slatsm-to-cray, have not been maintained.
   Anything whose time stamp preceds 2006 should be looked at with care!

** Possible problems with `make'
   `make' on some machines such as the SGI will not work; use gnu `gmake'

8. Invoke `make' to compile the slatsm library.

9. Invoke `make check' to test the operation of some of the most
   important branches of the code.  The checks are not complete, nor
   are they very sophisticated, and in some cases checks may fail when
   really the errors are minor.  See tests/test.slatsm for a list of
   which machine architectures have been checked.

 **test 7, which checks whether arguments may be read from the command
   line, is not as portable as it might be.

   `config.notes' may provide some hints.

   One possibility is to try commenting the line (routine cmdopt.f)
         call gtargc(iarg,strn)
   and uncommenting the line
         call getarg(iarg,strn)
   and see whether that works.

--------
Platform-specific problems
--------
Below are some known platform-specific problems with the code.

* DEC unix (mnemonic DECA)

  1. Tests may fail because the default soft limits are often set low.
     Invoke 'unlimit' before running tests.

  2. The 'make' utility works differently than on other platforms.
     However, 'configure' makes special accomodation for it.

* IBM SP2
  BLAS routine dcopy in the essl library, does not copy elements
  in order.  While this is not strictly a bug, some of the routines
  that overwrite parts of an array assume that the first element
  is copied first, the second copied second, etc.  To avoid this
  problem, add BLAS/dcopy.f into the slatsm library.
  It may be the origin of the following comment from T. Paxton:

  "The essl library seems all screwed up. I got a lot of garbage until
   I used the blas and lapack from the SLATSM distribution.  Oddly
   enough all the slatsm tests worked execpt the yqinv in which the
   yqinv inverted properly but the n and h lapack calls didn't."
   
* SUN sparc (e.g. sparc-sun-solaris2.8)
  The awk utility does not function as on other platforms, so the
  testing scripts fail even when programs produce the correct results.
  Correct by installing GNU awk; see prep.ai.mit.edu.
  Also the C compiler does not function in a standard way.
  copy 'configure.sun' to 'configure' before starting.

--------
Contacts
--------

This package was assembled or written by Mark van Schilfgaarde.
For comments or reporting errors, send mail to Mark.vanSchilfgaarde@asu.edu

--------
Functions in slatsm.a
--------
 These routine perform various functions, typically math functions,
 string manipulation routines and i/o handling; see below for a partial
 description.

 There are two groups of C-language routines, that are intended for
 functions outside the capabilities of fortran 77.  It is portable
 provided your program has a C compiler.  These are:

   fmain.c contains the global main; much of this library requires
   fortran programs using it let fmain.c be the entry point from the
   operating system.  main immediately calls the (user) fortran
   subroutine `fmain', which proceeds in the usual way.  The purpose
   here is to permit the fortran programs to extract command-line
   arguments in a dos- or unix-like environment.  You can invoke from
   a fortran program the following:

     nargc() is an integer function returning the number of arguments
       on the command line.

     getarf(iarg,strn) is a subroutine that returns the IARGth string
       from the command line.

   fsubs.c contains functions that are difficult for, or extend the
   capabilities of standard fortran.  You can call the following from
   a fortran program:

     subroutine fsystm(STRN,i) generates a system call of command STRN.
       The value returned to the shell is returned in i.

     subroutine cwrite(strn,i1,i2,nwlin) writes strn(i1..i2) to stdout,
        can either suppress a newline, or flush stdout.

     integer function locase(strn) converts `strn' to lower case.

     subroutine ftime(strn) returns the date and time in strn (26 characters)

     subroutine gtenv(name,strn) returns the value of environment variable
       `name' in strn.

     subroutine faloc(name,cast,size) is a fortran-callable memory allocator
       calling malloc.  Useful only for compilers with pointer capability.

 Many of the routines are taken from linpack or eispack.  Some of them, such
 as htridx are adapted from eispack but are optimized for risc machines.
 Each routine has a one-line summary of its function, which you can extract
 by invoking in directory slatsm
     grep '^C- ' *.f

 Some routines rely on the following functionality
   -- fortran compatible dynamic memory allocation (alloc.f)
   -- evaluation of expressions as passed in string form (a2bin.f)
   -- `standard form' for matrices stored on disk (rdm.f)
   -- a variety of string manipulation routines (strings.f,words.f,cpstr.f)

 A partial list of of the library functions:

  a2bin     converts to a binary number a string representing
            an algebraic expression.

  a2rotm    generate Euler angles from a sequence of rotations, ascii input

  a2vec     like a2bin, but for a sequence of expressions

  afcmd     allows extra arguments to be effectively added to the
            command line

  alloc     A fortran-compatible collection of dynamic memory management.
            routines.  For fortran compatibility, it works a little
            differently than the unix malloc

  amix      Anderson mixing of a vector to accelerate convergence in iterations

  arrprt    Prints out a table in multi-column format

  awrite    Formatted output, with ascii conversion of binary numbers
            It is patterned vaguely on the unix C routine printf, but has
            different capabilities.

  bin2a     Converts a binary number to a string in a "pretty" format

  bitops    A variety of bitwise operations

  brmin     One Broyden step in finding the root of an n-dimensional function

  cmdopt    Determines whether a command-line switch was supplied, and
            returns that switch.

  cpstr     some string manipulation routines

  cpudel    contains cpusec, which is process cputime, in seconds
            Routine cpudel is deprecated in favor of tc

  crdbf     Conditional read of an array in a binary format (see ywrm)

  d1mach    blas machine constants

  dpdbyl

  d*        a suite of real matrix manipulation routines
            For a brief list and desription, in directory slatsm invoke
              egrep '^C- ' d*.f

  falsi     Find a root by a modified regula falsi

  fftz3     A front end for computing fast fourier transforms.

  finits    Machine and compiler-dependent initialization for many programs

  fopna     File opening routines.  fopna serves two purposes: first to
            extract machine-dependence of file opening, and second,
            it keeps a list of unique files handle associated with names.
            Thus, the caller need not pay much attention to uniqueness of
            fortran file handles.

  fpiint    Points and weights for integration on a sphere surface

  garg      Returns vector numerical vals for a specified command-line argument

  getcat    low-level routines for a format-free file input.

  gradzr    Find zero in gradients of a multivariate function

  getgvf    Scatter-gather operations for mapping points on a full grid
            to a smaller list

  h*        A variety of eispack-compatible array operations on
            complex hermitian matrices.
            For a brief list and desription, in directory slatsm invoke
              egrep '^C- ' h*.f

  huntst    Brackets a string within an ordered array of strings

  huntx     Brackets a value within an ordered array of points

  i1mach    Integer machine constants, extension of BLAS routine

  idnear    Finds the index of element closest to specified value

  ipsw      Unpack a set of integers switches from a string

  isanrg    Sanity check for integer value

  ivheap    Heapsort array of integer vectors
  ivshel    Shell sort of a array of integer vectors

  mkdlst    Resolve ascii string as a vector of double-precision numbers

  mklagw    Quadrature weights for Laguerre Gaussian quadrature
  mklegw    Quadrature points and weights for Legendre Gaussian quadrature

  mstmin    Fletcher-Powell minimisation of a function of n coordinate variables.

  nintsp    Points and weights for integration on a sphere surface

  packi     Pack/unpack integer or double precision elements in a struc by index

  pade      Generate Pade approximation on at a list of points

  parchv    Parses a string for one or more character variable declarations

  polcof    Coefficients to interpolating polynomial given a tabulated function
  poldif    Differentiate by polynomial interpolation tabulated function
  poldvm    Derivative of tabulated function by rational function interpolation

  poseof    Positions file handle at end-of-file

  ppfac     Find all products of prime factors within some cutoff

  praxis    Minimisation of a function of n variables without derivatives

  pretty    "prettifies" a string representation of a floating-point number

  rdfiln    Reads one line from a file, with the possiblity of substition
            of expression, and flow control over which lines are read.

  rdm       Matrix input, parsing file with rdfiln.

  rfalsi    Find root of a function by a modified regular falsi method.

  s8tor8    Store character*(*) string in a double-precision variable.

  stkops    various stack operations

  symvar    Management of symbolic scalar variables

  symvec    Management of symbolic vector variables

  strings   Fortran string manipulation routines
  words
  wordg

  yy*       are complex math routines, with the real and imaginary parts
            separated from each other.
            For a brief list and desription, in directory slatsm invoke
              egrep '^C- ' y*.f

  y*        are complex math routines, with varying treatments of
            real and imaginary parts.

  z*        are complex math routines, using complex*16 arithmetic
            For a brief list and desription, in directory slatsm invoke
              egrep '^C- ' z*.f

  ztoyy     Converts between different representations of complex arithmetic
