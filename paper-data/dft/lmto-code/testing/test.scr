#!/bin/tcsh -f

# This file is a shell script to test the linear response acceleration of convergence

alias call 'set retcall = \!\!:2 ; set callarg = \!\!:3 ; goto \!\!:1'
alias runjob 'set retcall = \!\!:1; set outfile = \!\!:2 ; set callarg = \!\!:3 ; goto runjob'
alias query 'set retcall = \!\!:1 ; set retcall2 = \!\!:2 ; set callarg = \!\!:3 ; goto query'
alias zcat 'gunzip -c'
alias zcat 'cat'

set a
set slow
set testfile = $0
set testdir = $testfile:h
set topdir  = `(cd $testdir/..; pwd)`
set space = '        '
set arglst = ($argv)
# echo $arglst
set allpass

# --- Pick off switches ---
while (`echo $1 | sed -e 's/\(.\).*/\1/' `  ==  "-")

  set arg1 = $1; shift
  if ($?verb) echo test.lm: parsing switch $arg1
  switch ($arg1)
    case "--quiet":
      set quiet
      unset slow
      breaksw
    case "--no-iact*":
      unset slow
      breaksw
    case "--add0":
      set add0 = `which add0`
      if (! -x "$add0") then
        echo "test.dmft (abort): missing add0"
        exit
      endif
      breaksw
    case "--poszer":
      set poszer = `which poszer`
      if (! -x "$poszer") then
        echo "test.dmft (abort): missing poszer"
        exit
      endif
      breaksw
    case "--modeleps":
      set modeleps
      breaksw
    case "--clean":
      set clean
      breaksw
    case "--MPIK":
      set MPIK
      breaksw
    case "--verb*":
      set verb = 1
      breaksw
    default:
      echo unrecognized switch $arg1
      echo 'usage: test.scr [switches] [test-list]'
      echo '       test-list is a list of test cases, e.g.: 1 3'
      echo '       switches:'
      echo '       --no-iactive runs tests without prompting user'
      echo '       --MPIK       runs tests using lm'
      echo '       --modeleps   runs tests using model epsilon'
      echo '       --quiet runs tests without prompting user'
      echo '       --verbose    script prints out extra information'
      exit -1
  endsw

end

set joblist = ($argv)
if ($#joblist == 0 ) set joblist = (1 2 3 4 5 6 7)

echo $joblist | grep 1 >/dev/null
if ($status) goto chk1e
cat <<EOF

         --- Test 1.  Input file ctrl.scr ---
         Test of the linear response estimate of self-consistency
         NB: test destroys or changes files *.scr
EOF
set pass
query chk11 chk1e 'run this test'
chk11:
if ($?clean) then
  echo "$space rm -f {a11,a12,a13,a21,a22,a23,as1,as2,as3,e11,e12,e13,e21,e22,e23,ga1,ga2,ga3,log,mixm,out,save,sv,moms,wkp,psta,evec,ctrl,sdot,str}.scr"
               rm -f {a11,a12,a13,a21,a22,a23,as1,as2,as3,e11,e12,e13,e21,e22,e23,ga1,ga2,ga3,log,mixm,out,save,sv,moms,wkp,psta,evec,ctrl,sdot,str}.scr
  goto chk1e
endif
set refout=$testdir/out.scr  testout=out.scr
if ($?modeleps) set refout=$testdir/out.scr.iscr4
if ($?MPIK) set refout=$testdir/out.scr-MPIK

# for debugging script
# goto chk1sd

if ($?modeleps) goto chk13
query chk12 chk13 'generate a new psta'
chk13:

echo "$space ... make on-site screened W"
             rm -f *.scr; cp $testdir/ctrl.scr .
echo "$space lmstr scr >/dev/null"
             lmstr scr >/dev/null
echo "$space lm scr -vnit=0 -vscr=11 --time=5 --no-iactive >out.scr"
             lm scr -vnit=0 -vscr=11 --time=5 --no-iactive >out.scr
echo "$space zcat $testdir/psta.scr >psta.scr"
             zcat $testdir/psta.scr >psta.scr
if ($?modeleps) goto chk15
goto chk14


chk12:
echo "$space ... make psta.scr"
echo "$space rm -f *.scr; cp $testdir/ctrl.scr ."
             rm -f *.scr; cp $testdir/ctrl.scr .
echo "$space lmstr scr >/dev/null"
             lmstr scr >/dev/null
echo "$space lm scr -vnit=0 -vscr=11 --time=5 <<END >out.scr"
             lm scr -vnit=0 -vscr=11 --time=5 <<END >out.scr
1
i
END
set retval = $status
if ($retval != 0) goto cleanup
if ($?quiet) then
else
echo "$space lm returned successfully"
endif

chk14:
if ($?quiet) then
else
echo "$space ... compare psta.scr to that in testing ... largest difference is:"
echo "$space mcx -qr psta.scr -qr $testdir/psta.scr -- -max:g"
             mcx -qr psta.scr -qr $testdir/psta.scr -- -max:g
endif

if (`mcx -qr psta.scr -qr $testdir/psta.scr -- -max:g | tail -1 | awk '{{k=($3)>0?($3):(-$3);} print (k<=.000001)}'`) then
  echo "$space maximum difference in psta.scr and $testdir/psta.scr < 1e-6? ..." yes
else
  echo "$space maximum difference in psta.scr and $testdir/psta.scr < 1e-6? ... no (aborting)"
  unset pass
  unset allpass
  exit -1
endif

chk15:
set scr = 2
if ($?modeleps) set scr = 4
if ($?MPIK) then
#    echo "$space ... self-consistency using psta.scr ... MPIK mode ... making soft links for strx"
#    foreach i ( 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 )
#      rm -f str.scr_$i
#      ln -s str.scr str.scr_$i
#      rm -f sdot.scr_$i
#      ln -s sdot.scr sdot.scr_$i
#    end
  echo "$space mpirun -n 6 lm scr -vmet=3 -vnit=10 -vscr=$scr --no-iactive --time=5 >>out.scr"
               mpirun -n 6 lm scr -vmet=3 -vnit=10 -vscr=$scr --no-iactive --time=5 >>out.scr
else
  echo "$space lm scr -vnit=10 -vscr=$scr --no-iactive --time=5 >>out.scr"
               lm scr -vnit=10 -vscr=$scr --no-iactive --time=5 >>out.scr
endif

if ($?quiet) then
else
echo ' '
echo "$space ... Compare first screened output density to file $refout":
grep SCRMOM: $testout | sed -n 1,2p
echo ' ---'
zcat $refout | grep SCRMOM: | sed -n 1,2p
endif

call showout chk1sb SV
chk1sb:

call showout chk1sc CPU
chk1sc:

call zdiffiles chk1sd "$testout $refout"
chk1sd:

set udv = `grep SCRMOM: $testout | sed -n 1,1p | awk '{print substr($3,4)}'`
set sdv = `grep SCRMOM: $testout | sed -n 1,1p | awk '{print substr($5,4)}'`
set udvr = `zcat $refout | grep SCRMOM: | sed -n 1,1p | awk '{print substr($3,4)}'`
set sdvr = `zcat $refout | grep SCRMOM: | sed -n 1,1p | awk '{print substr($5,4)}'`
echo -n "$space initial unscreened dv equal to reference? ... "
if (`echo $udv $udvr | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k==0)}'`) then
  echo yes
else
  echo no
  unset pass
  unset allpass
endif

echo -n "$space initial screened dv equal to reference? ... "
if (`echo $sdv $sdvr | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k==0)}'`) then
  echo yes
else
  echo no
  unset pass
  unset allpass
endif

set udq = `grep SCRMOM: $testout | sed -n 1,2p | tail -1 | awk '{print substr($3,4)}'`
set sdq = `grep SCRMOM: $testout | sed -n 1,2p | tail -1 | awk '{print substr($5,4)}'`
set udqr = `zcat $refout | grep SCRMOM: | sed -n 1,2p | tail -1 | awk '{print substr($3,4)}'`
set sdqr = `zcat $refout | grep SCRMOM: | sed -n 1,2p | tail -1 | awk '{print substr($5,4)}'`

echo -n "$space initial unscreened dq equal to reference? ..."
if (`echo $udq $udqr | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k==0)}'`) then
  echo yes
else
  echo no
  unset pass
  unset allpass
endif

echo -n "$space initial screened dq equal to reference? ... "
if (`echo $sdq $sdqr | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k<2e-4)}'`) then
  echo yes
else
  echo no
  unset pass
  unset allpass
endif

if ($?pass) then
    echo "$space test 1 PASSED"
else
    echo "$space test 1 FAILED"
endif

chk1e:
echo ' '
if ($?allpass) then
    exit 0
else
    exit -1
endif

# ---------------- qprint (print only quiet not set) --------------
exit $allpass
qprint:
  set quitjob=$retcall
  if ($?quiet) goto $quitjob
  echo "$callarg"
  goto $quitjob

# ---------------- zdiffiles --------------
exit
zdiffiles:
  set quitjob=$retcall
  if ($?quiet) goto $quitjob
  set files = "$callarg"
  query zdiff11 $quitjob "compare $files"
zdiff11:
  zdiff $files
  goto $quitjob

# ---------------- showout --------------
exit
showout:
  set quitjob=$retcall
  if ($?quiet) goto $quitjob
  echo ' '
  echo "$space ... Compare $callarg to line(s) in file $refout":
  grep $callarg $testout
  if (`cat $testout | grep $callarg | wc | awk '{print $1}'` > 1) echo ' ---'
  zcat $refout | grep $callarg
  goto $quitjob

# ---------------- runjob --------------
exit
runjob:
  set quitjob=$retcall
  if ($outfile == ".") then
    echo "$space $callarg"
    echo " "
    $callarg
    set retval = $status
  else
    if (`echo $outfile | awk '{print substr($1,1,2)}'` == '>>') then
      set appfile = `echo $outfile | awk '{print substr($1,3)}'`
      echo "$space $callarg  >> $appfile"
      $callarg >> $appfile
      set retval = $status
    else
      echo "$space $callarg  > $outfile"
      $callarg > $outfile
      set retval = $status
  endif
  if ($retval != 0) goto cleanup
  goto $quitjob


# ---------------- cleanup --------------
exit
cleanup:
  if ($retval != 0) echo "$space Program lm returned with error status $retval"
  if ($retval != 0) echo "$space ... $testfile aborting"
  exit $retval

# ---------------- query --------------
exit
query:
  unset skip
  if ($?slow != 0) then
    echo "$space"'*'"hit <return> to $callarg, s <return> to skip it."
    set a = ($<)
    if ($a == "") goto $retcall
    switch ($a)
      case "quit":
      case "q":
      case "a":
        exit
      case "i":
        unset slow
        breaksw
      case "s":
        set skip
        breaksw
      case "t":
        time
        goto query
      default:
        echo 'q to quit; i unsets slow; s skips this job, t shows time'
        goto query
    endsw
  endif
  if ($?skip) goto $retcall2
  goto $retcall

