#!/bin/tcsh -f

# Tests the operation of ctrl file checker, lmchk

alias call 'set retcall = \!\!:2 ; set callarg = \!\!:3 ; goto \!\!:1'
alias runjob 'set retcall = \!\!:1; set outfile = \!\!:2 ; set callarg = \!\!:3 ; goto runjob'
alias findcmd  'set retcall = \!\!:1 ; set prog_cmd = \!\!:2 ; set path_name = \!\!:3 ; set make_path = \!\!:4 ; goto findcmd'
alias query 'set retcall = \!\!:1 ; set retcall2 = \!\!:2 ; set callarg = \!\!:3 ; goto query'
alias compare_res 'set retcall = \!\!:1; set keyword = \!\!:2 ; set testvar = \!\!:3 ; set refvar = \!\!:4 ; set tol = \!\!:5 ; set passvar = \!\!:6 ; goto compare_res'
alias zcmpmfiles_res_0 'set retcall = \!\!:1; set keyword = \!\!:2 ; set tol = \!\!:3 ; set passvar = \!\!:4 ; set ndig = \!\!:5 ; set srcfile = \!\!:6 ; set reffile = \!\!:7 ; goto zcmpmfiles_res_0 '

alias zcat 'gunzip -c'
alias zcat 'cat'

set a
set slow
set testfile = $0
set testdir = $testfile:h
set topdir  = `(cd $testdir/..; pwd)`
set tmpdir = $cwd
set space = '        '
set failed = 0

# Prepend current working-directory, top-level dir and maindir to path
set path = ($cwd $topdir $topdir/utils $path)

# --- Pick off switches ---
while (`echo $1 | sed -e 's/\(.\).*/\1/' `  ==  "-")

  set arg1 = $1; shift
  if ($?verb) echo test.ovlp: parsing switch $arg1
  switch ($arg1)
    case "--quiet":
      set quiet
      unset slow
      breaksw
    case "--add0":
      set add0 = `which add0`
      if (! -x "$add0") then
        echo "test.dmft (abort): missing add0"
        exit
      endif
      breaksw
    case "--poszer":
      set poszer = `which poszer`
      if (! -x "$poszer") then
        echo "test.dmft (abort): missing poszer"
        exit
      endif
      breaksw
    case "--clean":
      set clean
      breaksw
    case "--no-iact*":
      unset slow
      breaksw
    case "--list":
      goto showtests
      breaksw
    case "--whichexec"
      set quiet; unset quiet
      findcmd chk00 lmchk "$path" "$topdir"
      chk00:
      exit 0
      breaksw
    case "--noplot*":
      set noplot
      set have_pldos
      unset have_pldos
      set have_fplot
      unset have_fplot
      breaksw
    case "--verb*":
      set verb = 1
      breaksw
    default:
      echo " test.ovlp: unrecognized switch $arg1"
      echo 'usage: test.ovlp [switches] [test-list]'
      echo '       test-list is a list of test cases, e.g.: 1 3'
      echo '       switches:'
      echo '       --no-iactive runs tests without prompting user'
      echo '       --quiet runs tests without prompting user'
      echo '       --verbose    script prints out extra information'
      exit -1
  endsw

end

if (! $?quiet) echo "$space ... lmchk tests"

set joblist = ($argv)
if ($#joblist == 0 ) set joblist = (1 2 3 4 5 6 7 8 9)

echo $joblist | sed s/10// | grep 1 >/dev/null
if ($status) goto chk1e
cat <<EOF

         ------- Test 1.  Input file ctrl.scr ---
         Tests lmchk and the ES overlap minimizer for a Schottky barrier (--mino~z)

EOF

set refout=$testdir/out.lmchk.scr  testout=out.lmchk.scr ext=scr
set pass
query chk11 chk1e 'run this test'
chk11:
findcmd chk11a lmchk "$path" "$topdir"
chk11a:

if ($?clean) then
  touch a11.scr
  echo "$space rm -f {ctrl,log,out,a[123][123],e[123][123],ga[123],as[123]}.scr $testout"
               rm -f {ctrl,log,out,a[123][123],e[123][123],ga[123],as[123]}.scr $testout
  goto chk1e
endif
echo "$space cp $testdir/ctrl.scr ."
             cp $testdir/ctrl.scr .
runjob chk12 $testout "lmchk --mino~z  scr"
chk12:
if (! $?quiet) echo "$space Program lmchk returned successfully."
if ($?poszer) then
 echo -n "         ..." ; $poszer $testout
else if ($?add0) then
 echo -n "         ..." ; $add0 $testout
endif

if ($?quiet) goto chk1pa
query chk1s chk1s2 "compare $testout $refout"
chk1s:
zdiff $testout $refout
chk1s2:

chk1pa:
set avgoi = `cat $testout | grep fovl  | sed -n 1,1p | awk '{print $9}' | sed s/%//`
set avgof = `cat $testout | grep fovl  | tail -1 | awk '{print $7}' | sed s/%//`
set maxoi = `cat $testout | grep fovl  | sed -n 1,1p | awk '{split($13, a, ","); print a[1]}' | sed s/%//`
set maxof = `cat $testout | grep fovl  | tail -1 | awk '{print $11}' | sed s/%//`

set avgoir = `zcat $refout | grep fovl  | sed -n 1,1p | awk '{print $9}' | sed s/%//`
set avgofr = `zcat $refout | grep fovl  | tail -1 | awk '{print $7}' | sed s/%//`
set maxoir = `zcat $refout | grep fovl  | sed -n 1,1p | awk '{split($13, a, ","); print a[1]}' | sed s/%//`
set maxofr = `zcat $refout | grep fovl  | tail -1 | awk '{print $11}' | sed s/%//`

if (! $?quiet) then
  echo " "
  echo "$space Average initial sphere overlap atom = $avgoi %"
  echo "$space             corresponding reference = $avgoir %"
  echo "$space Maximum initial sphere overlap atom = $maxoi %"
  echo "$space             corresponding reference = $maxoir %"

  echo " "
  echo "$space Average   final sphere overlap atom = $avgof %"
  echo "$space             corresponding reference = $avgofr %"
  echo "$space Maximum   final sphere overlap atom = $maxof %"
  echo "$space             corresponding reference = $maxofr %"

endif

echo " "
compare_res chk1pb "Initial average overlap" $avgoi $avgoir 0 pass
chk1pb:
compare_res chk1pc "Initial maximum overlap" $maxoi $maxoir 0 pass
chk1pc:
compare_res chk1pd "Final average overlap" $avgof $avgofr 0 pass
chk1pd:
compare_res chk1pe "Final maximum overlap" $maxof $maxofr 0 pass
chk1pe:
echo " "

if ($?pass) then
    echo "$space lmchk test 1 PASSED ($ext)"
else
    echo "$space lmchk test 1 FAILED ($ext)"
    set failed = ($failed 1)
endif
chk1e:

echo $joblist | grep 2 >/dev/null
if ($status) goto chk2e
cat <<EOF

         ------- Test 2.  Input file ctrl.bi2te3 ---
         Tests lmchk's empty sphere finder (--findes) and site file generator (--wsitex)

EOF
if (! $?quiet) then
cat <<EOF2

         Also tested :

           1. automatic sphere size adjuster,
              with the Te radii constrained to its starting value

           2. The ability to include a shear.

           3. The generation of a site file

         The ES species data was copied to the SPEC category in the input file
         to enable you to run checks including empty spheres.
	 After this test executes, try:
            lmchk -vles=1 bi2te3
         and note that the sphere resizer essentially keeps sphere radii unchanged.

         Note also that the Bi sphere radius is very large.
         It is better to reduce its radius while allowing the ES radii to increase.
         The sphere resizer will do this if you remove the 10's digit in SCLWSR=10.99.
         (It tells the resizer to scale non-ES radii before the ES radii.)
         With the modified SCLWSR do:
            lmchk -vles=1 bi2te3
         and observe that the Bi and ES radii scale more symmetrically.

EOF2
endif

set refout=$testdir/out.lmchk.bi2te3  testout=out.lmchk.bi2te3 ext=bi2te3
set pass

query chk21 chk2e 'run this test'
chk21:
findcmd chk21a lmchk "$path" "$topdir"
chk21a:


touch ctrl.$ext
echo "$space rm -f {ctrl,log,bi,te,te2,poses}.$ext $testout"
             rm -f {ctrl,log,bi,te,te2,poses}.$ext $testout
if ($?clean) then
  goto chk2e
endif
echo "$space cp $testdir/ctrl.$ext ."
             cp $testdir/ctrl.$ext .
runjob chk22 $testout "lmchk -vles=0 --findes --wsitex~fn=essite $ext"
chk22:
if (! $?quiet) echo "$space Program lmchk returned successfully."
if ($?poszer) then
 echo -n "         ..." ; $poszer $testout
else if ($?add0) then
 echo -n "         ..." ; $add0 $testout
endif

if ($?quiet) goto chk2s2
query chk2s chk2s2 "compare $testout $refout"
chk2s:
zdiff $testout $refout
chk2s2:

echo " "
# cmp poses.$ext $testdir/poses.$ext >/dev/null
if ($?poszer) then
 echo -n "         ..." ; $poszer poses.$ext
else if ($?add0) then
 echo -n "         ..." ; $add0 poses.$ext
endif
diff -w poses.$ext $testdir/poses.$ext >/dev/null
set retval = $status
if ($retval == 0) then
  echo "$space ... files poses.$ext and $testdir/poses.$ext equivalent? ..." yes
  set pass
else
  echo "$space ... files poses.$ext and $testdir/poses.$ext equivalent? ..." no
  unset pass
endif
# endif

if ($?pass) then
    echo "$space lmchk test 2 PASSED ($ext)"
else
    echo "$space lmchk test 2 FAILED ($ext)"
    set failed = ($failed 2)
endif

chk2e:


echo $joblist | grep 3 >/dev/null
if ($status) goto chk3e
cat <<EOF

         ------- Test 3.  Input file ctrl.bi2te3 ---
         Tests lmchk's sphere-radius finder (--getwsr) for Bi2Te3
         Also tests automatic sphere size adjuster and the effect of adding shear.

EOF

set refout=$testdir/out.lmchk-getwsr.bi2te3  testout=out.lmchk.bi2te3 ext=bi2te3
set pass

query chk31 chk3e 'run this test'
chk31:
findcmd chk31a lmchk "$path" "$topdir"
chk31a:


touch ctrl.$ext
echo "$space rm -f {ctrl,log,bi,te,te2}.$ext $testout"
             rm -f {ctrl,log,bi,te,te2}.$ext $testout
if ($?clean) then
  goto chk3e
endif
echo "$space cp $testdir/ctrl.$ext ."
             cp $testdir/ctrl.$ext .
runjob chk32 $testout "lmchk -vles=0 --getwsr --pr45 $ext"
chk32:
if (! $?quiet) echo "$space Program lmchk returned successfully."
if ($?poszer) then
 echo -n "         ..." ; $poszer $testout
else if ($?add0) then
 echo -n "         ..." ; $add0 $testout
endif

call diffiles chk3s "CPU -1 $testout $refout"
chk3s:

echo " "
set rTe = `grep '1   Te'  $testout | tail -1 | awk '{print $3}'`
set rTeref = `zgrep '1   Te' $refout | tail -1 | awk '{print $3}'`
set srTe = `grep '1   Te'  $testout | tail -1 | awk '{print $4}'`
set srTeref = `zgrep '1   Te' $refout | tail -1 | awk '{print $4}'`

set rBi = `grep '2   Bi'  $testout | tail -1 | awk '{print $3}'`
set rBiref = `zgrep '2   Bi' $refout | tail -1 | awk '{print $3}'`
set srBi = `grep '2   Bi'  $testout | tail -1 | awk '{print $4}'`
set srBiref = `zgrep '2   Bi' $refout | tail -1 | awk '{print $4}'`

if (! $?quiet) then
  echo " "
  echo "$space unscaled Te sphere radius found by lmchk    = $rTe"
  echo "$space unscalad reference radius                   = $rTeref"
  set ediff = `echo $rTe $rTeref  | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print k}'`
  echo "$space difference                                  = $ediff"
  echo "$space scaled Te sphere radius found by lmchk      = $srTe"
  echo "$space scalad reference radius                     = $srTeref"
  set ediff = `echo $srTe $srTeref  | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print k}'`
  echo "$space difference                                  = $ediff"

  echo " "
  echo "$space unscaled Bi sphere radius found by lmchk    = $rBi"
  echo "$space unscalad reference radius                   = $rBiref"
  set ediff = `echo $rBi $rBiref  | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print k}'`
  echo "$space difference                                  = $ediff"
  echo "$space scaled Bi sphere radius found by lmchk      = $srBi"
  echo "$space scalad reference radius                     = $srBiref"
  set ediff = `echo $srBi $srBiref  | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print k}'`
  echo "$space difference                                  = $ediff"
  echo " "
endif

set drtol = 1d-6

# ... Check that sphere radii are within tol of reference
compare_res chk3ca "unscaled Te sphere radius" $rTe $rTeref $drtol  pass
chk3ca:
compare_res chk3cb "scaled Te sphere radius" $srTe $srTeref $drtol  pass
chk3cb:
compare_res chk3cc "unscaled Bi sphere radius" $rBi $rBiref $drtol  pass
chk3cc:
compare_res chk3cd "scaled Bi sphere radius" $srBi $srBiref $drtol  pass
chk3cd:

if ($?pass) then
    echo "$space lmchk test 3 PASSED ($ext)"
else
    echo "$space lmchk test 3 FAILED ($ext)"
    set failed = ($failed 3)
endif

chk3e:

echo $joblist | grep 4 >/dev/null
if ($status) goto chk4e
cat <<EOF

         ------- Test 4.  Add empty spheres to lattice positions ---
         This test uses lmchk's empty site locator (--findes)
         to add empty spheres/floating orbitals to 5-6-7 compound SbSeI.

EOF
if (! $?quiet) then
cat <<EOF2
         The ctrl file ($testdir/ctrl.sbsei) was autogenerated by blm (testing/test.blm 2)
         Read the tutorial associated with this test to generate a (ctrl,site) file pair,
         tailored to a GW calculation and including autogenerated floating orbitals.

EOF2
endif

set pass
set ext=sbsei
set refout=$testdir/out.lmchk.$ext  testout=out.$ext
if (! -e $refout) then
   echo ' '
   echo " test.ovlp aborting ... missing file $refout"
   exit -1
endif
if (! -e $testdir/ctrl.$ext) then
   echo ' '
   echo " test.ovlp aborting ... missing file $testdir/ctrl.$ext"
   exit -1
endif

query chk41 chk4e 'run this test'
chk41:
findcmd chk41b lmchk "$path" "$topdir"
chk41b:

if ($?clean) then
  echo "$space rm -f {ctrl,se,sb,i,poses,out,log,essite}.sbsei"
               rm -f {ctrl,se,sb,i,poses,out,log,essite}.sbsei
  goto chk4e
endif

echo "$space cp $testdir/{ctrl,site}.sbsei ."
             cp $testdir/{ctrl,site}.sbsei .
# echo "$space copy ctrl.sbsei to ctrl.sbsei, uncommenting sphere resizer tag"
# echo "$space cat $testdir/ctrl.sbsei  | sed 's/# SCLWSR=21/  SCLWSR=21/' > ctrl.sbsei"
#              cat $testdir/ctrl.sbsei  | sed 's/# SCLWSR=21/  SCLWSR=21/' > ctrl.sbsei

runjob chk42 $testout "lmchk ctrl.$ext --findes --nescut=12 --wsitex@short@fn=essite --sfill~sclwsr=21~wsrmax=3.3"
chk42:
if (! $?quiet) echo "$space Program lmchk returned successfully."
if ($?poszer) then
 echo -n "         ..." ; $poszer $testout
else if ($?add0) then
 echo -n "         ..." ; $add0 $testout
endif

call diffiles chk4s2 "CPU -1 $testout $refout"
chk4s2:

echo " "
if ($?poszer) then
 echo -n "         ..." ; $poszer poses.$ext
else if ($?add0) then
 echo -n "         ..." ; $add0 poses.$ext
endif
diff -w poses.$ext $testdir/poses.$ext >/dev/null
set retval = $status
if ($retval == 0) then
  echo "$space ... files poses.$ext and $testdir/poses.$ext equivalent? ..." yes
  set pass
else
  echo "$space ... files poses.$ext and $testdir/poses.$ext equivalent? ..." no
  unset pass
endif

diff -w essite.$ext $testdir/essite.$ext >/dev/null
set retval = $status
if ($retval == 0) then
  echo "$space ... files essite.$ext and $testdir/essite.$ext equivalent? ..." yes
  set pass
else
  echo "$space ... files essite.$ext and $testdir/essite.$ext equivalent? ..." no
  unset pass
endif

# endif

if ($?pass) then
    echo "$space lmchk test 4 PASSED ($ext)"
else
    echo "$space lmchk test 4 FAILED ($ext)"
    set failed = ($failed 4)
endif

chk4e:


echo $joblist | sed s/10// | grep 5 >/dev/null
if ($status) goto chk5e
cat <<EOF

         ------- Test 5.  Input file ctrl.biobr ---
         Demonstrates --fixlat and --fixpos switches.
         Lattice vectors as given are slightly distorted from exact hexagonal symmetry.
         Point group ops found by symmetry finder are similarly slightly distorted

         Switch --fixplat uses the symops to adjust the lattice vectors, and subsequently
         adjusts the point group based on updated lattice vectors.

         Switch --fixpos adjusts the site positions to be compatible with symops.

EOF

set refout=$testdir/out.lmchk.biobr  testout=out.lmchk.biobr ext=biobr
set pass
query chk51 chk5e 'run this test'
chk51:
findcmd chk51a lmchk "$path" "$topdir"
chk51a:

if ($?clean) then
  touch ctrl.biobr
  echo "$space rm -f *.biobr $testout"
	       rm -f *.biobr $testout
  goto chk5e
endif
echo "$space cp $testdir/{ctrl,essite}.biobr ."
             cp $testdir/{ctrl,essite}.biobr .
runjob chk52 $testout "lmchk ctrl.biobr --fixlat --fixpos"
chk52:
if (! $?quiet) echo "$space Program lmchk returned successfully."
if ($?poszer) then
 echo -n "         ..." ; $poszer $testout
else if ($?add0) then
 echo -n "         ..." ; $add0 $testout
endif

if ($?quiet) goto chk5pa

echo
echo -n "$space change in |plat|        "
cat $testout | grep 'updated g' | awk '{print $2}' | sed 's/|plat|=//'
echo -n "$space change in |g|           "
cat $testout | grep 'updated g' | awk '{print $4}' | sed 's/|g|=//'
echo -n "$space error in g after shift  "
cat $testout | grep 'updated g' | awk '{print $NF}' | sed 's/g=//'
echo

query chk5s chk5s2 "compare $testout $refout"
chk5s:
zdiff $testout $refout
chk5s2:

chk5pa:
echo
set errg = `cat $testout | grep 'updated g' | awk '{print $NF}' | sed s/g=//`
set drtol = 1e-15
echo -n "$space Error in updated g less than $drtol ? ... "
if (`echo $errg $drtol | awk '{print ($1<=$2)}'`) then
  echo yes
else
  echo no
  unset pass
endif

if ($?pass) then
    echo "$space lmchk test 5 PASSED ($ext)"
else
    echo "$space lmchk test 5 FAILED ($ext)"
    set failed = ($failed 5)
endif
chk5e:


echo $joblist | sed s/10// | grep 6 >/dev/null
if ($status) goto chk6e
cat <<EOF

         ------- Test 6.  Input file ctrl.kfese ---
         Demonstrates printout of angles between atom triplets
         and angles between spins defined through Euler angles.

         This test prints out angles only between second neighbors of a selected list.
	 To print out angles between first neighbors only, use --euler~r=6~sign~sites=24,22,9:22:2
	 To print out angles between first and second neighbors only, use --euler~r=10~sign~sites=24,22,9:22:2

EOF

set refout=$testdir/out.lmchk.kfese  testout=out.lmchk.kfese ext=kfese
set pass
query chk61 chk6e 'run this test'
chk61:
findcmd chk61a lmchk "$path" "$topdir"
chk61a:

if ($?clean) then
  touch ctrl.kfese
  echo "$space rm -f *.kfese $testout $testout.1 $testout.2"
	       rm -f *.kfese $testout $testout.1 $testout.2
  goto chk6e
endif
echo "$space cp $testdir/{ctrl,eula,rsta,site}.kfese ."
             cp $testdir/{ctrl,eula,rsta,site}.kfese .
runjob chk62 $testout "lmchk ctrl.kfese --rs=1,0 -vfile=t -vnc=1 --angles~r=2~sites=9,25 --euler~r=10,6~sign~sites=24,22,9:22:2"
chk62:
if (! $?quiet) echo "$space Program lmchk returned successfully."
if ($?poszer) then
 echo -n "         ..." ; $poszer $testout
else if ($?add0) then
 echo -n "         ..." ; $add0 $testout
endif

if ($?quiet) goto chk6pa
query chk6s chk6s2 "compare $testout $refout"
chk6s:
zdiff $testout $refout
chk6s2:

chk6pa:
grep -v CPU $testout > $testout.1
zcat $refout | grep -v CPU > $testout.2
echo -n "$space files $testout and $refout equivalent to 6 digits? ..."
call zcmpnfiles chk6c2 "exclude=START|CPU 6 $testout.1 $testout.2"
chk6c2:
  if ($retval == 0) then
    echo yes
  else if (`echo ' ' | awk -v ndiff=$retval -v ntot=$ncharfile '{print (100*ndiff/ntot<1.)}'` == 1) then
    echo ok "($retval difference(s) of $ncharfile)"
  else
    echo no "($retval difference(s) of $ncharfile)"
    unset pass
  endif
endif

if ($?pass) then
    echo "$space lmchk test 6 PASSED ($ext)"
else
    echo "$space lmchk test 6 FAILED ($ext)"
    set failed = ($failed 6)
endif
chk6e:

echo $joblist | sed s/10// | grep 7 >/dev/null
if ($status) goto chk7e
cat <<EOF

         ------- Test 7.  Input file ctrl.cuo ---
         Demonstrates extended neighbor table printout

EOF

set refout=$testdir/out.lmchk.cuo  testout=out.lmchk.cuo ext=cuo
set pass
query chk71 chk7e 'run this test'
chk71:
findcmd chk71a lmchk "$path" "$topdir"
chk71a:

if ($?clean) then
  touch ctrl.$ext
  echo "$space rm -f *.$ext $testout $testout.1 $testout.2"
	       rm -f *.$ext $testout $testout.1 $testout.2
  goto chk7e
endif
echo "$space cp $testdir/{ctrl,site}.$ext ."
             cp $testdir/{ctrl,site}.$ext .
runjob chk72 $testout "lmchk ctrl.$ext --shell:r=1.5:tab --angles --pr50"
chk72:
if (! $?quiet) echo "$space Program lmchk returned successfully."
if ($?poszer) then
 echo -n "         ..." ; $poszer $testout
else if ($?add0) then
 echo -n "         ..." ; $add0 $testout
endif

if ($?quiet) goto chk7pa
query chk7s chk7s2 "compare $testout $refout"
chk7s:
zdiff $testout $refout
chk7s2:

chk7pa:
grep -v CPU $testout > $testout.1
zcat $refout | grep -v CPU > $testout.2
echo -n "$space files $testout and $refout equivalent to 6 digits? ..."
call zcmpnfiles chk7c2 "exclude=START|CPU 6 $testout.1 $testout.2"
chk7c2:
  if ($retval == 0) then
    echo yes
  else if (`echo ' ' | awk -v ndiff=$retval -v ntot=$ncharfile '{print (100*ndiff/ntot<1.)}'` == 1) then
    echo ok "($retval difference(s) of $ncharfile)"
  else
    echo no "($retval difference(s) of $ncharfile)"
    unset pass
  endif
endif

if ($?pass) then
    echo "$space lmchk test 7 PASSED ($ext)"
else
    echo "$space lmchk test 7 FAILED ($ext)"
    set failed = ($failed 7)
endif
chk7e:

echo $joblist | sed s/10// | grep 8 >/dev/null
if ($status) goto chk8e
cat <<EOF

         ------- Test 8.  Input file ctrl.nbfe ---
         Demonstrates hard-sphere-like relaxation of an Nb/Fe interface
         using the --mino switch.

EOF

set refout=$testdir/out.lmchk.nbfe  testout=out.lmchk.nbfe ext=nbfe
set pass
query chk81 chk8e 'run this test'
chk81:
findcmd chk81a lmchk "$path" "$topdir"
chk81a:

if ($?clean) then
  touch ctrl.nbfe
  echo "$space rm -f *.nbfe $testout $testout.1 $testout.2"
	       rm -f *.nbfe $testout $testout.1 $testout.2
  goto chk8e
endif
echo "$space cp $testdir/{ctrl,site}.nbfe ."
             cp $testdir/{ctrl,site}.nbfe .
runjob chk82 $testout "lmchk nbfe --mino~dxmx=.001~xtol=.0001~nkill=10~maxit=60~1:21"
chk82:
if (! $?quiet) echo "$space Program lmchk returned successfully."
if ($?poszer) then
 echo -n "         ..." ; $poszer $testout
else if ($?add0) then
 echo -n "         ..." ; $add0 $testout
endif

if ($?quiet) goto chk8pa
query chk8s chk8s2 "compare $testout $refout"
chk8s:
zdiff $testout $refout
chk8s2:

chk8pa:
set avgoi = `cat $testout | grep fovl  | sed -n 1,1p | awk '{print $9}' | sed s/%//`
set avgof = `cat $testout | grep fovl  | tail -1 | awk '{print $7}' | sed s/%//`
set maxoi = `cat $testout | grep fovl  | sed -n 1,1p | awk '{print $13}' | sed s/%//`
set maxof = `cat $testout | grep fovl  | tail -1 | awk '{print $11}' | sed s/%//`

set avgoir = `zcat $refout | grep fovl  | sed -n 1,1p | awk '{print $9}' | sed s/%//`
set avgofr = `zcat $refout | grep fovl  | tail -1 | awk '{print $7}' | sed s/%//`
set maxoir = `zcat $refout | grep fovl  | sed -n 1,1p | awk '{print $13}' | sed s/%//`
set maxofr = `zcat $refout | grep fovl  | tail -1 | awk '{print $11}' | sed s/%//`

if (! $?quiet) then
  echo " "
  echo "$space Average initial sphere overlap atom = $avgoi %"
  echo "$space             corresponding reference = $avgoir %"
  echo "$space Maximum initial sphere overlap atom = $maxoi %"
  echo "$space             corresponding reference = $maxoir %"

  echo " "
  echo "$space Average   final sphere overlap atom = $avgof %"
  echo "$space             corresponding reference = $avgofr %"
  echo "$space Maximum   final sphere overlap atom = $maxof %"
  echo "$space             corresponding reference = $maxofr %"

endif

echo " "
compare_res chk8pb "Initial average overlap" $avgoi $avgoir 0 pass
chk8pb:
compare_res chk8pc "Initial maximum overlap" $maxoi $maxoir 0 pass
chk8pc:
compare_res chk8pd "Final average overlap" $avgof $avgofr 0 pass
chk8pd:
compare_res chk8pe "Final maximum overlap" $maxof $maxofr 0 pass
chk8pe:
echo " "

if ($?pass) then
    echo "$space lmchk test 8 PASSED ($ext)"
else
    echo "$space lmchk test 8 FAILED ($ext)"
    set failed = ($failed 8)
endif
chk8e:

echo $joblist | sed s/10// | grep 9 >/dev/null
if ($status) goto chk9e
cat <<EOF

         ------- Test 9.  Input file ctrl.co ---
         Demonstrates --syml switch

EOF

set refout=$testdir/out.lmchk.co  testout=out.lmchk.co ext=co
set pass
query chk91 chk9e 'run this test'
chk91:
findcmd chk91a lmchk "$path" "$topdir"
chk91a:

if ($?clean) then
  touch ctrl.$ext
  echo "$space rm -f *.$ext syml.$ext $testout"
	       rm -f *.$ext syml.$ext $testout
  goto chk9e
endif
echo "$space cp $testdir/{ctrl}.$ext ."
             cp $testdir/{ctrl}.$ext .
runjob chk92 $testout "lmchk ctrl.$ext --syml"
chk92:
if (! $?quiet) echo "$space cp syml.co syml1.co"
                            cp syml.co syml1.co
runjob chk92a ">>$testout" "lmchk ctrl.$ext --syml~n=21~mq~lblq:G=0,0,0,A=0,0,1/2,H=1/3,1/3,1/2,K=1/3,1/3,0,M=1/2,0,0~lbl=AGH,KMG"
chk92a:
if (! $?quiet) echo "$space Program lmchk returned successfully."
if ($?poszer) then
 echo -n "         ..." ; $poszer $testout
else if ($?add0) then
 echo -n "         ..." ; $add0 $testout
endif

if ($?quiet) goto chk9pa
query chk9s chk9s2 "compare $testout $refout"
chk9s:
zdiff $testout $refout
chk9s2:

chk9pa:
diff -w syml1.$ext $testdir/syml1.$ext >/dev/null
set retval = $status
if ($retval == 0) then
  echo "$space ... files syml1.$ext and $testdir/syml1.$ext equivalent? ..." yes
  set pass
else
  echo "$space ... files syml1.$ext and $testdir/syml1.$ext equivalent? ..." no
  unset pass
endif
diff -w syml.$ext $testdir/syml.$ext >/dev/null
set retval = $status
if ($retval == 0) then
  echo "$space ... files syml.$ext and $testdir/syml.$ext equivalent? ..." yes
  set pass
else
  echo "$space ... files syml.$ext and $testdir/syml.$ext equivalent? ..." no
  unset pass
endif

if ($?pass) then
    echo "$space lmchk test 9 PASSED ($ext)"
else
    echo "$space lmchk test 9 FAILED ($ext)"
    set failed = ($failed 9)
endif
chk9e:

# --- Summary ---
echo ' '
if ($#failed <= 1) then
    echo "$space $testfile : all tests PASSED ($ext)"
    echo " "
    exit 0
else
    shift failed
    echo "$space $testfile : These tests FAILED:" $failed
    echo " "
    exit -1
endif

# ---------------- zcmpnfiles --------------
# Compares two files, treating each field as a number.
# call arguments should contain 3 strings: n test-file reference-file
# |n| = number of digits which numbers are truncated to.
# If n<0, sort files before comparing them
# You can preced the first call argument with one of
#   nlines=#       specifies that the check is made on the first # lines only
#   exclude=regex  excludes lines containing regex
# Files with .gz or .Z extensions are assumed to be gzipped.
# (nlines doesn't work with gzipped files; sorry)
# Returns with retval = number of differences in reduced files.
# Example :  call zcmpnfiles chk25 "6 dos-cls.$ext $testdir/dos-cls.$ext.gz"
# Creates temporary files $tmpdir/tmp_compnfile_1 $tmpdir/tmp_compnfile_2
exit
zcmpnfiles:
  set quitjob=$retcall
  set zcmpnargs = ($callarg)

  set exclude ; unset exclude
  set nlines ; unset nlines
zcmpnfiles2:
  switch ($zcmpnargs[1])
    case "nlines=*":
      set nlines = `echo $zcmpnargs[1] | sed s/nlines=//`
      @ nlines = $nlines  # Checks to make sure this is an integer
      shift zcmpnargs
      goto zcmpnfiles2

    case "exclude=*":
      set exclude = `echo $zcmpnargs[1] | sed s/exclude=//`
      shift zcmpnargs
      goto zcmpnfiles2

    default:
  endsw

  set digits = $zcmpnargs[1]
  if ($digits < 0) then
    @ digits = - $digits
    set lsort
  endif
# set a = ' { for (i = NF; i > 0; --i) printf " %.'$digits'f", $i; printf "\n" }'
# set a = ' { for (i = 1; i <= NF; i++) { k = sprintf("%.'$digits'f",$i); if (k+k == 0) k = 0 ; printf "%s ", k}; printf "\n" }'
  set a = ' { for (i = 1; i <= NF; i++) { k = sprintf("%.'$digits'f",$i); if (k+k == 0) k = 0 ; printf "%s ", k}; print "" }'

  set fn1 = $tmpdir/tmp_compnfile_1
  set fn2 = $tmpdir/tmp_compnfile_2
  if ("$zcmpnargs[2]:e" == 'gz' || "$zcmpnargs[2]:e" == 'Z') then
    set cat1 = 'gunzip -c'
  else
    set cat1 = cat
    if ($?nlines) then
      set cat1 = "head -$nlines"
    endif
  endif
  if ("$zcmpnargs[3]:e" == 'gz' || "$zcmpnargs[3]:e" == 'Z') then
    set cat2 = 'gunzip -c'
  else
    set cat2 = cat
    if ($?nlines) then
      set cat2 = "head -$nlines"
    endif
  endif

  if ($?lsort && $?exclude) then
    $cat1  $zcmpnargs[2] | egrep -v "$exclude" | sed s/D-/E-/g | sed s/D+/E+/g | sort | awk "$a" > $fn1
    $cat2  $zcmpnargs[3] | egrep -v "$exclude" | sed s/D-/E-/g | sed s/D+/E+/g | sort | awk "$a" > $fn2
  else if ($?lsort) then
    $cat1  $zcmpnargs[2] | sed s/D-/E-/g | sed s/D+/E+/g | sort | awk "$a" > $fn1
    $cat2  $zcmpnargs[3] | sed s/D-/E-/g | sed s/D+/E+/g | sort | awk "$a" > $fn2
  else if ($?exclude) then
    $cat1  $zcmpnargs[2] | egrep -v "$exclude" | sed s/D-/E-/g | sed s/D+/E+/g | awk "$a" > $fn1
    $cat2  $zcmpnargs[3] | egrep -v "$exclude" | sed s/D-/E-/g | sed s/D+/E+/g | awk "$a" > $fn2
  else
    $cat1  $zcmpnargs[2] | sed s/D-/E-/g | sed s/D+/E+/g | awk "$a" > $fn1
    $cat2  $zcmpnargs[3] | sed s/D-/E-/g | sed s/D+/E+/g | awk "$a" > $fn2
  endif
  set ncharfile = `wc $fn1 | awk '{print $3}'`
  cmp $fn1 $fn2 >/dev/null
  set retval = $status

  if ($retval == 0) rm -f $fn1 $fn2
  if ($retval == 0) goto $quitjob

  set retval = `cmp -l $fn1 $fn2 |& grep -v EOF | wc | awk '{printf "%d", $1}'`
  if ($retval == 0) set retval = '-1'
  rm -f $fn1 $fn2
  goto $quitjob

# ---------------- qprint (print only quiet not set) --------------
exit
qprint:
  set quitjob=$retcall
  if ($?quiet) goto $quitjob
  echo "$callarg"
  goto $quitjob

# ---------------- diffiles --------------
# calling argument should consist of four strings:
# 1st string = string that terminates diff
# 2nd string = integer that counts how many times terminator should occur before terminating
# 3nd string = first file name
# 4th string = second file name
# example: call diffiles chk69 "CPU 3 $testout $refout"
exit
diffiles:
  set quitjob=$retcall
  if ($?quiet) goto $quitjob
  set files = ($callarg)
  set endstr = $files[1]
  shift files
  set nend = $files[1]
  shift files
  if ($nend == "-1") then
    set nend = `grep "$endstr" $files[1] | wc | awk '{print $1}'`
  endif

#    echo difffiles : $quitjob $nend
#    grep $endstr $files[1]

  query diff11 $quitjob "compare $files"
diff11:
  diff $files | awk -v endstr=$endstr -v nend=$nend -v endl=0 -v endr=0 '{if ($1 == "<" && endl < nend) print ; if ($1 == ">" && endr < nend) print ; if ($1 == ">" || $1 == "<" || endl >= nend && endr >= nend) ; else {print} ; if ($1 == "<" && $2 == endstr) {endl+=1}; if ($1 == ">" && $2 == endstr) {endr+=1};}' | sed -n 1,50p
  goto $quitjob


# ---------------- showout --------------
exit
showout:
  set quitjob=$retcall
  if ($?quiet) goto $quitjob
  echo ' '
  echo "$space ... Compare $callarg to line(s) in file $refout":
  grep $callarg $testout
  if (`cat $testout | grep $callarg | wc | awk '{print $1}'` > 1) echo ' ---'
  gunzip -c $refout | grep $callarg
  goto $quitjob

# ---------------- compare_res --------------
# Compares two numbers $testvar-$refvar and unsets $passvar if |testvar-refvar|<tol
# usage: compares_res retcall keyword testvar refvar tol passvar
#   keyword      : label (for printout)
#   testvar      : first number
#   refvar       : second number
#   tol          : tolerance
#   passvar      : $passvar is unset if |testvar-refvar|<tol
exit
compare_res:
  set quitjob=$retcall
# echo $retcall $keyword $testvar $refvar $tol $passvar
  echo -n "$space $keyword ($testvar) within tol ($tol) of reference ($refvar)? ... "
  set toll = `echo $tol | sed s/d/e/`
  if (`echo $testvar $refvar | awk -v tol=$toll '{{k=($1-$2)>0?($1-$2):($2-$1);tl=1.001*tol} print (k<=tl)}'`) then
    echo yes
  else
    echo no
    unset $passvar
  endif
  goto $quitjob

# ---------------- findcmd --------------
# Finds an executable program within the supplied path
# Usage: findcmd return_label executable_command path_name make_path
# If $executable_command is not found, findcmd does one of the following:
# If make_path = 'no' : returns silently.
# Otherwise findcmd aborts with a message, which assumes
# $make_path is the path where $executable_command is made.
exit
findcmd:
set found = 'no'
foreach ac_dir ($path_name)
 if (-x $ac_dir/$prog_cmd) then
   set $prog_cmd = $ac_dir/$prog_cmd
   set found = 'yes'
   break
 endif
end
if (! $?quiet) then
  if ($found == 'yes') echo "$space ... using executable $ac_dir/$prog_cmd"
  if ($found == 'no')  echo "$space ... no executable $prog_cmd found in path"
endif
if ($found == 'no' && $make_path != "no") then
  echo "  "
  echo "  Sorry, $testfile cannot find program '"$prog_cmd"' it needs to execute."
  echo "  '"$prog_cmd"' was not found in supplied path, or in the following:"
  echo "        $topdir"
# echo "  ... This script ($testfile) requires binary "'"rdcmd"'" to run."
  echo "  You must create or put '"$prog_cmd"' in your path before invoking this script."
  echo "  Normally '"$prog_cmd"' is created as part of the installation process."
  echo "  Invoking '"make $prog_cmd"' in $make_path should create it."
  echo "  $testfile aborting ..."
  exit -1
endif
goto $retcall

# ---------------- runjob --------------
exit
runjob:
  set quitjob=$retcall
  if ($outfile == ".") then
    echo "$space $callarg"
    echo " "
    $callarg
    set retval = $status
  else
    if (`echo $outfile | awk '{print substr($1,1,2)}'` == '>>') then
      set appfile = `echo $outfile | awk '{print substr($1,3)}'`
      echo "$space $callarg  >> $appfile"
      $callarg >> $appfile
      set retval = $status
    else
      echo "$space $callarg  > $outfile"
      $callarg > $outfile
      set retval = $status
  endif
  if ($retval != 0) goto cleanup
  goto $quitjob


# ---------------- cleanup --------------
exit
cleanup:
  if ($retval != 0) echo "$space Program returned with error status $retval"
  if ($retval != 0) echo "$space ... $testfile aborting"
  exit $retval

# ---------------- query --------------
exit
query:
  unset skip
  if ($?slow != 0) then
    echo "$space"'*'"hit <return> to $callarg, s <return> to skip it."
    set a = ($<)
    if ($a == "") goto $retcall
    switch ($a)
      case "quit":
      case "q":
      case "a":
        exit
      case "i":
        unset slow
        breaksw
      case "s":
        set skip
        breaksw
      case "t":
        time
        goto query
      default:
        echo 'q to quit; i unsets slow; s skips this job, t shows time'
        goto query
    endsw
  endif
  if ($?skip) goto $retcall2
  goto $retcall

# ---------------- List tests --------------
showtests:
cat <<EOF
  Usage: invoke with:    $testfile job-list

  Material   job      Tests
   GaAs/Pt    1       tests empty sphere overlap minimizer (--mino~z)
   Bi2Te3     2       tests empty sphere finder (--findes)
   Bi2Te3     3       tests WS radius finder (--getwsr)
   SbSeI      4       tests empty sphere finder (--findes) with aim of adding floating orbitals
   BiOBr      5       Demonstrates --fixlat and --fixpos switches.
   KFeSe      6       Prints bond angles between atom triplets and angles between spin axes
   CuO        7       Demonstrates extended neighbor table printout
   NbFe       8       Tests hard-sphere-like relaxation at an interface
   Co         9       Demonstrates --syml switch

EOF
exit

# ---------------- usage: --------------
usage:
cat <<EOF
 usage: test.ovlp [switches] [testcase-list]
        e.g., "test.ovlp 1 2"
        Switches:
        --list       list available materials and tests (no tests are made)
        --no-iactive runs tests without prompting user
        --quiet runs tests with minimal output and without prompting user
        --whichexec  prints out which lmchk executable it finds in path and exits
#       --verbose    script prints out extra information
EOF
exit -1
