#!/bin/tcsh -f

# A shell script testing operation of basic lm package
# set verbose

alias call 'set retcall = \!\!:2 ; set callarg = \!\!:3 ; goto \!\!:1'
alias runjob 'set retcall = \!\!:1; set outfile = \!\!:2 ; set callarg = \!\!:3 ; goto runjob'
alias runrdcmd 'set retcall = \!\!:1; set rdcmdfmt = \!\!:2 ; set outfile = \!\!:3 ; set callarg = \!\!:4 ; goto runrdcmd'
alias findcmd  'set retcall = \!\!:1 ; set prog_cmd = \!\!:2 ; set path_name = \!\!:3 ; set make_path = \!\!:4 ; goto findcmd'
alias compare_res 'set retcall = \!\!:1; set keyword = \!\!:2 ; set testvar = \!\!:3 ; set refvar = \!\!:4 ; set tol = \!\!:5 ; set passvar = \!\!:6 ; goto compare_res'
alias get_resf 'set retcall = \!\!:1; set testvar = \!\!:2 ; set refvar = \!\!:3 ; set keyword = \!\!:4  ; set arg_number = \!\!:5 ; set occur_number = \!\!:6 ; set sed_strn = \!\!:7 ; goto get_resf'
alias cnvt_d_fmt  'set retcall = \!\!:1; set testvar = \!\!:2 ; set testval = \!\!:3 ; goto cnvt_d_fmt'
alias query 'set retcall = \!\!:1 ; set retcall2 = \!\!:2 ; set callarg = \!\!:3 ; goto query'
alias compare_res_0 'set retcall = \!\!:1; set keyword = \!\!:2 ; set testvar = \!\!:3 ; set tol = \!\!:4 ; set passvar = \!\!:5 ; goto compare_res_0'
alias zcmpmfiles_res_0 'set retcall = \!\!:1; set keyword = \!\!:2 ; set tol = \!\!:3 ; set passvar = \!\!:4 ; set ndig = \!\!:5 ; set srcfile = \!\!:6 ; set reffile = \!\!:7 ; goto zcmpmfiles_res_0 '
alias zcat 'gunzip -c'
alias zcat 'cat'
# alias mpix mpirun

set a
set slow
set testfile = $0
set testdir = $testfile:h
set topdir  = `(cd $testdir/..; pwd)`
set tmpdir = $cwd
set space = '        '
set arglst = ($argv)
#echo $arglst
set failed = 0
set nmpi = 6

# Prepend current working-directory, top-level dir and maindir to path
set path = ($cwd $topdir $topdir/utils $path)

# see if fplot is available
set plot = `which fplot`
if (-x "$plot") then
  if `$plot -h | sed -n 1,1p | awk '{print ($1 == "fplot")}'` set have_fplot
endif
set pldos = `which pldos`
if (-x "$pldos") then
  if `$pldos -h | sed -n 1,1p | awk '{print ($2 == "pldos")}'` set have_pldos
endif
# see if ghostscript is available
set gs = `which gs`
if (-x "$gs") then
  if `$gs --help | sed -n 1,1p | awk '{print ($2 == "Ghostscript")}'` set have_ghostscript
endif
# see if gnu grep is available
echo X | grep -A 1 X > & /dev/null
set retval = $status
if ($retval == 0) set gnu_grep

# --- Pick off switches ---
while (`echo $1 | sed -e 's/\(.\).*/\1/' `  ==  "-")

  set arg1 = $1; shift
  if ($?verb) echo test.lm: parsing switch $arg1
  switch ($arg1)
    case "--quiet":
      set quiet
      unset slow
      breaksw
    case "--all":
      breaksw
    case "--add0":
      set add0 = `which add0`
      if (! -x "$add0") then
        echo "test.dmft (abort): missing add0"
        exit
      endif
      breaksw
    case "--poszer":
      set poszer = `which poszer`
      if (! -x "$poszer") then
        echo "test.dmft (abort): missing poszer"
        exit
      endif
      breaksw
    case "--MPIK=*":
     set narg = `echo $arg1 | sed s/--MPIK=// | awk '{print split($0, a, "," )}'`
     if ($narg < 1 || $narg > 1) then
       echo 'lmgw (abort): bad argument list to MPI=..'
       exit -1
     endif
#    extract nmpi from argument
     set nmpi = `echo $arg1 | sed s/--MPIK=// | awk '{split($0, a, "," ); print a[1]}'`
#    check to ensure argument is a valid integer
     @ nmpi = $nmpi
    case "--MPIK":
      set MPIK
      breaksw
    case "--clean":
      set clean
      breaksw
    case "--no-iact*":
      unset slow
      breaksw
    case "--haveout":
      set haveout
      breaksw
    case "--libxc":
      set with_libxc
      breaksw
    case "--list":
      goto showtests
      breaksw
    case "--whichexec"
      set quiet; unset quiet
      findcmd chk00 lmstr "$path" "$topdir"
      chk00:
      findcmd chk01 lm "$path" "$topdir"
      chk01:
      exit 0
      breaksw
    case "--noplot*":
      set noplot
      set have_pldos
      unset have_pldos
      set have_fplot
      unset have_fplot
      breaksw
    case "--verb*":
      set verb = 1
      breaksw
    default:
      echo " test.lm: unrecognized switch $arg1"
      goto usage
  endsw

end

set joblist = ($argv)
if ($#joblist == 0 ) set joblist = (1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16)

echo $joblist | egrep '\b1\b' >/dev/null
if ($status & "$joblist" != "gas"  && "$joblist" != "gaas" ) goto chk1e
cat <<EOF

         ------- Test 1.  Input file ctrl.gas (lmchk,lmstr,lm,lmdos) ---
         This file contains input for GaAs.
         Tests lmstr,lm and checker lmchk and band- and dos- generating programs
         Test destroys or changes files *.gas .

         For a contour plot of a screened envelope function generated by "lmstr gas --plot:con", try
           fplot -lt 1 -con 1e-6,1e-5,1e-4,1e-3,1e-2 -qr plot.gas -lt 2 -con -1e-6,-1e-5,-1e-4,-1e-3,-1e-2 -qr plot.gas
         The function is generated for a square of dimension +/- alat

EOF
if (-r fp/test) then
cat <<EOF
         You can also manually test the Levenberg-Marquardt fitting algorithm (2 variants)
         After this test completes, run:
           zcat fp/test/bnds.gas  > refbnds.gas
           rdcmd '-f:#rdcmd:%2f' -cat:TESTLM --noerr ctrl.gas > out.gas
             or
           zcat fp/test/bnds.gas  > refbnds.gas
           rdcmd '-f:#rdcmd:%2f' -cat:TESTLM1 --noerr ctrl.gas > out.gas
         Or use the MPI version
           zcat fp/test/bnds.gas  > refbnds.gas
           rdcmd '-f:#rdcmd:%2f' -cat:TESTMPI --noerr ctrl.gas > out.gas

         These commands read a bands file generated by lmf (gen by fp/test/test.fp gas)
         and adjusts the ASA potential parameters to fit the bands.
         Compare ASA output and fit bands to reference with:
           diff vext.gas testing/vext.gas
           zdiff out.gas testing/out.lmarq.gas
           zdiff bnds.gas testing/bnds.gas.lmarq
         or
           diff vext.gas testing/vext.gas.lmarq1
           zdiff out.gas testing/out.lmarq1.gas
           zdiff bnds.gas testing/bnds.gas.lmarq1

EOF
endif
if ($?MPIK) then
echo "$space Not set up for MPI job ... skipping"
goto chk1e
endif
query chk11 chk1e 'run this test'
chk11:
findcmd chk11a rdcmd "$path" "$topdir"
chk11a:
findcmd chk11b lm "$path" "$topdir"
chk11b:
findcmd chk11c lmstr "$path" "$topdir"
chk11c:
findcmd chk11d lmchk "$path" "$topdir"
chk11d:
findcmd chk11f lmdos "$path" "$topdir"
chk11f:

if ($?clean) then
  echo "$space rm -f {as,bnds,bnds-ewald,bnds-rs,dos,e1,e2,ga,log,mixm,moms,out,out.nmto,save,sv,wkp,plot,sdot,str,ctrl,shfac,syml}.gas plot.con plot.line"
               rm -f {as,bnds,bnds-ewald,bnds-rs,dos,e1,e2,ga,log,mixm,moms,out,out.nmto,save,sv,wkp,plot,sdot,str,ctrl,shfac,syml}.gas plot.con plot.line
  goto chk1e
endif
set refout=$testdir/out.gas  testout=out.gas
echo "$space touch ctrl.gas; rm -f *.gas ; cp $testdir/{ctrl,syml}.gas ."
             touch ctrl.gas; rm -f *.gas ; cp $testdir/{ctrl,syml}.gas .
runrdcmd chk12 %11f $testout "-cat:TEST --noerr ctrl.gas"
chk12:

if (! $?quiet) then
  echo ' '
  echo "$space 1st line of NN real-space strux to file $refout":
  cat $testout | \
  awk '{if ($1 == "SHOSTR:") {print;getline;getline;getline;getline;getline;print;getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;print " ",$0}}'
  echo '---'
  zcat $refout | \
  awk '{if ($1 == "SHOSTR:") {print;getline;getline;getline;getline;getline;print;getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;print " ",$0}}'
  call showout chk16 OVMIN
  chk16:
  call showout chk17 SV
  chk17:
endif

call diffiles chk1s "CPU -1 $testout $refout"
chk1s:

# check various criteria for passing tests
set pass
echo ' '

set outline = `cat $testout | awk '{if ($1 == "SHOSTR:") {getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;print " ",$0}}'`
set refline = `zcat $refout | awk '{if ($1 == "SHOSTR:") {getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;getline;print " ",$0}}'`
echo -n "$space ... 1st line of NN real-space strux equivalent? ..."
if ("$refline" == "$outline") then
  echo yes
else
  echo no
  unset pass
endif

set refline = `zcat $refout | grep OVMIN`
set outline = `grep OVMIN $testout`
echo -n "$space ... line OVMIN equivalent to file $refout? ..."
if ("$refline" == "$outline") then
  echo yes
else
  echo no
  unset pass
endif

set refline = `cat $testout | awk '{if ($1 == "SECMAT:") {getline; print;getline;print}}' | sed -n 1,1p`
set outline = `zcat $refout | awk '{if ($1 == "SECMAT:") {getline; print;getline;print}}' | sed -n 1,1p`
echo -n "$space ... Energy eigenvalues at Gamma equivalent? ... "
if ("$refline" == "$outline") then
  echo yes
else
  echo no
  unset pass
endif

set bndstol = 1e-4
zcmpmfiles_res_0 chk1ck1 "... Max deviation in bnds.gas from reference" $bndstol pass 4 bnds.gas $testdir/bnds.gas
chk1ck1:
set dostol = 1e-6
zcmpmfiles_res_0 chk1ck2 "... Max deviation in dos.gas from reference" $dostol pass 4 dos.gas $testdir/dos.gas
chk1ck2:
set plottol = 1e-6
zcmpmfiles_res_0 chk1ck3 "... Max deviation in plot.gas (con) from reference $testdir/plot.2gen.con" $plottol pass 4 plot.gas $testdir/plot.2gen.con
chk1ck3:
zcmpmfiles_res_0 chk1ck4 "... Max deviation in plot.gas (line) from reference $testdir/plot.2gen.line" $plottol pass 4 plot.line $testdir/plot.2gen.line
chk1ck4:

#  if ($?add0) then
#   echo -n "         ..." ; $add0 dos.gas
#  endif
#  if ($?add0) then
#   echo -n "         ..." ; $add0 bnds.gas
#  endif
#  zcat $testdir/dos.gas >dos2.gas
#  cmp dos.gas dos2.gas >/dev/null
#  set retval = $status
#  echo -n "$space ... files dos.gas and $testdir/dos.gas equivalent? ... "
#  if ($retval == 0) then
#    echo  yes
#  else
#    echo  no
#    echo -n "$space ... do they differ in fewer than 10 characters? ... "
#    if (`cmp -l dos.gas dos2.gas | awk 'END {print NR}'` < 10) then
#      echo yes
#    else
#      echo no
#      unset pass
#    endif
#  endif
#  rm dos2.gas

#  zcat $testdir/bnds.gas >bnds2.gas
#  cmp bnds.gas bnds2.gas >/dev/null
#  set retval = $status
#  rm bnds2.gas
#  if ($retval == 0) then
#    echo "$space ... files bnds.gas and $testdir/bnds.gas equivalent? ..." yes
#  else
#    echo "$space ... files bnds.gas and $testdir/bnds.gas equivalent? ..." no
#    unset pass
#  endif

set refline = `zcat $refout | grep SV`
set outline = `grep SV $testout`
set eref  = `echo $refline | awk '{print substr($6,1,9)}'`
set etest = `echo $outline | awk '{print substr($6,1,9)}'`

if ($?detol1 == 0) set detol1 = 1.0e-6
if ($?dqtol1 == 0) set dqtol1 = 1.0e-6
echo ' '
echo -n "$space ... ehk generated by lm equal within tolerance ($detol1) of reference? ... "
if (`echo $etest $eref $detol1 | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k<=$3)}'`) then
  echo yes
else
  echo no
  unset pass
endif

echo ' '
echo "$space Checking NMTO hamiltonian (LMTO(Ewald),QMTO(R.S))."
echo "$space To generate energy bands figure highlighting As p character in red, do:"
echo "$space echo -15,20,5,10 | plbnds -fplot -ef=0 -scl=13.6 -lt=1,col=1,0,0,colw=0,0,0 -lbl=L,G,X,W,G bnds-rs.gas"
echo "$space (requires fplot package)"
echo ' '
set refout=$testdir/out.nmto.gas  testout=out.nmto.gas

runrdcmd chk18 %11f $testout "-cat:TESTN --noerr ctrl.gas"
chk18:
echo ' '

call diffiles chk1s2 "rdcmd -1 $testout $refout"
chk1s2:

if ($?poszer) then
 echo -n "         ..." ; $poszer bnds-ewald.gas
 echo -n "         ..." ; $poszer bnds-rs.gas
else if ($?add0) then
 echo -n "         ..." ; $add0 bnds-ewald.gas
 echo -n "         ..." ; $add0 bnds-rs.gas
endif

set bndstol = 1e-4
zcmpmfiles_res_0 chk1ck5 "... Max deviation in bnds-ewald.gas from reference $testdir/bnds.nmto.gas" $bndstol pass 4 bnds-ewald.gas $testdir/bnds.nmto.gas
chk1ck5:
zcmpmfiles_res_0 chk1ck6 "... Max deviation in bnds-rs.gas from reference $testdir/bnds.nmto.rs.gas" $bndstol pass 4 bnds-rs.gas $testdir/bnds.nmto.rs.gas
chk1ck6:

#  echo -n "$space ... files bnds-ewald.gas and
#  zcat $testdir/bnds.nmto.gas >bnds2.gas
#  cmp bnds-ewald.gas bnds2.gas >/dev/null
#  set retval = $status
#  if ($retval == 0) then
#    echo yes
#  else
#    echo no
#    echo -n "$space ... do they differ in fewer than 10 characters? ... "
#    if (`cmp -l bnds-ewald.gas bnds2.gas | awk 'END {print NR}'` < 10) then
#      echo yes
#    else
#      echo no
#      unset pass
#    endif
#  endif
#  rm bnds2.gas

#  echo -n "$space ... files bnds-rs.gas and $testdir/bnds.nmto.rs.gas equivalent? ... "
#  zcat $testdir/bnds.nmto.rs.gas >bnds2.gas
#  cmp bnds-rs.gas bnds2.gas >/dev/null
#  set retval = $status
#  if ($retval == 0) then
#    echo yes
#  else
#    echo no
#    echo -n "$space ... do they differ in fewer than 10 characters? ... "
#    if (`cmp -l bnds-rs.gas bnds2.gas | awk 'END {print NR}'` < 10) then
#      echo yes
#    else
#      echo no
#      unset pass
#    endif
#  endif
#  rm bnds2.gas

if ($?pass) then
    echo "$space ... test 1 PASSED"
else
    echo "$space ... test 1 FAILED"
    set failed = ($failed 1)
endif

chk1e:

echo $joblist | egrep '\b2\b' >/dev/null
if ($status && "$joblist" != "tc") goto chk2e
cat <<EOF

         ------- Test 2.  Input file ctrl.tc (lmstr,lm) ---
         This file contains input for La2 Cu O4.
         Test the sphere and band program for a case with equivalent sites and downfolding.

         Also checks generalized screened envelope functions tabulated on an xy mesh (lmstr).
         If you have fplot installed, make a contour plot of the Cu s orbital in the xy plane with
           fplot -f testing/plot.tc-con
         It is interesting to compare against analogous 2nd generation function.
         To generate it, repeat the lmstr calculation, replacing --plot:smh:con with --plot:con
         A more striking contrast are line plots: see testing/plot.tc-con for their generation and plotting.

         Test destroys or changes files *.tc

EOF
query chk21 chk2e 'run this test'
chk21:
findcmd chk21a rdcmd "$path" "$topdir"
chk21a:
findcmd chk21b lm "$path" "$topdir"
chk21b:
findcmd chk21c lmstr "$path" "$topdir"
chk21c:
set refout=$testdir/out.tc  testout=out.tc
echo ' '
if ($?clean) then
  echo "$space rm -f {ctrl,bnds,cu,la,log,mixm,moms,out,out.nmto,ox2,ox,rsta,save,sdot,str,sv,shfac,syml,wkp}.tc $testout out.str.tc plot.tc plot.tc.line"
               rm -f {ctrl,bnds,cu,la,log,mixm,moms,out,out.nmto,ox2,ox,rsta,save,sdot,str,sv,shfac,syml,wkp}.tc $testout out.str.tc plot.tc plot.tc.line
  goto chk2e
endif
echo "$space touch ctrl.tc; rm -f *.tc ; cp $testdir/{ctrl.tc,syml.tc} ."
             touch ctrl.tc; rm -f *.tc ; cp $testdir/{ctrl.tc,syml.tc} .
runrdcmd chk22 %11f $testout "-cat:TEST --noerr ctrl.tc"
chk22:

#echo 'SKIP'; goto chk2ck1

get_resf chk23a etot eref "SV" 6 0 zzz
chk23a:
get_resf chk23b dq dqref "SV" 3 0 zzz
chk23b:
cnvt_d_fmt chk23c dq $dq
chk23c:
cnvt_d_fmt chk23d dqref $dqref
chk23d:

call showout chk24 CPU
chk24:
call showout chk25 SV
chk25:
if ($status) echo "$space ... abort ...: file $testout does not contain SV line\!"

set refline = `zcat $refout | grep SV`
set outline = `grep SV $testout`
set pass
if ($?detol2 == 0) set detol2 = 1.1e-6
if ($?dqtol2 == 0) set dqtol2 = 1.0e-7
echo ' '
echo -n "$space ... ehk ($etot) generated by lm equal within tolerance ($detol2) of reference? ... "
if (`echo $etot $eref $detol2 | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k<=$3)}'`) then
  echo yes
else
  echo no
  unset pass
endif
echo -n "$space ... rms DQ ($dq) generated by lm equal within tolerance ($dqtol2) of reference? ... "
if (`echo $dq $dqref $dqtol2 | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k<=$3)}'`) then
  echo yes
else
  echo no
  unset pass
endif

call diffiles chk2s "wkinfo -1 $testout $refout"
chk2s:

echo " "
echo "$space Repeat using QASA=3 hamiltonian,"
echo "$space and MIX CONV=# to illustrate check on energy tolerance"
echo "$space and --rs= to illustrate reading of restart file"
set refout=$testdir/out.tc.qasa  testout=out.tc
echo ' '
echo "$space touch ctrl.tc; rm -f *.tc ; cp $testdir/{ctrl.tc,syml.tc} ."
             touch ctrl.tc; rm -f *.tc ; cp $testdir/{ctrl.tc,syml.tc} .
if (! $?MPIK) then
runrdcmd chk2a2 %11f $testout "-cat:TEST3 --noerr ctrl.tc"
else
runrdcmd chk2a2 %11f $testout "-cat:TESTMPI --noerr ctrl.tc"
endif
chk2a2:

set ehf    =      `cat $testout | grep 'delsev=' | tail -1 | awk '{match($0,"ehf=[^ ]*"); print substr($0,RSTART+4,RLENGTH-4)}'`
set ehk    =      `cat $testout | grep 'delsev=' | tail -1 | awk '{match($0,"ehk=[^ ]*"); print substr($0,RSTART+4,RLENGTH-4)}'`
set ehfr   = `zcat $refout | grep 'delsev=' | tail -1 | awk '{match($0,"ehf=[^ ]*"); print substr($0,RSTART+4,RLENGTH-4)}'`
set ehkr   = `zcat $refout | grep 'delsev=' | tail -1 | awk '{match($0,"ehk=[^ ]*"); print substr($0,RSTART+4,RLENGTH-4)}'`


set dqr    =  `zcat $refout | grep 'RMS DQ=' | tail -1 | awk '{sub(".*RMS DQ=","");sub("last it=.*",""); print $0}'`
set dq     =  `cat $testout | grep 'RMS DQ=' | tail -1 | awk '{sub(".*RMS DQ=","");sub("last it=.*",""); print $0}'`

set pass
if ($?detol2 == 0) set detol2 = 1.1e-6
if ($?dqtol2 == 0) set dqtol2 = 1.0e-7
echo ' '
echo -n "$space ... ehk ($ehk) generated by lm equal within tolerance ($detol2) of reference? ... "
if (`echo $ehk $ehkr $detol2 | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k<=$3)}'`) then
  echo yes
else
  echo no
  unset pass
endif
echo -n "$space ... ehf ($ehf) generated by lm equal within tolerance ($detol2) of reference? ... "
if (`echo $ehf $ehfr $detol2 | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k<=$3)}'`) then
  echo yes
else
  echo no
  unset pass
endif
echo -n "$space ... rms DQ ($dq) generated by lm equal within tolerance ($dqtol2) of reference? ... "
if (`echo $dq $dqr $dqtol2 | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k<=$3)}'`) then
  echo yes
else
  echo no
  unset pass
endif

call diffiles chk2as "wkinfo -1 $testout $refout"
chk2as:

echo " "
echo "$space Checking NMTO hamiltonian (QMTO).  Invoke lm first to find E_f."
set refout=$testdir/out.nmto.tc  testout=out.nmto.tc
runrdcmd chk26 %11f $testout "-cat:TESTN --noerr ctrl.tc"
chk26:
if ($?poszer) then
 echo -n "         ..." ; $poszer bnds.tc
else if ($?add0) then
 echo -n "         ..." ; $add0 bnds.tc
endif

#  call zcmpnfiles chk27 "4 bnds.tc $testdir/bnds.nmto.tc"
#  chk27:
#  echo ' '
#  echo -n "$space ... files bnds.tc and $testdir/bnds.nmto.tc equivalent to 4 digits? ... "
#  if ($retval == 0) then
#    echo yes
#  else if (`echo ' ' | awk -v ndiff=$retval -v ntot=$ncharfile '{print (100*ndiff/ntot<1.)}'` == 1) then
#    echo ok "($retval difference(s) of $ncharfile)"
#  else
#    echo no "($retval difference(s) remaining of $ncharfile)"
#    unset pass
#  endif

call diffiles chk2s2 "wkinfo -1 $testout $refout"
chk2s2:

set bndstol = 1e-4
zcmpmfiles_res_0 chk2ck1 "Max deviation in bnds.tc from reference $testdir/bnds.nmto.tc" $bndstol pass 4 bnds.tc $testdir/bnds.nmto.tc
chk2ck1:

echo " "
set refout=$testdir/out.str.tc  testout=out.str.tc
echo "$space Check file of screened envelopes, with generalized functions"

echo "$space   lmstr --pr40 tc --plot:smh:line:-10,-10,-10,10,10,10 -vgmode=1 --edge=12 --iactiv=no --ikap=1 --atom=2 > $testout"
               lmstr --pr40 tc --plot:smh:line:-10,-10,-10,10,10,10 -vgmode=1 --edge=12 --iactiv=no --ikap=1 --atom=2 > $testout
echo "$space   cp plot.tc plot.tc.line"
               cp plot.tc plot.tc.line
echo "$space   lmstr --pr40 tc --plot:smh:con -vgmode=1 --edge=12 --iactiv=no --ikap=1 >> $testout"
               lmstr --pr40 tc --plot:smh:con -vgmode=1 --edge=12 --iactiv=no --ikap=1 >> $testout

call diffiles chk2s3 "wkinfo -1 $testout $refout"
chk2s3:

set bndstol = 1e-8
zcmpmfiles_res_0 chk2s4 "... Max deviation in plot.tc.line from reference" $bndstol pass 4 plot.tc.line $testdir/plot.tc.line
chk2s4:
zcmpmfiles_res_0 chk2s5 "... Max deviation in plot.tc from reference" $bndstol pass 4 plot.tc $testdir/plot.tc
chk2s5:


if ($?pass) then
    echo "$space ... test 2 PASSED"
else
    echo "$space ... test 2 FAILED"
    set failed = ($failed 2)
endif

chk2e:

echo $joblist | egrep '\b3\b' >/dev/null
if ($status && "$joblist" != "fe") goto chk3e
cat <<EOF

         ------- Test 3.  Input file ctrl.fe (lmstr,lm,lmdos) ---
         This file contains input for elemental bcc Fe.

         Tests the ASA collinear spin polarized case,
         especially density-of-states in various modes.

         Test destroys or changes files *.fe.

         You can also manually test the Levenberg-Marquardt fitting algorithm.
         After this test completes, run:
           cp testing/{refbnds,rsta,syml,vext}.fe .
           rdcmd '-f:#rdcmd:%2f' -cat:TESTLM --noerr ctrl.fe > out.fe
         Compare ASA output and fit bands to reference with:
           diff vext0.fe testing
           zdiff out.fe testing/out.lmarq.fe

EOF
set pass
query chk31 chk3e 'run this test'
chk31:
findcmd chk31a rdcmd "$path" "$topdir"
chk31a:
findcmd chk31b lm "$path" "$topdir"
chk31b:
findcmd chk31c lmstr "$path" "$topdir"
chk31c:
if ($?noplot) goto chk31e
findcmd chk31d pldos "$path" "no"
chk31d:
findcmd chk31e fplot "$path" "no"
chk31e:

if ($?clean) then
  echo "$space rm -f {dos,fe,log,mixm,moms,out,save,sv,wkp,sdot,str,ctrl,dos,mdos}.fe {dosp,dosp2}.{dat,ref} plot.dos ps.dos.fe"
               rm -f {dos,fe,log,mixm,moms,out,save,sv,wkp,sdot,str,ctrl,dos,mdos}.fe {dosp,dosp2}.{dat,ref} plot.dos ps.dos.fe
  goto chk3e
endif
set refout=$testdir/out.fe  testout=out.fe
touch ctrl.fe
echo "$space rm -f *.fe ; cp $testdir/{ctrl}.fe ."
             rm -f *.fe ; cp $testdir/{ctrl}.fe .
runrdcmd chk32 %11f $testout "-cat:TESTDOS --noerr ctrl.fe"
chk32:
if ($?poszer) then
 echo -n "         ..." ; $poszer dos.fe
else if ($?add0) then
 echo -n "         ..." ; $add0 dos.fe
endif
call showout chk33 SV
chk33:

# ... check various criteria for passing tests
echo ' '
set dostol = 2e-6
zcmpmfiles_res_0 chk3ck1 "... Max deviation in dos.fe from reference $testdir/dos.fe" $dostol pass 6 dos.fe $testdir/dos.fe
chk3ck1:

#  call zcmpnfiles chk34 "6 dos.fe $testdir/dos.fe"
#  chk34:
#  echo ' '
#  echo -n "$space ... files dos.fe and $testdir/dos.fe equivalent to 6 digits? ... "
#  if ($retval == 0) then
#    echo  yes
#  else
#    call zcmpnfiles chk34a "4 dos.fe $testdir/dos.fe"
#    chk34a:
#    echo -n "no ... to 4 digits? ... "
#    if ($retval == 0) then
#      echo yes
#    else if (`echo ' ' | awk -v ndiff=$retval -v ntot=$ncharfile '{print (100*ndiff/ntot<1.)}'` == 1) then
#      echo ok "($retval difference(s) of $ncharfile)"
#    else
#      echo no "($retval difference(s) remaining of $ncharfile)"
#      unset pass
#    endif
#  endif

set refline = `zcat $refout | grep SV`
set outline = `grep SV $testout`
set eref  = `echo $refline | awk '{print substr($6,1,9)}'`
set etest = `echo $outline | awk '{print substr($6,1,9)}'`
if ("$eref" == "$etest") then
  echo "$space ... energies ehk from SV line equivalent? ..." yes
else
  echo "$space ... energies ehk from SV line equivalent? ..." no
  unset pass
endif

cat <<EOF

         Invoke lmdos again to illustrate and check calculation of ballistic conductivity.

EOF

runrdcmd chk36 %11f ">>$testout" "-cat:TESTCND --noerr ctrl.fe"
chk36:
if ($?poszer) then
 echo -n "         ..." ; $poszer dos.fe
else if ($?add0) then
 echo -n "         ..." ; $add0 dos.fe
endif

echo ' '
set dostol = 2e-6
set pass
zcmpmfiles_res_0 chk3ck2 "... Max deviation in dos.fe from reference $testdir/cond.fe" $dostol pass 6 dos.fe $testdir/cond.fe
chk3ck2:
echo "$space to plot ballistic conductivity, try:"
echo "$space echo 1 4 -.6 .4 | pldos -fplot '-lst=1;3;5' '-lst2=2;4;6' $testdir/cond.fe"

#  call zcmpnfiles chk36a "6 dos.fe $testdir/cond.fe"
#  chk36a:
#  echo ' '
#  echo -n "$space ... files dos.fe and $testdir/cond.fe equivalent to 6 digits? ... "
#  if ($retval == 0) then
#    echo  yes
#  else
#    call zcmpnfiles chk36b "4 dos.fe $testdir/cond.fe"
#    chk36b:
#    echo -n "no ... to 4 digits? ... "
#    if ($retval == 0) then
#      echo yes
#    else if (`echo ' ' | awk -v ndiff=$retval -v ntot=$ncharfile '{print (100*ndiff/ntot<1.)}'` == 1) then
#      echo ok "($retval difference(s) of $ncharfile)"
#    else
#      echo no "($retval difference(s) remaining of $ncharfile)"
#      unset pass
#    endif
#  endif

cat <<EOF

         Repeat the first test, this time resolving the DOS by m.
         The moments file saves m-resolved weights if BZ SAVDOS=4.
         Note also that the symmetry operations are suppressed.

EOF
touch ctrl.fe
echo "$space rm -f fe.fe"
             rm -f fe.fe
runrdcmd chk35 %11f ">>$testout" "-cat:TESTDSM --noerr ctrl.fe"
chk35:
if ($?poszer) then
 echo -n "         ..." ; $poszer dos.fe
else if ($?add0) then
 echo -n "         ..." ; $add0 dos.fe
endif
cp dos.fe mdos.fe

if ($?have_pldos && ! $?quiet) then
cat <<EOF

         Note: generation of m-resolved DOS is numerically a rather delicate
         procedure.  That this check failed may not be very meaningful.
         It is likely that differences in m-resolved  DOS are artifacts of
         small numerical differences produced by different executables.

         It is best to verify that the dos is correct by graphing the dos
         just generated and comparing to the reference, $testdir/mdos.fe

EOF

if (! $?have_fplot || ! $?slow) goto chk3p2
query chk3p chk3p2 "plot m-resolved dos"
chk3p:
 echo \
"  ... the following makes postscript file fplot.ps with mdos.fe and $testdir/mdos.fe superimposed"
 echo \
"  echo 8 4 -.6 .4 | $pldos -fplot~ext=ref '-lst=1;3,5,7;9;11;13;15;17' '-lst2=2;4,6,8;10;12;14;16;18' $testdir/mdos.fe"
   echo 8 4 -.6 .4 | $pldos -fplot~ext=ref '-lst=1;3,5,7;9;11;13;15;17' '-lst2=2;4,6,8;10;12;14;16;18' $testdir/mdos.fe > /dev/null
 echo \
"  echo 8 4 -.6 .4 | $pldos -fplot '-lst=1;3,5,7;9;11;13;15;17' '-lst2=2;4,6,8;10;12;14;16;18' mdos.fe"
   echo 8 4 -.6 .4 | $pldos -fplot '-lst=1;3,5,7;9;11;13;15;17' '-lst2=2;4,6,8;10;12;14;16;18' mdos.fe > /dev/null
 echo \
"  awk '{if ($1 == "-colsy") {print;sub("dat","ref");print;} else {print}}' plot.dos >plot.dos~ "
   awk '{if ($1 == "-colsy") {print;sub("dat","ref");print;} else {print}}' plot.dos  >plot.dos~
 echo \
"  fplot -disp -pr10 -f plot.dos~"
   fplot -disp -pr10 -f plot.dos~
  query chk3p2 chk3p2 'continue'
chk3p2:
endif

set dostol = 2e-6
set passl
zcmpmfiles_res_0 chk3ck3 "... Max deviation in dos.fe from reference $testdir/mdos.fe" $dostol passl 6 dos.fe $testdir/mdos.fe
chk3ck3:
if (! $?quiet) then
echo "$space for detailed comparison of dos to reference, try:"
echo "$space mcx -cmpf:vverb:tol=.1:fn1=mdos.fe:fn2=$testdir/mdos.fe"
endif
# echo "$space number of elements in dos.fe differ by more than 0.1 in reference $testdir/mdos.fe :" `mcx -cmpf:ndiff:tol=.1:fn1=dos.fe:fn2=$testdir/mdos.fe` "out of"  `mcx -cmpf:nword:tol=.1:fn1=dos.fe:fn2=testing/mdos.fe`

cat <<EOF

         Mulliken DOS test, resolving DOS by eigenvector components rather than
         by projection of partial waves onto augmentation spheres.
         This test resolves DOS only by l; symmetry operations need not be suppressed.

EOF
echo "$space rm -f fe.fe mixm.fe"
             rm -f fe.fe mixm.fe
runrdcmd chk3m5 %11f ">>$testout" "-cat:TSTMULL --noerr ctrl.fe"
chk3m5:
if ($?poszer) then
 echo -n "         ..." ; $poszer dos.fe
else if ($?add0) then
 echo -n "         ..." ; $add0 dos.fe
endif

set dostol = 2e-6
set passl
zcmpmfiles_res_0 chkm3ck3 "... Max deviation in dos.fe from reference $testdir/dos-mull.fe" $dostol passl 6 dos.fe $testdir/dos-mull.fe
chkm3ck3:
echo "$space mcx -cmpf:vverb:tol=.1:fn1=dos.fe:fn2=$testdir/dos-mull.fe"

if ($?quiet) then
echo ' '
else
cat <<EOF

         Note generation of l-resolved Mulliken DOS is numerically more stable than the m-resolved partial dos.

EOF

if (! $?have_fplot || ! $?slow) goto chk3mp2
query chk3mp chk3mp2 "plot l-resolved Mulliken dos"
chk3mp:
 echo \
"  ... the following makes postscript file fplot.ps with dos.fe and $testdir/cond.fe superimposed"
 echo \
'  echo 20 10 -0.6 0.4 | pldos -fplot~ext=ref -lst="1;3;5" -lst2 $testdir/dos-mull.fe'
   echo 20 10 -0.6 0.4 | pldos -fplot~ext=ref -lst="1;3;5" -lst2 $testdir/dos-mull.fe > /dev/null
 echo \
'  echo 20 10 -0.6 0.4 | pldos -fplot -lst="1;3;5" -lst2 dos.fe'
   echo 20 10 -0.6 0.4 | pldos -fplot -lst="1;3;5" -lst2 dos.fe > /dev/null
 echo \
"  awk '{if ($1 == "-colsy") {print;sub("dat","ref");print;} else {print}}' plot.dos >plot.dos~ "
   awk '{if ($1 == "-colsy") {print;sub("dat","ref");print;} else {print}}' plot.dos >plot.dos~
 echo \
"  fplot -disp -pr10 -f plot.dos~"
   fplot -disp -pr10 -f plot.dos~
query chk3mp2 chk3p2 'continue'
chk3mp2:
endif
endif

call zdiffiles chk37 "CPU -1 $testout $refout"
chk37:

if ($?pass) then
    echo "$space ... test 3 PASSED"
else
    echo "$space ... test 3 FAILED"
    set failed = ($failed 3)
endif

chk3e:

echo $joblist | egrep '\b4\b' >/dev/null
if ($status && "$joblist" != "mix") goto chk4e
cat <<EOF

         ------- Test 4.  Input file ctrl.mix (lmstr,lm) ---
         This file tests the two-center hamiltonian, and different branches of the charge mixing
         Test destroys or changes files *.mix
EOF
if ($?MPIK) then
echo "$space this is not an MPI job ... skipping"
goto chk4e
endif
query chk41 chk4e 'run this test'
chk41:
findcmd chk41a rdcmd "$path" "$topdir"
chk41a:
findcmd chk41b lm "$path" "$topdir"
chk41b:
findcmd chk41c lmstr "$path" "$topdir"
chk41c:
if ($?clean) then
  echo "$space rm -f {a2,a,log,moms,mq,out,save,sv,wkp,mm,ctrl,sdot,str}.mix"
               rm -f {a2,a,log,moms,mq,out,save,sv,wkp,mm,ctrl,sdot,str}.mix
  goto chk4e
endif
set refout=$testdir/out.mix  testout=out.mix

# goto xxxx


echo "$space touch ctrl.mix; rm -f *.mix ; cp $testdir/ctrl.mix ."
             touch ctrl.mix; rm -f *.mix ; cp $testdir/ctrl.mix .
runjob chk42 /dev/null "lmstr mix"
chk42:
    set mixmod = -vmixmod=0
    echo "$space lm -vnit=0 -vbzj=0 -vnk=8 $mixmod mix >> out.mix <<EOF"
    lm -vnit=0 -vbzj=0 -vnk=8 $mixmod mix >> out.mix <<EOF
    9
    i
EOF
    echo "$space rm -f mm.mix mq.mix"
                 rm -f mm.mix mq.mix
    set mixmod = -vmixmod=1
    echo "$space lm -vnit=0 -vbzj=0 -vnk=8 $mixmod mix >> out.mix <<EOF"
    lm -vnit=0 -vbzj=0 -vnk=8 $mixmod mix >> out.mix <<EOF
    9
    i
EOF
    echo "$space rm -f mm.mix mq.mix"
                 rm -f mm.mix mq.mix
    set mixmod = -vmixmod=2
    echo "$space lm -vnit=0 -vbzj=0 -vnk=8 $mixmod mix >> out.mix <<EOF"
    lm -vnit=0 -vbzj=0 -vnk=8 $mixmod mix >> out.mix <<EOF
    9
    i
EOF
chk43:
echo "$space Program lm returned successfully."
if ($?poszer) then
 echo -n "         ..." ; $poszer out.mix
else if ($?add0) then
 echo -n "         ..." ; $add0 out.mix
endif
call showout chk44 CPU
chk44:
if ($?quiet) goto chk45
  echo ' '
  echo "$space Compare SV to lines in file $refout, mixmod=0":
  echo "$space ... file $testout"
  grep SV $testout | sed -n 1,9p
  echo "$space ... file $refout"
  zcat $refout | grep SV | sed -n 1,9p

  echo "$space Compare SV last iteration, all mix modes":
  echo "$space ... file $testout"
  grep SV $testout |  grep 'SV:  9'
  echo "$space ... file $refout"
  zcat $refout | grep 'SV:  9'
chk45:


xxxx:

# check various criteria for passing tests
set pass

zcat $refout | grep SV | sed -n 1,9p >out1.mix
zcat $refout | grep 'SV:  9' >>out1.mix
cat      $testout | grep SV | sed -n 1,9p >out2.mix
cat      $testout | grep 'SV:  9' >>out2.mix
cmp out1.mix out2.mix >/dev/null
set retval = $status
rm out1.mix out2.mix
if ($retval == 0) then
  echo "$space ... SV lines in files $testout and $refout equivalent? ..." yes
  set pass2
else
  echo "$space ... SV lines in files $testout and $refout equivalent? ..." no
  unset pass2
endif

set refline = `zcat $refout | grep SV | sed -n 1,9p | tail -1 | sed s/D/E/g `
set outline = `grep SV $testout | sed -n 1,9p | tail -1 | sed s/D/E/g`
set eref  = `echo $refline | awk '{print substr($6,1,9)}'`
set etest = `echo $outline | awk '{print substr($6,1,9)}'`
set dqref  = `echo $refline | awk '{printf "%5.2e\n", $3}'`
set dqtest = `echo $outline | awk '{printf "%5.2e\n", $3}'`

set detol2 = 1e-6
echo -n "$space ... ehk ($etest) from SV line 9 equal within tolerance ($detol2) of reference? ... "
if (`echo $etest $eref $detol2 | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k<=$3)}'`) then
  echo yes
else
  echo no
  unset pass
endif
set dqtol2 = 1e-6
echo -n "$space ... rms DQ ($dqtest) from SV line 9 within tolerance ($dqtol2) of reference? ... "
if (`echo $dqtest $dqref $dqtol2 | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k<=$3)}'`) then
  echo yes
else
  echo no
  unset pass
endif

set refline = `zcat $refout | grep SV | sed -n 1,18p | tail -1 | sed s/D/E/g `
set outline = `grep SV $testout | sed -n 1,18p | tail -1 | sed s/D/E/g`
set eref  = `echo $refline | awk '{print substr($6,1,9)}'`
set etest = `echo $outline | awk '{print substr($6,1,9)}'`
set dqref  = `echo $refline | awk '{printf "%5.2e\n", $3}'`
set dqtest = `echo $outline | awk '{printf "%5.2e\n", $3}'`

set detol2 = 3e-6
echo -n "$space ... ehk ($etest) from SV line 18 equal within tolerance ($detol2) of reference ($eref)? ... "
if (`echo $etest $eref $detol2 | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k<=$3)}'`) then
  echo yes
else
  echo no
  unset pass
endif
set dqtol2 = 5e-6
echo -n "$space ... rms DQ ($dqtest) from SV line 18 within tolerance ($dqtol2) of reference? ... "
if (`echo $dqtest $dqref $dqtol2 | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k<=$3)}'`) then
  echo yes
else
  echo no
  unset pass
endif

set refline = `zcat $refout | grep SV | sed -n 1,27p | tail -1 | sed s/D/E/g `
set outline = `grep SV $testout | sed -n 1,27p | tail -1 | sed s/D/E/g`
set eref  = `echo $refline | awk '{print substr($6,1,9)}'`
set etest = `echo $outline | awk '{print substr($6,1,9)}'`
set dqref  = `echo $refline | awk '{printf "%5.2e\n", $3}'`
set dqtest = `echo $outline | awk '{printf "%5.2e\n", $3}'`

set detol2 = 1e-6
echo -n "$space ... ehk ($etest) from SV line 27 equal within tolerance ($detol2) of reference? ... "
if (`echo $etest $eref $detol2 | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k<=$3)}'`) then
  echo yes
else
  echo no
  unset pass
endif
set dqtol2 = 1e-6
echo -n "$space ... rms DQ ($dqtest) from SV line 27 within tolerance ($dqtol2) of reference? ... "
if (`echo $dqtest $dqref $dqtol2 | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k<=$3)}'`) then
  echo yes
else
  echo no
  unset pass
endif



if ($?pass && $?pass2) then
    echo "$space ... test 4 PASSED"
else if ($?pass) then
    echo "$space ... test 4 PASSED, with some numerical differences in the SV file"
else
    echo "$space ... test 4 FAILED"
    set failed = ($failed 4)
endif

if ($?quiet) goto chk4e
echo " "
call diffiles chk4s "wkinfo -1 $testout $refout"
chk4s:
chk4e:

echo $joblist | egrep '\b5\b' >/dev/null
if ($status && "$joblist" != "gan") goto chk5e
cat <<EOF

         ------- Test 5.  Test downfolding, different lmx (ctrl.gan) ---
         This file contains input for GaN
         Tests lmstr,lm for lmx=1,2 on N site.
         Test destroys or changes files *.gan, plot.plbnds

EOF
query chk51 chk5e 'run this test'
chk51:
findcmd chk51a rdcmd "$path" "$topdir"
chk51a:
findcmd chk51b lm "$path" "$topdir"
chk51b:
findcmd chk51c lmstr "$path" "$topdir"
chk51c:

if ($?clean) then
  echo "$space rm -f plot.plbnds plot.plbnds2"
               rm -f plot.plbnds plot.plbnds2
  echo "$space rm -f {bnds1,bnds,log,out,mixm,moms,wkp,bnds2,sdot,str,a1,c1,ctrl,ea1,ec1,shfac,syml}.gan"
               rm -f {bnds1,bnds,log,out,mixm,moms,wkp,bnds2,sdot,str,a1,c1,ctrl,ea1,ec1,shfac,syml}.gan
  goto chk5e
endif
set pass
set refout=$testdir/out.gan  testout=out.gan
echo "$space ... set up ASA starting potential"
echo "$space touch ctrl.gan; rm -f *.gan ; cp $testdir/{ctrl,syml}.gan ."
             touch ctrl.gan; rm -f *.gan ; cp $testdir/{ctrl,syml}.gan .
runjob chk52 'out.gan' "lm -vnit=0 gan --no-iactive"
chk52:
if (! $?quiet) echo ' '
echo "$space ... output moments and bands for lmxn=2"
runjob chk53 '/dev/null' "lmstr gan -vlmxn=2"
chk53:
echo "$space lm gan -vnit=1 -vlmxn=2 --iactiv <<EOF >$testout"
             lm gan -vnit=1 -vlmxn=2 --iactiv <<EOF >$testout



q
EOF
set dq2  = `grep 'RMS DQ=' log.gan | tail -1 | awk '{print $9}'  | sed 's/DQ=//'`


if (! $?MPIK) then
runjob chk55 ">>$testout" "lm --band:fn=syml --no-iactive gan -vlmxn=2"
else
runjob chk55 ">>$testout" "mpirun -n $nmpi lm --band:fn=syml --no-iactive gan -vlmxn=2"
endif
chk55:
echo "$space cp bnds.gan bnds2.gan"
             cp bnds.gan bnds2.gan

if (! $?quiet) echo ' '
echo "$space ... output moments and bands for lmxn=1"
runjob chk56 '/dev/null' "lmstr gan -vlmxn=1"
chk56:
echo "$space lm gan -vnit=1 -vlmxn=1 --iactiv <<EOF >>$testout"
             lm gan -vnit=1 -vlmxn=1 --iactiv <<EOF >>$testout



q
EOF
set dq1  = `grep 'RMS DQ=' log.gan | tail -1 | awk '{print $9}'  | sed 's/DQ=//'`
if (! $?MPIK) then
runjob chk57 ">>$testout" "lm --band:fn=syml --no-iactive gan -vlmxn=1"
else
runjob chk57 ">>$testout" "mpirun -n $nmpi lm --band:fn=syml --no-iactive gan -vlmxn=1"
endif
chk57:
if ($?poszer) then
 echo -n "         ..." ; $poszer $testout
 echo -n "         ..." ; $poszer bnds.gan
else if ($?add0) then
 echo -n "         ..." ; $add0 $testout
 echo -n "         ..." ; $add0 bnds.gan
endif
echo "$space cp bnds.gan bnds1.gan"
             cp bnds.gan bnds1.gan
call diffiles chk58 "wkinfo -1 $testout $refout"
chk58:

if ($?quiet) goto chk5a

#  if ($?have_fplot && $?have_pldos && $?have_ghostscript) then
#  query chk59 chk5e 'plot a comparison of lmxn=2, lmxn=1 bands'
#  chk59:
#  echo "$space cp bnds2.gan bnds.gan"
#               cp bnds2.gan bnds.gan
#  echo "$space echo -1.2 1 5 10 | plbnds -fplot gan >/dev/null"
#               echo -1.2 1 5 10 | plbnds -fplot gan >/dev/null
#  echo "$space ... cp bnd\*.dat xbnd\*.dat"
#               foreach i (bnd?.dat)
#                  cp $i x$i
#               end
#  echo "$space cp bnds1.gan bnds.gan"
#               cp bnds1.gan bnds.gan
#  echo "$space echo -1.2 1 5 10 | plbnds -fplot gan >/dev/null"
#               echo -1.2 1 5 10 | plbnds -fplot gan >/dev/null
#    cat plot.plbnds | awk '{print;if ($5 == "-qr") {ncnt += 1; print "",$1,$2,$3,$4,$5, "-lt 2 xbnd" ncnt ".dat -lt 1";}}' > plot.plbnds2
#    runjob chk59a "/dev/null"  "fplot -disp -f plot.plbnds2"
#  chk59a:
#    rm bnd?.dat xbnd?.dat
#  endif

chk5a:
if (! $?quiet) echo ' '
call qprint chk5a1 "$space ... automatic pass checks :"
chk5a1:
if (`echo $dq2 | awk '{print ($1 < 1e-6)}'`) then
  echo "$space rms dq (=$dq2) < 1e-6 for lmxn=2 ? ..." yes
else
  echo "$space rms dq (=$dq2) < 1e-6 for lmxn=2 ? ..." no
  unset pass
endif

set dq1  = `grep 'RMS DQ=' log.gan | tail -1 | awk '{print $9}'  | sed 's/DQ=//'`
if (`echo $dq1 | awk '{print ($1 < 1e-2)}'`) then
  echo "$space rms dq (=$dq1) < 1e-2 for lmxn=1 ? ..." yes
else
  echo "$space rms dq (=$dq1) < 1e-2 for lmxn=1 ? ..." no
  unset pass
endif

set bndstol = 1e-4
zcmpmfiles_res_0 chk5a3 "... Max deviation in bnds1.gan from reference" $bndstol pass 4 bnds1.gan $testdir/bnds1.gan
chk5a3:
set bndstol = 1e-4
zcmpmfiles_res_0 chk5a4 "... Max deviation in bnds2.gan from reference" $bndstol pass 4 bnds2.gan $testdir/bnds2.gan
chk5a4:

echo ' '
if ($?pass) then
    echo "$space ... test 5 PASSED"
else
    echo "$space ... test 5 FAILED"
    set failed = ($failed 5)
endif

chk5e:

echo $joblist | egrep '\b6\b' >/dev/null
if ($status && "$joblist" != "cr3si6") goto chk6e
cat <<EOF

         ------- Test 6.  Input file ctrl.cr3si6 (lm) ---
         Tests branch generating nonspherical output moments, and various forms of partial DOS.

         The l-resolved partial DOS is also generated, in two ways.
         * the class-averaged DOS generated from the natural byproduct of the moments file.
         * the site DOS using --pdos.  Here it  sums the Cr DOS from the 3 Cr sites,
           and Si DOS from the 6 Si sites.
           (Note: only the Si sp DOS are generated in this case, to demonstrate the ~lcut option)
         Thus, the two kinds of DOS are identical, except for constant factors of 3 and 6.

         A third test is run which fits Cr spd and Si sp partial DOS to a reference DOS
         (generated in advance by the FP code), using the Levenberg-Marquardt algorithm.

EOF
if ($?have_fplot && $?have_pldos && $?have_ghostscript) then
cat <<EOF

         After the tests executes, draw a picture of the Cr spd and Si sp dos with:
           rdcmd '-f:#rdcmd:%2f' -cat:PLDOS --noerr ctrl.cr3si6
           ghostview fplot.ps

         You can verify that the two modes of generating partial DOS differ only
         by a constant factor (3 for Cr channels and 6 for Si channels).
         If you have the matrix calculator program installed, do this after
         executing the 'rdcmd' line above:
            mcx -f7f12.6 dosp.site.cr3si6  dosp.class.cr3si6 -coll 1:6 -de

         If you have the FP package installed, you can compare the ASA-generated partial DOS
         with the FP equivalent. The FP partial DOS is made with this command:
             fp/test/test.fp cr3si6 2
         To compare FP and ASA partial DOS invoke this command after the tests executes:
           rdcmd '-f:#rdcmd:%2f' -cat:PLFPDOS --noerr ctrl.cr3si6
           ghostview fplot.ps
         For FP DOS, this test uses the reference file fp/test/pdos.cr3si6
EOF
endif
cat <<EOF

EOF
set pass
query chk61 chk6e 'run this test'
chk61:
findcmd chk61a rdcmd "$path" "$topdir"
chk61a:
findcmd chk61b lm "$path" "$topdir"
chk61b:
findcmd chk61c lmstr "$path" "$topdir"
chk61c:
if ($?clean) then
  echo "$space rm -f {log,out,cr,mixm,moms,qpp,save,si,sv,wkp,ctrl,sdot,str,pdos.class,pdos.site,vext0,refdos}.cr3si6"
               rm -f {log,out,cr,mixm,moms,qpp,save,si,sv,wkp,ctrl,sdot,str,pdos.class,pdos.site,vext0,refdos}.cr3si6
  goto chk6e
endif

#  echo 'debugging ...'; goto chk6x

set refout=$testdir/out.cr3si6  testout=out.cr3si6
echo "$space touch ctrl.cr3si6; rm -f {cr,si,qpp,mixm}.cr3si6 ; cp $testdir/{ctrl}.cr3si6 ."
             touch ctrl.cr3si6; rm -f {cr,si,qpp,mixm}.cr3si6 ; cp $testdir/{ctrl}.cr3si6 .

runjob chk62 '/dev/null' "lmstr cr3si6"
chk62:
echo "$space ... Make one pass to provide initial qpp file"
echo "$space lm cr3si6 -vnsph=1 -vnit=0 --pr30,31 <<EOF >$testout"
             lm cr3si6 -vnsph=1 -vnit=0 --pr30,31 <<EOF >$testout
1

1
i
EOF
set retval = $status
if ($retval != 0) goto cleanup
echo "$space Program lm returned successfully."
echo "$space ... Restart with qpp on disk"
echo "$space rm mixm.cr3si6"
             rm mixm.cr3si6
set lm = lm
#  set lm = "mpirun -n $nmpi lm"
echo "$space $lm cr3si6 -vnsph=1 -vnit=-10  --pr30,31 --iactiv=no >>$testout"
             $lm cr3si6 -vnsph=1 -vnit=-10  --pr30,31 --iactiv=no >>$testout
set retval = $status
if ($retval != 0) goto cleanup
echo "$space Program lm returned successfully."
if ($?poszer) then
 echo -n "         ..." ; $poszer $testout
else if ($?add0) then
 echo -n "         ..." ; $add0 $testout
endif
if ($?quiet) goto chk6a

echo ' '
echo "$space ... Compare first iteration multipole moments to line in file $refout":
cat $testout | awk '{if ($1 == "ASAQMP:") {print;getline;print;getline;print;getline;print;getline;print;getline;print;getline;print;getline;print;getline;print;getline;print;getline;print;getline;print}}' | sed -n 1,12p
echo ' ---'
zcat $refout | awk '{if ($1 == "ASAQMP:") {print;getline;print;getline;print;getline;print;getline;print;getline;print;getline;print;getline;print;getline;print;getline;print;getline;print;getline;print}}' | sed -n 1,12p

#  call showout chk65 SV
#  chk65:

chk6a:
echo ' '
call qprint chk6a1 "$space ... automatic pass checks :"
chk6a1:

cat $testout | awk '{if ($1 == "ASAQMP:") {print;getline;print;getline;print;getline;print;getline;print;getline;print;getline;print;getline;print;getline;print;getline;print;getline;print;getline;print}}' | sed -n 1,24p >$testout{}.tmp
zcat $refout | awk '{if ($1 == "ASAQMP:") {print;getline;print;getline;print;getline;print;getline;print;getline;print;getline;print;getline;print;getline;print;getline;print;getline;print;getline;print}}' | sed -n 1,24p >$testout{}.tmp2
cmp $testout{}.tmp $testout{}.tmp2 >& /dev/null
set retval = $status
rm $testout{}.tmp $testout{}.tmp2
echo -n "$space multipole moments from first two iterations identical to reference ? ... "
if ($retval == 0) then
 echo yes
else
  echo no
  unset pass
endif

set dq2 = ` grep SV $testout | tail -1 | awk '{print $3}' | sed s/D/E/`
echo -n "$space rms dq (=$dq2) < tol(1e-5) ... "
if (`echo $dq2 | awk '{print ($1 < 1e-5)}'`) then
  echo yes
else
  echo no
  unset pass
endif

#  set ehfo = `cat $testout | grep ehf= | grep ehk= | tail -1 | awk '{print substr($6,5)}'`
#  set ehfr = `zcat $refout | grep ehf= | grep ehk= | tail -1 | awk '{print substr($6,5)}'`
set ehfo = `cat $testout | grep ' ehf= '  | grep -v last | awk '{print $6}' | tail -1`
set ehfr = `zcat $refout | grep ' ehf= '  | grep -v last | awk '{print $6}' | tail -1`
set etol6 = 1d-5
echo -n "$space Harris energy (=$ehfo) within tolerance (=$etol6) of reference? ... "
if (`echo $ehfo $ehfr $etol6 | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k<$3)}'`) then
  echo yes
else
  echo no
  unset pass
endif

call diffiles chk6s "wkinfo -1 $testout $refout"
chk6s:

echo  " "
echo "$space Generate and check partial DOS ..."
set refout=$testdir/out-dos.cr3si6  testout=out-dos.cr3si6
runrdcmd chk6t %11f $testout "-cat:TSTPDOS --noerr ctrl.cr3si6"
chk6t:

if ($?have_pldos && ! $?quiet && ! $?noplot) then
query chk6mp chk6mp2 "plot l-resolved dos"
chk6mp:
if ($?have_fplot && $?slow) then
  echo "  echo 100 6 -.6 .4 | $pldos -fplot '-lst=1;2;3;4;5'  dos.cr3si6"
          echo 100 6 -.6 .4 | $pldos -fplot '-lst=1;2;3;4;5'  dos.cr3si6
    fplot -disp -pr10 -f plot.dos
    rm fplot.ps
 else
   echo 100 6  -.6 .4 | $pldos '-lst=1,2,3' dos.cr3si6
 endif
endif
chk6mp2:

set dostol = 2e-6
zcmpmfiles_res_0 chk6u "... Max deviation in pdos.class.cr3si6 from reference $testdir/pdos.class.cr3si6" $dostol pass 6 pdos.class.cr3si6 $testdir/pdos.class.cr3si6
chk6u:

zcmpmfiles_res_0 chk6v "... Max deviation in pdos.site.cr3si6 from reference $testdir/pdos.site.cr3si6" $dostol pass 6 pdos.site.cr3si6 $testdir/pdos.site.cr3si6
chk6v:

call diffiles chk6w "wkinfo -1 $testout $refout"
chk6w:

echo  " "
echo "$space Generate and check Levenberg-Marquardt fit of ASA hamiltonian to given partial DOS ..."
set refout=$testdir/out-lm.cr3si6  testout=out-lm.cr3si6
echo "$space cp $testdir/refdos.cr3si6 ."
cp $testdir/refdos.cr3si6 .

if (! $?MPIK) then
runrdcmd chk6x %11f $testout "-cat:TESTLM --noerr ctrl.cr3si6"
else
runrdcmd chk6x %11f $testout "-cat:TSTLMP --noerr ctrl.cr3si6"
endif
chk6x:

zcmpmfiles_res_0 chk6y "... Max deviation in vext0.cr3si6  from reference" 0.000001 pass 6 vext0.cr3si6 $testdir/vext0.cr3si6
chk6y:

call diffiles chk6z "wkinfo -1 $testout $refout"
chk6z:

echo ' '
if ($?pass) then
    echo "$space test 6 PASSED"
else
    echo "$space test 6 FAILED"
    set failed = ($failed 6)
endif

chk6e:

echo $joblist | egrep '\b7\b' >/dev/null
if ($status && "$joblist" != "aux") goto chk7e
cat <<EOF

         ------- Test 7.  Test auxilliary programs  lmscell,lmxbs ---
EOF
if ($?MPIK) then
echo "$space Not set up for MPI job ... skipping"
goto chk7e
endif
query chk71 chk7e 'run the auxilliary tests'
chk71:
findcmd chk71a rdcmd "$path" "$topdir"
chk71a:
findcmd chk71b lmscell "$path" "$topdir"
chk71b:
findcmd chk71c lmxbs "$path" "$topdir"
chk71c:
set pass

set passargs
if ($?clean) set passargs = ($passargs --clean)
if ($?quiet) set passargs = ($passargs --quiet)
if ($?poszer) set passargs = ($passargs --poszer)
if (! $?slow) set passargs = ($passargs --no-iactive)

echo "$space invoke $testdir/test.blm $passargs"
                    $testdir/test.blm $passargs
if ($status) unset pass

echo "$space invoke $testdir/test.lmscell $passargs"
                    $testdir/test.lmscell $passargs
if ($status) unset pass

echo "$space invoke $testdir/test.lmxbs $arglst"
                    $testdir/test.lmxbs $arglst
if ($status) unset pass
echo ' '

echo "$space invoke $testdir/test.ovlp $passargs 1 2 3 4 5"
                    $testdir/test.ovlp $passargs 1 2 3 4 5
if ($status) unset pass

echo ' '
if ($?pass) then
    echo "$space ... test 7 PASSED"
else
    echo "$space ... test 7 FAILED"
    set failed = ($failed 7)
endif

chk7e:


echo $joblist | egrep '\b8\b' >/dev/null
if ($status && "$joblist" != "gd") goto chk8e
cat <<EOF

         ------- Test 8.  Input file ctrl.gd (lmstr,lm) ---
         This file contains input for hcp Gd
         Tests treatment of 4f as core which occupied in majority channel
         and unouccupied in the minority channel.
         Test destroys or changes files *.gd.

EOF
query chk81 chk8e 'run this test'
chk81:
findcmd chk81a rdcmd "$path" "$topdir"
chk81a:
findcmd chk81b lm "$path" "$topdir"
chk81b:
findcmd chk81c lmstr "$path" "$topdir"
chk81c:
findcmd chk81d vextract "$path" "$topdir"
chk81d:

set refout=$testdir/out.gd  testout=out.gd
set pass

echo ' '
echo "$space rm -f {ctrl,dos,gd1,gd,log,mixm,moms,save,sdot,str,sv,wkp,sigm}.gd"
             rm -f {ctrl,dos,gd1,gd,log,mixm,moms,save,sdot,str,sv,wkp,sigm}.gd
if ($?clean) then
  rm -f $testout
  goto chk8e
endif
echo "$space cp $testdir/{ctrl}.gd ."
             cp $testdir/{ctrl}.gd .

if (! $?MPIK) then
runrdcmd chk82 %11f $testout "-cat:TESTLM --noerr ctrl.gd"
else
runrdcmd chk82 %11f $testout "-cat:TESTMP --noerr ctrl.gd"
endif
chk82:

call showout chk85 SV
chk85:
if ($status) echo "$space ... abort ...: file $testout does not contain SV line\!"

call diffiles chk8s "CPU -1 $testout $refout"
chk8s:

set mmom1    = `cat save.gd | $vextract . mom | sed -n 1,1p`
set mmom1ref = `cat $testdir/save.gd | $vextract . mom | sed -n 1,1p`
set eh1      = `cat save.gd | $vextract . ehf | sed -n 1,1p`
set eh1ref   = `cat $testdir/save.gd | $vextract . ehf | sed -n 1,1p`
# set eh1ref   = `cat $testdir/save.gd | awk '{print $12}' | sed -n 1,1p | sed s/mmom=// | sed s/ehf=//`

set mmom2    = `cat save.gd | $vextract . mom | tail -1`
set mmom2ref = `cat $testdir/save.gd | $vextract . mom | tail -1`
set eh2      = `cat save.gd | $vextract . ehf | tail -1`
set eh2ref   = `cat $testdir/save.gd | $vextract . ehf | tail -1`

get_resf chk83b dq1 dq1ref "SV" 3 0 zzz
chk83b:

cnvt_d_fmt chk83c dq1 $dq1
chk83c:
cnvt_d_fmt chk83d dq1ref $dq1ref
chk83d:

cnvt_d_fmt chk83e mmom1 $mmom1
chk83e:
cnvt_d_fmt chk83f mmom1ref $mmom1ref
chk83f:
cnvt_d_fmt chk83g eh1ref $eh1ref
chk83g:
cnvt_d_fmt chk83h eh1 $eh1
chk83h:

cnvt_d_fmt chk84e mmom1 $mmom1
chk84e:
cnvt_d_fmt chk84f mmom1ref $mmom1ref
chk84f:
cnvt_d_fmt chk84g eh1ref $eh1ref
chk84g:
cnvt_d_fmt chk84h eh1 $eh1
chk84h:

if ($?detol8 == 0) set detol8 = 1.0e-6
if ($?dqtol8 == 0) set dqtol8 = 5.0e-6

if (! $?quiet) then
  echo " "
  echo "$space energy of FM state               = $eh1"
  echo "$space energy of reference              = $eh1ref"
  set ediff = `echo $eh1 $eh1ref  | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print k}'`
  echo "$space                    difference    =  $ediff"
  echo ' '
  if ($?mmom1) then
  echo "$space magnetic moment of FM state      = $mmom1"
  echo "$space FM reference magnetic moment     = $mmom1ref"
  set mdiff = `echo $mmom1 $mmom1ref | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print k}'`
  echo "$space difference                       = $mdiff"
  endif

  echo " "
  echo "$space energy of AFM state              = $eh2"
  echo "$space energy of reference              = $eh2ref"
  set ediff = `echo $eh2 $eh2ref  | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print k}'`
  echo "$space                    difference    =  $ediff"
  echo ' '
  if ($?mmom2) then
  echo "$space magnetic moment of AFM state     = $mmom2"
  echo "$space AFM reference magnetic moment    = $mmom2ref"
  set mdiff = `echo $mmom2 $mmom2ref | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print k}'`
  echo "$space difference                       = $mdiff"

  echo ' '
  set ediff = `echo $eh1 $eh2  | awk '{{k=($1-$2)} print k}'`
  echo "$space AFM-FM difference                = $ediff"
  echo ' '
  endif

endif

# pass checks
chk8c:

# ... Check that FM total energy is within tol of reference
compare_res chk8cb "Ferromagnetic ehf" $eh1 $eh1ref $detol8 pass
chk8cb:

if (! $?mmom1) goto chk8cd
compare_res chk8cd "Ferromagnetic mmom" $mmom1 $mmom1ref $dqtol8 pass
chk8cd:

# ... Check that AFM total energy is within tol of reference
compare_res chk8cf "AFM ehf" $eh2 $eh2ref $detol8 pass
chk8cf:

if ($?pass) then
    echo "$space ... test 8 PASSED"
else
    echo "$space ... test 8 FAILED"
    set failed = ($failed 8)
endif

chk8e:

echo $joblist | egrep '\b9\b' >/dev/null
if ($status && "$joblist" != "er") goto chk9e
cat <<EOF

         ------- Test 9.  Input file ctrl.er (lmstr,lm) ---
         This file contains input for hcp Er.
         Tests LDA+U treatment of 4f.
         The 4f majority channel is filled and get pushed down by ~U/2 relative to LDA.
         The 4f minority channel is split:
           four states (m=0,1,2,3, spherical harmonics) are occupied while
           three states (m=-3,-2,-1) are unoccupied.

         The test starts with miminum input information: (f moment=3, simple occnum)
         Test destroys or changes files *.er and specialspec1.

         Independent checks you can make:
          - How closely it follows rotational invariance (repeat without spherical harmonics, SHARM=0)
            Verify energy, magnetic moment, density-matrix and bands are very similar (not identical).

          - How dependent the result is on representation (repeat with GAMMA=0)
            Verify energy, magnetic moment, and bands are very similar.

          - How dependent the result is on off-diagonal part of U potential (repeat with UDIAG=1)
            Verify energy, magnetic moment, and bands are very similar.

          - Combination of real harmonics and diagonal-only.
            In this case, the result is very different.

EOF
query chk91 chk9e 'run this test'
chk91:
findcmd chk91a rdcmd "$path" "$topdir"
chk91a:
findcmd chk91b lm "$path" "$topdir"
chk91b:
findcmd chk91c lmstr "$path" "$topdir"
chk91c:

set refout=$testdir/out.lm.er  testout=out.lm.er
set pass

#  goto chk92

echo ' '
echo "$space rm -f {ctrl,er,log,mixm,moms,save,sdot,str,sv,wkp,sigm,dmats,site,shfac,syml,occnum,bnds,qpp}.er atparms specialspec1"
             rm -f {ctrl,er,log,mixm,moms,save,sdot,str,sv,wkp,sigm,dmats,site,shfac,syml,occnum,bnds,qpp}.er atparms specialspec1
if ($?clean) then
  rm -f $testout
  goto chk9e
endif
echo "$space cp $testdir/{ctrl.er,occnum.er,site.er,syml.er,specialspec1,atparms} ."
             cp $testdir/{ctrl.er,occnum.er,site.er,syml.er,specialspec1,atparms} .


if (! $?MPIK) then
runrdcmd chk92 %11f $testout "-cat:TESTLM --noerr ctrl.er"
else
runrdcmd chk92 %11f $testout "-cat:TSTLMP --noerr ctrl.er"
endif
chk92:

call showout chk95 SV
chk95:
if ($status) echo "$space ... abort ...: file $testout does not contain SV line\!"

call diffiles chk9s "CPU -1 $testout $refout"
chk9s:


set mmom1    = `tail -1 save.er | awk '{match($0,"(mmom=)([^ ]+)",a); print a[2]}'`
set mmom1ref = `tail -1 $testdir/save.er | awk '{match($0,"(mmom=)([^ ]+)",a); print a[2]}'`
set eh1      = `tail -1 save.er | awk '{match($0,"(ehf=)([^ ]+)",a); print a[2]}'`
set eh1ref   = `tail -1 $testdir/save.er | awk '{match($0,"(ehf=)([^ ]+)",a); print a[2]}'`

get_resf chk93b dq1 dq1ref "SV" 3 0 zzz
chk93b:

cnvt_d_fmt chk93c dq1 $dq1
chk93c:
cnvt_d_fmt chk93d dq1ref $dq1ref
chk93d:

cnvt_d_fmt chk93e mmom1 $mmom1
chk93e:
cnvt_d_fmt chk93f mmom1ref $mmom1ref
chk93f:
cnvt_d_fmt chk93g eh1ref $eh1ref
chk93g:
cnvt_d_fmt chk93h eh1 $eh1
chk93h:

cnvt_d_fmt chk94e mmom1 $mmom1
chk94e:
cnvt_d_fmt chk94f mmom1ref $mmom1ref
chk94f:
cnvt_d_fmt chk94g eh1ref $eh1ref
chk94g:
cnvt_d_fmt chk94h eh1 $eh1
chk94h:

if ($?detol9 == 0) set detol9 = 1.0e-6
if ($?dqtol9 == 0) set dqtol9 = 5.0e-6

if (! $?quiet) then
  echo " "
  echo "$space energy of FM state               = $eh1"
  echo "$space energy of reference              = $eh1ref"
  set ediff = `echo $eh1 $eh1ref  | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print k}'`
  echo "$space                    difference    =  $ediff"
  echo ' '
  if ($?mmom1) then
  echo "$space magnetic moment of FM state      = $mmom1"
  echo "$space FM reference magnetic moment     = $mmom1ref"
  set mdiff = `echo $mmom1 $mmom1ref | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print k}'`
  echo "$space difference                       = $mdiff"
  echo ' '
  endif

#    echo "$space energy of AFM state              = $eh2"
#    echo "$space energy of reference              = $eh2ref"
#    set ediff = `echo $eh2 $eh2ref  | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print k}'`
#    echo "$space                    difference    =  $ediff"
#    echo ' '
#    if ($?mmom2) then
#    echo "$space magnetic moment of AFM state     = $mmom2"
#    echo "$space AFM reference magnetic moment    = $mmom2ref"
#    set mdiff = `echo $mmom2 $mmom2ref | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print k}'`
#    echo "$space difference                       = $mdiff"

#    echo ' '
#    set ediff = `echo $eh1 $eh2  | awk '{{k=($1-$2)} print k}'`
#    echo "$space AFM-FM difference                = $ediff"
#    echo ' '
#    endif

endif

# pass checks
chk9c:

# ... Check that FM total energy is within tol of reference
compare_res chk9cb "... Ferromagnetic ehf" $eh1 $eh1ref $detol9 pass
chk9cb:

if (! $?mmom1) goto chk9cd
compare_res chk9cd "... Ferromagnetic mmom" $mmom1 $mmom1ref $dqtol9 pass
chk9cd:

#  # ... Check that AFM total energy is within tol of reference
#  compare_res chk9cf "... AFM ehf" $eh2 $eh2ref $detol9 pass
#  chk9cf:

if ($?poszer) then
 echo -n "         ..." ; $poszer bnds.er
else if ($?add0) then
 echo -n "         ..." ; $add0 bnds.er
endif
set bndstol = 2e-4
zcmpmfiles_res_0 chk9cg "... Max deviation in bnds.er from reference" $bndstol pass 4 bnds.er $testdir/bnds.er
chk9cg:

set dmatstol = 2e-4
zcmpmfiles_res_0 chk9ch "... Max deviation in dmats.er from reference" $dmatstol pass 4 dmats.er $testdir/dmats.er
chk9ch:

if ($?pass) then
    echo "$space ... test 9 PASSED"
else
    echo "$space ... test 9 FAILED"
    set failed = ($failed 9)
endif

chk9e:

echo $joblist | egrep '\b10\b' >/dev/null
if ($status && "$joblist" != "lap") goto chkae
cat <<EOF

         ------- Test 10.  Tests value-laplacian structure constants (lmstr) ---
         This file contains input to test (Gaussian) value-laplacian structure constants

         This test checks the (Gaussian) val-lap functions via --pltg:...
         To plot value-slope (screened Hankel) functions,  use --plot:...

         Try the following to view a contour plot of the screened Hankel functions:
           lmstr vlap --plot:con -vgmode=3 -vrmxs=0.8 -vrsma=0.3 -vivl=0 --iactive
         If you have fplot installed ...
           fplot -lt 1,col=0,0,0 -con 1e-3  plot.vlap -lt 1,col=1,0,0 -con  1e-4 plot.vlap -lt 1,col=.5,.5,0 -con  1e-5 plot.vlap -lt 1,col=0,1,0 -con 1e-6 plot.vlap \
                 -lt 2,col=0,0,0 -con -1e-3 plot.vlap -lt 2,col=1,0,0 -con -1e-4 plot.vlap -lt 2,col=.5,.5,0 -con -1e-5 plot.vlap -lt 2,col=0,1,0 -con -1e-6 plot.vlap

         Try the following to test the one-center expansion:
           lmstr vlap --plot:onec -vgmode=13 -vrmxs=0.8 -vrsma=0.3 -vivl=0 --iactive

         Try the following to generate screened u,s function along the y axis
           lmstr vlap --plot:line,0,-14,0,0,14,0 -vgmode=3 -vrmxs=0.8 -vrsma=0.3 -vivl=0 --iactive
         If you have fplot installed ...
           fplot -frme:ly 0,1,0,1 -y 1e-5,1 -ab x2 -colsy 4 -ord 'abs(y)' plot.vlap

EOF
if ($?MPIK) then
echo "$space Not set up for MPI job ... skipping"
goto chkae
endif
query chka1 chkae 'run this test'
chka1:
findcmd chka1a rdcmd "$path" "$topdir"
chka1a:
findcmd chka1c lmstr "$path" "$topdir"
chka1c:

set refout=$testdir/out.lmstr.vlap  testout=out.lmstr.vlap
set pass

#  goto chka2

echo ' '
echo "$space rm -f {ctrl,log,strg,str,sdot}.vlap"
             rm -f {ctrl,log,strg,str,sdot}.vlap
if ($?clean) then
  rm -f $testout
  goto chkae
endif
echo "$space cp $testdir/{ctrl.vlap} ."
             cp $testdir/{ctrl.vlap} .


runrdcmd chka2 %11f $testout "-cat:TLMSTR --noerr ctrl.vlap"
chka2:

call diffiles chkas "CPU -1 $testout $refout"
chkas:

set val1    = `grep value: out.lmstr.vlap | sed -n 1,1p | tail -1 | awk '{print $4'}`
set val2    = `grep value: out.lmstr.vlap | sed -n 1,2p | tail -1 | awk '{print $4'}`
set val3    = `grep value: out.lmstr.vlap | sed -n 1,3p | tail -1 | awk '{print $4'}`
set val4    = `grep value: out.lmstr.vlap | sed -n 1,4p | tail -1 | awk '{print $4'}`
set val5    = `grep value: out.lmstr.vlap | sed -n 1,5p | tail -1 | awk '{print $4'}`
set val6    = `grep value: out.lmstr.vlap | sed -n 1,6p | tail -1 | awk '{print $4'}`

set lap1    = `grep Laplacian: out.lmstr.vlap | sed -n 1,1p | tail -1 | awk '{print $4'}`
set lap2    = `grep Laplacian: out.lmstr.vlap | sed -n 1,2p | tail -1 | awk '{print $4'}`
set lap3    = `grep Laplacian: out.lmstr.vlap | sed -n 1,3p | tail -1 | awk '{print $4'}`
set lap4    = `grep Laplacian: out.lmstr.vlap | sed -n 1,4p | tail -1 | awk '{print $4'}`
set lap5    = `grep Laplacian: out.lmstr.vlap | sed -n 1,5p | tail -1 | awk '{print $4'}`
set lap6    = `grep Laplacian: out.lmstr.vlap | sed -n 1,6p | tail -1 | awk '{print $4'}`


#  cnvt_d_fmt chka3c dq1 $dq1
#  chka3c:
#  cnvt_d_fmt chka3d dq1ref $dq1ref
#  chka3d:

#  cnvt_d_fmt chka3e mmom1 $mmom1
#  chka3e:
#  cnvt_d_fmt chka3f mmom1ref $mmom1ref
#  chka3f:
#  cnvt_d_fmt chka3g eh1ref $eh1ref
#  chka3g:
#  cnvt_d_fmt chka3h eh1 $eh1
#  chka3h:

#  cnvt_d_fmt chka4e mmom1 $mmom1
#  chka4e:
#  cnvt_d_fmt chka4f mmom1ref $mmom1ref
#  chka4f:
#  cnvt_d_fmt chka4g eh1ref $eh1ref
#  chka4g:
#  cnvt_d_fmt chka4h eh1 $eh1
#  chka4h:

if ($?dvtola == 0) set dvtola = 1.0e-6
if ($?dltola == 0) set dltola = 1.0e-5

if (! $?quiet) then
  echo " "
  echo "$space test G0 + G1  deviation in val f1 at rMT   = $val1"
  echo "$space test G0 + G1  deviation in lap f1 at rMT   = $lap1"
  echo "$space test G0 + G1  deviation in val f2 at rMT   = $val2"
  echo "$space test G0 + G1  deviation in lap f2 at rMT   = $lap2"

  echo "$space test G0 + Hsm deviation in val f1 at rMT   = $val3"
  echo "$space test G0 + Hsm deviation in lap f1 at rMT   = $lap3"
  echo "$space test G0 + Hsm deviation in val f2 at rMT   = $val4"
  echo "$space test G0 + Hsm deviation in lap f2 at rMT   = $lap4"

  echo "$space test G0 + Hdt deviation in val f1 at rMT   = $val5"
  echo "$space test G0 + Hdt deviation in lap f1 at rMT   = $lap5"
  echo "$space test G0 + Hdt deviation in val f2 at rMT   = $val6"
  echo "$space test G0 + Hdt deviation in lap f2 at rMT   = $lap6"

endif

# pass checks
chkac:

echo " "

# ... Check that FM total energy is within tol of reference
compare_res_0 chkaca "Max deviation val f1" $val1 $dvtola pass
chkaca:

# ... Check that FM total energy is within tol of reference
compare_res_0 chkacb "Max deviation val f2" $val2 $dvtola pass
chkacb:

# ... Check that FM total energy is within tol of reference
compare_res_0 chkacc "Max deviation lap f1" $lap1 $dltola pass
chkacc:

# ... Check that FM total energy is within tol of reference
compare_res_0 chkacd "Max deviation lap f2" $lap2 $dltola pass
chkacd:

if ($?pass) then
    echo "$space ... test 10 PASSED"
else
    echo "$space ... test 10 FAILED"
    set failed = ($failed 10)
endif

chkae:

echo $joblist | egrep '\b11\b' >/dev/null
if ($status && "$joblist" != "si") goto chkbe
cat <<EOF

         ------- Test 11.  Levenberg-Marquardt fit of ASA hamiltonian to bands ---

       Fit ASA energy bands of Si to FP bands.

EOF
query chkb1 chkbe 'run this test'
chkb1:
findcmd chkb1a rdcmd "$path" "$topdir"
chkb1a:
findcmd chkb1c lmstr "$path" "$topdir"
chkb1c:
findcmd chkb1d lm "$path" "$topdir"
chkb1d:

set refout=$testdir/out.lm.si  testout=out.lm.si
set pass

# echo DEBUG; goto chkb2

echo ' '
echo "$space rm -f {ctrl,log,strg,str,sdot,vext0,moms,wkp,es,si,refbnds,bnds,vext,vext0}.si"
             rm -f {ctrl,log,strg,str,sdot,vext0,moms,wkp,es,si,refbnds,bnds,vext,vext0}.si
if ($?clean) then
  rm -f $testout
  goto chkbe
endif
echo "$space cp $testdir/{ctrl.si,refbnds.si} ."
             cp $testdir/{ctrl.si,refbnds.si} .

if (! $?MPIK) then
runrdcmd chkb2 %11f $testout "-cat:TESTLM --noerr ctrl.si"
else
runrdcmd chkb2 %11f $testout "-cat:TESTMPI --noerr ctrl.si"
endif
chkb2:

call diffiles chkbs "CPU -1 $testout $refout"
chkbs:

set rms1  = `cat $testout      | grep 'starting RMS error=' | sed -n 1,1p | awk '{match($0,"error=[^ ]*"); print substr($0,RSTART+6,RLENGTH-6)}'`
set rmsr1 = `zcat $refout | grep 'starting RMS error=' | sed -n 1,1p | awk '{match($0,"error=[^ ]*"); print substr($0,RSTART+6,RLENGTH-6)}'`
set rmsf  = `cat $testout      | grep 'new RMS=' | tail -1  | awk '{match($0,"RMS=[^ ]*"); print substr($0,RSTART+4,RLENGTH-4)}'`
set rmsrf = `zcat $refout | grep 'new RMS=' | tail -1  | awk '{match($0,"RMS=[^ ]*"); print substr($0,RSTART+4,RLENGTH-4)}'`


if (! $?quiet) then
  echo " "
  echo "$space Initial rms deviation in energy bands         = $rms1"
  echo "$space Initial rms deviation, reference              = $rmsr1"
  echo "$space Final rms deviation in energy bands           = $rmsf"
  echo "$space Final rms deviation, reference                = $rmsrf"

endif

# pass checks
chkbc:

echo " "

# ... Check that initial rms deviation within tol of reference
compare_res chkbd "... Initial RMS deviation" $rms1 $rmsr1 .00001 pass
chkbd:

compare_res chkbf "... Final RMS deviation" $rmsf $rmsrf .00001 pass
chkbf:

zcmpmfiles_res_0 chkbg "... Max deviation in vext0.si  from reference" 0.000001 pass 6 vext0.si $testdir/vext0.si
chkbg:

if ($?pass) then
    echo "$space ... test 11 PASSED"
else
    echo "$space ... test 11 FAILED"
    set failed = ($failed 11)
endif

chkbe:

echo $joblist | egrep '\b12\b' >/dev/null
if ($status && "$joblist" != "inp") goto chkce
cat <<EOF

         ------- Test 12.  Levenberg-Marquardt fit of ASA hamiltonian to DOS ---

       Fit ASA partial DOS in InP to reference.
       Fit In "s" partial DOS by varying In s (C, Delta) parameters,
       over an energy range approximately covered by the occupied states.

EOF
if ($?have_fplot && $?have_pldos && $?have_ghostscript) then
cat <<EOF
       After the test executes, draw a picture comparing fit and reference DOS with:
         fplot -disp -lt 1,col=1,0,0 dosr.inp -lt 2,col=0,1,0 dosf.inp

EOF
endif


query chkc1 chkce 'run this test'
chkc1:
findcmd chkc1a rdcmd "$path" "$topdir"
chkc1a:
findcmd chkc1c lmstr "$path" "$topdir"
chkc1c:
findcmd chkc1d lm "$path" "$topdir"
chkc1d:

set refout=$testdir/out.lm.inp  testout=out.lm.inp
set pass

# echo DEBUG; goto chkc2
echo ' '
echo "$space rm -f {ctrl,a1,c1,dosf,dosr,ea1,ec1,log,moms,refdos,sdot,str,vext0,vext,wkp,sigm}.inp"
             rm -f {ctrl,a1,c1,dosf,dosr,ea1,ec1,log,moms,refdos,sdot,str,vext0,vext,wkp,sigm}.inp
if ($?clean) then
  rm -f $testout
  goto chkce
endif
echo "$space cp $testdir/{ctrl,vext,refdos}.inp ."
             cp $testdir/{ctrl,vext,refdos}.inp .

if (! $?MPIK) then
runrdcmd chkc2 %11f $testout "-cat:TESTLM --noerr ctrl.inp"
else
runrdcmd chkc2 %11f $testout "-cat:TESTMPI --noerr ctrl.inp"
endif
chkc2:

call diffiles chkcs "CPU -1 $testout $refout"
chkcs:

set rms1  = `cat $testout      | grep 'starting RMS error=' | sed -n 1,1p | awk '{match($0,"error=[^ ]*"); print substr($0,RSTART+6,RLENGTH-6)}'`
set rmsr1 = `zcat $refout | grep 'starting RMS error=' | sed -n 1,1p | awk '{match($0,"error=[^ ]*"); print substr($0,RSTART+6,RLENGTH-6)}'`
set rmsf  = `cat $testout      | grep 'new RMS=' | tail -1  | awk '{match($0,"RMS=[^ ]*"); print substr($0,RSTART+4,RLENGTH-4)}'`
set rmsrf = `zcat $refout | grep 'new RMS=' | tail -1  | awk '{match($0,"RMS=[^ ]*"); print substr($0,RSTART+4,RLENGTH-4)}'`


if (! $?quiet) then
  echo " "
  echo "$space Initial rms deviation in energy bands         = $rms1"
  echo "$space Initial rms deviation, reference              = $rmsr1"
  echo "$space Final rms deviation in energy bands           = $rmsf"
  echo "$space Final rms deviation, reference                = $rmsrf"

endif

# pass checks
chkcc:

echo " "

# ... Check that initial rms deviation within tol of reference
compare_res chkcd "... Initial RMS deviation" $rms1 $rmsr1 .00001 pass
chkcd:

compare_res chkcf "... Final RMS deviation" $rmsf $rmsrf .00001 pass
chkcf:

zcmpmfiles_res_0 chkcg "... Max deviation in vext0.inp  from reference" 0.000001 pass 6 vext0.inp $testdir/vext0.inp
chkcg:

if ($?pass) then
    echo "$space ... test 12 PASSED"
else
    echo "$space ... test 12 FAILED"
    set failed = ($failed 12)
endif

chkce:

echo $joblist | egrep '\b13\b' >/dev/null
if ($status && "$joblist" != "feal") goto chkde
cat <<EOF

         ------- Test 13.  Levenberg-Marquardt fit of ASA hamiltonian to QSGW DOS ---

       Fit ASA partial DOS in FeAl to QSGW reference DOS.

       Although the bands are not fit directly, you can compare the bands to QSGW bands;
       the latter are kept in this directory as file refbnds.feal.

EOF
if ($?have_fplot && $?have_pldos && $?have_ghostscript) then
cat <<EOF
       After the test executes, draw a picture comparing fit and reference DOS with:
         fplot -disp -colsy 6 -lt 1,col=1,0,0 dosr.feal -colsy 6 -lt 2,col=0,1,0 dosf.feal

EOF
endif


query chkd1 chkde 'run this test'
chkd1:
findcmd chkd1a rdcmd "$path" "$topdir"
chkd1a:
findcmd chkd1c lmstr "$path" "$topdir"
chkd1c:
findcmd chkd1d lm "$path" "$topdir"
chkd1d:

set refout=$testdir/out.lm.feal  testout=out.lm.feal
set pass

#  echo DEBUG; goto chkdc

echo ' '
echo "$space rm -f {a1,bnds,c1,ctrl,dosf,dosr,log,moms,refdos,save,sdot,str,shfac,syml,vext,vext0,wkp}.feal specialspecc specialspeca specialh"
             rm -f {a1,bnds,c1,ctrl,dosf,dosr,log,moms,refdos,save,sdot,str,shfac,syml,vext,vext0,wkp}.feal specialspecc specialspeca specialh


if ($?clean) then
  rm -f $testout
  goto chkde
endif
echo "$space cp $testdir/{ctrl,vext,refdos,syml}.feal $testdir/semi.mater ."
             cp $testdir/{ctrl,vext,refdos,syml}.feal $testdir/semi.mater .

if (! $?MPIK) then
runrdcmd chkd2 %11f $testout "-cat:TESTLM --noerr ctrl.feal"
else
runrdcmd chkd2 %11f $testout "-cat:TESTMPI --noerr ctrl.feal"
endif
chkd2:

call diffiles chkds "CPU -1 $testout $refout"
chkds:

set rms1  = `cat $testout      | grep 'starting RMS error=' | sed -n 1,1p | awk '{match($0,"error=[^ ]*"); print substr($0,RSTART+6,RLENGTH-6)}'`
set rmsr1 = `zcat $refout | grep 'starting RMS error=' | sed -n 1,1p | awk '{match($0,"error=[^ ]*"); print substr($0,RSTART+6,RLENGTH-6)}'`
set rmsf  = `cat $testout      | grep 'new RMS=' | tail -1  | awk '{match($0,"RMS=[^ ]*"); print substr($0,RSTART+4,RLENGTH-4)}'`
set rmsrf = `zcat $refout | grep 'new RMS=' | tail -1  | awk '{match($0,"RMS=[^ ]*"); print substr($0,RSTART+4,RLENGTH-4)}'`


if (! $?quiet) then
  echo " "
  echo "$space Initial rms deviation in DOS                  = $rms1"
  echo "$space Initial rms deviation, reference              = $rmsr1"
  echo "$space Final rms deviation in DOS                    = $rmsf"
  echo "$space Final rms deviation, reference                = $rmsrf"

endif

# pass checks
chkdc:

echo " "

# ... Check that initial rms deviation within tol of reference
compare_res chkdca "... Initial RMS deviation" $rms1 $rmsr1 .00001 pass
chkdca:

compare_res chkdcb "... Final RMS deviation" $rmsf $rmsrf .00001 pass
chkdcb:

if ($?add0) then
  echo -n "         ..." ; $add0 vext0.feal
else if ($?poszer) then
  echo -n "         ..." ; $poszer vext0.feal
endif
zcmpmfiles_res_0 chkdcc "... Max deviation in vext0.feal  from reference" 0.000005 pass 6 vext0.feal $testdir/vext0.feal
chkdcc:

set bndstol = 2e-4
if ($?add0) then
  echo -n "         ..." ; $add0 bnds.feal
else if ($?poszer) then
  echo -n "         ..." ; $poszer bnds.feal
endif
zcmpmfiles_res_0 chkdcd "... Max deviation in bnds.feal from reference" $bndstol pass 4 bnds.feal $testdir/bnds.feal
chkdcd:

if ($?pass) then
    echo "$space ... test 13 PASSED"
else
    echo "$space ... test 13 FAILED"
    set failed = ($failed 13)
endif

chkde:

echo $joblist | egrep '\b14\b' >/dev/null
if ($status && "$joblist" != "smstr") goto chkee
cat <<EOF

         ------- Test 14.  Tests double-kappa structure constants (lmstr) ---
         This file contains input to test double-kappa structure constants for unsm Hankels

         To plot functions,  use --plot:con or --plot:line

         To test 1-center expansion on a surface different from the HCR,
         append to any of the following lmstr commands, e.g.  --radius=1.5


EOF
if ($?MPIK) then
echo "$space Not set up for MPI job ... skipping"
goto chkee
endif
query chke1 chkee 'run this test'
chke1:
findcmd chke1a rdcmd "$path" "$topdir"
chke1a:
findcmd chke1c lmstr "$path" "$topdir"
chke1c:

set refout=$testdir/out.lmstr.2kap  testout=out.lmstr.smh
set pass

#  goto chke2

echo ' '
echo "$space rm -f {ctrl,log,strg,str,sdot}.smh"
             rm -f {ctrl,log,strg,str,sdot}.smh
if ($?clean) then
  rm -f $testout
  goto chkee
endif
echo "$space cp $testdir/{ctrl.smh} ."
             cp $testdir/{ctrl.smh} .


runrdcmd chke2 %11f $testout "-cat:TLMSTR2 --noerr ctrl.smh"
chke2:

call diffiles chkes "difference -1 $testout $refout"
chkes:

set val1    = `grep 'Ha vs 1c' out.lmstr.smh | sed -n 1,1p | tail -1 | awk '{print $6}'`
set val2    = `grep 'Ha vs 1c' out.lmstr.smh | sed -n 1,2p | tail -1 | awk '{print $6}'`
set val3    = `grep 'Ha vs 1c' out.lmstr.smh | sed -n 1,3p | tail -1 | awk '{print $6}'`
set val4    = `grep 'Ha vs 1c' out.lmstr.smh | sed -n 1,4p | tail -1 | awk '{print $6}'`

set slo1    = `grep 'H.a vs 1c' out.lmstr.smh | sed -n 1,1p | tail -1 | awk '{print $6}'`
set slo2    = `grep 'H.a vs 1c' out.lmstr.smh | sed -n 1,2p | tail -1 | awk '{print $6}'`
set slo3    = `grep 'H.a vs 1c' out.lmstr.smh | sed -n 1,3p | tail -1 | awk '{print $6}'`
set slo4    = `grep 'H.a vs 1c' out.lmstr.smh | sed -n 1,4p | tail -1 | awk '{print $6}'`


if ($?dvtola == 0) set dvtola = 1.0e-7
if ($?dstola == 0) set dstola = 1.0e-6

if (! $?quiet) then
  echo " "
  echo "$space 2-kappa strux deviation in VAL at rmt (head=2, ib=2, ikap=1) = $val1"
  echo "$space 2-kappa strux deviation in VAL at rmt (head=2, ib=2, ikap=2) = $val2"
  echo "$space 2-kappa strux deviation in VAL at rmt (head=1, ib=2, ikap=1) = $val3"
  echo "$space 2-kappa strux deviation in VAL at rmt (head=1, ib=2, ikap=2) = $val4"
  echo " "
  echo "$space 2-kappa strux deviation in SLO at rmt (head=2, ib=2, ikap=1) = $slo1"
  echo "$space 2-kappa strux deviation in SLO at rmt (head=2, ib=2, ikap=2) = $slo2"
  echo "$space 2-kappa strux deviation in SLO at rmt (head=1, ib=2, ikap=1) = $slo3"
  echo "$space 2-kappa strux deviation in SLO at rmt (head=1, ib=2, ikap=2) = $slo4"

endif

# pass checks
chkec:

echo " "

if ($val1 == "") then
  echo "$space ... no checks generated"
  unset pass
  goto chkech
endif

compare_res_0 chkeca "Max deviation val (ia=2, ib=2, ikap=1)" $val1 $dvtola pass
chkeca:

compare_res_0 chkecb "Max deviation val (ia=2, ib=2, ikap=2)" $val2 $dvtola pass
chkecb:

compare_res_0 chkecc "Max deviation slo (ia=2, ib=2, ikap=1)" $slo1 $dstola pass
chkecc:

compare_res_0 chkecd "Max deviation slo (ia=2, ib=2, ikap=2)" $slo2 $dstola pass
chkecd:

compare_res_0 chkece "Max deviation val (ia=1, ib=2, ikap=1)" $val3 $dvtola pass
chkece:

compare_res_0 chkecf "Max deviation val (ia=1, ib=2, ikap=2)" $val4 $dvtola pass
chkecf:

compare_res_0 chkecg "Max deviation slo (ia=1, ib=2, ikap=1)" $slo3 $dstola pass
chkecg:

compare_res_0 chkech "Max deviation slo (ia=1, ib=2, ikap=2)" $slo4 $dstola pass
chkech:


if ($?pass) then
    echo "$space ... test 14 PASSED"
else
    echo "$space ... test 14 FAILED"
    set failed = ($failed 14)
endif

chkee:

echo $joblist | egrep '\b15\b' >/dev/null
if ($status && "$joblist" != "smstr") goto chkfe
cat <<EOF

         ------- Test 15.  Tests structure constants for skw (lmstr) ---
         This file contains input to test structure constants for sm Hankels
         It tests 1-center expansions. To plot functions,  use --plot:con or --plot:line

EOF
if ( $?slow == 1 ) then
cat <<EOF
         To test 1-center expansion at on a surface different from the HCR,
         append to any of the following lmstr commands, e.g.  --radius=1.5

         You can also try fitting mode 5, where the K.E. at a tail site is numerically very small.  Do one of:
           lmstr smh --plot:smh5:onec -vgmode=1  --pr45 --ikap=1 --ixi=2 | tee out
           lmstr --pr40 tc --plot:smh4:onec -vgmode=1 --iactiv=no --ikap=1 --atom=7 --ixi=2 | tee out
         and compare them to files in the testing directory
           diff out $topdir/testing/out.lmstr.1kap.smh5.smh
           diff out $topdir/testing/out.lmstr.1kap.smh4.tc
EOF
endif
if ($?MPIK) then
echo "$space Not set up for MPI job ... skipping"
goto chkfe
endif
query chkf1 chkfe 'run this test'
chkf1:
findcmd chkf1a rdcmd "$path" "$topdir"
chkf1a:
findcmd chkf1c lmstr "$path" "$topdir"
chkf1c:

set pass = 1
set ext = smh
set dvtola = 3.0d-5
set dstola = 2.0d-5

# Re-entry point for another test
chkf1d:
set refout=$testdir/out.lmstr.1kap.$ext  testout=out.lmstr.$ext

echo ' '
echo "$space rm -f {ctrl,log,strg,str,sdot}.$ext"
             rm -f {ctrl,log,strg,str,sdot}.$ext
if ($?clean) then
  rm -f $testout
  goto chkfe
endif
echo "$space cp $testdir/{ctrl.$ext} ."
             cp $testdir/{ctrl.$ext} .


runrdcmd chkf2 %11f $testout "-cat:TLMSTR --noerr ctrl.$ext"
chkf2:

call diffiles chkfs "difference -1 $testout $refout"
chkfs:

set val1    = `grep 'Ha vs 1c' out.lmstr.$ext | sed -n 1,1p | tail -1 | awk '{print $6}'`
set val2    = `grep 'Ha vs 1c' out.lmstr.$ext | sed -n 1,2p | tail -1 | awk '{print $6}'`
set val3    = `grep 'Ha vs 1c' out.lmstr.$ext | sed -n 1,3p | tail -1 | awk '{print $6}'`
set val4    = `grep 'Ha vs 1c' out.lmstr.$ext | sed -n 1,4p | tail -1 | awk '{print $6}'`

set slo1    = `grep 'H.a vs 1c' out.lmstr.$ext | sed -n 1,1p | tail -1 | awk '{print $6}'`
set slo2    = `grep 'H.a vs 1c' out.lmstr.$ext | sed -n 1,2p | tail -1 | awk '{print $6}'`
set slo3    = `grep 'H.a vs 1c' out.lmstr.$ext | sed -n 1,3p | tail -1 | awk '{print $6}'`
set slo4    = `grep 'H.a vs 1c' out.lmstr.$ext | sed -n 1,4p | tail -1 | awk '{print $6}'`

set ib = `grep 'Expand head' $testout | awk '{print substr($3,5,1)}'     | sed -n 1,1p`
if (! $?quiet) then
  echo " "
  set jb = `grep 'Expand head' $testout | awk '{print substr($6,5,1)}' | sed -n 1,1p`
  echo "$space unsm H strux deviation in VAL at rmt (head=$ib, tail=$jb) = $val1"
  set jb = `grep 'Expand head' $testout | awk '{print substr($6,5,1)}' | sed -n 2,2p`
  echo "$space unsm H strux deviation in VAL at rmt (head=$ib, tail=$jb) = $val2"
  set jb = `grep 'Expand head' $testout | awk '{print substr($6,5,1)}' | sed -n 3,3p`
  echo "$space   sm H strux deviation in VAL at rmt (head=$ib, tail=$jb) = $val3"
  set jb = `grep 'Expand head' $testout | awk '{print substr($6,5,1)}' | sed -n 4,4p`
  echo "$space   sm H strux deviation in VAL at rmt (head=$ib, tail=$jb) = $val4"
  echo " "
  echo "$space unsm H strux deviation in SLO at rmt (head=$ib, tail=$jb) = $slo1"
  set jb = `grep 'Expand head' $testout | awk '{print substr($6,5,1)}' | sed -n 1,1p`
  echo "$space unsm H strux deviation in SLO at rmt (head=$ib, tail=$jb) = $slo2"
  set jb = `grep 'Expand head' $testout | awk '{print substr($6,5,1)}' | sed -n 2,2p`
  echo "$space   sm H strux deviation in SLO at rmt (head=$ib, tail=$jb) = $slo3"
  set jb = `grep 'Expand head' $testout | awk '{print substr($6,5,1)}' | sed -n 3,3p`
  echo "$space   sm H strux deviation in SLO at rmt (head=$ib, tail=$jb) = $slo4"
  set jb = `grep 'Expand head' $testout | awk '{print substr($6,5,1)}' | sed -n 4,4p`
endif

# pass checks
chkfc:

echo " "

if ($val1 == "") then
  echo "$space ... no checks generated"
  unset pass
  goto chkfcz
endif

set jb = `grep 'Expand head' $testout | awk '{print substr($6,5,1)}' | sed -n 1,1p`
compare_res_0 chkfca "Max deviation val (head=$ib, tail=$jb)" $val1 $dvtola pass
chkfca:

set jb = `grep 'Expand head' $testout | awk '{print substr($6,5,1)}' | sed -n 2,2p`
compare_res_0 chkfcb "Max deviation val (head=$ib, tail=$jb)" $val2 $dvtola pass
chkfcb:

set jb = `grep 'Expand head' $testout | awk '{print substr($6,5,1)}' | sed -n 1,1p`
compare_res_0 chkfcc "Max deviation slo (head=$ib, tail=$jb)" $slo1 $dstola pass
chkfcc:

set jb = `grep 'Expand head' $testout | awk '{print substr($6,5,1)}' | sed -n 2,2p`
compare_res_0 chkfcd "Max deviation slo (head=$ib, tail=$jb)" $slo2 $dstola pass
chkfcd:

set jb = `grep 'Expand head' $testout | awk '{print substr($6,5,1)}' | sed -n 3,3p`
compare_res_0 chkfce "Max dev, smh, val (head=$ib, tail=$jb)" $val3 $dvtola pass
chkfce:

set jb = `grep 'Expand head' $testout | awk '{print substr($6,5,1)}' | sed -n 4,4p`
compare_res_0 chkfcf "Max dev, smh, val (head=$ib, tail=$jb)" $val4 $dvtola pass
chkfcf:

set jb = `grep 'Expand head' $testout | awk '{print substr($6,5,1)}' | sed -n 3,3p`
compare_res_0 chkfcg "Max dev, smh, slo (head=$ib, tail=$jb)" $slo3 $dstola pass
chkfcg:

set jb = `grep 'Expand head' $testout | awk '{print substr($6,5,1)}' | sed -n 4,4p`
compare_res_0 chkfch "Max dev, smh, slo (head=$ib, tail=$jb)" $slo4 $dstola pass
chkfch:

chkfcz:


if ($?pass) then
    echo "$space ... test 15 PASSED"
else
    echo "$space ... test 15 FAILED"
    set failed = ($failed 15)
    goto chkfe
endif

# Repeat tests for Tc
if ($pass == 1) then
  set pass = 2
  set ext = tc
  set dvtola = 7.0d-4
  set dstola = 5.0d-3
  goto chkf1d
endif

chkfe:

echo $joblist | egrep '\b16\b' >/dev/null
if ($status && "$joblist" != "kfese") goto chkge
cat <<EOF

         ------- Test 16.  Different tests of XC functional (ctrl.kfese) ---
         This file contains tests of XC functionals for KFeSe (an Fe based superconductor)
         in a striped antiferromagnetic phase.

         The starting potential is self-consistent one using an old implementation
         of the GGA from K. Burke (easypbe).  You should be able to generate almost
         identically the same result with the libxc implementation (--libxc)

         Starting from this potential, the LDA density is made self-consistent.
         This reduces the Fe magnetic moment M.

         Next the XC B field is scaled by 0.9, which further reduces M.

EOF
endif

# if ($?MPIK) then
# echo "$space Not set up for MPI job ... skipping"
# goto chkge
# endif

query chkg1 chkge 'run this test'
chkg1:
findcmd chkg1a rdcmd "$path" "$topdir"
chkg1a:
findcmd chkg1b lm "$path" "$topdir"
chkg1b:
findcmd chkg1c lmstr "$path" "$topdir"
chkg1c:
findcmd chkg1d vextract "$path" "$topdir"
chkg1d:

if ($?clean) then
  touch ctrl.kfese
  echo "$space rm -f *.kfese semi.mater"
               rm -f *.kfese semi.mater
  goto chkge
endif
set pass
set refout=$testdir/out.kfese  testout=out.kfese

# If output already available, just run through checks
if ($?haveout) goto chk16s

set pbe = "-vlxcf=3 -vgga=3"
if ($?with_libxc) set pbe = "-vlxcf=101 -vlxcf2=130"

echo "$space ... set up ASA starting potential"
echo "$space touch ctrl.kfese; rm -f *.kfese qasa ; cp $testdir/{ctrl,shfac}.kfese $testdir/semi.mater ."
             touch ctrl.kfese; rm -f *.kfese qasa ; cp $testdir/{ctrl,shfac}.kfese $testdir/semi.mater .
echo "$space cp $testdir/rsta.kfese.pbe rsta.kfese"
             cp $testdir/rsta.kfese.pbe rsta.kfese
runjob chkg2 "/dev/null" "lmstr ctrl.kfese -vnm=0 -vfile=0 $pbe -vstripe=1 -vz4e=0.3539 -vzes=0.19"
chkg2:
runjob chkg3 "$testout" "lm ctrl.kfese -vconvc=1e-6 --rs=1,0 -vnit=0 -vnsp=2 -vnm=0 -vfile=0 $pbe -vstripe=1 -vz4e=0.3539 -vzes=0.19 --iactiv=no"
chkg3:

if ($?MPIK) then
set lm = "mpirun -n $nmpi lm -vmet=3"
else
set lm = lm
endif

echo ""
if ($?with_libxc) then
    echo "$space ... band pass with self-consistent PBE potential (libxc implementation)"
else
    echo "$space ... band pass with self-consistent PBE potential (easypbe implementation)"
endif
runjob chkg4 ">>$testout" "$lm ctrl.kfese -vconvc=1e-6 -vnit=1 -vnsp=2 -vnm=0 -vfile=0 $pbe -vstripe=1 -vz4e=0.3539 -vzes=0.19 --iactiv=no"
chkg4:

echo
echo "$space ... band pass to make self-consistent PBE potential, with bxc scaled by 0.9"
rm -f mixm.kfese
runjob chkg5 ">>$testout" "lm -vbxcs=1 ctrl.kfese -vconvc=1e-6 --rs=1,0 -vnit=0 -vnsp=2 -vnm=0 -vfile=0 $pbe -vstripe=1 -vz4e=0.3539 -vzes=0.19 --iactiv=no"
chkg5:
runjob chkg6 ">>$testout" "$lm -vbxcs=1 ctrl.kfese -vconvc=1e-6 -vnit=40 -vnsp=2 -vnm=0 -vfile=0 $pbe -vstripe=1 -vz4e=0.3539 -vzes=0.19 --iactiv=no"
chkg6:

echo
echo "$space ... band pass to make self-consistent LDA potential"
rm -f mixm.kfese
runjob chkg7 ">>$testout" "lm ctrl.kfese -vconvc=1e-6 --rs=1,0 -vnit=0 -vnsp=2 -vnm=0 -vfile=0 -vlxcf=2 -vgga=0 -vstripe=1 -vz4e=0.3539 -vzes=0.19 --iactiv=no"
chkg7:
runjob chkg8 ">>$testout" "$lm ctrl.kfese -vconvc=1e-6 -vnit=30 -vnsp=2 -vnm=0 -vfile=0 -vlxcf=2 -vgga=0 -vstripe=1 -vz4e=0.3539 -vzes=0.19 --iactiv=no"
chkg8:

echo ""
echo "$space ... band pass to make self-consistent LDA potential, with bxc scaled by 0.9"
rm -f mixm.kfese
runjob chkg9 ">>$testout" "lm -vbxcs=1 ctrl.kfese -vconvc=1e-6 --rs=1,0 -vnit=0 -vnsp=2 -vnm=0 -vfile=0 -vlxcf=2 -vgga=0 -vstripe=1 -vz4e=0.3539 -vzes=0.19 --iactiv=no"
chkg9:
runjob chkga ">>$testout" "$lm -vbxcs=1 ctrl.kfese -vconvc=1e-6 -vnit=40 -vnsp=2 -vnm=0 -vfile=0 -vlxcf=2 -vgga=0 -vstripe=1 -vz4e=0.3539 -vzes=0.19 --iactiv=no"
chkga:


call diffiles chk16s "CPU -1 $testout $refout"
chk16s:

set mgga    = `cat $testout | grep M=Fe2 | sed -n 1,2p | tail -1 | $vextract . mom`
set mggaref = `zcat $refout | grep M=Fe2 | sed -n 1,2p | tail -1 | $vextract . mom`
set egga    = `cat $testout | egrep ^x | sed -n 1,1p | tail -1 | $vextract . ehf`
set eggaref = `zcat $refout | egrep ^x | sed -n 1,1p | tail -1 | $vextract . ehf`
set dqgga  =     `cat $testout | grep 'RMS DQ' | sed -n 1,1p | tail -1 | vextract . DQ`

set nit = `cat $testout | grep -B 4 'more=F' | grep SV | sed -n 1,1p | awk '{print $2}'`
set nitgs = $nit
@ nline = $nit + 3
@ ndq = $nline - 2
set msgga    = `cat $testout | grep M=Fe2 | sed -n {$nline},{$nline}p | $vextract . mom`
set msggaref = `zcat $refout | grep M=Fe2 | sed -n {$nline},{$nline}p | $vextract . mom`
set esgga    = `cat $testout | egrep ^c | sed -n 2,2p | $vextract . ehf`
set esggaref = `zcat $refout | egrep ^c | sed -n 2,2p | $vextract . ehf`
set dqsgga   =  `cat $testout | grep 'RMS DQ' | sed -n {$ndq},{$ndq}p | vextract . DQ`

set nit = `cat $testout | grep -B 4 'more=F' | grep SV | sed -n 2,2p | awk '{print $2}'`
@ nline = $nline + $nit + 1
@ ndq = $nline - 3
set nitl = $nit
set mlda    = `cat $testout | grep M=Fe2 | sed -n {$nline},{$nline}p | $vextract . mom`
set mldaref = `zcat $refout | grep M=Fe2 | sed -n {$nline},{$nline}p | $vextract . mom`
set elda    = `cat $testout | egrep ^c | sed -n 2,2p | $vextract . ehf`
set eldaref = `zcat $refout | egrep ^c | sed -n 2,2p | $vextract . ehf`
set dqlda   =  `cat $testout | grep 'RMS DQ' | sed -n {$ndq},{$ndq}p | vextract . DQ`

set nit = `cat $testout | grep -B 4 'more=F' | grep SV | sed -n 3,3p | awk '{print $2}'`
set nitls = $nit
@ nline = $nline + $nit + 1
@ ndq = $nline - 4
set mslda    = `cat $testout | grep M=Fe2 | tail -1 | $vextract . mom`
set msldaref = `zcat $refout | grep M=Fe2 | tail -1 | $vextract . mom`
set eslda    = `cat $testout | egrep ^x |  tail -1 | $vextract . ehf`
set esldaref = `zcat $refout | egrep ^x | tail -1 | $vextract . ehf`
set dqslda  =  `cat $testout | grep 'RMS DQ' | tail -1 | vextract . DQ`

if (! $?quiet) then
  echo " "
  echo "$space energy of GGA solution           = $egga"
  echo "$space energy of reference              = $eggaref"
  set ediff = `echo $egga $eggaref  | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print k}'`
  echo "$space                    difference    =  $ediff"
  echo ' '
  echo "$space magnetic moment of Fe, GGA       = $mgga"
  echo "$space reference magnetic moment        = $mggaref"
  set mdiff = `echo $mgga $mggaref | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print k}'`
  echo "$space difference                       = $mdiff"
  echo ' '

  echo "$space scaled GGA solution converged in $nitgs iterations"
  echo "$space PBE moment with Bxc scaled       = $msgga"
  echo "$space reference magnetic moment        = $msggaref"
  set mdiff = `echo $msgga $msggaref | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print k}'`
  echo "$space difference                       = $mdiff"
  set ediff = `echo $mgga $msgga  | awk '{{k=($1-$2)} print k}'`
  echo "$space Effect of scaling Bxc            =$ediff"

  echo
  echo "$space LDA solution converged in $nitl iterations"
  echo "$space energy of LDA solution           = $elda"
  echo "$space energy of reference              = $eldaref"
  set ediff = `echo $elda $eldaref  | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print k}'`
  echo "$space                    difference    =  $ediff"
  echo ' '
  echo "$space magnetic moment of Fe, LDA       = $mlda"
  echo "$space reference magnetic moment        = $mldaref"
  set mdiff = `echo $mlda $mldaref | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print k}'`
  echo "$space difference                       = $mdiff"

  echo
  echo "$space scaled LDA solution converged in $nitls iterations"
  echo "$space LDA moment with Bxc scaled       = $mslda"
  echo "$space reference magnetic moment        = $msldaref"
  set mdiff = `echo $mslda $msldaref | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print k}'`
  echo "$space difference                       = $mdiff"
  set ediff = `echo $mlda $mslda  | awk '{{k=($1-$2)} print k}'`
  echo "$space Effect of scaling Bxc            =$ediff"
  echo
endif

call qprint chkgc1 "$space ... automatic pass checks :"
chkgc1:

echo -n "$space ... rms dq (GGA) (=$dqgga) < tol(3e-6) ... "
if (`echo $dqgga | awk '{print ($1 < 3e-6)}'`) then
  echo yes
else
  echo no
  unset pass
endif

echo -n "$space ... rms dq (LDA) (=$dqlda) < tol(2e-6) ... "
if (`echo $dqlda | awk '{print ($1 < 4e-5)}'`) then
  echo yes
else
  echo no
  unset pass
endif

echo -n "$space ... rms dq (scaled Bxc) (=$dqslda) < tol(2e-6) ... "
if (`echo $dqslda | awk '{print ($1 < 4e-5)}'`) then
  echo yes
else
  echo no
  unset pass
endif

compare_res chkgca "... GGA Fe moment" $mgga $mggaref 1e-3 pass
chkgca:

compare_res chkgcb "... LDA Fe moment" $mlda $mldaref 1e-3 pass
chkgcb:

compare_res chkgcc "... scaled LDA Fe moment" $mslda $msldaref 1e-3 pass
chkgcc:

if ($?pass) then
    echo "$space ... test 16 PASSED"
else
    echo "$space ... test 16 FAILED"
    set failed = ($failed 16)
endif

chkge:

if ($?clean) exit 0

echo ' '
if ($#failed <= 1) then
    echo "$space $testfile : all tests PASSED"
    echo " "
    exit 0
else
    shift failed
    echo "$space $testfile : These tests FAILED:" $failed
    echo " "
    exit -1
endif

# ---------------- qprint (print only quiet not set) --------------
exit
qprint:
  set quitjob=$retcall
  if ($?quiet) goto $quitjob
  echo "$callarg"
  goto $quitjob

# ---------------- diffiles --------------
# Compare two files
# calling argument should consist of four strings:
# 1st string = string that terminates diff
# 2nd string = integer that counts how many times terminator should occur before terminating
#              -1 -> last occurence
# 3nd string = first file name
# 4th string = second file name
# example: call diffiles chk69 "CPU 3 $testout $refout"
exit
diffiles:
  set quitjob=$retcall
  if ($?quiet) goto $quitjob
  set files = ($callarg)
  set endstr = $files[1]
  shift files
  set nend = $files[1]
  shift files

  if ($nend == "-1") then
    set nend = `grep "$endstr" $files[1] | wc | awk '{print $1}'`
  endif

  if ( $?slow == 0 ) echo "$space ... compare $files"
  query diff11 $quitjob "compare $files"
diff11:
  diff -Icpudel -Iwritten $files | awk -v endstr="$endstr" -v nend=$nend -v endl=0 -v endr=0 '{if ($1 == "<" && endl < nend) print ; if ($1 == ">" && endr < nend) print ; if ($1 == ">" || $1 == "<" || endl >= nend && endr >= nend) ; else {print} ; if ($1 == "<" && $2 == endstr) {endl+=1}; if ($1 == ">" && $2 == endstr) {endr+=1};}' | sed -n 1,50p
  echo " "
  goto $quitjob

# ---------------- zdiffiles --------------
# Compare compressed files
# calling argument should consist of four strings:
# 1st string = string that terminates zdiff
# 2nd string = integer that counts how many times terminator should occur before terminating
#              -1 -> last occurence
# 3nd string = first file name
# 4th string = second file name
# example: call zdiffiles chk69 "CPU 3 $testout $refout"
exit
zdiffiles:
  set quitjob=$retcall
  if ($?quiet) goto $quitjob
  set files = ($callarg)
  set endstr = $files[1]
  shift files
  set nend = $files[1]
  shift files

  if ($nend == "-1") then
    set nend = `grep "$endstr" $files[1] | wc | awk '{print $1}'`
  endif

  if ( $?slow == 0 ) echo "$space ... compare $files"
  query zdiff11 $quitjob "compare $files"
zdiff11:
  zdiff -Icpudel -Iwritten $files | awk -v endstr="$endstr" -v nend=$nend -v endl=0 -v endr=0 '{if ($1 == "<" && endl < nend) print ; if ($1 == ">" && endr < nend) print ; if ($1 == ">" || $1 == "<" || endl >= nend && endr >= nend) ; else {print} ; if ($1 == "<" && $2 == endstr) {endl+=1}; if ($1 == ">" && $2 == endstr) {endr+=1};}' | sed -n 1,50p
  echo " "
  goto $quitjob

#  # ---------------- zdiffiles --------------
#  exit
#  zdiffiles:
#    set quitjob=$retcall
#    if ($?quiet) goto $quitjob
#    set files = "$callarg"
#    query zdiff11 $quitjob "compare $files"
#  zdiff11:
#    $testdir/zdiff $files | sed -n 1,50p
#    goto $quitjob

# ---------------- showout --------------
exit
showout:
  set quitjob=$retcall
  if ($?quiet) goto $quitjob
  echo ' '
  echo "$space ... Compare $callarg to line(s) in file $refout":
  grep $callarg $testout
  if (`cat $testout | grep $callarg | wc | awk '{print $1}'` > 1) echo ' ---'
  zcat $refout | grep $callarg
  goto $quitjob

# ---------------- runjob --------------
exit
runjob:
  set quitjob=$retcall
  if ($outfile == ".") then
    echo "$space $callarg"
    echo " "
    $callarg
    set retval = $status
  else
    if (`echo $outfile | awk '{print substr($1,1,2)}'` == '>>') then
      set appfile = `echo $outfile | awk '{print substr($1,3)}'`
      echo "$space $callarg  >> $appfile"
      $callarg >> $appfile
      set retval = $status
    else
      echo "$space $callarg  > $outfile"
      $callarg > $outfile
      set retval = $status
  endif
  if ($retval != 0) goto cleanup
  goto $quitjob

# ---------------- compare_res --------------
# Compares two numbers $testvar-$refvar and unsets $passvar if |testvar-refvar|<tol
# usage: compares_res retcall keyword testvar refvar tol passvar
#   keyword      : label (for printout)
#   testvar      : first number
#   refvar       : second number
#   tol          : tolerance
#   passvar      : $passvar is unset if |testvar-refvar|<tol
exit
compare_res:
  set quitjob=$retcall
# echo $retcall $keyword $testvar $refvar $tol $passvar
  echo -n "$space $keyword ($testvar) within tol ($tol) of reference ($refvar)? ... "
  if (`echo $testvar $refvar | awk -v tol=$tol '{{k=($1-$2)>0?($1-$2):($2-$1);tl=1.001*tol} print (k<=tl)}'`) then
    echo yes
  else
    echo no
    unset $passvar
  endif
  goto $quitjob

# ---------------- get_resf --------------
# Extracts one element of a line in files $testout and $refout containing a keyword.
# Variables testout and refout point to file names and must be set beforehand ($refout is gzipped file)
# usage: get_resf retcall testvar refvar keyword arg_number occur_number sed_strn
#   Variables testout and refout referring to file names must be set
#   testvar      : put result from file $testout into this variable
#   refvar       : put result from file $refout (compressed) into this variable
#   keyword      : string line must contain
#   arg_number   : extracts $arg_number'th entry in line, as defined by awk
#   occur_number : argument from $occur_number'th line; if zero, use last line
#   sed_strn     : purge this string from result before assigning
exit
get_resf:
  set quitjob=$retcall
# echo $retcall $testvar $refvar $keyword $arg_number $occur_number $sed_strn
  set $testvar = `grep "$keyword" $testout | awk -v ncnt=0 -v num=$arg_number -v count=$occur_number '{ncnt+=1; if (ncnt==count || count == 0) {print $num}}' | sed "s/$sed_strn//" | tail -1`
  set $refvar = `zcat $refout | grep "$keyword" | awk -v ncnt=0 -v num=$arg_number -v count=$occur_number '{ncnt+=1; if (ncnt==count || count == 0) {print $num}}' | sed "s/$sed_strn//" | tail -1`
  goto $quitjob

# ---------------- cnvt_d_fmt --------------
# converts exponential format #.##D## or #.##d## to #.##E##
# usage: cnvt_d_fmt retcall testvar testval
exit
cnvt_d_fmt:
  set quitjob = $retcall
  set $testvar = `echo $testval | sed s/D/E/ | sed s/d/E/`
  goto $quitjob

# ---------------- runrdcmd --------------
exit
runrdcmd:
  set quitjob=$retcall
  if ($outfile == ".") then
    echo "$space Invoking rdcmd will execute the following job(s):"
    $rdcmd -f:$rdcmdfmt --n $callarg
    echo "$space $rdcmd '-f:rdcmd:%2f' $callarg"
                 $rdcmd '-f:rdcmd:%2f' $callarg
    set retval = $status
    set outf = "."
  else
    echo "$space Invoking  rdcmd $callarg  will execute the following job(s): (written to $outfile)"
    if (`echo $outfile | awk '{print substr($1,1,2)}'` == '>>') then
      $rdcmd -f:$rdcmdfmt --n $callarg
      set appfile = `echo $outfile | awk '{print substr($1,3)}'`
      echo "$space $rdcmd '-f:#rdcmd:%2f' $callarg >>& $appfile"
      $rdcmd '-f:rdcmd:%2f' $callarg >>& $appfile
      set retval = $status
      set outf = "$appfile"
    else
      $rdcmd -f:$rdcmdfmt --n $callarg
      echo "$space $rdcmd '-f:#rdcmd:%2f' $callarg  >& $outfile"
      $rdcmd '-f:rdcmd:%2f' $callarg >& $outfile
      set retval = $status
      set outf = "$outfile"
    endif
  endif

  if ($retval == 0) then
    echo "$space Job(s) completed successfully; output in $outfile"
    if ($?poszer && "$outf" != ".") then
      echo -n "         ..." ; $poszer $outf
    else if ($?add0 && "$outf" != ".") then
      echo -n "         ..." ; $add0 $outf
    endif
    goto $quitjob
  else
    echo "$space ...oops... the following command returned with nonzero exit status:"
    echo -n "$space   "
    grep $rdcmd:t{:} $outfile | tail -1 | sed 's/rdcmd:  //'
    goto cleanup
  endif

# ---------------- findcmd --------------
# Finds an executable program within the supplied path
# Usage: findcmd return_label executable_command path_name make_path
# If $executable_command is not found, findcmd does one of the following:
# If make_path = 'no' : returns silently.
# Otherwise findcmd aborts with a message, which assumes
# $make_path is the path where $executable_command is made.
exit
findcmd:
set found = 'no'
foreach ac_dir ($path_name)
 if (-x $ac_dir/$prog_cmd) then
   set $prog_cmd = $ac_dir/$prog_cmd
   set found = 'yes'
   break
 endif
end
if (! $?quiet) then
  if ($found == 'yes') echo "$space ... using executable $ac_dir/$prog_cmd"
  if ($found == 'no')  echo "$space ... no executable $prog_cmd found in path"
endif
if ($found == 'no' && $make_path != "no") then
  echo "  "
  echo "  Sorry, $testfile cannot find program '"$prog_cmd"' it needs to execute."
  echo "  '"$prog_cmd"' was not found in supplied path, or in the following:"
  echo "        $topdir"
# echo "  ... This script ($testfile) requires binary "'"rdcmd"'" to run."
  echo "  You must create or put '"$prog_cmd"' in your path before invoking this script."
  echo "  Normally '"$prog_cmd"' is created as part of the installation process."
  echo "  Invoking '"make $prog_cmd"' in $make_path should create it."
  echo "  $testfile aborting ..."
  exit -1
endif
goto $retcall

# ---------------- cleanup --------------
exit
cleanup:
  if ($retval != 0) echo "$space job returned with error status $retval"
  if ($retval != 0) echo "$space ... $testfile aborting"
  exit $retval

# ---------------- compare_res --------------
# Compares two numbers $testvar-$refvar and unsets $passvar if |testvar-refvar|<tol
# usage: compares_res retcall keyword testvar refvar tol passvar
#   keyword      : label (for printout)
#   testvar      : first number
#   refvar       : second number
#   tol          : tolerance
#   passvar      : $passvar is unset if |testvar-refvar|<tol
exit
compare_res:
  set quitjob=$retcall
# echo $retcall $keyword $testvar $refvar $tol $passvar
  set toll = `echo $tol | sed s/d/e/`
  echo -n "$space $keyword ($testvar) within tol ($toll) of reference ($refvar)? ... "
  if (`echo $testvar $refvar | awk -v tol=$toll '{{k=($1-$2)>0?($1-$2):($2-$1);tl=1.001*tol} print (k<=tl)}'`) then
    echo yes
  else
    echo no
    unset $passvar
  endif
  goto $quitjob

# ---------------- compare_res_0 --------------
# Compares a number $testvar and unsets $passvar if |testvar|<tol
# usage: compares_res_0 retcall keyword testvar tol passvar
# Example:
# compare_res_0 chk274a "Max deviation in pdos from reference" $retval $pdostol pass
#   keyword      : label (for printout)
#   testvar      : first number
#   tol          : tolerance
#   passvar      : $passvar is unset if |testvar|<tol
exit
compare_res_0:
  set quitjob=$retcall
#  echo $retcall $keyword $testvar $tol $passvar
  set toll = `echo $tol | sed s/d/e/`
  echo -n "$space $keyword ($testvar) within tol ($toll)? ... "
  if ($testvar == "") then
    echo no
    unset $passvar
  else if (`echo $testvar 0 | awk -v tol=$toll '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k<=tol)}'`) then
    echo yes
  else
    echo no
    unset $passvar
  endif
  goto $quitjob

# ---------------- zcmpmfiles_res_0 --------------
# Compares two files, stripping all but numerical fields.
# Checks for max absolute difference and unsets $passvar if difference<$tol
# Files with .gz or .Z extensions are assumed to be gzipped.
# usage: zcmpnfiles_res_0 retcall keyword testvar tol passvar ndig srcfile reffile
#   retcall      : return to this point in script on exit
#   keyword      : label (for printout)
#   tol          : tolerance in maximum allowed deviation
#   passvar      : $passvar is unset if |testvar|<tol
#   ndig         : number of digits numbers in file are stripped to
#   srcfile      : first file to compare
#   reffile      : second file to compare
# Example:
# zcmpmfiles_res_0 chk1ck "Max deviation in bnds.$ext from reference" $bndstol pass 4 bnds.$ext $testdir/bnds.$ext.gz
exit
zcmpmfiles_res_0:
  set quitjobl=$retcall
# echo $retcall $keyword $tol $?passvar $ndig $srcfile $reffile

  unset retval
  call zcmpmfiles zcmpmfilesx "$ndig $srcfile $reffile"
zcmpmfilesx:
  echo -n "$space $keyword ($retval) within tol ($tol)? ... "
  if (`echo $retval 0 | awk -v tol=$tol '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k<=tol)}'`) then
    echo yes
  else
    echo no
    unset $passvar
  endif
  goto $quitjobl

# ---------------- zcmpnfiles --------------
# Compares two files, treating each field as a number.
# call arguments should contain 3 strings: n test-file reference-file
# |n| = number of digits which numbers are truncated to.
# If n<0, sort files before comparing them
# Files with .gz or .Z extensions are assumed to be gzipped.
# Returns with retval = number of differences in reduced files
# Example :  call zcmpnfiles chk25 "6 dos-cls.$ext $testdir/dos-cls.$ext.gz"
# Creates temporary files $tmpdir/tmp_compnfile_1 $tmpdir/tmp_compnfile_2
exit
zcmpnfiles:
  set quitjob=$retcall
  set zcmpnargs = ($callarg)
  set digits = $zcmpnargs[1]
  if ($digits < 0) then
    @ digits = - $digits
    set lsort
  endif
# set a = ' { for (i = NF; i > 0; --i) printf " %.'$digits'f", $i; printf "\n" }'
# set a = ' { for (i = 1; i <= NF; i++) { k = sprintf("%.'$digits'f",$i); if (k+k == 0) k = 0 ; printf "%s ", k}; printf "\n" }'
  set a = ' { for (i = 1; i <= NF; i++) { k = sprintf("%.'$digits'f",$i); if (k+k == 0) k = 0 ; printf "%s ", k}; print "" }'

  set fn1 = $tmpdir/tmp_compnfile_1
  set fn2 = $tmpdir/tmp_compnfile_2
  if ("$zcmpnargs[2]:e" == 'gz' || "$zcmpnargs[2]:e" == 'Z') then
    set cat1 = 'gunzip -c'
  else
    set cat1 = cat
  endif
  if ("$zcmpnargs[3]:e" == 'gz' || "$zcmpnargs[3]:e" == 'Z') then
    set cat2 = 'gunzip -c'
  else
    set cat2 = cat
  endif

  if ($?lsort) then
    $cat1  $zcmpnargs[2] | sed s/D-/E-/g | sed s/D+/E+/g | sort | awk "$a" > $fn1
    $cat2  $zcmpnargs[3] | sed s/D-/E-/g | sed s/D+/E+/g | sort | awk "$a" > $fn2
  else
    $cat1  $zcmpnargs[2] | sed s/D-/E-/g | sed s/D+/E+/g | awk "$a" > $fn1
    $cat2  $zcmpnargs[3] | sed s/D-/E-/g | sed s/D+/E+/g | awk "$a" > $fn2
  endif
  set ncharfile = `wc $fn1 | awk '{print $3}'`
  cmp $fn1 $fn2 >/dev/null
  set retval = $status

  if ($retval == 0) rm -f $fn1 $fn2
  if ($retval == 0) goto $quitjob

  set retval = `cmp -l $fn1 $fn2 |& grep -v EOF | wc | awk '{printf "%d", $1}'`
  if ($retval == 0) set retval = '-1'
  rm -f $fn1 $fn2
  goto $quitjob

# ---------------- zcmpmfiles --------------
# Compares two files, treating each field as a number.
# Call arguments should contain 3 strings: no-digits test-file reference-file
# files with .gz or .Z extensions are assumed to be gzipped.
# Returns with retval = max numerical difference
# Example :  call zcmpmfiles chk25 "6 dos-cls.$ext $testdir/dos-cls.$ext.gz"
# Creates temporary files $tmpdir/tmp_compnfile_1 $tmpdir/tmp_compnfile_2
exit
zcmpmfiles:
  set quitjob=$retcall
  set zcmpnargs = ($callarg)
  set digits = $zcmpnargs[1]
# set a = ' { for (i = NF; i > 0; --i) printf " %.'$digits'f", $i; printf "\n" }'
  set a = ' { for (i = 1; i <= NF; i++) { k = sprintf("%.'$digits'f",$i); if (k+k == 0) k = 0 ; printf "%s ", k}; printf "\n" }'

  set fn1 = $tmpdir/tmp_compnfile_1
  set fn2 = $tmpdir/tmp_compnfile_2
  if ("$zcmpnargs[2]:e" == 'gz' || "$zcmpnargs[2]:e" == 'Z') then
    set cat1 = 'gunzip -c'
  else
    set cat1 = cat
  endif
  if ("$zcmpnargs[3]:e" == 'gz' || "$zcmpnargs[3]:e" == 'Z') then
    set cat2 = 'gunzip -c'
  else
    set cat2 = cat
  endif

  $cat1  $zcmpnargs[2] | sed s/D-/E-/g | sed s/D+/E+/g | awk "$a" > $fn1
  $cat2  $zcmpnargs[3] | sed s/D-/E-/g | sed s/D+/E+/g | awk "$a" > $fn2

  set retval = `diff -y --width=300 $fn1 $fn2 | grep '|' | awk -v top=0 '{n=split($0,a,"|"); n1=split(a[1],b1); n2=split(a[2],b2); { j=0; while (j++ < n1) if (j <= n1 && j<=n2) {x = (b1[j]-b2[j])>0?(b1[j]-b2[j]):(b2[j]-b1[j]); top = (top-x)>0?top:x; }}} END {printf "%12.4e\n", top}'`
  rm -f $fn1 $fn2
  goto $quitjob

# ---------------- zdiffiles --------------
# File differences, with additional check for numerical differences
# callarg should consist of four strings; there is an optional fifth and sixth
# 1st word = string that terminates diff
# 2nd word = counts how many times terminator should occur before terminating
#            -1 -> last occurence
# 3nd word = first file name
# 4th word = second file name
# 5th word = (optional) tolerance.  Numerical differences < tolerance are counted as 0
#            If present, and not "-", passed to mcx as the argument to ~tol=
# 6th word = (optional) if present, it is used instead of mcexcl
#
# Returns ndif = number of differences, and maxdif = difference (if mcx is available)
# Example: call zdiffiles chk69 "CPU 3 $testout $refout"
exit
zdiffiles:

  set quitjob=$retcall

  set noglob
  set files = ($callarg)
  unset noglob

  set endstr = $files[1]
  shift files
  set nend = $files[1]
  shift files

  if ($nend == "-1") then
    set nend = `grep "$endstr" $files[1] | wc | awk '{print $1}'`
  endif

  if ($?quiet) goto zdiffiles2

  if ( $?slow == 0 ) echo "$space ... compare $files[1] $files[2]"
  query zdiff1 $quitjob "compare $files[1] $files[2]"
zdiff1:
  zdiff -Icpudel -Iwritten $files[1] $files[2] | awk -v endstr="$endstr" -v nend=$nend -v endl=0 -v endr=0 '{if ($1 == "<" && endl < nend) print ; if ($1 == ">" && endr < nend) print ; if ($1 == ">" || $1 == "<" || endl >= nend && endr >= nend) ; else {print} ; if ($1 == "<" && $2 == endstr) {endl+=1}; if ($1 == ">" && $2 == endstr) {endr+=1};}' | sed -n 1,50p
  echo " "

zdiffiles2:
  if (! $?mcx) goto $quitjob

  if (! $?mcexcll) set mcexcll
  if (! $?mcexcl) set mcexcl
  if ($?mcexcl) set mcexcll = "$mcexcl"
  if ($#files > 3) then
    set mcexcll = "$files[4]"
  endif

  if (! $?mcterm) set mcterm
# Don't do this step ... check that each test initializes its own gmaxdif
# if (! $?gmaxdif) set gmaxdif = 0
  set toldif
  if ($#files > 2) then
    if ("$files[3]" != "-") set toldif = "~tol=$files[3]"
  endif

  set maxdif = `$mcx -cmpf~fn1=$files[1]~fn2=$files[2]~max$toldif$mcterm$mcexcll`
  set ndif = `$mcx -cmpf~fn1=$files[1]~fn2=$files[2]~ndiff$toldif$mcterm$mcexcll`
#  set gmaxdif = `echo $gmaxdif $maxdif  | awk '{print ($1>$2)?$1:$2}'`

  echo "$space $ndif numerical differences in $files[1] compared to ref, max diff = $maxdif"
  if ($?slow > 0 && $?verb) then
    echo
    echo "$space The following make a detailed comparison of numerical differences:"
    echo "$space $mcx -cmpf~fn1=$files[1]~fn2=$files[2]~vverb$toldif$mcterm$mcexcll"

    query zdiff2  $quitjob "show comparison"
zdiff2:
    $mcx -cmpf~fn1=$files[1]~fn2=$files[2]~vverb$toldif$mcterm$mcexcll
    echo
    echo "$space"'*'"hit <return> to continue"
    set a = ($<)
  endif
  if (! $?quiet) echo
  goto $quitjob

# ---------------- zdiffilesx --------------
# Identical to zdiffiles, but gmaxdif is accumulated
# callarg should consist of four strings; there is an optional fifth and sixth
# 1st word = string that terminates diff
# 2nd word = counts how many times terminator should occur before terminating
#            -1 -> last occurence
# 3nd word = first file name
# 4th word = second file name
# 5th word = (optional) tolerance.  Numerical differences < tolerance are counted as 0
#            If present, and not "-", passed to mcx as the argument to ~tol=
# 6th word = (optional) if present, it is used instead of mcexcl
#
# Returns ndif = number of differences, and maxdif = difference (if mcx is available)
exit
zdiffilesx:

  set quitjob=$retcall

  set noglob
  set files = ($callarg)
  unset noglob

  set endstr = $files[1]
  shift files
  set nend = $files[1]
  shift files

  if ($nend == "-1") then
    set nend = `grep "$endstr" $files[1] | wc | awk '{print $1}'`
  endif

  if ($?quiet) goto zdiffilesx2

  if ( $?slow == 0 ) echo "$space ... compare $files[1] $files[2]"
  query zdiffx1 $quitjob "compare $files[1] $files[2]"
zdiffx1:
  zdiff -Icpudel -Iwritten $files[1] $files[2] | awk -v endstr="$endstr" -v nend=$nend -v endl=0 -v endr=0 '{if ($1 == "<" && endl < nend) print ; if ($1 == ">" && endr < nend) print ; if ($1 == ">" || $1 == "<" || endl >= nend && endr >= nend) ; else {print} ; if ($1 == "<" && $2 == endstr) {endl+=1}; if ($1 == ">" && $2 == endstr) {endr+=1};}' | sed -n 1,50p
  echo " "

zdiffilesx2:
  if (! $?mcx) goto $quitjob

  if (! $?mcexcll) set mcexcll
  if (! $?mcexcl) set mcexcl
  if ($?mcexcl) set mcexcll = "$mcexcl"
  if ($#files > 3) then
    set mcexcll = "$files[4]"
  endif

  if (! $?mcterm) set mcterm
# Don't do this step ... check that each test initializes its own gmaxdif
# if (! $?gmaxdif) set gmaxdif = 0
  set toldif
  if ($#files > 2) then
    if ("$files[3]" != "-") set toldif = "~tol=$files[3]"
  endif

  set maxdif = `$mcx -cmpf~fn1=$files[1]~fn2=$files[2]~max$toldif$mcterm$mcexcll`
  set ndif = `$mcx -cmpf~fn1=$files[1]~fn2=$files[2]~ndiff$toldif$mcterm$mcexcll`
  if (! $?gmaxdif) set gmaxdif = 0
  set gmaxdif = `echo $gmaxdif $maxdif  | awk '{print ($1>$2)?$1:$2}'`

  echo "$space $ndif numerical differences in $files[1] compared to ref, max diff = $maxdif"
  if ($?slow > 0 && $?verb) then
    echo
    echo "$space The following make a detailed comparison of numerical differences:"
    echo "$space $mcx -cmpf~fn1=$files[1]~fn2=$files[2]~vverb$toldif$mcterm$mcexcll"

    query zdiffx2  $quitjob "show comparison"
zdiffx2:
    $mcx -cmpf~fn1=$files[1]~fn2=$files[2]~vverb$toldif$mcterm$mcexcll
    echo
    echo "$space"'*'"hit <return> to continue"
    set a = ($<)
  endif
  if (! $?quiet) echo
  goto $quitjob

# ---------------- query --------------
exit
query:
  unset skip
  if ($?slow != 0) then
    if ("$retcall" == "$retcall2") then
    echo "$space"'*'"hit <return> to $callarg"
    else
    echo "$space"'*'"hit <return> to $callarg, s <return> to skip it."
    endif
    set a = ($<)
    if ($a == "") goto $retcall
    switch ($a)
      case "quit":
      case "q":
      case "a":
        exit
      case "i":
        unset slow
        breaksw
      case "s":
        set skip
        breaksw
      case "t":
        time
        goto query
      default:
        echo 'q to quit; i unsets slow; s skips this job, t shows time'
        goto query
    endsw
  endif
  if ($?skip) goto $retcall2
  goto $retcall

# ---------------- List tests --------------
showtests:
cat <<EOF
  Usage: invoke with:    $testfile job-list
  Specify job-list by material or job number, e.g. "$testfile fe"  or "$testfile 10 11"

  Material  number  Executables             Tests
    gas       1     lmchk,lmstr,lm,lmdos    Basic checker of ASA code, and NMTO
    tc        2     lmstr,lm                Basic checker of ASA code, and NMTO, including --rs switch
    fe        3     lmstr,lm,lmdos          ASA code spin polarized case, Levenberg-Marquardt, DOS and ballistic conductivity
    mix       4     lmstr,lm                Tests two-center ASA hamiltonian, mixing schemes
    gan       5     lm                      Tests downfolding, different lmx
    cr3si6    6     lmstr,lm                Tests nonspherical output moments, and various forms of partial DOS.
    aux       7     lmscell,lmchk,blm,poscar2init,lmxbs
                                            Tests various branches of auxiliary programs
    gd        8     lm                      Tests treatment of partially occupied 4f as core
    er        9     lm                      Tests LDA+U treatment of 4f
    lap      10     lmstr                   Tests (Gaussian) value-laplacian structure constants
    si       11     lm                      Tests Levenberg-Marquardt fit of ASA hamiltonian to bands
    inp      12     lm                      Tests Levenberg-Marquardt fit of ASA hamiltonian to QSGW DOS
    feal     13     lm                      Tests Levenberg-Marquardt fit of ASA hamiltonian to QSGW DOS
    smstr    14     lmstr                   Tests of new structure constants, 2-kappa
    smstr    15     lmstr                   Tests of new structure constants, 1-kappa
    kfese    16     lm                      Compares GGA, LDA XC functionals; demonstrates scaling of the Bxc field

EOF
exit

# ---------------- usage: --------------
usage:
cat <<EOF
 usage: test.lm [switches]  testcase-list | test-name
        e.g., "test.lm fe"  or "test.lm 10 11"
        switches:
        --list       list available materials and tests (no tests are made)
        --no-iactive runs tests without prompting user
        --libxc      uses libxc library in test 16, testing the PBE functional
        --quiet      runs tests with minimal output and without prompting user
        --noplot     skip any steps that generate a plot'
        --clean      runs cleanup
        --add0       adds leading zeros in output for real numbers \`.nnn'
        --poszer     strips (-) sign from numbers represented as 0
        --whichexec  prints out which lmstr and lm executables it finds in path and exits
        --MPIK[=#]   run lm in MPIK mode
                     If # is given, it specifies the number of processors.
                     Run MPI job as
                     mpirun -n # lm ...

EOF
exit -1
