#!/bin/tcsh -f

# This file is a shell script to test various aspects of ASA suite

alias call 'set retcall = \!\!:2 ; set callarg = \!\!:3 ; goto \!\!:1'
alias runjob 'set retcall = \!\!:1; set outfile = \!\!:2 ; set callarg = \!\!:3 ; goto runjob'
alias query 'set retcall = \!\!:1 ; set retcall2 = \!\!:2 ; set callarg = \!\!:3 ; goto query'
alias compare_res_0 'set retcall = \!\!:1; set keyword = \!\!:2 ; set testvar = \!\!:3 ; set tol = \!\!:4 ; set passvar = \!\!:5 ; goto compare_res_0'
alias zcmpmfiles_res_mc 'set retcall = \!\!:1; set keyword = \!\!:2 ; set tol = \!\!:3 ; set passvar = \!\!:4 ; set ndig = \!\!:5 ; set srcfile = \!\!:6 ; set reffile = \!\!:7; set nlines = \!\!:8;; set count = \!\!:9; goto zcmpmfiles_res_mc'
alias compare_res 'set retcall = \!\!:1; set keyword = \!\!:2 ; set testvar = \!\!:3 ; set refvar = \!\!:4 ; set tol = \!\!:5 ; set passvar = \!\!:6 ; goto compare_res'
alias findcmd  'set retcall = \!\!:1 ; set prog_cmd = \!\!:2 ; set path_name = \!\!:3 ; set make_path = \!\!:4 ; goto findcmd'
alias zcat 'gunzip -c'
alias zcat 'cat'

set a
set slow
set testfile = $0
set testdir = $testfile:h
set topdir  = `(cd $testdir/..; pwd)`
set tmpdir = $cwd
set space = '        '
set failed = 0

set mcx = `which mcx`
if (-x "$mcx") then
  if `$mcx --h |& sed -n 1,1p | awk '{print ($7 == "(vsn" && ($8 * 1 >= 1.072))}'` set have_mc
endif

# Prepend current working-directory, top-level and related dir to path
set path = ($cwd $topdir $topdir/utils $topdir/testing $path)

# --- Pick off switches ---
while (`echo $1 | sed -e 's/\(.\).*/\1/' `  ==  "-")

  set arg1 = $1; shift
  if ($?verb) echo test.lmscell: parsing switch $arg1
  switch ($arg1)
    case "--quiet":
      set quiet
      unset slow
      breaksw
    case "--add0":
      set add0 = `which add0`
      if (! -x "$add0") then
        echo "test.dmft (abort): missing add0"
        exit
      endif
      breaksw
    case "--poszer":
      set poszer = `which poszer`
      if (! -x "$poszer") then
        echo "test.dmft (abort): missing poszer"
        exit
      endif
      breaksw
#   does nothing here
    case "--all":
      breaksw
    case "--clean":
      set clean
      breaksw
    case "--no-iact*":
      unset slow
      breaksw
    case "--list":
      goto showtests
      breaksw
    case "--whichexec"
      set quiet; unset quiet
      findcmd chk00 lmscell "$path" "$topdir"
      chk00:
      exit 0
      breaksw
    case "--noplot*":
      set noplot
      set have_pldos
      unset have_pldos
      set have_fplot
      unset have_fplot
      breaksw
    case "--verb*":
      set verb = 1
      breaksw
    default:
      echo " test.lmscell: unrecognized switch $arg1"
      goto usage
  endsw

end

if ( $?joblist == 0 ) then
set joblist = ($argv)
if ( $#joblist == 0 ) set joblist = (1 2 3 4 5 6 7 8 9)
endif

# ------------------ job 1 --------------------
echo $joblist | grep 1 >/dev/null
if ($status) goto chk1e
set pass
cat <<EOF

         --- Test 1.  Supercell of ctrl.cr3si6 ---

EOF
if ($?quiet) then
else
cat <<EOF

         This test checks and illustrates the following switches:

           --wsite      ... writes site file

           --sort:      ... orders sites according to keys (species, followed by projection along c)

           --pl         ... Principal layers defined according to given expr

EOF
endif
set job=1
query chk11 chk1e 'test lmscell (file ctrl.cr3si6)'
chk11:
if ($?clean) then
  echo "$space rm -f {log,out,site,ctrl}.cr3si6"
               rm -f {log,out,site,ctrl}.cr3si6
  goto chk1e
endif
set ext=cr3si6
set refout=$testdir/out.lmscell.$ext  testout=out.$ext
echo "$space touch ctrl.$ext; rm -f *.$ext ; cp $testdir/ctrl.$ext ."
             touch ctrl.$ext; rm -f *.$ext ; cp $testdir/ctrl.$ext .
echo "$space lmscell $ext --wsite:map --sort:'is x3' '--pl:flor(x3)' --pr41 > $testout"
             lmscell $ext --wsite:map --sort:'is x3' '--pl:flor(x3)' --pr41 > $testout
set retval = $status
if ($retval != 0) goto cleanup
if (! $?quiet) echo "$space Program lmscell returned successfully."
if ($?add0) then
  echo -n "         ..." ; $add0 $testout
endif
if ($?poszer) then
  echo -n "         ..." ; $poszer $testout
endif

if ($?quiet) goto chk1pa
query chk1s chk1pa "compare output files $testout $refout"
chk1s:
$testdir/zdiff $testout $refout

chk1pa:
if (! $?quiet) echo "$space ... automatic pass checks :"
set ndig = 6
call zcmpnfiles chk1pb "$ndig site.$ext $testdir/site.$ext"
chk1pb:
echo -n "$space ... files site.$ext and $testdir/site.$ext equivalent to $ndig digits? ... "
if ($retval == 0) then
  echo  yes
else
  echo no "($retval difference(s) remaining of $ncharfile)"
  unset pass
endif

if ($?pass) then
    echo "$space lmscell test 1 PASSED ($ext)"
else
    echo "$space lmscell test 1 FAILED ($ext)"
    set failed = ($failed 1)
endif
chk1e:

# ------------------ job 2 --------------------
echo $joblist | grep 2 >/dev/null
if ($status) goto chk2e
set pass
set ext = co
cat <<EOF

         --- Test 2.  Supercell of ctrl.co ---

EOF
if ($?quiet) then
else
cat <<EOF

         This test checks and illustrates the following switches:

           ... writes a site file as multiples of lattice vectors in short format,
               and tests map feature (for restart files) with the following:
                 --wsite~map~short~fn=sitex

          ... tests reading superlattice vectors from stdin,
              as multiples of original vectors, using the following
                echo m 2 0 0 1 2 0 0 0 1 | lmscell ...
              or avoid stdin with --plx
                lmscell --plx~m~2,0,0,1,2,0,0,0,1 ...

EOF
endif
set job=2
query chk21 chk2e "test lmscell (file ctrl.$ext)"
chk21:
if ($?clean) then
  echo "$space rm -f {log,out,site,ctrl}.$ext"
               rm -f {log,out,site,ctrl}.$ext
  goto chk2e
endif
set refout=$testdir/out.lmscell.$ext  testout=out.$ext
echo "$space touch ctrl.$ext; rm -f *.$ext ; cp $testdir/ctrl.$ext ."
             touch ctrl.$ext; rm -f *.$ext ; cp $testdir/ctrl.$ext .
echo "$space lmscell --plx~m~2,0,0,1,2,0,0,0,1 $ext --wsite~map~short~fn=sitex > $testout"
#              echo m 2 0 0 1 2 0 0 0 1 | lmscell $ext --wsite~map~short~fn=sitex > $testout
             lmscell --plx~m~2,0,0,1,2,0,0,0,1 $ext --wsite~map~short~fn=sitex > $testout
set retval = $status
if ($retval != 0) goto cleanup
if (! $?quiet) echo "$space Program lmscell returned successfully."
if ($?add0) then
  echo -n "         ..." ; $add0 $testout
endif
if ($?poszer) then
  echo -n "         ..." ; $poszer $testout
endif

if ($?quiet) goto chk2pa
query chk2s chk2pa "compare output files $testout $refout"
chk2s:
$testdir/zdiff $testout $refout

chk2pa:
if (! $?quiet) echo "$space ... automatic pass checks :"
set ndig = -6
call zcmpnfiles chk2pb "$ndig sitex.$ext $testdir/sitex.$ext"
chk2pb:
@ ndig = - $ndig
echo -n "$space ... (sorted) files sitex.$ext and $testdir/sitex.$ext equivalent to $ndig digits? ... "
if ($retval == 0) then
  echo  yes
else
  echo no "($retval difference(s) remaining of $ncharfile)"
  unset pass
endif

if ($?pass) then
    echo "$space lmscell test 2 PASSED ($ext)"
else
    echo "$space lmscell test 2 FAILED ($ext)"
    set failed = ($failed 2)
endif
chk2e:

echo $joblist | grep 3 >/dev/null
if ($status) goto chk3e
set pass
cat <<EOF

         --- Test 3.  Incorporation of displacements into a different cell ---

EOF
if ($?quiet) then
else
cat <<EOF
         This test checks and illustrates incorporation of displacements as calculated
         from a small (54 atom) unit cell to a different one.

         File ctrl.mngasf is an input file for a full-potential calculation of the
         As antisite defect in a 54-atom unit cell.  (The antisite is the first atom,
         and sits at the origin.)  The site positions (before relaxation) are contained
         in the site file site.mngasf.  The four antisite NN were allowed to relax;
         the relaxed positions are in file pos.mngasf.

         Invoking lmchk as shown below generates a table of connecting vectors
         for the four neighbors, both undisplaced and displaced, in file tab2.
         The switch to lmchk that makes file tab2 is:
            --shell:tab=2:disp=pos:sites:1:r=3:fn=tab2:nn
         Option ':tab=2:disp=pos' generates the neighbor table and displacements
         relative to ideal positions (6 columns)
         Option 'fn=tab2' names the file
         Option 'r=1' restricts the range (not needed, because:)
         Option 'nn' restricts the table to NN
         Option 'sites:1' tells lmchk to make the neighbor table for site 1 only.
         Note: lmchk should generate a neighbor table for only one atom.

         File ctrl.mngas is an input file for an ASA calculation involving one Mn
         atom (first atom, at the origin) and an As antisite (atom 65, species 21x).

         Invoking lmscell as shown below incorporates these displacements around
         atom 65, species 21x, writing the result to site2.mngas and pos.mngas.
         Note that lmchk correctly identifies the four As neighbors to GaAs
         (sites 152, 154, 169, 173), and displaces them radially from the As antisite.

         The switch to lmscell that generates displacments from file tab2 is:
            --disp:tab2:style=3:21x
         Switch --disp requires 2 arguments: the file name (tab2) and a reference to
         which atom should be treated.  'style=3:21x' says the site is specified by
         a species label ('21x').

EOF
endif
set job=3
query chk31 chk3e 'invoke test (file ctrl.mngas)'
chk31:
if ($?clean) then
  echo "$space rm -f {out,log,tab2,122,123,124,12,212,213,214,215,21,21x,ctrl,pos,pos2,site,site2,tab2}.{mngas,mngasf}"
               rm -f {out,log,tab2,122,123,124,12,212,213,214,215,21,21x,ctrl,pos,pos2,site,site2,tab2}.{mngas,mngasf}
  goto chk3e
endif
set ext = mngas
set refout=$testdir/out.lmscell.$ext  testout=out.$ext
touch ctrl.$ext
echo "$space rm -f *.$ext *.$ext{f} ; cp $testdir/{{ctrl,site}.{$ext,$ext{f}},pos.$ext{f}} ."
             rm -f *.$ext *.$ext{f} ; cp $testdir/{{ctrl,site}.{$ext,$ext{f}},pos.$ext{f}} .
echo "$space lmchk $ext{f} --shell:tab=2:disp=pos:sites=1:r=3:fn=tab2:nn > $testout"
             lmchk $ext{f} --shell:tab=2:disp=pos:sites=1:r=3:fn=tab2:nn > $testout
set retval = $status
if ($retval != 0) goto cleanup
echo "$space cp tab2.$ext{f} tab2.$ext"
             cp tab2.$ext{f} tab2.$ext
echo "$space echo / | lmscell $ext --disp:tab2:style=3:21x --wsite=site2 --wpos=pos2 >>$testout"
             echo / | lmscell $ext --disp:tab2:style=3:21x --wsite=site2 --wpos=pos2 >>$testout
set retval = $status
if ($retval != 0) goto cleanup
if (! $?quiet) echo "$space Programs lmchk, lmscell returned successfully."
if ($?add0) then
  echo -n "         ..." ; $add0 $testout
endif
if ($?poszer) then
  echo -n "         ..." ; $poszer $testout
endif

if ($?quiet) goto chk3pa
query chk3s chk3pa "compare output files $testout $refout"
chk3s:
$testdir/zdiff $testout $refout

chk3pa:
if (! $?quiet) echo "$space ... automatic pass checks :"

echo "$space sorting data in files: tab2.$ext{f} $testdir/tab2.$ext{f} ..."
cat  tab2.$ext{f} | sort -n | grep -v neigh >tab2.$ext{f}~
cat  $testdir/tab2.$ext{f} | sort -n | grep -v neigh >$testdir/tab2.$ext{f}~
set ndig = 6
call zcmpnfiles chk3pb "$ndig tab2.$ext{f}~ $testdir/tab2.$ext{f}~"
chk3pb:
echo -n "$space ... files tab2.$ext{f}~ and $testdir/tab2.$ext{f}~ equivalent to $ndig digits? ... "
if ($retval == 0) then
  echo  yes
else
  echo no "($retval difference(s) remaining of $ncharfile)"
  unset pass
endif
rm -r tab2.$ext{f}~ $testdir/tab2.$ext{f}~

call zcmpnfiles chk3pc "$ndig pos2.$ext $testdir/pos2.$ext"
chk3pc:
echo -n "$space ... files pos2.$ext and $testdir/pos2.$ext equivalent to $ndig digits? ... "
if ($retval == 0) then
  echo  yes
else
  echo no "($retval difference(s) remaining of $ncharfile)"
  unset pass
endif

call zcmpnfiles chk3pd "$ndig site2.$ext $testdir/site2.$ext"
chk3pd:
echo -n "$space ... files site2.$ext and $testdir/site2.$ext equivalent to $ndig digits? ... "
if ($retval == 0) then
  echo  yes
else
  echo no "($retval difference(s) remaining of $ncharfile)"
  unset pass
endif

if ($?pass) then
    echo "$space lmscell test 3 PASSED ($ext)"
else
    echo "$space lmscell test 3 FAILED ($ext)"
    set failed = ($failed 3)
endif
chk3e:

echo $joblist | sed s/10// | grep 4 >/dev/null
if ($status) goto chk4e
cat <<EOF

         --- Test 4.  Input file ctrl.kfese ---
         Demonstrates generation of restart file,
         including angle rotation of 180 degrees for sites with negative moments.

         Separate calculations demonstrate permute of pairs of sites in supercell,
         and also cycling a subset of sites, together with the ~map switch.

         After program executes, confirm that the modified site and rsta files generate
         nearly identical moments, bands:, e.g. compare 1 and 2 as follows:
             rm mixm.kfese
             lm  -vnk1=2 ctrl.kfese --rs=1,0 -vnit=0 -vfile=t -vnc=1 --iactiv | tee 1
             cp rstax.kfese  rsta.kfese
             cp site2.kfese  site.kfese
             rm eula.kfese mixm.kfese
             lm  -vnk1=2 ctrl.kfese --rs=1,0 -vnit=0 -vfile=t -vnc=1 --iactiv | tee 2

EOF

set pass
set job=4
query chk41 chk4e 'run this test (file ctrl.kfese)'
chk41:
#  findcmd chk41a lmscell "$path"
chk41a:
set ext = kfese
set refout=$testdir/out.lmscell.kfese  testout=out.lmscell.kfese ext=kfese
if ($?clean) then
  touch ctrl.kfese
  echo "$space rm -f *.kfese $testout $testout.1 $testout.2"
               rm -f *.kfese $testout $testout.1 $testout.2
  goto chk4e
endif
echo "$space cp $testdir/{ctrl,eula,rsta,site}.kfese ."
             cp $testdir/{ctrl,eula,rsta,site}.kfese .

echo "$space echo / | lmscell $ext -vfile=t -vnc=1 --wsitex:fn=site2 --rsta,amom >$testout"
             echo / | lmscell $ext -vfile=t -vnc=1 --wsitex:fn=site2 --rsta,amom >$testout
set retval = $status
if ($retval != 0) goto cleanup
if (! $?quiet) echo "$space Program lmscell returned successfully."

echo "$space echo / | lmscell $ext -vfile=t -vnc=1 --swap:8,10,7,12 --wsitex~map~fn=site3 >>$testout"
             echo / | lmscell $ext -vfile=t -vnc=1 --swap:8,10,7,12 --wsitex~map~fn=site3 >>$testout
set retval = $status
if ($retval != 0) goto cleanup
if (! $?quiet) echo "$space Program lmscell returned successfully."

echo "$space echo / | lmscell $ext -vfile=t -vnc=1 --ring:8,12 --wsitex~map~fn=site4 >>$testout"
             echo / | lmscell $ext -vfile=t -vnc=1 --ring:8,12 --wsitex~map~fn=site4 >>$testout
set retval = $status
if ($retval != 0) goto cleanup
if (! $?quiet) echo "$space Program lmscell returned successfully."

if ($?quiet) goto chk4s2
query chk4s chk4s2 "compare $testout $refout"
chk4s:
$testdir/zdiff $testout $refout
chk4s2:

# chk4pa:
# grep -v CPU $testout > $testout.1
# zcat $refout | grep -v CPU > $testout.2
# echo -n "$space files $testout and $refout equivalent to 6 digits? ..."
# call zcmpnfiles chk4c2 "6 $testout.1 $testout.2"
# chk4c2:
#   if ($retval == 0) then
#     echo yes
#   else if (`echo ' ' | awk -v ndiff=$retval -v ntot=$ncharfile '{print (100*ndiff/ntot<1.)}'` == 1) then
#     echo ok "($retval difference(s) of $ncharfile)"
#   else
#     echo no "($retval difference(s) of $ncharfile)"
#     unset pass
#   endif
# endif

echo -n "$space files site2.$ext and $testdir/site2.$ext equivalent to 6 digits? ..."
call zcmpnfiles chk4c3 "6 site2.$ext $testdir/site2.$ext"
chk4c3:
  if ($retval == 0) then
    echo yes
  else if (`echo ' ' | awk -v ndiff=$retval -v ntot=$ncharfile '{print (100*ndiff/ntot<1.)}'` == 1) then
    echo ok "($retval difference(s) of $ncharfile)"
  else
    echo no "($retval difference(s) of $ncharfile)"
    unset pass
  endif
endif

echo -n "$space files site3.$ext and $testdir/site3.$ext equivalent to 6 digits? ..."
call zcmpnfiles chk4c4 "6 site3.$ext $testdir/site3.$ext"
chk4c4:
  if ($retval == 0) then
    echo yes
  else if (`echo ' ' | awk -v ndiff=$retval -v ntot=$ncharfile '{print (100*ndiff/ntot<1.)}'` == 1) then
    echo ok "($retval difference(s) of $ncharfile)"
  else
    echo no "($retval difference(s) of $ncharfile)"
    unset pass
  endif
endif

echo -n "$space files site3.$ext and $testdir/site3.$ext equivalent to 6 digits? ..."
call zcmpnfiles chk4c5 "6 site3.$ext $testdir/site3.$ext"
chk4c5:
  if ($retval == 0) then
    echo yes
  else if (`echo ' ' | awk -v ndiff=$retval -v ntot=$ncharfile '{print (100*ndiff/ntot<1.)}'` == 1) then
    echo ok "($retval difference(s) of $ncharfile)"
  else
    echo no "($retval difference(s) of $ncharfile)"
    unset pass
  endif
endif

if ($?quiet) goto chk4t2
query chk4t chk4t2 "compare rstax.$ext $testdir/rstax.$ext"
chk4t:
$testdir/zdiff rstax.$ext $testdir/rstax.$ext
chk4t2:
#  echo -n "$space files rstax.$ext and $testdir/rstax.$ext equivalent to 6 digits? ..."
#  call zcmpnfiles chk4c6 "6 rstax.$ext $testdir/rstax.$ext"
#  chk4c6:
#    if ($retval == 0) then
#      echo yes
#    else if (`echo ' ' | awk -v ndiff=$retval -v ntot=$ncharfile '{print (100*ndiff/ntot<1.)}'` == 1) then
#      echo ok "($retval difference(s) of $ncharfile)"
#    else
#      echo no "($retval difference(s) of $ncharfile)"
#      unset pass
#    endif
#  endif

if ($?pass) then
    echo "$space lmscell test 4 PASSED ($ext)"
else
    echo "$space lmscell test 4 FAILED ($ext)"
    set failed = ($failed 4)
endif
chk4e:

echo $joblist | sed s/10// | grep 5 >/dev/null
if ($status) goto chk5e
cat <<EOF

         --- Test 5.  SQS maker (ctrl.nio) ---
         Checks lmscell's special quasirandom structures generator.

         The SQS feature of lmscell rearranges sites associated with species 1 and 2.
         It uses a Metropolis algorithm to minimize some average of correlation
         functions within a supercell you specify.

EOF
if ($?quiet) then
else
cat <<EOF
         This test checks and illustrates incorporation of displacements as calculated
         from a small (54 atom) unit cell to a different one.

         NiO is an antiferromagnet, with spins ordered below the Neel
         temperature.  At high temperature they disorder.
         This test permutes the up and down spin sites of NiO
         to form an SQS structure with 16 Ni atoms.

         The following correlation functions vanish:
           pairs with connecting vectors less than 1.3 (sqrt(2)/2, 1, sqrt(3/2))
           triplets with perimeter/3 less than 1 (408 possible combinations of sqrt(2)/2, 1, sqrt(3/2) per site)

         A site file for the SQS structure is written to site2.nio.
         Look at the last lines of site2.nio to see how the the original cell is mapped into the supercell.

         Note: the site ordering may change, depending on the details of the compiler's random number generator.
         There are many configurations for which the the 'configuration' energy vanishes.
         But it should vanish for any acceptable configuration.

EOF
endif

set pass
set ext = nio
set job=5
query chk51 chk5e "run this test (file ctrl.$ext)"
chk51:
findcmd chk51a lmscell "$path" "$topdir"
chk51a:
findcmd chk51b vextract "$path" "$topdir"
chk51b:

set refout=$testdir/out.lmscell.$ext  testout=out.lmscell.$ext
if ($?clean) then
  touch ctrl.$ext
  echo "$space rm -f *.$ext $testout"
               rm -f *.$ext $testout
  goto chk5e
endif
if (! -e $refout) then
   echo ' '
   echo " test.lmscell aborting ... missing file $refout"
   exit -1
endif
if (! -e $testdir/ctrl.$ext) then
   echo ' '
   echo " test.lmscell aborting ... missing file $testdir/actrl.$ext"
   exit -1
endif

echo "$space cp $testdir/{ctrl,site}.$ext $testdir/semi.mater ."
             cp $testdir/{ctrl,site}.$ext $testdir/semi.mater .

# echo "$space echo 1.0 1.0 2.0 1.0 2.0 1.0 2.0 1.0 1.0 | $lmscell nio -vfile=t  --wsite~map~fn=site2 --sqs~r3mode=1~seed=1 > $testout"
#              echo 1.0 1.0 2.0 1.0 2.0 1.0 2.0 1.0 1.0 | $lmscell nio -vfile=t  --wsite~map~fn=site2 --sqs~r3mode=1~seed=1 > $testout
echo "$space echo 1.0 1.0 2.0 1.0 2.0 1.0 2.0 1.0 1.0 | $lmscell nio -vfile=t  --wsite~map~fn=site2 --sqs~r3max=1~r3mode=2~seed=1 > $testout"
             echo 1.0 1.0 2.0 1.0 2.0 1.0 2.0 1.0 1.0 | $lmscell nio -vfile=t  --wsite~map~fn=site2 --sqs~r3max=1~r3mode=2~seed=1 > $testout
set retval = $status
if ($retval != 0) goto cleanup
if (! $?quiet) echo "$space Program lmscell returned successfully."

call diffiles chk5s "CPU -1 $testout $refout"
chk5s:

set esqs1 =  `cat $testout | $vextract . esqs | sed -n 1,1p`
set esqs1r = `zcat $refout | $vextract . esqs | sed -n 1,1p`
set esqsn =  `cat $testout | $vextract . esqs | sed -n 2,2p`
set esqsnr = `zcat $refout | $vextract . esqs | sed -n 2,2p`

set nbas = `head -1 site2.nio | $vextract . nbas`

if (! $?quiet) then
  echo "$space starting configuration energy     = $esqs1"
  echo "$space corresponding reference           = $esqs1r"
  set ediff = `echo $esqs1 $esqs1r  | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print k}'`
  echo "$space difference                        = $ediff"
  echo

  echo "$space final configuration energy        = $esqsn"
  echo "$space corresponding reference           = $esqsnr"
  set ediff = `echo $esqsn $esqsnr  | awk '{{k=($1-$2)>0?($1-$2):($2-$1);} print k}'`
  echo "$space difference                        = $ediff"
  echo

endif

if (! $?quiet) echo "$space ... automatic pass checks :"

compare_res chk5da "Initial configuration energy" $esqs1 $esqs1r 0 pass
chk5da:

compare_res chk5db "Final configuration energy" $esqsn $esqsnr 0 pass
chk5db:

compare_res chk5dc "Number of sites in site2.$ext" $nbas 32 0 pass
chk5dc:

if ($?pass) then
    echo "$space lmscell test 5 PASSED ($ext)"
else
    echo "$space lmscell test 5 FAILED ($ext)"
    set failed = ($failed 5)
endif
chk5e:

echo $joblist | sed s/10// | grep 6 >/dev/null
if ($status) goto chk6e
cat <<EOF

         --- Test 6.  Superlattice of InAs/GaSb ---
         Uses lmscell's superlattice editor to demonstrate the generation of
         a (InAs)_4/(GaSb)_4 superlattice from site files for InAs and GaSb.

         The basal plane is a cubic edge; the superlattice is built along
	 the [110] line.

EOF

set pass
set ext = inas
set job=6
query chk61 chk6e "run this test (file ctrl.$ext)"
chk61:
findcmd chk61a lmscell "$path" "$topdir"
chk61a:
set refout=$testdir/out.lmscell.$ext  testout=out.lmscell.$ext ext=$ext
if ($?clean) then
  touch ctrl.$ext
  echo "$space rm -f *.$ext $testout"
               rm -f *.$ext $testout
  goto chk6e
endif
echo "$space cp $testdir/{ctrl,site}.$ext $testdir/site.gasb ."
             cp $testdir/{ctrl,site}.$ext $testdir/site.gasb .

rm -f $testout
echo "$space lmscell $ext -vz=11.5/11.43 '--stack~show~file site.inas dup=3~file@site.gasb@scale=1/z@stretch=z^3@dpos=(z^3-1)/16,(z^3-1)/16,0@dup=4~show~wsite@short' >> out.lmscell.inas"
             lmscell $ext -vz=11.5/11.43 '--stack~show~file site.inas dup=3~file@site.gasb@scale=1/z@stretch=z^3@dpos=(z^3-1)/16,(z^3-1)/16,0@dup=4~show~wsite@short' >> out.lmscell.inas
set retval = $status
if ($retval != 0) goto cleanup
if (! $?quiet) echo "$space Program lmscell returned successfully."

call diffiles chk6s "CPU -1 $testout $refout"
chk6s:

echo ''
echo -n "$space files sites.$ext and $testdir/sites.$ext equivalent to 6 digits? ..."
call zcmpnfiles chk6c3 "6 sites.$ext $testdir/sites.$ext"
chk6c3:
  if ($retval == 0) then
    echo yes
  else if (`echo ' ' | awk -v ndiff=$retval -v ntot=$ncharfile '{print (100*ndiff/ntot<1.)}'` == 1) then
    echo ok "($retval difference(s) of $ncharfile)"
  else
    echo no "($retval difference(s) of $ncharfile)"
    unset pass
  endif
endif

if ($?pass) then
    echo "$space lmscell test 6 PASSED ($ext)"
else
    echo "$space lmscell test 6 FAILED ($ext)"
    set failed = ($failed 6)
endif
chk6e:

echo $joblist | sed s/10// | grep 7 >/dev/null
if ($status) goto chk7e
cat <<EOF

         --- Test 7.  Superlattice of Nb/Fe ---
         Uses lmscell's superlattice editor to demonstrate the generation of
         a reconstructed Nb_6/Fe_12/Nb_6 superlattice from Nb and Fe site files

EOF

set pass
set ext = nb
set job=7
query chk71 chk7e "run this test (file ctrl.$ext)"
chk71:
findcmd chk71a lmscell "$path" "$topdir"
chk71a:
set refout=$testdir/out.lmscell.$ext  testout=out.lmscell.$ext ext=$ext
if ($?clean) then
  touch ctrl.$ext
  echo "$space rm -f *.$ext $testout"
               rm -f *.$ext $testout
  goto chk7e
endif
echo "$space cp $testdir/{ctrl,site3}.$ext $testdir/site4.fe ."
             cp $testdir/{ctrl,site3}.$ext $testdir/site4.fe .

rm -f $testout
echo "$space lmscell -vfile=3 nb '--stack~newspec~file@site3.nb~file@site4.fe@dup=3~file@site3.nb~newspec~file@site3.nb~wsite@fn=sitein~q'"
             lmscell -vfile=3 nb '--stack~newspec~file@site3.nb~file@site4.fe@dup=3~file@site3.nb~newspec~file@site3.nb~wsite@fn=sitein~q' >> out.lmscell.nb
set retval = $status
if ($retval != 0) goto cleanup
if (! $?quiet) echo "$space Program lmscell returned successfully."

call diffiles chk7s "CPU -1 $testout $refout"
chk7s:

echo ''
echo -n "$space files sitein.$ext and $testdir/sitein.$ext equivalent to 6 digits? ..."
call zcmpnfiles chk7c3 "6 sitein.$ext $testdir/sitein.$ext"
chk7c3:
  if ($retval == 0) then
    echo yes
  else if (`echo ' ' | awk -v ndiff=$retval -v ntot=$ncharfile '{print (100*ndiff/ntot<1.)}'` == 1) then
    echo ok "($retval difference(s) of $ncharfile)"
  else
    echo no "($retval difference(s) of $ncharfile)"
    unset pass
  endif
endif

if ($?pass) then
    echo "$space lmscell test 7 PASSED ($ext)"
else
    echo "$space lmscell test 7 FAILED ($ext)"
    set failed = ($failed 7)
endif
chk7e:

echo $joblist | sed s/10// | grep 8 >/dev/null
if ($status) goto chk8e
cat <<EOF

         --- Test 8.  Convert bulk unit cell of CsPbI3 to trilayer geometry ---
         Uses lmscell's superlattice editor to convert CsPbI3 to
         (1) double the unit cell
         The active region consists of 2 unit cells:
         The first cell becomes the left lead, the second the right lead.
         (2) Construct principal layer indices

         To confirm that the 2-layer superlattice exactly reproduces
         the original cell, do the following after this test completes:
           cp rstax rsta.cspbi3
           lmstr -vfile=2 ctrl.cspbi3 --rs=1,0 -vnit=-1 -vnk2=4 --quit=rho
           lm -vfile=2 ctrl.cspbi3 --rs=1,0 -vnit=-1 -vnk2=4 --quit=rho

         You can also confirm that lmgf is as about as self-consistent for the doubled
         cell as it is for the single cell.  Compare:
           lmstr ctrl.cspbi3 -vgamma=t --rs=1,0 -vnit=-1 -vgf=1 --quit=rho
           lmgf ctrl.cspbi3 -vgamma=t -vgf=1 -vfile=2 --rs=1,0 -vnit=-1 -vnk2=4 --quit=rho
         to:
           cp rstax rsta.cspbi3
           lmstr ctrl.cspbi3 -vgamma=t -vgf=1 -vfile=2 --rs=1,0 -vnit=-1 -vnk2=4 --quit=rho
           lmgf ctrl.cspbi3 -vgamma=t -vgf=1 -vfile=2 --rs=1,0 -vnit=-1 -vnk2=4 --quit=rho


EOF

set pass
set ext = cspbi3
set job=8
query chk81 chk8e "run this test (file ctrl.$ext)"
chk81:
findcmd chk81a lmscell "$path" "$topdir"
chk81a:
set refout=$testdir/out.lmscell.$ext  testout=out.lmscell.$ext ext=$ext
if ($?clean) then
  touch ctrl.$ext
  echo "$space rm -f *.$ext $testout"
               rm -f *.$ext $testout
  goto chk8e
endif
echo "$space cp $testdir/{ctrl,site,rsta}.$ext ."
             cp $testdir/{ctrl,site,rsta}.$ext .

rm -f $testout
echo "$space lmscell -vpgf=0 cspbi3 --stack~rsasa@fn=rsta.cspbi3@rdim~file@site.cspbi3@rsasa@rdim@fn=rsta.cspbi3~wsite:fn=site2:rsasa=rsta2 >> $testout"
             lmscell -vpgf=0 cspbi3 --stack~rsasa@fn=rsta.cspbi3@rdim~file@site.cspbi3@rsasa@rdim@fn=rsta.cspbi3~wsite:fn=site2:rsasa=rsta2 >> $testout
set retval = $status
if ($retval != 0) goto cleanup
echo "$space lmscell -vpgf=5 cspbi3 --stack~rsasa@fn=rsta2~setpl:sort:range=9:shorps=0,0,1~wsite:fn=site3:rsasa=rsta3 >> $testout"
             lmscell -vpgf=5 cspbi3 --stack~rsasa@fn=rsta2~setpl:sort:range=9:shorps=0,0,1~wsite:fn=site3:rsasa=rsta3 >> $testout
set retval = $status
if ($retval != 0) goto cleanup
if (! $?quiet) echo "$space Program lmscell returned successfully."

call diffiles chk8s "CPU -1 $testout $refout"
chk8s:

echo ''
echo -n "$space files site3.$ext and $testdir/site3.$ext equivalent to 6 digits? ..."
call zcmpnfiles chk8c3 "6 site3.$ext $testdir/site3.$ext"
chk8c3:
  if ($retval == 0) then
    echo yes
  else if (`echo ' ' | awk -v ndiff=$retval -v ntot=$ncharfile '{print (100*ndiff/ntot<1.)}'` == 1) then
    echo ok "($retval difference(s) of $ncharfile)"
  else
    echo no "($retval difference(s) of $ncharfile)"
    unset pass
  endif
endif

echo -n "$space files rsta2 and $testdir/rsta2.$ext differ by 3 or fewer lines? ..."
set retval = `diff -y --suppress-common-lines rsta2 $testdir/rsta2.$ext | wc -l`
  if ($retval <= 3) then
    echo yes
  else
    echo no "($retval differences)"
    unset pass
  endif
endif

echo -n "$space files rsta3 and $testdir/rsta3.$ext differ by 3 or fewer lines? ..."
set retval = `diff -y --suppress-common-lines rsta3 $testdir/rsta3.$ext | wc -l`
  if ($retval <= 3) then
    echo yes
  else
    echo no "($retval differences)"
    unset pass
  endif
endif

if ($?pass) then
    echo "$space lmscell test 8 PASSED ($ext)"
else
    echo "$space lmscell test 8 FAILED ($ext)"
    set failed = ($failed 8)
endif
chk8e:

echo $joblist | sed s/10// | grep 9 >/dev/null
if ($status) goto chk9e
cat <<EOF

         --- Test 9.  Scale shift in site positions relative to reference file  ---
         Uses lmscell's --refsite option to read positions from a reference file and:
         (1) determine the change delta of the current positions relative to a
             reference, given by another site file ('supercell-001')
         (2) scale delta by a factor -1
         (3) add scaled delta to the reference
         (4) write the modified positions to a new site file

         The system is monoclinic VO2 (12 atoms), and
         the switch that generates the the shift is
            --refsite~swap~plx~fn=supercell-001~scl=-1

	 'swap' tells lmscell to exchange the role of 'current' and 'reference', so
         that 'reference' refers to the current site positions, and the shift
         is given by the shift in positions in file 'supercell-001' relative to it.

         'plx' tells lmscell to compute the shift as changes in positions in
         units of the lattice vectors.  Since the lattice vectors in 'site.vo2'
         and 'supercell-001.vo2' are equivalent, plx produces the same result as
         if it were not there.  This will not be the case if the lattice
         vectors are not equivalent.

         --keep tells lmscell not to look for sites in the supercell but
         to keep the site positions as given.

         A new site file (site2) is created.
         Shifts in site positions are compared to establish that the
         positions in site2 are shifted in the opposite sense from those in supercell-001.
         Note that this test is non-trivial since the lattice vectors in supercell-001
         are equivalent, but the distribution between alat and plat is different.

EOF

set pass
set ext = vo2

set job=9
query chk91 chk9e "run this test (file ctrl.$ext)"
chk91:
findcmd chk91a lmscell "$path" "$topdir"
chk91a:
findcmd chk91b lmchk "$path" "$topdir"
chk91b:

set refout=$testdir/out.lmscell.$ext  testout=out.lmscell.$ext ext=$ext
if ($?clean) then
  touch ctrl.$ext
  echo "$space rm -f *.$ext $testout"
               rm -f *.$ext $testout
  goto chk9e
endif
echo "$space cp $testdir/{ctrl,site,supercell-001}.$ext ."
             cp $testdir/{ctrl,site,supercell-001}.$ext .

rm -f $testout
echo "$space $lmscell vo2  --plx=no -keep --refsite~swap~plx~fn=supercell-001~scl=-1 --wsitex~fn=site2 >> $testout"
             $lmscell vo2  --plx=no -keep --refsite~swap~plx~fn=supercell-001~scl=-1 --wsitex~fn=site2 >> $testout
set retval = $status
if ($retval != 0) goto cleanup
if (! $?quiet) echo "$space Program lmscell returned successfully."

call diffiles chk9s "CPU -1 $testout $refout"
chk9s:


if (! $?lmchk) goto chk9c

echo "$space $lmchk vo2  --wpos=pos >/dev/null"
             $lmchk vo2  --wpos=pos >/dev/null
echo "$space $lmchk vo2 -vfile=2 --wpos=pos2 >/dev/null"
             $lmchk vo2 -vfile=2 --wpos=pos2 >/dev/null
rm -f site3.vo2
echo "$space ln -s supercell-001.vo2 site3.vo2"
             ln -s supercell-001.vo2 site3.vo2 
echo "$space $lmchk vo2 -vfile=3 --wpos=pos3 >/dev/null"
             $lmchk vo2 -vfile=3 --wpos=pos3 >/dev/null
rm -f site3.vo2

set r3 = `$mcx -valat=8.53589631 pos3.$ext -s1/alat pos.$ext  -- -p -xe -csum -e1 'sqrt(x1)' -rsum -w:nohead .`
echo "$space shift pos3 (from supercell-001) relative to pos (mcx -valat=8.53589631 pos3.$ext -s1/alat pos.$ext  -- -p -xe -csum -e1 'sqrt(x1)' -rsum -w:nohead .)"  : $r3
set r2 = `mcx -valat=8.53589631 pos2.$ext pos.$ext -- -p -xe -csum -e1 'sqrt(x1)' -rsum -w:nohead .`
echo "$space shift pos2 (from site2) relative to pos (mcx -valat=8.53589631 pos2.$ext pos.$ext -- -p -xe -csum -e1 'sqrt(x1)' -rsum -w:nohead .)"  : $r2
set diff1 = `echo 0 $r2 $r3 | mcx . -e1 'abs(x2-x3)<=1d-6*1.01' -w:nohead .`
set xdiff2 = `mcx -valat=8.53589631 pos3.$ext -s1/alat pos.$ext  -- pos2.$ext pos.$ext  -- -+ -p -xe -csum -e1 'sqrt(x1)' -rsum -w:nohead .`
set diff2 = `mcx -valat=8.53589631 pos3.$ext -s1/alat pos.$ext  -- pos2.$ext pos.$ext  -- -+ -p -xe -csum -e1 'sqrt(x1)' -rsum -e1 'abs(x1)<=1d-6*1.01' -w:nohead .`

chk9c:
if (! $?quiet) echo 
if (! $?quiet) echo "$space ... automatic pass checks :"
if ( $?have_mc == 0) then
  echo ''
  echo -n "$space files site2.$ext and $testdir/site2.$ext equivalent to 6 digits? ..."
  call zcmpnfiles chk9c1 "6 site2.$ext $testdir/site2.$ext"
  chk9c1:
  if ($retval == 0) then
    echo yes
  else if (`echo ' ' | awk -v ndiff=$retval -v ntot=$ncharfile '{print (100*ndiff/ntot<1.)}'` == 1) then
    echo ok "($retval difference(s) of $ncharfile)"
  else
    echo no "($retval difference(s) of $ncharfile)"
    unset pass
  endif
else
  set i = 6  tol = 1e-6 exclude = 'CPU|written|LMSCELL'
  zcmpmfiles_res_mc chk9c2 "Max deviation in site2.$ext from ref $testdir/site2.$ext" $tol pass $i site2.$ext $testdir/site2.$ext 0 0
  chk9c2:

  echo -n "$space magnitude of shift (pos2-pos = $r2, pos3-pos = $r3) equal within tolerance (1e-6)? ... "
  if (`echo $diff1 0 | awk '{print ($1 == 1)}'`) then
    echo yes
  else
    echo no
    set failed = ($failed 9)
  endif

  echo -n "$space magnitude of shift (pos2-pos + pos3-pos = $xdiff2) zero within tolerance (1e-6)? ... "
  if (`echo $diff2 0 | awk '{print ($1 == 1)}'`) then
    echo yes
  else
    echo no
    set failed = ($failed 9)
  endif

endif # automatic pass checks
chk9e:

# --- Summary ---
echo ' '
if ($?clean) exit
if ($#failed <= 1) then
    echo "$space $testfile : all tests PASSED"
    echo " "
    exit 0
else
    shift failed
    echo "$space $testfile : These tests FAILED:" $failed
    echo " "
    exit ($failed[1])
endif


# ---------------- zcmpnfiles --------------
# Compares two files, treating each field as a number.
# call arguments should contain 3 strings: n test-file reference-file
# |n| = number of digits which numbers are truncated to.
# If n<0, sort files before comparing them
# Files with .gz or .Z extensions are assumed to be gzipped.
# Returns with retval = number of differences in reduced files
# Example :  call zcmpnfiles chk25 "6 dos-cls.$ext $testdir/dos-cls.$ext.gz"
# Creates temporary files $tmpdir/tmp_compnfile_1 $tmpdir/tmp_compnfile_2
exit
zcmpnfiles:
  set quitjob=$retcall
  set zcmpnargs = ($callarg)
  set digits = $zcmpnargs[1]
  if ($digits < 0) then
    @ digits = - $digits
    set lsort
  endif
# set a = ' { for (i = NF; i > 0; --i) printf " %.'$digits'f", $i; printf "\n" }'
# set a = ' { for (i = 1; i <= NF; i++) { k = sprintf("%.'$digits'f",$i); if (k+k == 0) k = 0 ; printf "%s ", k}; printf "\n" }'
  set a = ' { for (i = 1; i <= NF; i++) { k = sprintf("%.'$digits'f",$i); if (k+k == 0) k = 0 ; printf "%s ", k}; print "" }'

  set fn1 = $tmpdir/tmp_compnfile_1
  set fn2 = $tmpdir/tmp_compnfile_2
  if ("$zcmpnargs[2]:e" == 'gz' || "$zcmpnargs[2]:e" == 'Z') then
    set cat1 = 'gunzip -c'
  else
    set cat1 = cat
  endif
  if ("$zcmpnargs[3]:e" == 'gz' || "$zcmpnargs[3]:e" == 'Z') then
    set cat2 = 'gunzip -c'
  else
    set cat2 = cat
  endif

  if ($?lsort) then
    $cat1  $zcmpnargs[2] | sed s/D-/E-/g | sed s/D+/E+/g | sort | awk "$a" > $fn1
    $cat2  $zcmpnargs[3] | sed s/D-/E-/g | sed s/D+/E+/g | sort | awk "$a" > $fn2
  else
    $cat1  $zcmpnargs[2] | sed s/D-/E-/g | sed s/D+/E+/g | awk "$a" > $fn1
    $cat2  $zcmpnargs[3] | sed s/D-/E-/g | sed s/D+/E+/g | awk "$a" > $fn2
  endif
  set ncharfile = `wc $fn1 | awk '{print $3}'`
  cmp $fn1 $fn2 >/dev/null
  set retval = $status

  if ($retval == 0) rm -f $fn1 $fn2
  if ($retval == 0) goto $quitjob

  set retval = `cmp -l $fn1 $fn2 |& grep -v EOF | wc | awk '{printf "%d", $1}'`
  if ($retval == 0) set retval = '-1'
  rm -f $fn1 $fn2
  goto $quitjob

# ---------------- zcmpmfiles_res_mc --------------
# Compares numerical arguments in two files, using mcx -cmpf
# If mcx is not installed, calls zcmpnfiles_res_tol with the same arguments but the last
# usage: zcmpnfiles_res_mc retcall keyword tol passvar ndig srcfile reffile nlines count
#   retcall      : return to this point in script on exit
#   keyword      : label (for printout)
#   tol          : tolerance in maximum allowed deviation
#   passvar      : $passvar is unset if numerical value of word > tol, count occurences
#   ndig         : number of digits numbers in file are stripped to
#   srcfile      : first file to compare
#   reffile      : second file to compare
#   nlines       : number of lines to compare. Use 0 to include all lines.
#   count        : maximum number of deviations to permit before unsetting passvar.
#
# Checks for max absolute difference and unsets $passvar if difference<$tol fewer than count times
# If variable exclude is set, it is used as a regular expression to exclude lines containing it
# Example:
# zcmpmfiles_res_mc chk1ck "Max deviation in bnds.$ext from reference" $bndstol pass 4 bnds.$ext $testdir/bnds.$ext.gz 0 1
exit
zcmpmfiles_res_mc:
  set quitjobl=$retcall
# echo $retcall $keyword $tol $?passvar $ndig $srcfile $reffile $nlines $count

  if (! $?mcx) then
    echo "$space OOPS! missing mcx calculator ... skipping test $keyword"
    goto $quitjobl
  endif

  set fn1 = $tmpdir/tmp_compnfile_1
  set fn2 = $tmpdir/tmp_compnfile_2

  if ($?exclude) then
    cat   $srcfile | sed 's:\([1-9]\)-:\1 -:g' | egrep -v "$exclude" > $fn1
    cat   $reffile | sed 's:\([1-9]\)-:\1 -:g' | egrep -v "$exclude" > $fn2
  else
    cat   $srcfile | sed 's:\([1-9]\)-:\1 -:g' > $fn1
    cat   $reffile | sed 's:\([1-9]\)-:\1 -:g' > $fn2
  endif

  set nl
  if ($nlines != 0) set nl = "~ln=$nlines"
# echo $mcx -cmpf$nl~fn1=$fn1~fn2=$fn2~tol=1d-$ndig~max~verb
  set retval = `$mcx -cmpf$nl~fn1=$fn1~fn2=$fn2~tol=1d-15~max`
# echo retval $retval
  set ndiff = `$mcx -cmpf$nl~fn1=$fn1~fn2=$fn2~tol=1d-$ndig~ndiff`
# echo ndiff $ndiff
# echo $count

  echo -n "$space $keyword ($retval) within tol ($tol)? ... "
  if (`echo $retval 0 | awk -v tol=$tol '{print ($1 <= tol)}'`) then
    echo yes
  else if ($count > 0) then
    echo -n "no ... fewer than $count occurences? ..."
    if (`echo $ndiff 0 | awk -v count=$count '{print ($1 <= count)}'`) then
      echo yes
    else
      echo no
      unset $passvar
    endif
  else
    echo no
    unset $passvar
  endif
  goto $quitjobl

# ---------------- qprint (print only quiet not set) --------------
exit
qprint:
  set quitjob=$retcall
  if ($?quiet) goto $quitjob
  echo "$callarg"
  goto $quitjob

# ---------------- showout --------------
exit
showout:
  set quitjob=$retcall
  if ($?quiet) goto $quitjob
  echo ' '
  echo "$space ... Compare $callarg to line(s) in file $refout":
  grep $callarg $testout
  if (`cat $testout | grep $callarg | wc | awk '{print $1}'` > 1) echo ' ---'
  gunzip -c $refout | grep $callarg
  goto $quitjob

# ---------------- diffiles --------------
# calling argument should consist of four strings:
# 1st string = string that terminates diff
# 2nd string = integer that counts how many times terminator should occur before terminating
# 3nd string = first file name
# 4th string = second file name
# example: call diffiles chk69 "CPU 3 $testout $refout"
exit
diffiles:
  set quitjob=$retcall
  if ($?quiet) goto $quitjob
  set files = ($callarg)
  set endstr = $files[1]
  shift files
  set nend = $files[1]
  shift files
  if ($nend == "-1") then
    set nend = `grep "$endstr" $files[1] | wc | awk '{print $1}'`
  endif

#    echo difffiles : $quitjob $nend
#    grep $endstr $files[1]

  query diff11 $quitjob "compare $files"
diff11:
  diff $files | awk -v endstr=$endstr -v nend=$nend -v endl=0 -v endr=0 '{if ($1 == "<" && endl < nend) print ; if ($1 == ">" && endr < nend) print ; if ($1 == ">" || $1 == "<" || endl >= nend && endr >= nend) ; else {print} ; if ($1 == "<" && $2 == endstr) {endl+=1}; if ($1 == ">" && $2 == endstr) {endr+=1};}' | sed -n 1,50p
  goto $quitjob

# ---------------- compare_res --------------
# Compares two numbers $testvar-$refvar and unsets $passvar if |testvar-refvar|<tol
# usage: compares_res retcall keyword testvar refvar tol passvar
#   keyword      : label (for printout)
#   testvar      : first number
#   refvar       : second number
#   tol          : tolerance
#   passvar      : $passvar is unset if |testvar-refvar|<tol
exit
compare_res:
  set quitjob=$retcall
# echo $retcall $keyword $testvar $refvar $tol $passvar
  set toll = `echo $tol | sed s/d/e/`
  echo -n "$space $keyword ($testvar) within tol ($toll) of reference ($refvar)? ... "
  if (`echo $testvar $refvar | awk -v tol=$toll '{{k=($1-$2)>0?($1-$2):($2-$1);tl=1.001*tol} print (k<=tl)}'`) then
    echo yes
  else
    echo no
    unset $passvar
  endif
  goto $quitjob

# ---------------- compare_res_0 --------------
# Compares a number $testvar and unsets $passvar if |testvar|<tol
# usage: compares_res_0 retcall keyword testvar tol passvar
# Example:
# compare_res_0 chk274a "Max deviation in pdos from reference" $retval $pdostol pass
#   keyword      : label (for printout)
#   testvar      : first number
#   tol          : tolerance
#   passvar      : $passvar is unset if |testvar|<tol
exit
compare_res_0:
  set quitjob=$retcall
#  echo $retcall $keyword $testvar $tol $passvar
  set toll = `echo $tol | sed s/d/e/`
  echo -n "$space $keyword ($testvar) within tol ($toll)? ... "
  if (`echo $testvar 0 | awk -v tol=$toll '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k<=tol)}'`) then
    echo yes
  else
    echo no
    unset $passvar
  endif
  goto $quitjob

# ---------------- findcmd --------------
# Finds an executable program within the supplied path
# Usage: findcmd return_label executable_command path_name make_path
# If $executable_command is not found, findcmd does one of the following:
# If make_path = 'no' : returns silently.
# Otherwise findcmd aborts with a message, which assumes
# $make_path is the path where $executable_command is made.
exit
findcmd:
set found = 'no'
foreach ac_dir ($path_name)
 if (-x $ac_dir/$prog_cmd) then
   set $prog_cmd = $ac_dir/$prog_cmd
   set found = 'yes'
   break
 endif
end
if (! $?quiet) then
  if ($found == 'yes') echo "$space ... using executable $ac_dir/$prog_cmd"
  if ($found == 'no')  echo "$space ... no executable $prog_cmd found in path"
endif
if ($found == 'no' && $make_path != "no") then
  echo "  "
  echo "  Sorry, $testfile cannot find program '"$prog_cmd"' it needs to execute."
  echo "  '"$prog_cmd"' was not found in supplied path, or in the following:"
  echo "        $topdir"
# echo "  ... This script ($testfile) requires binary "'"rdcmd"'" to run."
  echo "  You must create or put '"$prog_cmd"' in your path before invoking this script."
  echo "  Normally '"$prog_cmd"' is created as part of the installation process."
  echo "  Invoking '"make $prog_cmd"' in $make_path should create it."
  echo "  $testfile aborting ..."
  exit -1
endif
goto $retcall

# ---------------- runjob --------------
exit
runjob:
  set quitjob=$retcall
  if ($outfile == ".") then
    echo "$space $callarg"
    echo " "
    $callarg
    set retval = $status
  else
    if (`echo $outfile | awk '{print substr($1,1,2)}'` == '>>') then
      set appfile = `echo $outfile | awk '{print substr($1,3)}'`
      echo "$space $callarg  >> $appfile"
      $callarg >> $appfile
      set retval = $status
    else
      echo "$space $callarg  > $outfile"
      $callarg > $outfile
      set retval = $status
  endif
  if ($retval != 0) goto cleanup
  goto $quitjob


# ---------------- cleanup --------------
exit
cleanup:
  if ($retval != 0) then
     echo "$space Program lm returned with error status $retval"
     echo "$space lmscell test $job FAILED ($ext)"
     echo "$space ... $testfile aborting"
  endif
  exit $retval

# ---------------- query --------------
exit
query:
  unset skip
  if ($?slow != 0) then
    echo "$space"'*'"hit <return> to $callarg, s <return> to skip it."
    set a = ($<)
    if ($a == "") goto $retcall
    switch ($a)
      case "quit":
      case "q":
      case "a":
        exit
      case "i":
        unset slow
        breaksw
      case "s":
        set skip
        breaksw
      case "t":
        time
        goto query
      default:
        echo 'q to quit; i unsets slow; s skips this job, t shows time'
        goto query
    endsw
  endif
  if ($?skip) goto $retcall2
  goto $retcall

# ---------------- List tests --------------
showtests:
cat <<EOF
  Usage: invoke with:    $testfile job-list

  Material   job      Tests
   cr3si6     1       basic test of supercell maker
   co         2       Supercell of co, showing features of --wsite
   mngas      3       incorporation of lattice displacements around impurity
   kfese      4       supercell restart file (ASA).  Also --swap and --ring features
   nio        5       SQS structure in NiO
   inas       6       Superlattice of (InAs)_4/(GaSb)_4
   nb         7       Superlattice of Nb and Fe
   cspbi3     8       Converts crystalline CsPbI3 to trilayer with 2 principal layers

EOF
exit

# ---------------- usage: --------------
usage:
cat <<EOF
 usage: test.lmscell [switches] [file-extension] [testcase-list]
        e.g., "test.lmscell cr3si6 1 2"
        If file-extension is missing, 'cr3si6' is used
        Switches:
        --no-iactive runs tests without prompting user
        --quiet runs tests with minimal output and without prompting user
        --whichexec  prints out which lmscell executable it finds in path and exits
EOF
#       --verbose    script prints out extra information
exit -1
