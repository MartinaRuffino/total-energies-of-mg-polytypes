      subroutine sugwin(s_site,s_spec,s_lat,s_ham,s_gw,s_bz,nbas,qval)
C- Creates these input files as setup to GW: GWinput, QIBZ
C ----------------------------------------------------------------------
Cio Structures
Cio  s_site :struct for site-specific data; see structures.h
Ci     Elts read:  spec pnu pz
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:*
Cio    Passed to:  *
Cio  s_spec :struct for species-specific data; see structures.h
Ci     Elts read:  lmxa z p pz idxdn pb1 pb2 nr
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:rmt a name
Cio    Passed to:  gtpcor
Cio  s_lat  :struct containing lattice information; see structures.h
Ci     Elts read:  alat plat qlat nabc npgrp nsgrp igv2 kv2
Co     Stored:     igv2 kv2
Co     Allocated:  *
Cio    Elts passed:symgr igv2 kv2
Cio    Passed to:  sugvec
Cio  s_ham  :struct for parameters defining hamiltonian; see structures.h
Ci     Elts read:  basopt ldham
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:*
Cio    Passed to:  *
Cio  s_gw  :struct for gw-related parameters
Ci     Elts read:  mksig lgw nkabc nband qoffp gcutb gcutx ecuts nime
Ci                 delre deltax deltaw pbtol gsmear ecutpb
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:*
Cio    Passed to:  *
Cio  s_bz   :struct for the Brillouin Zone; see structures.h
Ci     Elts read:  nkabc lshft
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:*
Cio    Passed to:  *
Ci Inputs
Ci   nbas  :size of basis
Ci   qval  :number of valence electrons (sets number of bands)
Cs Command-line switches
Cs   --make-Q0P   : Create files Q0P, QGpsi, QGcou
Cs   --no-GWinput : Suppress making GWinput
Cs   --gwin0      : Read parts of template from GWin0.
Cs   --sc         :
Co Outputs
Co    Files GWinput, QIBZ, KPTin1BZ created.
Co    Optionally files Q0P, QGpsi, QGcou are created. (--make-Q0P)
Co      These latter are redundant because they are generated by
Co      the GW code 'qg4gw'.   For the newer offset meshes, this
Co      routine generates the wrong output.
Co     --make-Q0P is useful so that the GW driver can be tested
Co     standalone, without requiring qg4gw.
Cu Updates
Cu   06 Apr 18 (Jerome Jackson) Added first BSE variables: UseBSEW,NumCondStates,Qvec_bse
Cu   17 Jan 17 Bug fixes to GWin0 read option
Cu   20 Dec 16 First cut at enabling read of GWin0 to construct parts of GWinput
Cu   25 Jun 16 Change default product basis tolerance
Cu   02 Jul 15 Improve defaults for GWinput template
Cu   08 Jul 13 Replace f77 pointers with f90 ones
Cu   11 Feb 13 Replace gvlst2 call with sugvec call
Cu   06 Jul 12 Weights are written to file QIBZ
Cu   10 Nov 11 Begin migration to f90 structures
Cu   30 Aug 05 sugw handles ngp=0 and/or ngc=0
Cu   04 Jul 05 handle sites with lmxa=-1 -> no rep'sn in GWinput
Cu   24 Oct 01 Adapted from v6.11 sugw
C ----------------------------------------------------------------------
      use structures
      implicit none
C ... Passed parameters
      integer nbas,n0,nkap0
      parameter (n0=10,nkap0=4)
      double precision qval
C ... For structures
!      include 'structures.h'
      type(str_site)::  s_site(*)
      type(str_spec)::  s_spec(*)
      type(str_lat)::   s_lat
      type(str_ham)::   s_ham
      type(str_gw)::    s_gw
      type(str_bz)::    s_bz
C ... Dynamically allocated local arrays
      integer, allocatable :: ipq(:),kv(:),ngpn(:,:),ngcn(:,:),iblst(:)
      real(8),allocatable :: qbz(:,:),qibz(:,:),wbz(:),q0x(:,:),q0i(:,:),wt(:),wt0(:),
     .  qnum(:,:),wtnum(:),qirr(:,:),wtirr(:),rofi(:),rwgt(:),rhoc(:),gcore(:,:,:)
      integer,pointer :: igvsav(:,:),kvsav(:,:),irr(:)
      integer,pointer :: ngvecp(:,:),ngvecc(:,:)
C ... Local parameters
      logical ltmp,lfval
      integer,parameter:: NULLI = -99999, nmaster = 42
      integer i,iaf,iat,idxdn(n0,nkap0),ifi,ifi0,ifii,ii,imx,iqnum,nr,kcor,lcor,igwin0,
     .  ipr,iq,iq0i,iqall,is,iwk(3),j,j1,j2,k,k1,k2,k3,konf,konfig(0:n0),i1,i2,
     .  l,lcutmx(nbas),ldim,lgunit,lgw,lmaxa,lshft(3),mksig,
     .  n1,n1q,n2,n2q,n3,n3q,nat,nband,nblst,ncinc,ncinc2,ncore,ngabc(3),ngc,
     .  ngcmx,ngp,ngpmx,niw,nkgw(3),nkp,nl,nncx,nnvv(n0,nbas),
     .  nocc,npgrp,npqn,nq0i,nqibz,nqnum,nsgrp,nsp,nunocc,nx0,nqirr,ntolpb,stdo,
     .  usebsew,have_master(nmaster)
      equivalence (n1,ngabc(1)),(n2,ngabc(2)),(n3,ngabc(3))
      equivalence (n1q,nkgw(1)),(n2q,nkgw(2)),(n3q,nkgw(3))
      double precision alp,gcutb,gcutx,ecuts,pnu(n0,2),pnz(n0,2),z,xx,sumec,sumtc,
     .  dw(2),delta,deltaw,esmr,tolpb(10),plat(3,3),qlat(3,3),
     .  qb(3,3),xn,alat,q(3),qp(3),qcor(2),ecore(50),elocmx
      character pb1*8,pb2*8,pbi(2,3)*8,outs*80,strn*512
      character lsym(0:n0-1)*1, lorb(3)*1, dig(9)*1, strn8*8
      character master_tags(nmaster)*13,cat_tags(3)*15
      procedure(logical) cmdopt,rdstrn
      procedure(integer) fopnx,nglob
      data lsym /'s','p','d','f','g','5','6','7','8','9'/
      data lorb /'p','d','l'/
      data dig /'1','2','3','4','5','6','7','8','9'/
      data have_master /nmaster*0/, master_tags /
     .  'Verbose',
     .  'GWversion',
     .  'Q0P_Choice',
     .  'CoreOrth',
     .  'multitet',
     .  'EXonly',
     .  'EIBZmode',
     .  'TimeReversal',
     .  'KeepEigen',
     .  'KeepPPOVL',
     .  'Chi',
     .  'BZmesh',
     .  'WgtQ0P',
     .  'NormChk',
     .  'n1n2n3',
     .  'QpGcut_psi',
     .  'QpGcut_cou',
     .  'unit_2pioa',
     .  'alpha_OffG',
     .  'nband_chi0',
     .  'emax_chi0',
     .  'nband_sigm',
     .  'emax_sigm',
     .  'dw',
     .  'omg_c',
     .  'iSigMode',
     .  'niw',
     .  'delta',
     .  'deltaw',
     .  'esmr',
     .  'rsm',
     .  'GaussSmear',
     .  'UseBSEW',
     .  'NumCondStates',
     .  'NumValStates',
     .  'MinOmega_BSE',
     .  'MaxOmega_BSE',
     .  'numOmega_BSE',
     .  'dOmega_BSE',
     .  'Qvec_bse',
     .  'ImagEner1',
     .  'ImagEner2'/
      data cat_tags /
     .  '<PRODUCT_BASIS>',
     .  '<QPNT>',
     .  '<QforEPS>'/

C --- Setup ---
      call getpr(ipr)
      alat = s_lat%alat
      plat = s_lat%plat
      qlat = s_lat%qlat
      ngabc = s_lat%nabc
      npgrp = s_lat%npgrp
      nsgrp = s_lat%nsgrp
      call fftz30(n1,n2,n3,k1,k2,k3)
      stdo = lgunit(1)
      nsp  = nglob('nsp')
      nl   = nglob('nl')
      mksig = s_gw%mksig
      if (cmdopt('--sc',4,0,outs)) then
        if (mksig == 0) mksig = 1
      endif
      lgw = s_gw%lgw
      if (mksig /= 0) lgw = 1
      nkgw = s_gw%nkabc
      nband = s_gw%nband
      alp = s_gw%qoffp
      gcutb = s_gw%gcutb
      gcutx = s_gw%gcutx
      ecuts = s_gw%ecuts
      elocmx = s_ham%basopt(3)  ! Core states
      ldim = s_ham%ldham(1)
      usebsew = s_gw%usebsew
      call info0(30,0,0,' ... Creating files GWinput, QIBZ, KPTin1BZ')

      if (n1q*n2q*n3q == 0) then
        call info(30,0,0,
     .    ' ... (warning) using k-points from BZ category',0,0)
        nkgw = s_bz%nkabc
        lshft = s_bz%lshft
      endif

C ... Count number of atoms : exclude floating orbitals
      nat = 0
      do  i = 1, nbas
        is = s_site(i)%spec
        lmaxa = s_spec(is)%lmxa
        if (lmaxa > -1) then
          nat = nat + 1
        endif
      enddo

C ... qp in full BZ, Arysetiawan's order; write file KPTin1BZ
      nkp = n1q*n2q*n3q
      allocate(qbz(3,nkp),wbz(nkp))
      call genqbz(qlat,n1q,n2q,n3q,qbz,wbz)
C     Irreducible qp in BZ
      call iinit(iwk,3)
C     call defi(oipq,nkp)
      allocate(ipq(nkp))
      allocate(qibz(3,nkp))
      wbz(1) = 0
      call bzmesh(plat,qb,n1q,n2q,n3q,iwk,s_lat%symgr,npgrp,ipq,
     .  qibz,wbz,nqibz,nkp,0,0)
      deallocate(ipq)
C ... shorten QIBZ
C      if (.not. cmdopt('--lmv6',6,0,outs)) then
CC       call prmx('qibz before shortening',qibz,3,3,nqibz)
C        call shorps(nqibz,qlat,(/72,2,2/),qibz,qibz)
C     C       call prmx('qibzo after shortening',qibz,3,3,nqibz)
C      endif

C ... Create first part of GWinput
      if (.not. cmdopt('--no-GWinput',12,0,outs)) then

      ifii = fopnx('GWinput',2,2,-1)
      rewind ifii

C ... Prepare to read fixed lines from GWin0
      igwin0 = 0
      if (cmdopt('--gwin0',7,0,outs)) then
        call info0(30,0,0,' ... reading GWinput data from template GWin0 ...')
        igwin0 = 1
        ifi0 = fopnx('GWin0',2,1,-1)
        rewind ifi0
        if (.not. rdstrn(ifi0,strn,len(strn),.false.))
     .    call rx('sugwin (abort) : empty GWin0 file')
        rewind ifi0
      endif
      do while (igwin0 == 1)
        if (.not. rdstrn(ifi0,strn,len(strn),.false.)) exit

C       Pass comments through
        i = index(strn,'!')
        if (i > 0) then
          if (i == 1 .or. strn(1:len(strn(1:i-1))) == ' ') then
            write(ifii,333) trim(strn)
  333       format(a)
            cycle
          endif
        endif

        call word(strn,1,i1,i2)

C       Exit if start-of-category
        if (strn(1:1) == '<') then
          igwin0 = -1
          call tokmat(strn(i1:i2),cat_tags,size(cat_tags),len(cat_tags(1)),' ',j1,j2,.false.)
          if (j1 >= 0) igwin0 = j1+2  ! Marks which category is next
          exit
        endif

C       Flag known tags
        call tokmat(strn(i1:i2),master_tags,size(master_tags),len(master_tags(1)),' ',j1,j2,.false.)
        if (j1 >= 0) then
          have_master(j1+1) = 1
        endif
        write(ifii,333) trim(strn)

      enddo

      if (igwin0 == 0) then
        write(ifii,301)
  301   format(
     .  '! Text following "!" are comments'/
     .  '! Input lines consist of "keyword value(s)"'/
     .  '! New section begins with <tagname>'/
     .  '!Verbose    41  ! 0-->default; 100-->debug'/
     .  'GWversion   12  ! 0-->Sep12 compatible.'/
     .  '                ! The following are active (take any combination)'/
     .  '                !   1 include LFC in offset-Gamma treatment (original version)'/
     .  '                !   2 improved LFC; see J. Phys. Soc. Jpn. 83, 094711 (2014))'/
     .  '                !  10 improved unocc counting in making G*W'/
C     .  '                ! 200 rotate sigm to basis of LDA-LMTO ',
C     .                         'eigenfunctions'/
     .  '!Q0P_Choice 1   ! 1(default):Near q->0 limit ',
     .                    '2:1/q^2 average in Gamma region'/
     .  '!CoreOrth  off  ! off --> Do not orthogonalize core to valence'
     .                           ,' (default)'/
     .  '                ! on  --> Orthogonalize cores to valence ',
     .                            '(may give strange core functions!)'/
     .  '!multitet 2 2 2 ! tetrahedra divided into micro-tetrahedra'/
     .  '!EXonly   .15   ! for exchange-only calculations'/
     .  '!EIBZmode off   ! turn off to suppress use of symmetrization',
     .                   ' in calculating polarization'/
     .  '!TimeReversal off ! when time-reversal symmetry is broken'/
     .  'KeepEigen  on   ! keep eigenfunctions in memory'/
     .  'KeepPPOVL  on   ! keep PPOVL in memory'/
     .  '!Chi_RegQbz off ! Offset Gamma point mesh for chi.  on => no offset'/
     .  'BZmesh     1    ! Offset Gamma point mesh for Sigma=iGW'/
     .  'WgtQ0P     0.01 ! Weight used when BZmesh is 2'/
     .  'NormChk    0    ! 1,2 writes norm check files (diagonal or full)')
      else
        write(ifii,"(/'! Supply possible tags not found in GWin0')")
        if (have_master(2) == 0)  write(ifii,333) 'GWversion   12'
        if (have_master(9) == 0)  write(ifii,333) 'KeepEigen   on'
        if (have_master(10) == 0) write(ifii,333) 'KeepPPOVL   on'
        if (have_master(12) == 0) write(ifii,333) 'BZmesh      1'
        if (have_master(13) == 0) write(ifii,333) 'WgtQ0P      0.01'
        if (have_master(14) == 0) write(ifii,333) 'NormChk     0'
      endif
      if (igwin0 == 0 .or. have_master(15) == 0) then ! n1n2n3
      write(ifii,'(''n1n2n3'',3I3,'' ! for GW BZ mesh'')') n1q,n2q,n3q
      endif
      if (igwin0 == 0 .or. have_master(16) == 0) then ! QpGcut_psi
      call awrit1('QpGcut_psi %d %16p! |q+G| cutoff for eigenfunction',' ',80,ifii,gcutb)
      endif
      if (igwin0 == 0 .or. have_master(17) == 0) then ! QpGcut_cou
      call awrit1('QpGcut_cou %d %16p! |q+G| cutoff for coulomb int.',' ',80,ifii,gcutx)
      endif
      if (igwin0 == 0 .or. have_master(18) == 0) then ! unit_2pioa
      write(ifii,302)
  302 format('unit_2pioa off  ! off --> units of 2 preceding Gcut are ',
     .       'a.u.; on--> units are 2*pi/alat')
      endif
      if (igwin0 == 0 .or. have_master(19) == 0) then ! alpha_OffG
      call awrit1('alpha_OffG %d%16p! (a.u.) parameter (auxiliary'
     .  //' function, offset-Gamma method)',' ',80,ifii,alp)
      endif
      if (igwin0 == 0) then
      write(ifii,303)
  303 format(
     .  '!nband_chi0 999 ! nband cutoff for chi0  (Optional)'/
     .  '!emax_chi0 999. ! emax  cutoff for chi0, Ry  (Optional)'/
     .  '!nband_sigm 999 ! nband cutoff for Sigma (Optional)')
      endif
      if (igwin0 == 0 .or. have_master(23) == 0) then ! emax_sigm
      call awrit1('emax_sigm %d%16p%b ! Energy cutoff for Sigma, '//
     .  'Ry (Optional)',' ',80,ifii,ecuts)
      endif

C ... Energy parameters for file GWinput
      niw = s_gw%nime
      dw = s_gw%delre
      delta = s_gw%deltax
      deltaw = s_gw%deltaw
      ntolpb = 0; tolpb = NULLI; tolpb(1:size(s_gw%pbtol)) = s_gw%pbtol
      do while (tolpb(ntolpb+1) /= NULLI .and. ntolpb < size(tolpb))
        ntolpb = ntolpb+1
      enddo
      if (tolpb(1) == NULLI) then
        ntolpb = 3; tolpb(1:3) = [3d-4,3d-4,1d-3]
      endif
      esmr = s_gw%gsmear
      if (igwin0 == 0 .or. have_master(24) == 0) then  ! dw
      call awrit1('dw       %d%16p! mesh spacing along Real axis'//
     .  ' (Hartree)',' ',80,ifii,dw)
      endif
      if (igwin0 == 0 .or. have_master(25) == 0) then  ! omg_c
      call awrit1('omg_c    %d%16p! mesh spacing increases linearly '//
     .  'with w: becomes 2*dw at omg_c',
     .  ' ',80,ifii,dw(2))
      endif
      if (igwin0 == 0 .or. have_master(26) == 0) then  ! iSigMode
      call awrit1('iSigMode %i%16p! QSGW mode switch (QSGW only)',
     .  ' ',80,ifii,mksig)
      endif
      if (igwin0 == 0 .or. have_master(27) == 0) then  ! niw
      call awrit1('niw      %i%16p! # freq. on Im axis; used for '//
     .  'integration to make Sigma_c',' ',100,ifii,niw)
      endif
      if (igwin0 == 0 .or. have_master(28) == 0) then  ! delta
      call awrit1('delta    %g%16p! delta-function broadening for calc.'
     .  //' x0, a.u.. delta<0 => tetrahedron',' ',100,ifii,delta)
      endif
      if (igwin0 == 0 .or. have_master(29) == 0) then  ! deltaw
      call awrit1('deltaw   %g%16p! width in finite diff for sigma '
     .  //'energy derivative, a.u.',' ',100,ifii,deltaw)
      endif
      if (igwin0 == 0 .or. have_master(30) == 0) then  ! esmr
      call awrit1('esmr     %g%16p! Broadening in the poles of '
     .  //'G(LDA) (hsfp0)',' ',100,ifii,esmr)
      endif
      if (igwin0 /= 0 .and. have_master(32) == 0) then  ! Gausssmear
      call awrit0('GaussSmear on %16p! on  => broadening of poles in G(LDA) by Gaussian',
     .  ' ',100,ifii)
      endif
      if (igwin0 == 0) write(ifii,304)
  304 format(16x,'! Change esmr for metals: ',
     .  'see DOSACC* --- especially around Ef'/
     .  'GaussSmear on   ',
     .  '! on  => broadening of poles in G(LDA) by Gaussian'/16x,
     .  '! off => broadening of poles by a rectangle'/
     .  '!mixbeta  .25   ',
     .  '! mixing of input, output sigma for self-consistency')
      endif

C ... extra BSE related flags
C      if (igwin0 == 0 .and. have_master(33) == 0) then  ! n conduction states
C      call awrit1('!UseBSEW   %i%16p! include BSE (ladder diagram) contributions to W',
C     .  ' ',100,ifii,usebsew)
C      endif
      if (igwin0 == 0 .and. have_master(35) == 0) then  ! n conduction states
      call awrit0('NumCondStates 4 %16p! (BSE only) number of conduction states',' ',100,ifii)
      endif
      if (igwin0 == 0 .and. have_master(36) == 0) then  ! n valence states
      call awrit0('!NumValStates %16p! (BSE only) number of valence states',' ',100,ifii)
      endif
      if (igwin0 == 0 .and. have_master(37) == 0) then
      call awrit0('!MinOmega_BSE 0 %16p! (BSE eps only) compute eps(w) for MinOmega < w < MaxOmega (Ry)',
     .    ' ',100,ifii)
      endif
      if (igwin0 == 0 .and. have_master(38) == 0) then
      call awrit0('MaxOmega_BSE 1.0 %16p! (BSE eps only) compute eps(w) for MinOmega < w < MaxOmega (Ry)',
     .    ' ',100,ifii)
      endif
      if (igwin0 == 0 .and. have_master(39) == 0) then
      call awrit0('!numOmega_BSE 1001 %16p! (BSE eps only) number of mesh points to compute eps',
     .  ' ',100,ifii)
      endif
      if (igwin0 == 0 .and. have_master(39) == 0) then
      call awrit0('dOmega_BSE .001 %16p! (BSE eps only) (alternate to numOmega_BSE) mesh spacing',
     .  ' ',100,ifii)
      endif
      if (igwin0 == 0 .and. have_master(40) == 0) then
      call awrit0('Qvec_bse 0 0 1 %16p! (BSE eps only) direction in which to take the q->0 limit',
     .  ' ',100,ifii)
      endif
      if (igwin0 == 0 .and. have_master(41) == 0) then
      call awrit0('!ImagEner1 .02%16p! (BSE eps only, Ry, default=0.02) broadening at MinOmega_BSE',
     .  ' ',100,ifii)
      endif
      if (igwin0 == 0 .and. have_master(42) == 0) then
      call awrit0('!ImagEner2 .1%16p! (BSE eps only, Ry) broadening at MaxOmega_BSE',
     .  ' ',100,ifii)
      endif

C ... End of header section ... no further input from GWin0 unless new category
      if (igwin0 == 1) igwin0 = -1

C ... Create file QIBZ
      ifi = fopnx('QIBZ',2,2,-1)
      write(ifi,'(i4)') nqibz
      do  i = 1, nqibz
        write(ifi,"(3d24.16,3x,d24.16)") qibz(1:3,i), wbz(i)
      enddo
      call fclr(' ',ifi)
      deallocate(wbz)

C ... Write product basis block to GWinput
      if (.not. cmdopt('--no-GWinput',12,0,outs)) then
      write(ifii,305) 'PRODUCT_BASIS','! Product basis block'
  305 format(/'<',a,'>':,3x,a)
  306 format('</',a,'>')

C ... Possibly copy GWin0's product basis section
      if (igwin0 == 2) then
        igwin0 = -1  ! Default : not found
        if (rdstrn(ifi0,strn,len(strn),.false.)) then
          call word(strn,1,i1,i2)
          if (strn(i1:i2) == 'tolerance') then
            write(ifii,333) trim(strn)
            if (.not. rdstrn(ifi0,strn,len(strn),.false.))
     .        call rx('sugwin (abort) : missing line after tolerance')
            write(ifii,333) trim(strn)
            igwin0 = 2 ! Still alive
          endif
        endif
      endif
      if (igwin0 <= 0) then
        write(ifii,'(1x,a)')
     .  ' tolerance = minimum eigenvalue in PB overlap to reduce '//
     .  'linear dependency'
        call awrit2(' %n:1,1;3e',' ',80,ifii,ntolpb,tolpb)
      endif

      if (igwin0 == 2) then
        igwin0 = -1  ! Default : not found
        if (rdstrn(ifi0,strn,len(strn),.false.)) then
          call word(strn,1,i1,i2)
          if (strn(i1:i2) == 'lcutmx(atom)') then
            write(ifii,333) trim(strn)
            if (.not. rdstrn(ifi0,strn,len(strn),.false.))
     .        call rx('sugwin (abort) : missing line after lcutmx(atom)')
            write(ifii,333) trim(strn)
            igwin0 = 2 ! Still alive
          endif
        endif
      endif
      if (igwin0 <= 0) then
      write(ifii,*) ' lcutmx(atom) = l-cutoff for the product basis'
      iat = 0
      do  i = 1, nbas
        is = s_site(i)%spec
        lmaxa = s_spec(is)%lmxa
        z =     s_spec(is)%z
        if (lmaxa > -1) then
          iat = iat + 1
          lcutmx(iat) = lmaxa
          if (z == 0) lcutmx(iat) = min(lmaxa,3)
        endif
      enddo
      write(ifii,'(100i3)') lcutmx(1:nat)
      endif

      write(ifii,'(1x,a,a,a)')
     .  ' atom   l  nnvv  nnc ! nnvv: num. radial',
     .  ' functions (valence) for augmentation-waves.',
     .  ' nnc = num. for core.'
      nnvv = 2; iat = 0
      do  i = 1, nbas
        is = s_site(i)%spec
        pnu = s_site(i)%pnu
        pnz = s_site(i)%pz
        lmaxa = s_spec(is)%lmxa
        if (lmaxa > -1) then
          iat = iat + 1
          call atwf(0,xx,lmaxa,xx,nsp,pnu,pnz,xx,xx,xx,xx,xx,k,ncore,
     .      konfig,xx,xx,xx)
          do  l = 0, lmaxa
            if (pnz(l+1,1) /= 0) nnvv(l+1,iat) = 3
            konf = pnu(l+1,1)
            if (pnz(l+1,1) /= 0)
     .        konf = min(int(pnu(l+1,1)),int(mod(pnz(l+1,1),10d0)))
            nncx = konf - l - 1
            write(ifii,'(4i5)') iat,l,nnvv(l+1,iat),nncx
          enddo
          do  l = lmaxa+1, nl-1
            write(ifii,'(4i5)') iat,l,0,0
          enddo
        endif
      enddo

C     if (ii == 1) then
      call info(30,1,0,
     .  ' ... Creating in GWinput the following product basis:',0,0)
      call info(30,0,0,
     .  ' site%2fphi(o)%5fphi(u)%5fdot(o)%5fdot(u)%5floc(o)%5floc(u)',
     .  0,0)
C      endif

      write(ifii,*) ' atom   l    n  occ  unocc  :Valence(1=yes, 0=no)'
      iat = 0
      do  i = 1, nbas
        strn8 = '     *'
        pbi = '  ------'
        pbi = '        '
        is = s_site(i)%spec
        z =  s_spec(is)%z
        lfval = z >= 57 .and. z <= 72  .or. z >= 89 .and. z <= 104  ! f state in valence
        lmaxa = s_spec(is)%lmxa
        if (lmaxa < 0) cycle

        iat = iat+1
        pnu = s_spec(is)%p
        pnz = s_spec(is)%pz
        idxdn = s_spec(is)%idxdn
        pb1 = s_spec(is)%pb1
        pb2 = s_spec(is)%pb2

C        nr = s_spec(is)%nr
C        allocate(rofi(nr),rwgt(nr),rhoc(nr*nsp),gcore(nr,2,50))
C        call radmsh(s_spec(is)%rmt,s_spec(is)%a,nr,rofi)
C        call radwgt(10*nglob('lrquad'),s_spec(is)%rmt,s_spec(is)%a,nr,rwgt)
C        call gtpcor(s_spec,is,kcor,lcor,qcor)
C        call getcor(1,z,s_spec(is)%a,pnu,pnz,nr,lmaxa,rofi,s_site(i)%v0,0,0,qcor,
C     .    sumec,sumtc,rhoc,ncore,ecore,gcore)

        do  l = 0, lmaxa
        npqn = 2
        if (pnz(l+1,1) /= 0) npqn = 3
        do  k = 1, npqn

C         Read PB1 or set default values for those not specified
          if (pb1(l+1:l+1) /= ' ') then
            read(pb1(l+1:l+1),'(I1)') nocc
          else
C           default occ PB 0 for f orbitals or higher
            if (l > 2 .and. .not. lfval .or. l > 3) then
              nocc = 0
            else
              nocc = 1
            endif
            if (l > 1 .and. z == 0) nocc = 0

C           default occ PB 0 for dot function, no local orbital
            if (npqn == 2) then
              if (k >= 2) nocc = 0
C           default occ PB 0 for dot function w/ local orbital
            else
C             High local orbital
              if (mod(pnz(l+1,1),10d0) > pnu(l+1,1)) then
                if (k == 3) nocc = 0
C             Low local orbital
              else
                if (k == 3) nunocc = 0
              endif
            endif
          endif

C         Read PB2 or set default values for those not specified
          if (pb2(l+1:l+1) /= ' ') then
            read(pb2(l+1:l+1),'(I1)') nunocc
          else
C           Default unocc PB 0 for g orbitals or higher
            if (l > 3 .and. .not. lfval .or. l > 4) then
              nunocc = 0
            else
              nunocc = 1
            endif
            if (l > 2 .and. z == 0) nunocc = 0
C           default unocc PB 0 for dot- functions
            if (npqn == 2) then
              if (k >= 2) nocc = 0
C           default unocc PB 0 for dot function w/ local orbital
            else
C             Low local orbital
              if (mod(pnz(l+1,1),10d0) < pnu(l+1,1)) then
                if (k == 3) nunocc = 0
              endif
            endif
          endif

C         Universal default for dot function: no local orbital
          if (k == 2) nocc = 0
          if (k == 2) nunocc = 0

C         Write pb1..3 as guide to GWinput
          j = l+1
          write(pbi(1,k)(j:j),'(I1)') nocc
          write(pbi(2,k)(j:j),'(I1)') nunocc
          if (l <= lmaxa .and. k == 1) then
            write(pbi(1,3)(j:j),'(''-'')')
            write(pbi(2,3)(j:j),'(''-'')')
          endif

C         Create string for comment appended to PB line
          konf = pnu(l+1,1)
          if (k == 3) konf = mod(pnz(l+1,1),10d0)
          strn8(1:4) = dig(konf)//lsym(l)//'_'//lorb(k)
          if (idxdn(l+1,1) == 1 .or. idxdn(l+1,2) == 1)
     .      call chcase(0,1,strn8(2:2))

          write(ifii,'(5i5,3x,''! '',a)') iat,l,k,nocc,nunocc,trim(strn8)
          strn8 = '     '
        enddo
        enddo
        if (ipr >= 30) then
          write(stdo,'(i4,20(3x,a))') iat,(pbi(1,k),pbi(2,k),k=1,3)
        endif
C        deallocate(rofi,rwgt,rhoc,gcore)
      enddo

      write(ifii,*) ' atom   l    n  occ unocc   ',
     .  'ForX0 ForSxc :CoreState(1=yes, 0=no)'
      iat = 0
      do  i = 1, nbas
        is = s_site(i)%spec
        pnu = s_site(i)%pnu
        pnz = s_site(i)%pz
        lmaxa = s_spec(is)%lmxa
        if (lmaxa < 0) cycle
        iat = iat+1

        call atwf(0,xx,lmaxa,xx,nsp,pnu,pnz,xx,xx,xx,xx,xx,k,ncore,
     .    konfig,xx,xx,xx)

        nr = s_spec(is)%nr
        z  = s_spec(is)%z
        allocate(rofi(nr),rwgt(nr),rhoc(nr*nsp),gcore(nr,2,50))
        call radmsh(s_spec(is)%rmt,s_spec(is)%a,nr,rofi)
        call radwgt(10*nglob('lrquad'),s_spec(is)%rmt,s_spec(is)%a,nr,rwgt)
        call gtpcor(s_spec,is,kcor,lcor,qcor)
        call getcor(1,z,s_spec(is)%a,pnu,pnz,nr,lmaxa,rofi,s_site(i)%v0,0,0,qcor,
     .    sumec,sumtc,rhoc,ncore,ecore,gcore)

        strn8 = '   *'
        ncore = 0
        do  l = 0, lmaxa
          do  konf = l+1, mod(konfig(l),10)-1
            ncore = ncore+1
            nocc = 0
            nunocc = 0
            ncinc = 0
            ncinc2 = 0
            strn8(1:2) = dig(konf)//lsym(l)
            call chcase(0,1,strn8(2:2))

            if (s_gw%ecutpb < ecore(ncore)) then
              call info5(10,0,0,' Add to core product basis: site %i species '//trim(s_spec(is)%name)//
     .          ' state %i'//lsym(l)//' ecore=%d',i,konf,ecore(ncore),0,0)
              nocc = 1
            endif

            write(ifii,'(5i5,2x,2i5,''    ! '',a)')
     .        iat,l,konf-l,nocc,nunocc,ncinc,ncinc2, trim(strn8)
            strn8 = ' '
          enddo
        enddo

        deallocate(rofi,rwgt,rhoc,gcore)

      enddo
      write(ifii,306) 'PRODUCT_BASIS'

C ... QPNT category
      do while (igwin0 > 0 .and. igwin0 /= 3)
        if (.not. rdstrn(ifi0,strn,len(strn),.false.)) then  ! end-of-file
          igwin0 = -1; exit
        endif
C       Exit if start-of-category
        if (strn(1:1) == '<') then
          call word(strn,1,i1,i2)
          call tokmat(strn(i1:i2),cat_tags,size(cat_tags),len(cat_tags(1)),' ',j1,j2,.false.)
          if (j1 >= 0) igwin0 = j1+2  ! Marks which category is next
        endif
      enddo

      write(ifii,305) 'QPNT','! Specify particular k-points and bands (one-shot mode)'
      if (cmdopt('--sigw',6,0,outs)) then
        write(ifii,'(a/a/17x,a/17x,a)')
     .    '***** ---Specify data for Sigma(omega) ---',
     .    '   0.01 2   (Ry) ! spacing ommax(optional)',
     .    ': range is -ommax < omega < ommax',
     .    ': If ommax is too large or not exist, use the range set by hx0fp0'
      else
        write(ifii,'(a)') ' --- Specify qp and band indices'//
     .    ' at which to evaluate Sigma'
        write(ifii,*)
      endif

      do while (igwin0 == 3)  ! Look in GWin0 for *** Sigma at all q
        if (.not. rdstrn(ifi0,strn,len(strn),.false.)) then  ! end-of-file
          igwin0 = -1; exit
        endif
        if (strn(1:9) == '*** Sigma') then
          write(ifii,333) trim(strn)
          if (.not. rdstrn(ifi0,strn,len(strn),.false.)) call rx('failed to read GWin0 file')
          write(ifii,333) trim(strn)
          exit
        endif
      enddo
      if (igwin0 /= 3) then
        write(ifii,'(a)')
     .  '*** Sigma at all q -->1; to specify q -->0.'//
     .  '  Second arg : up only -->1, otherwise 0'
        iqall = 0
        if (cmdopt('--sigw',6,0,outs)) iqall = 1
        iaf = 0
        write(ifii,'(2i3)') iqall, iaf
      endif

      do while (igwin0 == 3)  ! Look in GWin0 for '*** no. states'
        if (.not. rdstrn(ifi0,strn,len(strn),.false.)) then  ! end-of-file
          igwin0 = -1; exit
        endif
        if (strn(1:7) == '*** no.') then
          write(ifii,333) trim(strn)
          if (.not. rdstrn(ifi0,strn,len(strn),.false.)) call rx('failed to read GWin0 file')
          write(ifii,333) trim(strn)
          if (.not. rdstrn(ifi0,strn,len(strn),.false.)) call rx('failed to read GWin0 file')
          write(ifii,333) trim(strn)
          exit
        endif
      enddo
      if (igwin0 /= 3) then
        write(ifii,'(a)')
     .    '*** no. states and list of band indices to make Sigma '//
     .    'and QP energies'
        nblst = nint(qval/2+4)
        if (cmdopt('--ib=',5,0,outs)) then
          call word(outs,1,j1,j2); if (j1+5 > j2) call rx('sugwin: bad list, ib=..')
          call mkils0(outs(j1+5:j2),nblst,j)
          if (nblst < 1) call rx('sugwin: bad list, ib=..')
          allocate(iblst(nblst))
          call mkilst(outs(j1+5:j2),nblst,iblst)
          call imxmn(nblst,iblst,1,i,j)
          if (i < 1 .or. j > min(ldim,nband)) then
            call rx('sugwin: list outside range, ib=..')
          endif
        else
          allocate(iblst(nblst))
          forall (i = 1:nblst) iblst(i) = i
        endif
        write(ifii,'(i3)')  nblst
        call awrit2(' %n:1i',' ',1024,ifii,nblst,iblst)
C       write(ifii,'(99i3)') (iblst(i),i=1,nblst)
        deallocate(iblst)
      endif

      do while (igwin0 == 3)  ! Look in GWin0 for '*** q-points'
        if (.not. rdstrn(ifi0,strn,len(strn),.false.)) then  ! end-of-file
          igwin0 = -1; exit
        endif
        if (strn(1:12) == '*** q-points') then
   30     continue
          write(ifii,333) trim(strn)
          ltmp = rdstrn(ifi0,strn,len(strn),.false.)
          if (.not. ltmp) call rx('sugwin : GWin0 missing </QPNT>')
          if (strn(1:7) == '</QPNT>') exit
          goto 30
        endif
      enddo
      if (igwin0 /= 3) then
        write(ifii,'(a)') '*** q-points'//
     .    ' (must belong to mesh of points in BZ).'
        write(ifii,'(i5)') min(nqibz,3)
        write(ifii,'(i5,3f23.16)') (i,qibz(1:3,i),i=1,nqibz)
      endif
      write(ifii,306) 'QPNT'

C ... Write EPScond to GWinput
      write(ifii,307)
  307   format(/
     .  'QforEPSIBZ off'/
     .  '<QforEPS>'/
     .  '0d0 0d0 0.015d0'/
     .  '</QforEPS>'/
     .  'EPSrange  1    !(Ry) [0,EPSrange] for dielectric function'/
     .  'EPSdw     0.05 !(Ry) energy mesh  for dielectric function')
      endif

C --- Special gamma-points ---
      if (cmdopt('--make-Q0P',10,0,outs)) then
      call info(20,1,0, ' ... Creating files Q0P, QGpsi, QGcou',0,0)
      nx0 = 1
      xn  = 3d0
      allocate(q0x(3,6*nx0), wt0(6*nx0), wt(6*nx0), q0i(3,6*nx0))
      call suq0x(alat,plat,alp,qbz,nkp,nx0,xn,q0x,wt0)
C     No support for point groups yet ... use space group
      nsgrp = s_lat%nsgrp
      call q0irre(q0x,wt0,nx0*6,s_lat%symgr,nsgrp,q0i,nq0i,wt)
C     Open the file with no case change or extension added
      ifi = fopnx('Q0P',2,2,-1)
C      if (.not. cmdopt('--lmv6',6,0,outs)) then
CC       call prmx('q0i before shortening',q0i,3,3,nq0i)
C        call shorps(nq0i,qlat,(/72,2,2/),q0i,q0i)
CC       call prmx('q0i after shortening',q0i,3,3,nq0i)
C      endif
      write(ifi,'(i5)') nq0i
      write(ifi,'(e24.16,3x,3e24.16)') (wt(i),q0i(1:3,i),i=1,nq0i)
      call fclr('Q0P',ifi)

C ... PW cutoffs for each qp in BZ for each of nq0i shifted meshes
      allocate(ngpn(nkp,nq0i+1), ngcn(nkp,nq0i+1))
      if (ipr >= 100) write(stdo,369)
  369 format(/' G cutoffs for each q0i and qp in BZ'/18x,'qp',20x,
     .  ' ngp  ngc')
      imx = 0    ! Max multiples of G in any of the 3 directions
                 ! for compatibility with Kotani
      do  iq0i  = 1, 1 + nq0i
        if (ipr >= 100) then
          if (iq0i == 1) write(stdo,*) '   no offset'
          if (iq0i > 1) write(stdo,'(/''   offset q0i='',3f12.6)')
     .      q0i(1:3,iq0i-1)
        endif
        do  iq  = 1, nkp
          call dcopy(3,qbz(1,iq),1,q,1)
          if (iq0i > 1) call daxpy(3,1d0,q0i(1,iq0i-1),1,q,1)
C          if (.not. cmdopt('--lmv6',6,0,outs)) then
C            call shorps(1,qlat,(/72,2,2/),q,q)
C          endif
          call pshpr(1)
          if (gcutb > 0) then
C            call iinit(iwk,3)
C            call gvlst2(alat,plat,q,iwk(1),iwk(2),iwk(3),0d0,gcutb,0,
C     .        100,1,ngpn(iq,iq0i),xx,xx,xx,xx)
C            l = ngpn(iq,iq0i)
            call iinit(iwk,3)
            call sugvec(s_lat,100000+128+16+0,q,0d0,gcutb,iwk,0,
     .        ngpn(iq,iq0i))
            imx = max(imx,iwk(1),iwk(2),iwk(3))
C           if (l /= ngpn(iq,iq0i)) stop 'oops'
          else
            ngpn(iq,iq0i) = 0
          endif
          if (gcutx > 0) then
C            call iinit(iwk,3)
C            call gvlst2(alat,plat,q,iwk(1),iwk(2),iwk(3),0d0,gcutx,0,
C     .        100,1,ngcn(iq,iq0i),xx,xx,xx,xx)
C            l = ngcn(iq,iq0i)
            call iinit(iwk,3)
            call sugvec(s_lat,100000+64+16+0,q,0d0,gcutx,iwk,0,
     .        ngcn(iq,iq0i))
C           if (l /= ngcn(iq,iq0i)) stop 'oops'
          else
            ngcn(iq,iq0i) = 0
          endif
          call poppr
          if (ipr >= 100)
     .    write(stdo,'(3f12.6,3x,2i5)') q,ngpn(iq,iq0i),ngcn(iq,iq0i)
        enddo
      enddo
      ngpmx = maxval(ngpn)
      ngcmx = maxval(ngcn)
C      call info2(20,1,0,' Maximum number of PW = %i for '//
C     .  'basis,  %i for coulomb',ngpmx,ngcmx)
      if (ipr >= 20) call awrit2('%N Maximum number of PW = %i for '
     .  //'basis,  %i for coulomb',' ',80,stdo,ngpmx,ngcmx)

      nqnum = nkp * (1+nq0i)
      allocate(qnum(3,nqnum+1))
      qnum(1:3,1:nkp) = qbz(1:3,1:nkp)
      ii = nkp
      do  i = 1, nq0i
        do  iq = 1, nkp
          ii = ii+1
          qnum(1:3,ii) = qbz(1:3,iq) +  q0i(1:3,i)
        enddo
      enddo
C     qnum(1:3,nqnum+1) = 0  ! Add gamma point (not used now)

      allocate(wtnum(nqnum),qirr(3,nqnum),wtirr(nqnum),irr(nqnum))
      wtnum = 1
      call q0irri(qibz,0,qnum,wtnum,nqnum,s_lat%symgr,nsgrp,
     .  qirr,nqirr,wtirr,plat,irr)

      call info2(20,0,1, ' Extended mesh has %i irreducible'//
     .  ' qp out of %i',nqirr,nqnum)

      ifi = fopnx('QGpsi',2,4,-1)
      rewind ifi
      write(ifi) nqnum,ngpmx,gcutb,nkp,nqirr,imx,nqibz !Consistent w/ Kotani's Sep2012
      ifi = fopnx('QGcou',2,6,-1)
      rewind ifi
      write(ifi) nqnum,ngcmx,gcutx

      igvsav => s_lat%igv2; kvsav => s_lat%kv2

      iqnum = 0
      do  iq0i  = 1, 1+nq0i
      do  iq = 1, nkp
        iqnum = iqnum+1

C       True q, as distinct from -q in LMTO.ver.4 used by Ferdi's hx0kw
        call dcopy(3,qbz(1,iq),1,q,1)
        if (iq0i > 1) call daxpy(3,1d0,q0i(1,iq0i-1),1,q,1)
        call shorbz(q,qp,qlat,plat)


C        if (cmdopt('--lmv6',6,0,outs)) then
C          call shorbz(q,qp,qlat,plat)
C          qx = q
C        else
C          call shorps(1,qlat,(/72,2,2/),q,qp)
C          qx = qp
C        endif

        ngp = ngpn(iq,iq0i)
        ngc = ngcn(iq,iq0i)
        allocate( ngvecp(3,max(ngp,1)),ngvecc(3,max(ngc,1)) )
        call pshpr(1)
        allocate(kv(3*max(ngp,ngc)))
        if (gcutb > 0) then
C          call iinit(iwk,3)
C          call gvlst2(alat,plat,q,iwk(1),iwk(2),iwk(3),0d0,gcutb,0,102,
C     .      1,ngpn(iq,iq0i),kv,xx,xx,ngvecp)
          call iinit(iwk,3)
          call sugvec(s_lat,100000+64+16+2,q,0d0,gcutb,iwk,0,ngp)
          if (ngp /= ngpn(iq,iq0i)) call rx('bug in sugwin ngp')
C         print *, ngvecp - s_lat%igv2
          call icopy(ngp*3,s_lat%igv2,1,ngvecp,1)
          deallocate(s_lat%kv2,s_lat%igv2)
        else
          ngvecp = 0
        endif
        if (gcutx > 0) then
C          call iinit(iwk,3)
C          call gvlst2(alat,plat,q,iwk(1),iwk(2),iwk(3),0d0,gcutx,0,102,
C     .      1,ngcn(iq,iq0i),kv,xx,xx,ngvecc)

          call iinit(iwk,3)
          call sugvec(s_lat,100000+64+16+2,q,0d0,gcutx,iwk,0,ngc)
          if (ngc /= ngcn(iq,iq0i)) call rx('bug in sugwin ngc')
C         print *, ngvecc - s_lat%igv2
          call icopy(ngc*3,s_lat%igv2,1,ngvecc,1)
          deallocate(s_lat%kv2,s_lat%igv2)
        else
          ngvecc = 0
        endif
        deallocate(kv)
        call poppr
        if (ngp /= ngpn(iq,iq0i) .or. ngc /= ngcn(iq,iq0i))
     .    call rx('bug in sugwin')

        ifi = fopnx('QGpsi',2,4,-1)
        write (ifi) q, ngp, irr(iqnum)
        write (ifi) ngvecp

        ifi = fopnx('QGcou',2,4,-1)
        write (ifi) q, ngc
        write (ifi) ngvecc

        deallocate(ngvecp,ngvecc)

      enddo ! Loop over qp
      enddo ! Loop over nq0i

      s_lat%igv2 => igvsav; s_lat%kv2 => kvsav

      ifi = fopnx('QGpsi',2,4,-1)
      call fclr(' ',ifi)
      ifi = fopnx('QGcou',2,4,-1)
      call fclr(' ',ifi)
      endif
      return

      end
