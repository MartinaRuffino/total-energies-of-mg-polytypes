      subroutine sugw(s_ctrl,s_site,s_spec,s_lat,s_ham,s_pot,s_bz,s_gw,sblockh,nbas,ppn,jobgw)
C- Driver to set up GW
C ----------------------------------------------------------------------
Cio Structures
Cio  s_ctrl :struct for program flow parameters; see structures.h
Ci     Elts read:  lfp lwsig
Co     Stored:     lfp
Co     Allocated:  *
Cio    Elts passed:lcd
Cio    Passed to:  *
Cio  s_site :struct for site-specific data; see structures.h
Ci     Elts read:  spec pos pnu pz class clabel sighh sighk sigkk pihh
Ci                 pihk pikk sighhx sighkx sigkkx pihhx pihkx pikkx
Ci                 sohh sohk sokk
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:v0 pihhx tauhh pikkx taukk pihkx tauhk
Cio    Passed to:  chkgwin sugwin wlattc mk_hamindex hambl augmbl
Cio                bstrux smhsbl hsibq hsubblock hsibq2 hsibq4 hambls
Cio                makusq pusq1 gwcphi pwmat pwmat2
Cio  s_spec :struct for species-specific data; see structures.h
Ci     Elts read:  lmxa pz p idxdn a nr z rmt name pb1 pb2 lmxb orbp
Ci                 kmxt rsma ngcut lmxl
Co     Stored:     orbp
Co     Allocated:  *
Cio    Elts passed:name
Cio    Passed to:  chkgwin sugwin wlattc mk_hamindex uspecb hambl
Cio                augmbl bstrux smhsbl hsibq tbhsi hsubblock hsibq2
Cio                hsibq4 hambls makusq pusq1 gwcphi pwmat pwmat2
Cio  s_lat  :struct containing lattice information; see structures.h
Ci     Elts read:  alat plat qlat nabc gmax npgrp nsgrp vol igv2 kv2 kv
Ci                 igv awald tol nkd nkq ng napw
Co     Stored:     napw igv2 kv2 igv
Co     Allocated:  gv kv igv kv2 igv2
Cio    Elts passed: s_sym symgr nsgrp igv2 vol kv2 qlat igv gv ag pos
Cio                plat cg indxcg jcg cy qlv dlv kv
Cio    Passed to:  chkgwin sugwin sugvec mk_hamindex hambl augmbl
Cio                bstrux hxpbl ghibl hklbl gklbl hxpgbl ghigbl hklgbl
Cio                smhsbl hhibl phhibl hsmbl hsibq hambls makusq pusq1
Cio                pwmat pwmat2
Cio  s_ham  :struct for parameters defining hamiltonian; see structures.h
Ci     Elts read:  lsig nqsig oveps ovncut nlmto ldham pwmode pwemin
Ci                 pwemax ndham ndhrs nprs sigp eseavr
Co     Stored:     *
Co     Allocated:  qsig
Cio    Elts passed:qsig lncol iprmb eseavr lrsa iaxs hrs
Cio    Passed to:  sugwin mk_hamindex hambl augmbl hambls sopert3 makusq
Cio  s_pot  :struct for information about the potential; see structures.h
Ci     Elts read:  vesrmt
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:qval smpoth smvcnst lcplxp smpot
Cio    Passed to:  *
Cio  s_bz   :struct for the Brillouin Zone; see structures.h
Ci     Elts read:  nkabc lshft
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:*
Cio    Passed to:  chkgwin sugwin
Cio  s_gw  :struct for gw-related parameters
Ci     Elts read:  gcutb code nkabc mksig lgw nband qoffp gcutx ecuts
Ci                 nime delre deltax deltaw pbtol gsmear
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:nkabc lshft
Cio    Passed to:  chkgwin sugwin
Ci Inputs
Ci   sblockh: used to zero out M.E. of orbital subblock with neighbors
Ci   nbas  :size of basis
Ci   smpot :smooth potential on uniform mesh (mkpot.f)
Ci   ppn   :NMTO pot pars; see potpus.f
Ci   gwcode:0 setup for fpgw v033a6
Ci         :2 setup for fpgw, Sep 2012
Ci         :1 setup for spex v02.04
Ci   jobgw :-999 prompt for and read jobgw from stdin
Ci         :-1 creates files GWinput, QPNT, QIBZ, Q0P, QGpsi, QGcou, KPTin1BZ
Ci         :-2 Performs some sanity checks on GWinput
Ci         : 0 init mode.
Ci         :   If gwcode is 0:
Ci         :   create files SYMOPS,LATTC,CLASS,NLAindx,ldima
Ci         :   if gwcode is 2:
Ci         :   same as gwcode=0, but no SYMOPS generated
Ci         :   if gwcode is 1:
Ci         :   create files lattice,lmto,sym.out
Ci         : 1 GW driver mode: create files gwb,gw1,gw2,gwa,vxc,evec,rhoMT.*,normchk
Ci         :   if gwcode is 0 or 2
Ci         :   In the MPIK case,
Ci         :   gwb,gw1,gw2,vxc,evec,normchk are split into separate files
Ci         :   lmf2gw, hsfp0, hqpe updated to parse data split into files
Ci         :   How files are split is communicated through file mpiqlst.
Ci         :   If gwcode is 1:
Ci             create files atval,atcore,vxc,evec.ext,evcof,evals
Ci         :   not ready
Ci         : 2 Calculate LDA vxc and write to disk in sigm format.
Ci         :   if gwcode is 0 or 2:
Ci         :   If s_ctrl%lwsig=LW9 or s_ctrl%lwsig=LW19, sugw acts as though jobgw=2
Ci         :   If after these initializations, then:
Ci         :      s_ctrl%lwsig=LW9 => vxc is generated by sugw and written to 'vxcsig' file
Ci         :      s_ctrl%lwsig=LW19 => vxc is read from existing 'vxc' file(s) and dumped into 'vxcsig' file
Ci         :      s_ctrl%lwsig=anything else => error
Ci         :  6 Synchronize q list with lmf:
Ci         :    Read k-points and write irreducible qp to file qpts (requires file QIBZ)'
Co Outputs
Co   Files written according to jobgw
Co   The following shows what files are written for jobgw=1
Co   and the records stored in each file.
Co .. gwcode=0,2:
Co   gw1:  evals of Hlda+sigma-vxc
Co        *for each q-point and spin:
Co         q, evl(i:ndimh)
Co   gw2:  evals of Hlda+sigma-vxc-vxc
Co        *for each q-point and spin
Co         q, evl(i:ndimh)
Co   gwb:  Information about eigenfunctions, matrix elements
Co         nat,nsp,ndima,ndham,alat,qlat,ef0,nqbz,plat,nqnum,nqi
Co         lmxa(1:nat), bas(1:3,1:nat)
Co         ngpmx,npmbx  -- largest number of G vectors for psi, vcoul
Co        *for each q-point and spin:
Co           q, ndimh
Co           evl, cphi
Co           ngp, ngc
Co           ngvecp, ngvecc, pwz  (G vectors for psi,vcou; PW expansion of z)
Co   gwa:  site data.
Co        *for each site:
Co           z, nr, a, b, rmt, lmaxa, nsp, ncore
Co           konfig(0:lmaxa) : note
Co           rofi
Co          *for each l, spin isp
Co             l, isp
Co             radial w.f. gval: phi
Co             radial w.f. gval: phidot
Co             radial w.f. gval: phiz    written if konfig(l)>10
Co             *for each l, spin, konf
Co                icore, l, isp, konf, ecore(icore)+vshft
Co                gcore(1:nr,1,icore)
Co   evec: eigenvectors.
Co         ndham, nsp, nnn, nqnum
Co        *for each q-point and spin:
Co           q, evec(1:ndimh,1:ndimh)
Co   vxc:  matrix elements of XC potential
Co         ndham, nsp, nnn
Co        *for each q-point and spin:
Co           q, vxc
Co .. gwcode=1:
Co
Cs Command-line switches
Cs   --evecl  : Write file evecl: evecs of the LDA excluding the PAW part of the basis
Cs   --mlog   : (MPI) write MPI commands to log file
Cs   --novxc  : Suppress writing matrix elments of vxc to disk
Cs   --shorbz=no: Suppress shortening of q
Cs   --pwmat2 : Old convention for pwmat; See "Overlap of IPWs" below
Cs   --vxcsig : Write qsgw sigma in place of LDA vxc into 'vxc' file.
Cs              This is needed for one-shot calculations based on a QSGW hamiltonian.
Cs   --novxc  : Suppress writing 'vxc' file
Cs   --sigw   : (jobgw=-1 only) modify GWinput to include lines for calculating sigma(omega)
Cs   --wrange : write min,max eval to file
Cl Local variables
Cl   lpdiag:0 use standard diagonalization (zhev)
Cl         :1 use parallel diagonalization (pzhev)
Cl         :2 diagonalization done internally (hambls)
Cl   lsig  :switch to create files vxc and evec for making sigma
Cl   lwvxc :1 or 2, write to evec and vxc files for irreducible qp on regular mesh
Cl         :2 write evec file for all irreducible qp
Cl   lsapw :T, APW's indices must be modified because q vector
Cl             has been shortened (see comments before call to pwmat)
Cl   nnn   :number of qp in irr BZ (code 2); in full BZ (code 0)
Cl   nqnum :number of qp in full BZ * number of 'special gamma points'
Cl         :or generally the number of qp at which eigenfunctions calc.
Cl   nqibz :number of qp in irreducible BZ on regular mesh
Cl   nqi   :total number of qp in irreducible BZ, including offset gamma mesh
Cl   ngp   :no. G vectors for eigenfunction expansion (depends on q-pt)
Cl   ngc   :no. G vectors for coulomb interaction (depends on q-pt)
Cl   ispc  :2 when working on (2,2) block of noncollinear hamiltonian;
Cl         :otherwise 1
Cl   ipb   :index to true basis (excluding floating orbitals)
Cl         :given site index including those orbitals
Cl   ndima :number of augmentation channels
Cl   lnwpwm:0 calling pwmat (standard convention)
Cl         :1 call pwmat2 instead of pwmat; see Remarks
Ci   ndham :dimensioning parameter, at least as large as largest
Ci         :hamiltonian dimension
Ci   iprocq:procid for q where file data is generated
Ci         :In the MPIK case each processor writes a portion of evec and vxc
Ci         :to a procid-specific file (name has _procid appended)
Ci tprodbas:Switch to generate product basis
Ci         :1s digit radial product basis
Ci         :1  use valence partial waves only
Ci         :>1 Product basis for merged valence and core partial waves
Ci         :2  Modify noccc, noccv according to Kotani's prescription.  Rethink for future
Ci         :4  noccc, noccv taken from GWinput
Ci         :10s digit Matrix elements of partial waves and radial product basis
Ci         :1  make orthonormalized product basis and matrix elements with B
Ci         :2  ditto, orthonormalized product basis compatible with old GW code
Ci         :3  Same as 2, but also write PPBRD_V2_* files to disk
Ci         :100s digit Full product basis; check completeness
Ci         :1  make full product basis
Ci         :2  check completeness
Cb Bugs
Cb   code writes extra file evec whose data should be
Cb   extracted from gwb.
Cr Remarks
Cr   By default sugw calls pwmat for IPW matrix elements.
Cr   The call to pwmat can optionally be replaced by a call to
Cr   pwmat2 (see comments preceding the call to pwmat or pwmat2).
Cr   However, the results are not identical.
Cr   The pwmat construction depends on both the LMTO cutoff gmax
Cr   and the GW cutoff QpGcut_psi, even though these nominally serve
Cr   the same purpose.
Cr   The pwmat2 construction depends only on the GW cutoff QpGcut_psi.
Cr   The pwmat construction is usually more accurate (i.e. the norm of
Cr   the overlap matrix is closer to 1; see output in file normchk),
Cr   because gmax is typically larger than QpGcut_psi.
Cu Updates
Cu   30 Mar 19 Remove --wevec option (not needed)
Cu   07 Mar 18 Can write file rhoc
Cu   25 Mar 17 New jobs 6,7 (write qpts to qpts.ext)
Cu   09 Dec 15 Bug fixes when writing vxcsig (job=2)
Cu   30 Apr 15 New mode to write vxsig file
Cu             (job=2, or job=2 in conjunction with s_ctrl%lwsig == LW19)
Cu   11 Aug 14 Adapted to work with PMT basis
Cu   30 Jun 14 MPIK version
Cu   27 Dec 13 (1-shot) Make --vxcsig work in conjunction with lso=3
Cu   08 Jul 13 Replace f77 pointers with f90 ones
Cu   24 Feb 13 First cut at modifications for Takao's Sep 2012 code
Cu             (gwcode=2)
Cu   10 Feb 13 New ability to shorten qp in local routines
Cu             to avoid global shortening.  For compatibility with new GW.
Cu             To test, set default for OPTIONS_SHORBZ to F.
Cu             All tests should be unaffected.
Cu             Problem: GaAs test fails ...
Cu   09 Aug 12 New SO=3 option
Cu   04 Aug 12 Optionally writes file erange with min,max evals
Cu   19 Apr 12 First cut at interface to spex code
Cu   10 Nov 11 Begin migration to f90 structures
Cu   01 Jun 10 Option to render blocks of hamiltonian diagonal
Cu   31 May 10 New --vxcsig switch (Use sigm-vxc+vxc for vxc)
Ci   22 Aug 09 Start on interface for spex code
Ci   22 Jun 09 (T. Kotani) modify for q-dependent orbital dimension
Ci             Use this version must be used with fpgw033a5 or later
Ci   27 Apr 09 (T. Kotani) new argument inn for APW basis
Cu   29 Jan 09 Incorporate APW basis
Cu   27 Mar 07 bug fix: expunging floating orbitals from class list, file CLASS
Cu   30 Aug 05 sugw handles ngp=0 and/or ngc=0
Cu    5 Jul 05 handle sites with lmxa=-1 -> no augmentation
Cu             Bug fix, job 5 case
Cu    4 Sep 04 Adapted to extended local orbitals
Cu    1 Sep 04 Adapted to handle complex ppi; S.O. put into ppi
Cu      Mar 04 (mark) small changes for bandmode
Cu      Sep 03 (takao)
Cu             Implemented job 5
Cu             read nqbz from QGpsi.  GWIN0 no longer used.
Cu   14 Sep 03 dimensioning bug fix when inequivalent lmxa
Cu   07 Jun 03 sugw redesigned for new interpolation mode for sigma
Cu             jobs 1 and 2 have been combined.
Cu             Altered argument list.
Cu   20 Jun 02 (S. Faleev) write vxc to disk
Cu   18 Jun 02 Added debugging code to check call to roth
Cu   25 Apr 02 Added local orbitals
Cu   25 Oct 01 (T. Kotani) split functions into parts, with job
Cu             Binary files imcompatible with prior versions.
Cu   23 Apr 01 First created
C ----------------------------------------------------------------------
      use structures
!     use bzdata
      implicit none
C ... Passed parameters
      integer nbas,n0,nkap0,nppn
      parameter (n0=10, nppn=12, nkap0=4)
      integer jobgw,lh(n0)
C     real(8) sab(nab,n0,*)
      real(8) rsml(n0),ehl(n0),ppn(nppn,n0,nbas)
      character sblockh*(*)
C ... For structures
!      include 'structures.h'
      type(str_ctrl)::  s_ctrl
      type(str_site)::  s_site(*)
      type(str_spec)::  s_spec(*)
      type(str_lat)::   s_lat
      type(str_ham)::   s_ham
      type(str_pot)::   s_pot
      type(str_bz)::    s_bz
      type(str_gw)::    s_gw
C     type(str_symops),allocatable::  s_sym(:)
C ... Dynamically allocated local arrays
      integer, allocatable :: kpproc(:) ! q loop blocking indices for multithreaded case
      integer, allocatable :: iprocq(:) ! Written to file mpiqlst
      integer, allocatable :: kv(:)
      integer,allocatable :: ips(:),ipc(:),ipcx(:),ibidx(:,:),nqq(:),lmxa(:),nlindx(:,:,:),
     .  ngvecp(:,:),ngvecp_p(:,:),konfa(:,:),lcuta(:),iiyf(:)
      real(8),allocatable:: ww(:),wk(:,:),bas(:,:),rofi(:),rwgt(:),gcore(:,:,:),gval(:,:,:,:,:)
      real(8),pointer:: gvala(:,:,:,:,:),gtota(:,:,:,:,:),gtoto(:,:,:,:,:),gvalo(:,:,:,:,:)
      real(8),pointer:: gcora(:,:,:,:,:)
      real(8),allocatable:: evl(:,:),ovv(:,:),evl_p(:,:),qq1(:,:),qq2(:,:),cphin(:,:,:),qpgw(:,:)
      complex(8),allocatable:: ham(:,:,:),ovl(:,:,:),evec(:,:),vxc(:,:,:),vxcsig(:,:,:,:),
     .  ppovl(:,:),phovl(:,:),pwh(:,:),pwz(:,:),pzovl(:,:),ppovld(:),testc(:,:),
     .  testcd(:),cphi(:,:,:),cphi_p(:,:,:),geig(:,:,:),geig_p(:,:,:)
      complex(8), allocatable :: aus(:,:,:,:,:)  ! val,slo of w.f. at MT sphere surface for Cphi
      integer,allocatable, target :: ngvecc(:,:,:)

C ... Local parameters
      logical :: bandmode=.false.,endofline=.false.
      integer :: tprodbas=0, lgrad=0,lwvxc=0
      logical rank0  ! Equal to  procid == master
      logical lsapw,passl
      logical keephi ! If T, stores partial waves into large array with all sites
      integer ierr,im2,konf,mnevl,nline,nqibz,gwcode,i,i1,i2,iat,ib,ibr,ic,icore,
     .  ifeigen,ifi,ifiqg,ifiqgc,ifqeigen,ifsyml,iix,iline,im1,imx,ipqn,ipr,iq,
     .  iqibz,irr,is,isp,ispc,j,jb,jfi,job,jobb,jsp,k,k1,k2,k3,l,lchk,ldim,lmaxa,
     .  lmxax,lnwpwm,lpdiag,lrsig,lso,lwsig,mx,mxint,n1,n2,n3,napws,nat,nclasx,
     .  ncore,ndham,ndhamx,ndima,ndimh,ndimhs,ndimhx,ndimhxs,nev,nevl,ngc,ngp,ngp_p,
     .  ngpmx,nkp,nlinemax,nlmax,nlmto,nmb,nmcore,nmx,nn1,nn2,nnn,npgrp,nphimx,
     .  ndlmto,npmbx,npqn,nqbz,nqi,nqibze,nqnum,nqnumx,nqtot,nr,nrmx,nsgrp,
     .  nsp,nspc,nspc3,ntmb,ovncut,stdo
      integer procid, master, mpipid, nproc ! For MPIK
      integer iflband(2),inn(3),ipb(nbas),konfig(0:n0),ngabc(3),ivec(10),nlnmaug(nbas,2)
      integer, parameter :: LW9=9,LW19=19
      integer n1q,n2q,n3q,nkgw(3)
      equivalence (n1q,nkgw(1)),(n2q,nkgw(2)),(n3q,nkgw(3))
      double precision dnn(3)
C     integer lshft(3)
      equivalence (n1,ngabc(1)),(n2,ngabc(2)),(n3,ngabc(3))
      real(8) q(3),QpGcut_psi,QpGcut_cou,dum,qpscale,xx(5),gmax,gcutb,
     .  pnu(n0,2),pnz(n0,2),ecore(50),a,z,rmt(nbas),b,vshft,alat,alfa,ef0,
     .  plat(3,3),qlat(3,3),qp(3),qpos,qx(3),q_p(3),epsovl,qb(3,3)
      integer ltab(n0*nkap0),ktab(n0*nkap0),offl(n0*nkap0),norb
C     integer ndhamx,nspx,nnnx
      character strn*120,ext*20,dc*1
      integer,allocatable:: nevls(:,:)
      integer, parameter :: lSOf=4,lSzLz=32,lSzLzp=64,lSzLzp0=128
      procedure(logical) :: cmdopt,latvec
      procedure(integer) :: bitand,iprint,maxnphi,parg2,idalloc,allocvb,nglob,lgunit
      procedure(integer) :: fopna,fopnx,fopng,iclbas,isw,wordsw,a2vec,iofa
      procedure(real(8)) :: dlength,dval
C#ifdefC SIGNN
C      complex(8),allocatable:: sig(:,:)
C#endif
C#ifdefC TAKAO
C      integer, allocatable :: iproct(:,:)
C      integer nbalance,iproc,iqq,iadd,nrr,ifiproc,numproc
C#endif

C ... For PW basis
      integer,parameter:: NULLI = -99999
      real(8),parameter:: NULLR =-99999
      integer pwmode,napw
      double precision pwemin,pwemax,pwgmin,pwgmax,eomin,ebot,etop
      complex(8), parameter :: zer=(0d0,0d0),one=(1d0,0d0)

C ... for reading self-energy
      integer nqsig

C ... for reading BZDATA (job=6,7)
      type str_bzdata

      integer    ::   nqbz     ! Number of k-points in the full BZ
      integer    ::   nqibz    ! Number of k-points in the irreducible part
      integer    ::   nqbzw    ! Dimensions qbzw,ib1bz.  Should be (n1+1)*(n2+1)*(n3+1)
      integer    ::   ntetf    ! Number of tetrahedra in the full BZ
      integer    ::   nteti    ! Number of tetrahedra in the irreducible part
      integer    ::   ngrp     ! Number of symmetry operations
      integer    ::   nqibz_r  !
      integer    ::   n123(3)  ! Number of k-divisions along the reciprocal lattice vectors
      integer,pointer::
     .  idtetf(:,:),           ! corners of tetrahedra for full BZ
     .  ib1bz(:),              ! maps k-points in the padded qp list (qbzw) to the original list
     .  idteti(:,:),           ! corners of tetrahedra for irreducible BZ
     .  nstar(:),              ! star of k
     .  irk(:,:),              ! irreducible
     .  nstbz(:)               !
      real(8),pointer::
     .  qbz(:,:),wbz(:),       ! k-points in the full Brillouin zone, and weights
     .  qibz(:,:),wibz(:),     ! k-points in the irreducible Brillouin zone, and weights
     .  qbzw(:,:),             ! k-points on the regular mesh, padded to repeat boundary points
     .  qibz_r(:,:)
      end type str_bzdata
      type(str_bzdata)::  s_bzdata

C ... External calls
      external atwf2l,awrit1,awrit2,awrit3,awrit8,bndconn_v2,chcase,
     .         daxpy,dgemm,dinv33,dpcopy,dpzero,dscal,dvset,fclose,fclr,
     .         fexit2,fftz30,getpr,gintsl,gvlst2,gwcphi,hambls,
     .         iinit,info0,info2,info5,iosigh,makusq,mk_hamindex,
     .         mshnrl,orbl,phmbls,poppr,prtev,pshpr,pvsug1,
     .         pwmat2,radmsh,radwgt,rx0,rxi,shorps,sitepack,sopert3,
     .         spex_read_k,sugvec,tcn,tcx,uspecb,wlattc,wsymops,zcopy,
     .         zgemm,zhevo,zinit,zqinvb,zslabl

C ... for band plotting
      real(8),allocatable :: ovvx(:,:,:)
      real(8) ::ovvpp
      real(8), allocatable :: double_dummy(:)

C ... for testing product basis
      logical :: lwriteVcoulTK = .false.
      logical :: lwrhoc = .false. ! If .true., write core densities (job 0)
      integer nl,nqc,ncoremx,maxcor(2),ndrphi,nradpb,lcutmx,nlcutmx,jat,js,nlmi,nlmj
      integer iqfbz,nnegevl,ndrpb,mxnpba,ntpb,ntpba(0:nbas)
      equivalence (ncoremx,maxcor(1))
      integer, allocatable :: ncwf(:,:,:),ncwf2(:,:,:),nrpb(:,:)
      integer, pointer :: npmb(:),nrphi(:,:),nrphiv(:,:),nrphic(:,:),
     .                    nocc(:,:,:),noccv(:,:,:),noccc(:,:,:),
     .                    nunoccv(:,:,:),nunoccc(:,:,:),nunocc(:,:,:)
      real(8), allocatable :: rprodb(:,:)
      real(8), allocatable :: tolbas(:),rojb(:,:,:,:),sgbb(:,:,:,:),sgbc(:,:,:),
     .                        qc(:,:),qibze(:,:),wibze(:)
      real(8), allocatable :: prbasr(:,:,:,:,:,:),prbas(:,:,:,:)
      complex(8), allocatable :: rojp(:,:,:),sgpb(:,:,:,:),fouvb(:,:,:,:),
     .                           strx(:,:,:,:),vcoul(:,:)
!     complex(8), allocatable :: sgpp(:,:,:)
      real(8) :: Ecoul,p(3),minnegevl
      real(8), parameter :: tolq = 1d-5, tolevl = 1d-10
      complex(8) :: phasep,img=(0d0,1d0)
      real(8) :: pi=4d0*datan(1d0)

      integer idxdn(n0,nkap0)
      character lsym(0:n0-1)*1, lorb(3)*1, dig(9)*1, strn4*4
      data lsym /'s','p','d','f','g','5','6','7','8','9'/
      data lorb /'p','d','l'/
      data dig /'1','2','3','4','5','6','7','8','9'/

      xx = 0

C      integer jfi
C      integer,allocatable::  ngvecp_(:,:),ngvecc_(:,:)
C      real(8),allocatable:: evl_(:,:)
C      complex(8),allocatable:: evec_(:,:),cphi_(:,:,:),pwz_(:,:)

C --- Setup ---
      call tcn('sugw')
      call getpr(ipr)
      nproc = mpipid(0)
      procid = mpipid(1)
      master = 0
      rank0 = procid == master  ! true if master process
      gcutb = s_gw%gcutb
      gwcode = s_gw%code
      call sanrg(.true.,gwcode,0,2,'sugw:','gwcode')
      if (.not. associated(s_ham%qsig)) call ptr_ham(s_ham,1,'qsig',1,1,xx)

      alat = s_lat%alat
      plat = s_lat%plat
      qlat = s_lat%qlat
      ngabc = s_lat%nabc
      gmax = s_lat%gmax
      etop = NULLI
      ebot = -etop
      nmcore = 1000*(bitand(s_ctrl%lcd,16)/16)
      npgrp = s_lat%npgrp
      nsgrp = s_lat%nsgrp
      call fftz30(n1,n2,n3,k1,k2,k3)
      stdo = lgunit(1)
      lchk = 1
      nsp  = nglob('nsp')
      nspc = nglob('nspc')    ! 2 for noncollinear case
      nspc3 = nglob('nspc3')  ! 2 if spins coupled perturbatively (lso=3)
      lso =   isw(IAND(s_ham%lncol,4)/=0)
     .    + 2*isw(IAND(s_ham%lncol,lSzLz)/=0)
     .    + 3*isw(IAND(s_ham%lncol,lSzLzp)/=0)
     .    + 4*isw(IAND(s_ham%lncol,lSzLzp0)/=0)
      lrsig= s_ham%lsig
      lwsig = 0
C     lsig = 0
      nqsig = s_ham%nqsig

C ... For reduced hilbert space
      epsovl = s_ham%oveps
      ovncut = s_ham%ovncut
      mnevl = 9999 !for printout, smallest ham dimension
      nlmto = s_ham%nlmto

C ... See Local variables, above for meaning of lnwpwm
      lnwpwm = 0
      if (cmdopt('--pwmat2',8,0,strn)) lnwpwm = 1
      tprodbas = 0
      if (cmdopt('--tprodbas',10,0,strn)) then
        dc = strn(11:11)
        if (wordsw(strn,dc,'wvcoud','',j) > 0) lwriteVcoulTK = .true.
        tprodbas = 4
        k = wordsw(strn,dc,'mode=','',j) + 5
        if (k > 5) then
          if (a2vec(strn,len_trim(strn),k,2,', '//dc,3,2,1,ivec,tprodbas) < 1)
     .      call rx('sugw failed to parse '//trim(strn))
        endif
      endif
      keephi = tprodbas > 0
      allocate(double_dummy(1))

C     Number of partial waves for a given l.  For now:
      nphimx = 3
C     gwcode=2: do not shorten vectors
      if (gwcode == 2 .and. s_ctrl%lfp/2 /= 0) s_ctrl%lfp = s_ctrl%lfp - 2

C ... Count number of atoms : exclude floating orbitals; also get lmxax, maxcor, konfa
      lmxax = -1
      nat = 0
      j = -1
      do  ib = 1, nbas
        is = s_site(ib)%spec
        ipb(ib) = 0
        lmaxa = s_spec(is)%lmxa
        if (lmaxa == -1) cycle
        if (lmaxa > -1) nat = nat + 1
        ipb(ib) = nat
        if (j == -1) j = lmaxa
        if (lmaxa /= j) call rx('sugw: lmfgwd requires a fixed lmxa for all sites, sorry')
        lmxax = max(lmxax,lmaxa)
      enddo
C     Get mxcor and konfa
      allocate(konfa(0:lmxax,nat))
      call GWdimpar(1,s_site,s_spec,nbas,lmxax+1,nsp,maxcor,konfa)

      job = jobgw; lwsig = 0
      if (s_ctrl%lwsig == LW9 .or. s_ctrl%lwsig == LW19) job = 2
      if (job == -999) then
        write(stdo,*) ' lmfgw: input one of the following jobs:'
        if (gwcode == 0 .or. gwcode == 2) then
          write(stdo,*) '  -1 : creates files GWinput, QPNT, QIBZ, Q0P, QGpsi, QGcou, KPTin1BZ'
          write(stdo,*) '  -2 : Performs some sanity checks on GWinput'
          write(stdo,*) '   0 : init mode; creates files SYMOPS, LATTC, CLASS, NLAindx, ldima'
          write(stdo,*) '   1 : GW driver mode; creates files HAMindex,gwb,gw1,gw2,gwa,vxc,evec,rhoMT.*,normchk,mpiqlst'
          write(stdo,*) '   2 : Make file vxcsig'
          write(stdo,*) '   4 : band mode'
          write(stdo,*) '   5 : eigenvalue-only mode' !takao Sep 2003
          write(stdo,*) '   6 : Read k-points and write irreducible qp to file qpts (requires file QIBZ)'
          write(stdo,*) '   7 : Read k-points and write to file qpts'
        elseif (gwcode == 1) then
          write(stdo,*) '   0 : init mode; creates files lattice, lmto, sym.out'
          write(stdo,*) '   1 : GW driver mode; creates files atval, atcore, vxc, evec.ext, evcof, evals'
          write(stdo,*) '       Requires additional input file: kpts'
        endif
        write(stdo,*) ' job?'
        read (5,*) job
      elseif (job == 2) then
        lwsig = s_ctrl%lwsig
        if (lwsig == 0) lwsig = LW9
        if (lwsig /= LW9 .and. lwsig /= LW19) call rxi('sugw: transformation mode not recognized: ',lwsig)
      endif
      if (rank0) print "(/a,i3,' ',a,i3)", ' gw setup, job', job, 'code', gwcode
      if (job == 2) job = 1   ! Make a band pass in the same manner as job=1. lwsig>0 modifies behavior

C ... Mode -2 ... sanity check on GWinput
      if (job == -2) then
        call chkgwin(s_site,s_spec,s_lat,s_gw,s_bz,nbas)
        call rx0('lmfgw, job -2')
      endif

C ... Mode -1 ... only after mkpot because qval made in mkpot
      if (job == -1) then
        call sugwin(s_site,s_spec,s_lat,s_ham,s_gw,s_bz,nbas,s_pot%qval)
        call rx0('lmfgw, job -1')
      endif

      call sanrg(.true.,job,0,7,'sugw:','job')
      if (job == 3) call rxi('sugw: bad job = ',job)
      bandmode = .false.
      jobb = 0
      if (job == 4) then
        job = 1
        bandmode = .true.
      elseif (job == 5) then
        job = 1
        bandmode = .true.
        jobb = 5
      endif

      napw = 0
      ldim = s_ham%ldham(1)
      pwmode = s_ham%pwmode; pwemin = s_ham%pwemin; pwemax = s_ham%pwemax; ndham = s_ham%ndham
      allocate(evl(ndham,nsp))
      if (nlmto/=ndham) call info0(30,0,0,' PMT: Make eigenvectors in LMTO basis for sigm interpolation')
      ndhamx = ndham*nspc

C ... Generate ndima,nlindx
      allocate(nlindx(3,0:lmxax,nat))
      nlindx = -1
      ndima = 0
      do  ipqn = 1, nphimx   ! loop over phi, phidot, LO
        do  ib = 1, nbas
          is = s_site(ib)%spec
          lmaxa = s_spec(is)%lmxa
          pnz = s_spec(is)%pz
          lmxax = max(lmxax,lmaxa)
          if (lmaxa > -1) then
            do  l = 0, lmaxa
              npqn = 2
              if (pnz(l+1,1) /= 0) npqn = 3
              if (ipqn <= npqn) then
                nlindx(ipqn,l,ipb(ib)) = ndima
                ndima = ndima + (2*l+1)
              endif
            enddo
          endif
        enddo
      enddo

C --- Make files SYMOPS, LATTC, CLASS, NLAindx, ldima ---
      if (job==0 .and. rank0) then
        lwrhoc = cmdopt('--rhoc',4,0,strn)
        if (gwcode == 0 .or. gwcode == 2) call info(30,1,1,
     .    ' Creating files SYMOPS, LATTC, CLASS, NLAindx, ldima%?#n#, rhoc##',isw(lwrhoc),0)
        if (gwcode == 1) call info(30,1,1,
     .    ' Creating files: lattice, lmto, sym.out',0,0)
C   ... Create file SYMOPS
        if (gwcode == 0 .or. gwcode == 2) then
          ifi = fopnx('SYMOPS',2,2,-1); rewind ifi
        elseif (gwcode == 1) then
          ifi = fopnx('sym.out',2,2,-1)
        endif
C       allocate(s_sym(nsgrp))
C       call sitepack(s_site,1,nbas,'pos',3,xx,bas)
C       i = mks_sym(11,plat,s_lat%symgr,s_lat%ag,nsgrp,nbas,bas,s_sym)
C       call shosym(4,nbas,nsgrp,0,plat,s_sym)

        call wsymops(mod(gwcode,2),ifi,nsgrp,s_lat%s_sym)
        call fclr(' ',ifi)

C   ... Write rhoc
        if (cmdopt('--rhoc',6,0,strn)) then
          ifi = fopna('rhoc',-1,0); rewind ifi
          do  i = 1, nbas
            is = s_site(i)%spec
            if (s_spec(is)%lmxa < 0) cycle
            k = iofa(33,s_spec(is)%name,0,0,[0d0],[0d0],[0d0],xx,s_spec(is)%z,s_spec(is)%rmt,
     .        s_spec(is)%a,s_spec(is)%nr,nsp,NULLR,NULLR,NULLR,NULLR,[NULLR],s_site(i)%rhoc,[NULLR],-ifi)
          enddo
          call fclose(ifi)
C         call info0(10,0,0,' write file rhoc')
        endif

C   ... Make lmxax and possibly create file ldima
        allocate(ips(nbas),lmxa(nbas),bas(3,nbas))
        call sitepack(s_site,1,nbas,'spec',1,ips,xx)
        if (gwcode == 0 .or. gwcode == 2) then
          ifi = fopnx('ldima',2,2,-1); rewind ifi
        endif
        do  i = 1, nbas
          lmxa(i) = s_spec(ips(i))%lmxa
          bas(1:3,i) = s_site(i)%pos
          if (lmxa(i) > -1) then
          call orbl(i,0,ldim,s_ham%iprmb,norb,ltab,ktab,xx,offl,i1)
          if (gwcode == 0 .or. gwcode == 2) then
            write(ifi,"(3i10)") i1
          endif
          endif
        enddo
        deallocate(ips)
        lmxax = mxint(nbas,lmxa)

C   ... Create ipcx; write to file CLASS
        allocate(ipc(nbas),ipcx(nbas))
        call sitepack(s_site,1,nbas,'class',1,ipc,xx)
        call pvsug1(nbas,lmxa,ipc,ipcx)
        if (gwcode == 0 .or. gwcode == 2) then
          ifi = fopnx('CLASS',2,2,-1); rewind ifi
          do  i = 1, nbas
            if (lmxa(i) > -1) then
              write(ifi,'(2I4)') ipb(i), ipcx(i)
            endif
          enddo
C          write(ifi,'(I4," augmentation sites",I4," total")') nat, nbas
C          write(ifi,'(1000I4)') ipbi(1:nat)
          call fclr(' ',ifi)
        endif

C   ... Create file LATTC (or lattice)
C       Make also:
C       maxcor(1) = largest number of core radial functions in system
C       maxcor(2) = largest l for which a core state exists
C        allocate(konfa(0:lmxax,nbas,nsp))
C        call GWdimpar(1,s_site,s_spec,nbas,lmxax+1,nsp,maxcor,konfa)
C        maxcor(1) = 0; maxcor(2) = -1
C        allocate(konfa(0:lmxax,nbas,nsp))
C        do  i = 1, nbas
C          is = s_site(i)%spec
C          pnu = s_site(i)%pnu
C          pnz = s_site(i)%pz
C          do  isp = 1, nsp
C            do  l  = 0, lmxa(i)
C              konfa(l,i,isp) = pnu(l+1,isp)
C              if (mod(pnz(l+1,isp),10d0) < pnu(l+1,isp) .and.
C     .            pnz(l+1,isp) > 0)
C     .          konfa(l,i,isp) = mod(pnz(l+1,isp),10d0)
C              maxcor(1) = max(maxcor(1),konfa(l,i,isp)-l-1)
C              if (konfa(l,i,isp)-l-1 > 0) then
C                maxcor(2) = max(maxcor(2),l)
C              endif
C            enddo
C          enddo
C        enddo

        if (gwcode == 0 .or. gwcode == 2) then
          ifi = fopnx('LATTC',2,2,-1)
          jfi = 0
        else if (gwcode == 1) then
          ifi = fopnx('lattice',2,2,-1)
          jfi = fopnx('lmto',2,2,-1)
          rewind jfi
        else
          call rx('lmfgwd: bad gwcode')
        endif
        rewind ifi

C       Maximum number of radial functions describing partial waves
C       for a given l (2 for phi,phidot; 3 if any local orbitals)
        call wlattc(mod(gwcode,2),ifi,jfi,s_site,s_spec,alat,plat,nbas,
     .    nat,maxcor,gcutb,ipb,ipcx,lmxax,bas,lmxa,nsp,konfa)
         call fclr(' ',ifi)

C   ... Create file NLAindx
        if (gwcode == 0 .or. gwcode == 2) then
        ifi = fopnx('NLAindx',2,2,-1); rewind ifi
        write(ifi,'(''----NLAindx start---------------''/I6)') ndima
        ndima = 0
C       This loop order is backwardly compatible with prior versions
        do  ipqn = 1, 3
          do  ib = 1, nbas
            is = s_site(ib)%spec
            lmaxa = s_spec(is)%lmxa
            pnu = s_spec(is)%p
            pnz = s_spec(is)%pz
            idxdn = s_spec(is)%idxdn
            if (lmaxa > -1) then
            do  l = 0, lmaxa
              npqn = 2
              if (pnz(l+1,1) /= 0) npqn = 3
              if (ipqn <= npqn) then
                konf = pnu(l+1,1)
                if (ipqn == 3) konf = mod(pnz(l+1,1),10d0)
                strn4 = dig(konf)//lsym(l)//'_'//lorb(ipqn)
                if (idxdn(l+1,1) == 1 .or. idxdn(l+1,2) == 1)
     .            call chcase(0,1,strn4(2:2))
                write(ifi,'(i6,i3,i4,i6,4x,a)')
     .            ipqn, l, ipb(ib), ndima, strn4
                ndima = ndima + (2*l+1)
C             else
C               write(ifi,'(i6,i3,i4,i6)') ipqn, l, ib, -1
              endif
            enddo
            endif
          enddo
        enddo
        call fclr(' ',ifi)
        endif

        deallocate(ipc,ipcx)

        if(.not.allocated(double_dummy)) allocate(double_dummy(1))

        call fexit(0,1,' OK! lmfgw generated files, job 0',double_dummy)

      endif

C --- GW setup files, fpgw format, job 1 ---
      if (gwcode == 0 .or. gwcode == 2) then

C  ...  Read file NLAindx ... no longer needed: nlindx already made
C       allocate(nlindx(3,0:lmxax,nat))
C       ifi = fopnx('NLAindx',2,1,-1)
C       call ioaindx(3,lmxax,nat,ndima,nlindx,ifi)

C   ... Read QGpsi and QGcou (takao 2003 Sep)
        if (jobb == 0) then
          if (gwcode == 0) then
            ifiqg  = fopnx('QGpsi',2,4,-1)
            read(ifiqg) nqnum, ngpmx, QpGcut_psi, nqbz
            nqi = 0; imx = 0 ; nqibz = 0
            ifiqgc = fopnx('QGcou',2,4,-1)
            read(ifiqgc) nqnumx, npmbx, QpGcut_cou
            if (nqnum /= nqnumx)
     .        call rx('sugw: different nqnum in QGcou QGpsi')
          else
            call mk_hamindex(s_ham,s_lat,s_site,s_spec) ! SYMOPS is rewritten
            ifiqg  = fopnx('QGpsi',2,4+1,-1); rewind ifiqg
            read(ifiqg) nqnum, ngpmx, QpGcut_psi, nqbz, nqi,imx,nqibz
          endif
        endif

C   ... Write, or read past header information, file gwb
        ifi = fopna('gwb',-1,4); rewind ifi
        if (job == 1) then
          ef0 = 1d99                !dummy

          i = fopna('gw1',-1,4); rewind i
          i = fopna('gw2',-1,4); rewind i

C     ... Determine nphimx and nrmx (needed for product basis manipulations)
C         Populate lmxa(:), bas(:,:), write header to file gwb
          allocate(lmxa(nat),bas(3,nat))
          iat = 0; nphimx = 0; nrmx = 0; a = 0 ; nr = 0 ; z = 0
          do  i = 1, nbas
            is = s_site(i)%spec
            pnu = s_site(i)%pnu
            pnz = s_site(i)%pz
C           a = s_spec(is)%a
C           nr = s_spec(is)%nr
C           z = s_spec(is)%z
            rmt(i) = s_spec(is)%rmt ! Not needed; avoid compiler complaint
            lmaxa = s_spec(is)%lmxa
            if (lmaxa < 0) cycle
            iat = iat + 1
            if (iat > nat) call rx('bug in sugw')
            bas(1:3,iat) = s_site(i)%pos
            lmxa(iat) = lmaxa
            call atwf(nmcore,a,lmaxa,nr,nsp,pnu,pnz,rsml,ehl,rmt(i),z,
     .        xx,i1,ncore,konfig,ecore,xx,xx)
            nphimx = max(nphimx,i1)
            nrmx = max(nrmx,s_spec(is)%nr)
          enddo
          if (rank0) then
            write(ifi) nat,nsp,ndima,ndham,alat,qlat,ef0,nqbz,plat,nqnum,nqi !takao 2012 Sep
            write(ifi) lmxa(1:nat), bas(1:3,1:nat)
          endif
          deallocate(lmxa,bas)

C     ... For band mode
          if (bandmode .and. jobb == 0) then
            allocate(ovvx(ndima,ndima,nsp))
            ovvx = 0d0
          endif

C     ... Atom data (gwa)
          call info(30,1,1,' ... Generate radial wave functions (file gwa)',0,0)
          if (rank0) then
            ifi = fopna('gwa',-1,4); rewind ifi
          endif
          if (keephi) then
            allocate(gvala(nrmx,0:lmxax,nphimx,nsp,nat))
            allocate(gcora(nrmx,0:lmxax,ncoremx,nsp,nat))
            call dpzero(gvala,size(gvala))
            call dpzero(gcora,size(gcora))
          endif
          do  ib = 1, nbas
            is = s_site(ib)%spec
            pnu = s_site(ib)%pnu
            pnz = s_site(ib)%pz
C           p_v0 => s_site(ib)%v0
            a = s_spec(is)%a
            nr = s_spec(is)%nr
            z = s_spec(is)%z
            rmt(ib) = s_spec(is)%rmt
            lmaxa = s_spec(is)%lmxa
            if (lmaxa < 0) cycle
            call atwf(nmcore,a,lmaxa,nr,nsp,pnu,pnz,rsml,ehl,rmt(ib),z,
     .        s_site(ib)%v0,i1,ncore,konfig,ecore,xx,xx)
            allocate(rofi(nr),rwgt(nr),gcore(nr,2,ncore))
            allocate(gval(nr,2,0:lmaxa,nphimx,nsp))
            call dpzero(gval,nr*2*(1+lmaxa)*nphimx*nsp)
C           Create augmented wave functions for this atom
            call uspecb(0,4,s_spec,is,is,lh,rsml,ehl,i)
            call atwf(nmcore+03,a,lmaxa,nr,nsp,pnu,pnz,rsml,ehl,rmt(ib),z,
     .        s_site(ib)%v0,nphimx,ncore,konfig,ecore,gcore,gval)
C           Header data for this atom
            b = rmt(ib)/(dexp(a*nr-a)-1d0)
            call radmsh(rmt(ib),a,nr,rofi)
            call radwgt(0,rmt(ib),a,nr,rwgt)

C       ... For band mode only
            if (bandmode .and. jobb==0) then
              do  l = 0, lmaxa
                nmx = 2
                if (konfig(l) >= 10) nmx=3
                do  nn1 = 1,nmx
                do  nn2 = 1,nmx
                do  isp = 1,nsp
                  call gintsl(gval(1,1,l,nn1,isp),gval(1,1,l,nn2,isp),a,nr,rofi,ovvpp)
                  do  mx = 1, 2*l+1
                    im1 = nlindx(nn1,l,ipb(ib))+mx
                    im2 = nlindx(nn2,l,ipb(ib))+mx
                    ovvx(im1,im2,isp) = ovvpp
                  enddo
                enddo
                enddo
                enddo
              enddo
            endif

C       ... Write to disk
            if (rank0) then       ! Master node only writes to gwa
              write(ifi) z, nr, a, b, rmt(ib), lmaxa, nsp, ncore
              write(ifi) konfig(0:lmaxa)
              write(ifi) rofi

C             Write orthonormalized valence wave functions for this atom
              do  l = 0, lmaxa
              do  i = 1, nsp
                write(ifi) l,i
                write(ifi) gval(1:nr,1,l,1,i)
                write(ifi) gval(1:nr,1,l,2,i)
                if (konfig(l) >= 10) write(ifi) gval(1:nr,1,l,3,i)
              enddo
              enddo

C             Core wave functions for this atom
              icore = 0
              vshft = s_pot%vesrmt(ib)
C             As of v6.11, shift is included in v0, passed in vval to
C             locpot, in routine mkpot.f
              vshft = 0
              do  l = 0, lmaxa
              do  isp = 1, nsp
                do  konf = l+1, mod(konfig(l),10)-1
                  icore = icore+1
                  write(ifi) icore, l, isp, konf, ecore(icore)+vshft
                  write(ifi) gcore(1:nr,1,icore)
C               print *, icore,gcore(nr,1,icore)
                enddo
              enddo
              enddo
            endif                 ! Write for rank=0

C           Keep large component of g
            if (keephi) then
              icore = 0
              do  l = 0, lmaxa
              do  isp = 1, nsp
                do  i = 1, nr
                  gvala(i,l,1,isp,ipb(ib)) = gval(i,1,l,1,isp)
                  gvala(i,l,2,isp,ipb(ib)) = gval(i,1,l,2,isp)
                  if (konfig(l) >= 10) gvala(i,l,3,isp,ipb(ib)) = gval(i,1,l,3,isp)
                enddo
                do  konf = l+1, mod(konfig(l),10)-1
                  icore = icore+1
                  forall (i=1:nr) gcora(i,l,konf-l,isp,ipb(ib)) = gcore(i,1,icore)
                enddo
C               call info5(1,0,0,' l=%i gcore(nr)=%n:2;4g',l,konfa(l,ipb(ib))-1-l,gcora(nr,l,:,isp,ipb(ib)),4,5)
              enddo
              enddo
            endif
            deallocate(rofi,rwgt,gcore,gval)
          enddo  ! Loop over ib
          if (rank0) call fclr('gwa',ifi)

        elseif (job == 6 .or. job == 7) then
          ifi = fopna('QPTS',-1,0) ! Write header to qpts file
          call info0(20,1,-1,' Read qp from BZDATA and write to qpts file, ')
          call read_bzdata(10,s_bzdata)
          if (job == 6) then
            call info2(20,0,0,'%i irr qp in first BZ of %i qp',
     .        s_bzdata%nqibz,s_bzdata%nqbz)
            call getqp(2,-ifi,s_bzdata%nqibz,s_bzdata%n123,[0,0,0],
     .        s_bzdata%nteti,s_bzdata%qibz,s_bzdata%wibz,s_bzdata%idteti)
          else
            call info2(20,0,0,'%i qp in full BZ',s_bzdata%nqbz,2)
            call getqp(2,-ifi,s_bzdata%nqbz,s_bzdata%n123,[0,0,0],
     .        s_bzdata%ntetf,s_bzdata%qbz,2*s_bzdata%wbz,s_bzdata%idtetf)
          endif
          call rx0('wrote file qpts')
        else
          call rxi('sugw: bad job',job)
        endif

C --- GW setup files, spex format, job 1 ---
      else if (gwcode == 1) then
        if (nglob('lpz') > 0) then
          nphimx = 3
        else
          nphimx = 2
        endif

        call info(30,1,0,' ... Generate radial wave functions '//
     .    '(files atval, atcore)',0,0)
        ifi = fopnx('atval',2,4,-1); rewind ifi
        jfi = fopnx('atcore',2,4,-1); rewind jfi
        allocate(ips(nbas),ipc(nbas),ipcx(nbas),lmxa(nbas))
        call sitepack(s_site,1,nbas,'spec',1,ips,xx)
        call sitepack(s_site,1,nbas,'class',1,ipc,xx)
        do  i = 1, nbas
          lmxa(i) = s_spec(ips(i))%lmxa
        enddo
        call pvsug1(nbas,lmxa,ipc,ipcx)
        nclasx = mxint(nbas,ipcx)
        write(ifi) nclasx   ! 1st record: how many classes to write
        write(jfi) nclasx   ! 1st record: how many classes to write
        do  ic = 1, nclasx
          ib = iclbas(ic,ipcx,size(ipcx))
          if (ib == 0) cycle
          is = s_site(ib)%spec
          call info5(30,1,0,' site:%,4i  spec '//s_spec(is)%name//
     .      '  class %i',ib,is,ic,0,0)
          pnu = s_site(ib)%pnu
          pnz = s_site(ib)%pz
C         p_v0 => s_site(ib)%v0
          a = s_spec(is)%a
          nr = s_spec(is)%nr
          z = s_spec(is)%z
          rmt(ib) = s_spec(is)%rmt
          lmaxa = lmxa(ib)
          if (lmaxa > -1) then
C           Dimensioning
            call atwf(nmcore,a,lmaxa,nr,nsp,pnu,pnz,rsml,ehl,rmt(ib),z,
     .        s_site(ib)%v0,i1,ncore,konfig,ecore,xx,xx)
            allocate(rofi(nr),rwgt(nr),gcore(nr,2,ncore))
            allocate(gval(nr,2,0:lmaxa,nphimx,nsp))
            call dpzero(gval,nr*2*(1+lmaxa)*nphimx*nsp)
C           Create radial wave functions for this atom, valence and core
            call uspecb(0,4,s_spec,is,is,lh,rsml,ehl,i)
            call atwf(nmcore+03,a,lmaxa,nr,nsp,pnu,pnz,rsml,ehl,rmt(ib),z,
     .        s_site(ib)%v0,nphimx,ncore,konfig,ecore,gcore,gval)
C           Translate to standard log mesh (spex format), and write
            call atwf2l(ifi,jfi,ic,a,lmaxa,nr,nsp,pnz,rmt(ib),nphimx,
     .        konfig,ppn(1,1,(ib-1)*nsp+1),ecore,gcore,gval)
            deallocate(rofi,rwgt,gcore,gval)
          endif
        enddo
        call fclr('atval',ifi)
        call fclr('atcore',jfi)

C ...   Get maximum number of G vectors, for dimensioning
        call info0(30,1,-1,' ... Reading k points (file kpts)')
        ifi = fopnx('kpts',2,1,-1); rewind ifi
        read(ifi,*) nqtot, qpscale, nkgw
        call info2(30,0,0,' ... generate data for %i points',nqtot,0)

C        if (ipr >= 100) write(stdo,369)
C  369   format(/' G cutoffs for each q0i and qp in BZ'/18x,'qp',20x,
C     .    ' ngp  ngc')
        ngpmx = 0
        call info0(40,0,0,'%12fk (qlat units)%23fk(2pi/a)%14fwt')
        do  iq = 1, nqtot
          call spex_read_k(ifi,qlat,qpscale,q,xx(1))
          call pshpr(1)
C          call gvlst2(alat,plat,q,0,0,0,0d0,gcutb,0,
C     .      0,1,ngp,dum,dum,dum,dum)
          stop 'sugw sugvec'
          inn = 0
          call sugvec(s_lat,64,q,0d0,gcutb,inn,0,ngp)
          call poppr
          ngpmx = max(ngpmx,ngp)
        enddo
        rewind ifi  ! Reset kpts file pointer to 1st kpoint
        read(ifi,*) nqtot
        call info2(30,0,0,'%5fLargest number of gvec found: %i',ngpmx,0)

C       Header for files 'evals' and 'evcof'
        ifi = fopnx('evals',2,4,-1); rewind ifi
        write(ifi) 1, ngpmx, nqtot   ! First record : version number, dimensioning

        ifi = fopnx('evcof',2,4,-1); rewind ifi
        write(ifi) 1, ngpmx, nqtot ! First record : version number, dimensioning
        if (nglob('lpz') > 0) then
          nphimx = 3
        else
          nphimx = 2
        endif
        write(ifi) nphimx, lmxax, nat, ndima, ndham ! Dimensions nlindx and cphi
        write(ifi) nlindx(1:nphimx,:,:)
      else
        call rx('lmfgwd: bad gwcode')
      endif

C --- Make product basis and coulomb matrix ---
      if (mod(tprodbas,10) > 0) then

        nnegevl = 0; minnegevl = 0
        nl = lmxax+1
        Ecoul = -1d-4
        lcutmx = 2*(nl-1)

        allocate (nrphiv(0:nl-1,nat),nrphic(0:nl-1,nat),
     .            noccv(0:nl-1,nphimx,nat),noccc(0:nl-1,ncoremx,nat),
     .            nunoccv(0:nl-1,nphimx,nat),nunoccc(0:nl-1,ncoremx,nat),
     .            ncwf(0:nl-1,ncoremx,nat),ncwf2(0:nl-1,ncoremx,nat))
        allocate (tolbas(0:lcutmx),lcuta(nat))
        call GWinputprodbas(nl,nat,nphimx,ncoremx,lcuta,
     .    nrphiv,nrphic,noccv,nunoccv,noccc,nunoccc,ncwf,ncwf2,tolbas)

        if (mod(tprodbas,10) == 1) then
          nocc => noccv
          nunocc => nunoccv
          nrphi => nrphiv
          ndrphi = maxval(nrphiv)
          gtota => gvala
          call rx('sugw need check tprodbas == 1')
        elseif (mod(tprodbas,10) == 2 .or. mod(tprodbas,10) == 4) then
          if (mod(tprodbas,10) == 2) then
C           Modify noccc, noccv according to Takao's prescription.
C           Rethink for future
C           noccc = mirror of nwsc; nunocc = 0;  nunoccv <- (or(nunoccv,occv)
            forall (l=0:nl-1, ic=1:ncoremx, ib=1:nat) noccc(l,ic,ib) = 1-ncwf2(l,ic,ib)
            nunoccc = 0
            forall (l=0:nl-1, ic=1:nphimx, ib=1:nat)  nunoccv(l,ic,ib) = min(nunoccv(l,ic,ib)+noccv(l,ic,ib),1)
          endif
          ndrphi = maxnphi(nrphiv,nrphic,nl,nat) ! Max number of (core+valence) waves in any l
          allocate(nocc(0:nl-1,ndrphi,nat),nunocc(0:nl-1,ndrphi,nat),nrphi(0:nl-1,nat))
          allocate(gtota(nrmx,0:nl-1,ndrphi,nsp,nat))
          nocc = NULLI; nunocc = NULLI
          call dpzero(gtota,size(gtota))
          call mergephivc(11,nl,nsp,nat,nphimx,ncoremx,ndrphi,nrmx,
     .      nrphiv,nrphic,noccv,nunoccv,noccc,nunoccc,nocc,nunocc,nrphi,
     .      gvala,gcora,gtota)
        endif

C   ... Make the product basis B
        allocate(nrpb(0:lcutmx,nat+1)); call iinit(nrpb,size(nrpb))
        call pshpr(1)
C       Count number of radial product basis functions (nradpb)
        call rprodbasa(0,s_site,s_spec,nl,nsp,nbas,nat,ndrphi,nrphi,lcuta,nocc,nunocc,tolbas,
     .    nrmx,gtota,nradpb,ndrpb,nrpb,ntpba,xx)
        mxnpba = maxval(ntpba(1:nat)); ntpb = sum(ntpba(1:nat))
        call poppr
        allocate(rprodb(nrmx,nradpb))
C       Next call makes the product basis and its gradient
        i = 20
        if (cmdopt('--checkrpb',10,0,strn)) i = i+2000 ! Check completeness
        if (cmdopt('--checkrpb=2',12,0,strn)) i = i+2000 ! Verbose output
        call rprodbasa(i,s_site,s_spec,nl,nsp,nbas,nat,ndrphi,nrphi,lcuta,nocc,nunocc,tolbas,
     .    nrmx,gtota,nradpb,ndrpb,nrpb,ntpba,rprodb)
        ntpba(0) = mxnpba       ! prodbas may use ntpba(0), depending on 10s digit mode
C       Debugging printout
        call info0(1,1,0,'debugging printout')
        call info2(1,0,0,'%n:1i',lcutmx*nat+1,nrpb)
        call info2(1,0,1,'%n:1i',nat+1,ntpba)

C   ... Make orthogonalized valence partial waves
        if (mod(tprodbas/10,10) > 0) then
          ivec(1:5) = shape(gvala)
          allocate(gvalo(ivec(1),0:ivec(2)-1,ivec(3),ivec(4),ivec(5)))
          i = 1
          if (mod(tprodbas/10,10) > 1) i = 21 ! Kotani conventions to check code
          call gworthphi(i,s_site,s_spec,nl,nsp,nbas,nat,nphimx,nrmx,nrphiv,gvala,gvalo)

          if (mod(tprodbas,10) == 1) then
            gtoto => gvalo
          else
            allocate(gtoto(nrmx,0:nl-1,ndrphi,nsp,nat))
            call dpzero(gtoto,size(gtoto))
            call mergephivc(10,nl,nsp,nat,nphimx,ncoremx,ndrphi,nrmx,
     .        nrphiv,nrphic,noccv,nunoccv,noccc,nunoccc,nocc,nunocc,nrphi,
     .        gvalo,gcora,gtoto)
          endif

          call nrpb2nbl(11,nl,nat,nrpb,offl,i,j) ! offl and j are dummies; return mxrbls in i
          allocate(prbasr(0:nl-1,ndrphi,0:nl-1,ndrphi,0:2*(nl-1),i))
          call dpzero(prbasr,size(prbasr))
          call prodbasmea(0,s_site,s_spec,nl,nsp,nbas,nat,ndrphi,nrphi,nrmx,nrpb,rprodb,gtoto,prbasr)
          if (mod(tprodbas/10,10) >= 3) then
            i = 0
            call iopbme(12,1,nat,nl,ndrphi,nrpb,i,prbasr)
          endif
C     ... Make prbas
          if (mod(tprodbas/100,10) > 0) then
            call mtodim(3,s_site,s_spec,nl,nbas,nat,nrphiv,nrphic,nlnmaug)
            ndlmto = maxval(nlnmaug(1:nat,1))
            is = idalloc('prbas',allocvb()+2,ndlmto*ndlmto,mxnpba*nat)
            allocate(prbas(ndlmto,ndlmto,mxnpba,nat))  ! Old GW convention
            call dpzero(prbas,size(prbas))
            i = min(9,nsgrp) ! For debugging
            call prodbasa(3,s_lat,s_site,s_spec,i,nl,nsp,nbas,nat,ndrphi,nrphiv,nrphic,
     .        nrpb,ntpba,ndlmto,prbasr,prbas)
            call rx0('done making prbas')
          endif
        endif

        lgrad = 1
        allocate(rojb(ndrpb,0:lcutmx,0:lgrad,nbas),sgbb(ndrpb,ndrpb,0:lcutmx,nbas),sgbc(ndrpb,0:1,nbas))
C        call dbgonsitecoul(s_lat,s_site,s_spec,7,lgrad,nbas,lcutmx,ndrpb,nrpb,Ecoul,
C     .    nrmx,rprodb,xx,xx,xx,xx,rojb,sgbb,sgbc,xx,xx,xx,xx)
        call onsitecoul(s_lat,s_site,s_spec,3+4,lgrad,nbas,lcutmx,ndrpb,nrpb,Ecoul,
     .    nrmx,rprodb,xx,xx,xx,xx,rojb,sgbb,sgbc,xx,xx,xx,xx)

        call info2(1,1,0,' sumcheck sgbc %;12,12F', sum(sgbc),2)


C#ifdefC DEBUG
C        call info2(1,1,0,' sumcheck rojb %;12,12F  sgbb %;12,12F', sum(rojb),sum(sgbb))
C#endif

C   ... For now, read qp from file QIBZ and Q0P and G vectors from file QGcou
        i = 0; call rdQIBZ(3,nqibz,i,xx,xx)
        nqibze = nqibz + i
        allocate(qibze(3,nqibze),wibze(nqibze))
        call rdQIBZ(30,nqibz,i,qibze,wibze)

C   ... For now, read G vectors from file QGcou
        call rdQGcou(1,nqc,npmbx,QpGcut_cou,xx,xx,xx)
        allocate(ngvecc(3,npmbx,nqc)) ! called ngvecc in old GW code
        allocate(npmb(nqc))           ! called ngc in old GW code
        allocate(qc(3,nqc))
        call rdQGcou(10,nqc,npmbx,QpGcut_cou,qc,npmb,ngvecc)
        if (npmbx < maxval(npmb)) call rx('dimensioning error in file QGcou')

        call info2(10,1,0,' sugw: make matrices and strux for vcoul, E=%g',Ecoul,2)
        s_lat%lmxst = 2*lcutmx
        s_lat%nkdmx = 2*s_lat%nkdmx
        s_lat%nkqmx = 2*s_lat%nkqmx
        call setcg(s_lat,lcutmx,2*lcutmx)
        call lattic(s_lat,s_ctrl,s_site)

C   ... For each qp in extended BZ + offset gamma, do
C       grep sumcheck out | grep rojp  |  awk '{print $(NF-1),$NF}' > 2
        nlcutmx = (lcutmx+1)**2
        do  iq = 1, nqibze

          call findqbz(nqc,qc,plat,tolq,qibze(1,iq),iqfbz)
          if (iqfbz < 0) call rx1('sugw cannot find qp=%s,%3d among qp read from QGcou',qibze(1,iq))
          s_lat%igvcc => ngvecc(:,:,iqfbz)
          allocate(rojp(npmb(iqfbz),nlcutmx,nbas))
          allocate(sgpb(npmb(iqfbz),ndrpb,nlcutmx,nbas))
          allocate(fouvb(npmb(iqfbz),ndrpb,nlcutmx,nbas))
C     ... Coulomb matrix
          nmb = npmb(iqfbz)+ntpb
          ntmb = npmbx+ntpb; allocate(vcoul(ntmb,ntmb))
          is = idalloc('sgpb',allocvb()+2,npmb(iqfbz)*ndrpb,nlcutmx*nbas*2)
          is = idalloc('vcoul',allocvb()+2,ntmb,ntmb*2)
          call dpzero(sgpb,2*size(sgpb)); call dpzero(fouvb,2*size(fouvb)); call dpzero(vcoul,2*size(vcoul))
          call onsitecoul(s_lat,s_site,s_spec,30,lgrad,nbas,lcutmx,ndrpb,nrpb,Ecoul,nrmx,rprodb,
     .      qibze(1,iq),ntpb,npmb(iqfbz),ntmb,xx,xx,xx,rojp,sgpb,fouvb,vcoul)

C     ... Structure constants
          i = idalloc('strx',allocvb()+2,nlcutmx*nbas,nlcutmx*nbas)
          allocate(strx(nlcutmx,nat,nlcutmx,nat)); call dpzero(strx,2*size(strx))
          iat = 0
          do  ib = 1, nbas
            is = s_site(ib)%spec
            if (s_spec(is)%lmxa < 0) cycle
            iat = iat + 1
            jat = 0
            do  jb = 1, nbas
              js = s_site(jb)%spec
              if (s_spec(js)%lmxa < 0) cycle
              jat = jat + 1
              p = s_site(jb)%pos - s_site(ib)%pos
              phasep = exp(img*2*pi*sum(qibze(1,iq)*p))
C             For now, strux made to lcutmx for all sites
              nlmi = (lcutmx+1)**2; nlmj = (lcutmx+1)**2
              call strxq(1,Ecoul,qibze(1,iq),p,nlmi,nlmj,nlcutmx*nat,
     .          alat,s_lat%vol,s_lat%awald,s_lat%nkd,s_lat%nkq,s_lat%dlv,s_lat%qlv,
     .          s_lat%cg,s_lat%indxcg,s_lat%jcg,strx(1,iat,1,jat),xx)
C              call zprm0('(1p9e22.12)')
C              call zprm('strx',2,strx(1,iat,1,jat),nlcutmx*nat,nlcutmx,nlcutmx)
            enddo ! jb
          enddo ! ib
          call dscal(2*size(strx),4*pi,strx,1)
C#ifdefC DEBUG
C          call info2(1,0,0,' sumcheck strx/1e6 iq=%i %2;18,6D',iq,sum(strx)/1d6)
C#endif

          call vcoulq(s_lat,lgrad,qibze(1,iq),ntpb,npmb(iqfbz),ntmb,
     .      nbas,nat,lcutmx,nrpb,ndrpb,qlat,strx,
     .      rojp,rojb,sgbb,sgpb,fouvb,Ecoul,vcoul)

          i = idalloc('strx',allocvb()+4,nlcutmx*nbas,nlcutmx*nbas)
          i = idalloc('sgpb',allocvb()+4,npmb(iqfbz)*ndrpb,nlcutmx*nbas*2)
          deallocate(rojp,sgpb,fouvb,strx)

C     ... Diagonalize
          call tcn('diagonalize')

C         Overlap matrix
          i = idalloc('ppovl',allocvb()+2,ntmb,ntmb)
          allocate(ppovl(ntmb,ntmb)); call dpzero(ppovl,2*size(ppovl))
          call pwmat(s_lat,s_site,s_spec,1,nbas,xx,xx,
     .      xx,qibze(1,iq),ntmb,npmb(iqfbz),s_lat%igvcc,xx,xx,ppovl(1+ntpb,1+ntpb),xx)
C#ifdefC DEBUG
C          call info2(1,0,0,' sumcheck ppovl iq=%i %2;18,6D',iq,sum(ppovl))
C#ifdefC DEBUG2
C          call zprm0('(1p9e22.12)')
C          call zprm('vcoul',2,vcoul,ntmb,nmb,nmb)
C          call zprm('ppovl',2,ppovl,ntmb,nmb,nmb)
C#endifC
C#endif

C         Overlap matrix for PB part
          forall (i = 1:ntpb) ppovl(i,i) = 1

C         Eigenvectors, eigenvalues of vcoul
          if (allocated(evl)) deallocate(evl)
          allocate(evec(nmb,nmb),ww(max(11,2*nmb)*nmb),evl(nmb,1))
          call dscal(2*size(vcoul),-1d0,vcoul,1)  ! So that evals ordered large to small
          call zhevx(nmb,ntmb,vcoul,ppovl,1,.true.,nmb,9d99,nev,
     .      ww,.false.,evl,nmb,evec)
          call dscal(nmb,-1d0,evl,1)
C         call prmx('evals of coulomb matrix',evl,nmb,nmb,1)

C     ... Reset negative eigenvalues; collect list of evals for printout
          if (allocated(nevls)) deallocate(nevls); allocate(nevls(nmb,1))
          j = 0; k = 0
          do  i = 1, nev
            if (.not. (i > 10 .and. i < nev-5 .and. evl(i,1) > 0)) then
              k = k+1
              nevls(k,1) = i
              ww(k) = evl(i,1)
            endif
            if (evl(i,1) < tolevl) then
              minnegevl = min(minnegevl,evl(i,1))
              j = j+1
              nnegevl = nnegevl+1
              evl(i,1) = tolevl
            endif
          enddo

C     ... Printout
          call info5(20,1,0,
     .      ' evals of vcoul for iq = %i of %i  q =%3;9,5D  rank %i%?#n#%-1j  (%i neg evl)##',
     .      iq,nqibze,qibze(1,iq),nmb,j)
          if (iprint() > 45) then
            call arrprt(' state  evl','%,5i  %;7,7F','id',k,0,4,0,'  | ',nevls,ww,3,4,5,6,7,8)
          endif

          call tcx('diagonalize')

C     ... Write to disk, Kotani style
          if (lwriteVcoulTK .and. rank0) then  ! Write Vcoud Kotani style
            strn = 'Vcoud.'
            i = 6
            call bin2a('i5',0,0,iq,2,0,20,strn,i)
            ifi = fopng(trim(strn),-1,4)
            call info0(10,0,0,' Write coulomb integrals to file '//trim(strn))
            write(ifi) nmb
            write(ifi) qibze(:,iq)
            write(ifi) evl(1:nmb,1)
            write(ifi) evec
            call fclr(' ',ifi)
          endif

          i = idalloc('ppovl',allocvb()+4,ntmb,ntmb)
          i = idalloc('vcoul',allocvb()+4,ntmb,ntmb*2)
          deallocate(ppovl,vcoul,ww,evec,evl)

        enddo

        call rx0('finished making bare coulomb integrals')

      endif

C --- GW setup loop over k-points ---
      if (lchk >= 1 .and. job == 1) then

        ifi = fopna('normchk',-1,0); rewind ifi
        write(ifi,849)
  849   format('#     eval          IPW    ',
     .         '    IPW(diag) ',
     .         '   Onsite(tot)',
     .         '   Onsite(phi)',
     .         '      Total')
      endif

C --- Band mode ---
      if (bandmode .and. jobb == 0 .and. gwcode == 0) then
        if (pwmode /= 0) call rx('band mode not ready for APW')
        ndimh = ldim + napw
        allocate(iiyf(ndimh),ibidx(ndimh,nsp),ovv(ndimh,ndimh),
     .          cphi_p(ndima,ndimh,nsp),evl_p(ndham,nsp))

C   ... Open LBAND files
        do  isp = 1, nsp
          if (isp==1) iflband(isp) = fopnx('LBAND.UP',2,6,-1)
          if (isp==2) iflband(isp) = fopnx('LBAND.DN',2,6,-1)
          write(iflband(isp)) ndimh,nqnum
          write(iflband(isp)) plat,qlat
        enddo

C   ... Read SYML file
        nlinemax = 50
        allocate(nqq(nlinemax),qq1(1:3,nlinemax),qq2(1:3,nlinemax))
        ifsyml = fopnx('SYML',2,1,-1)
        nline = 0
        do
          nline = nline + 1
          read(ifsyml,*,err=601,end=601)
     .      nqq(nline),qq1(1:3,nline),qq2(1:3,nline)
        enddo
  601   continue
        call fclose(ifsyml)
        nline = nline - 1
        qpos  = 0d0
        iline = 1
        if (nline == 0) call rx('sugw: no lines in SYML file')
      elseif (bandmode .and. jobb == 5 .and. (gwcode == 0 .or. gwcode == 2)) then
        ifqeigen = fopnx('Qeigval',2,1,-1)
        read(ifqeigen,*) nqnum
        ifeigen = fopnx('eigval',2,4,-1)
        write(ifeigen) ndham,nqnum,nsp
      endif

C ... Write, or read past, ngpmx,npmbx
      if (gwcode == 0 .or. gwcode == 2) then
        if (rank0) then
        if (job == 1) then
          ifi = fopna('gwb',-1,4)
          if (gwcode == 0) write(ifi) ngpmx,npmbx
          if (gwcode == 2) write(ifi) ngpmx
        else
          ifi = fopna('gwb',-1,4)
          read(ifi)
        endif
        endif

        if (gwcode == 0) then
C         nnn = n1q*n2q*n3q  n1q,n2q,n3q no longer read in (takao sep 2003)
          nnn = nqbz
          if (job == 1) nqtot = nqnum
        else
C         nnn = nqibz (Takao Sep 2012)
          nqtot = nqnum
          nnn = nqibz
        endif
      else if (gwcode == 1) then ! data from kpts file
        nqnum = nqtot
        nnn = nqtot
      endif

C ... Setup for qp read from QIBZ
      if (job==1 .and. (gwcode == 0 .or. gwcode == 2)) then
        if (gwcode == 0) then
          if (nqnum < nnn) call rxi('sugw: nqnum < nnn, nqnum=',nqnum)
          ifi = fopnx('QIBZ',2,1,-1); rewind ifi
          read(ifi,*) nqibz
        endif
      endif

C ... Headers for evecs and matrix elements of vxc files for irr qp ---
C     lwsig = LW19 : read 'vxc' and write 'vxcsig'
C     lwsig = LW9  : generate vxc and write 'vxcsig'
C     lwvxc = 1,   : write 'vxc' and 'evec'
      lwvxc = isw(job==1 .and. .not. bandmode .and. .not. lwsig/=0 .and.
     .        .not. cmdopt('--novxc',7,0,strn))
      if (lwsig == LW19) then
        ifi = fopna('vxc',-1,4); rewind ifi
        if (rank0) read(ifi) i,j,k
        if (i/=ndham .or. j/=nsp .or. k/=nqibz) call rx('sugw failed to read vxc header')
      elseif (lwvxc>0) then
        if (gwcode == 1) then
          ifi = fopnx('vxc',2,4,-1)
          call rx('sugw revisit spex branch')
          call iosigh(0,7,nsp,nspc,ndham,nlmto,n1q,n2q,n3q,nqtot,nqtot,0,0,0,-ifi,(/0d0,0d0/))
        else
          ifi = fopna('vxc',-1,4); rewind ifi
          if (rank0) write(ifi) ndham, nsp, nnn

          ifi = fopna('evec',-1,4); rewind ifi
          if (rank0) call iosigh(0,5,nsp,1,ndham,nlmto,s_gw%nkabc(1),s_gw%nkabc(2),s_gw%nkabc(3),
     .      nnn,nqi,0,0,0,-ifi,[0d0,0d0])
        endif
      endif

C --- Main loop for eigenfunction generation ---
      if (gwcode == 0 .or. gwcode == 2) then
        if (job == 1 .and. bandmode) call info2(20,1,1,
     .   ' ... Make LDA eigenvalues, %i qp (file eigval)',nqtot,0)
        if (job == 1 .and. .not. bandmode) call info5(20,1,1,
     .    ' ... Make w.f. and matrix elements, %i qp'//
     .    '%?#n#%-1j (%i irr)##: file(s) gwb%?#n#, vxc, evec##%?#n#%-3fvxcsig##',
     .    nqtot,nqi,lwvxc,lwsig,0)
      else
        if (job == 1 .and. .not. bandmode) call info2(20,1,1,
     .    ' ... Make LDA eigefunctions, %i qp (files'//
     .    ' evals, evcof, vxc%?#n#, evec##)',nqtot,lwvxc)
      endif

C ... Setup for main k loop, distributing load among processors
C     This loop assigns weight of 1 or 0 to each qp,
C     depending on whether is to be calculated or not.
      allocate(kpproc(0:nproc))
      kpproc(0) = 1; kpproc(1) = nqtot+1 ! Serial case
      if (rank0 .and. nproc > 1) then
        allocate(ww(nqtot))
        do  iq = 1, nqtot
          ww(iq) = 0
          read(ifiqg)  q,  ngp, irr
          read(ifiqg)
          if (irr==1) ww(iq) = 1
        enddo
        rewind ifiqg  ! Reset file pointer
        read(ifiqg)
        if (sum(ww) /= nqi) call rx('sugw: nqi mismatch') ! Sanity check
        if (nproc > nqi) call rxi('MPIK job cannot allocate more processors than nqi =',nqi)
        call dstrbpx(nqtot,nproc,ww,kpproc)
        deallocate(ww)
      endif
      call mpibc1(kpproc,nproc+1,2,.false.,'sugw','kpproc')

C Writes file in Takao's format for compatibility with his codes
C#ifdefC TAKAO
C      numproc = max(numprocs,1)
C      nbalance = nqi*nsp/numproc
C      if(mod(nqi*nsp,numproc)/=0) nbalance = nbalance+1
C      if (iprint()>10) print *,'nbalance=',nbalance
C      iproc = numproc-1         !from bottom
C      allocate(iproct(nqi,nsp))
C      iqq  = 0
C      iadd = 0
C      do iq = 1, nqtot
C         read(ifiqg)  q,  ngp, irr
C         read(ifiqg)
C         if(irr==0) cycle
C         iqq = iqq + 1
C         do isp  = 1, nsp
C            iadd = iadd+1
C            iproct(iqq,isp)=iproc
C            if(iadd == nbalance) then
C               iproc = iproc-1
C               iadd = 0
C            endif
C         enddo
C      enddo
C      rewind ifiqg              ! Reset file pointer
C      read(ifiqg)
C      nrr=iqq
C      if(nqi/=nrr) call rxi('sugw: nqi/=nrr=',nrr)
C      if(rank0) then
C         ifiproc = fopnx('lmfgw_kdivider',2,2,-1)
C         call fextg(ext)
C         write(ifiproc,"(a,'    ! extension ')") trim(ext)
C         write(ifiproc,"(3i10,'    ! nqi nsp numproc')")
C     .     nqi,nsp,numproc
C         do isp=1,nsp
C         do iqq=1,nqi
C            write(ifiproc,"(3i9,'  ! iqq isp irank')")
C     .       iqq, isp, iproct(iqq,isp)
C         enddo
C         enddo
C         call fclose(ifiproc)
C      endif
C#endif

C ... Write header information for file vxcsig.  Get qp list in same order as file sigm.
      if (lwsig == LW9 .or. lwsig == LW19) then
C       Warning: nqibz was read from QIBZ file and s_gw%nkabc from ctrl file. They may not be consistent.
C       Check at least whether the number of irreducible points match.
        allocate(qpgw(3,s_gw%nkabc(1)*s_gw%nkabc(2)*s_gw%nkabc(3)))  ! Don't know nkp in advance => space for full BZ
        call bzmshp('  SUGW',1,s_gw%nkabc,s_gw%lshft,plat,s_lat%symgr,s_lat%nsgrp,s_lat%nsgrp,
     .    .false.,0,0,qb,nkp,qpgw,xx,xx,xx)
        if (nkp /= nqibz) call
     .    rx2(' sugw (warning) q-point mismatch QIBZ has %i but expected %i from GW_NKBAC',nqibz,nkp)
        ifi = fopna('vxcsig',-1,4); rewind ifi
        call iosigh(0,mod(lwsig,10),nsp,nspc,ndimh,nlmto,s_gw%nkabc(1),s_gw%nkabc(2),s_gw%nkabc(3),
     .    nqibz,nqibz,0,0,0,-ifi,0*s_ham%eseavr)
        allocate(vxcsig(ndham,ndham,nqibz,nsp)); vxcsig(1,1,:,:) = NULLI  ! Flags which qp are copied
      endif

C  --- Loop over k-points ---
C     Jobs 1,2,4,5 all use this loop, but only job 1 is maintained
      iqibz = 0 ! counter incremented each time a qp is actually calculated
      if (gwcode == 0 .or. gwcode == 1) then
        allocate(iprocq(nqtot)) ! Needed by lmf2gw: procid that calculates point iq
      elseif (gwcode == 2) then
        allocate(iprocq(nqi))   ! Needed by lmf2gw: procid that calculates point iq
      endif
      iprocq = 0
      do  iq = 1, nqtot

        if (jobb == 5) then
          read(ifqeigen,*) q
          goto 1021
        endif

        if (gwcode == 0 .or. gwcode == 2) then
          if (gwcode == 0) then
            read (ifiqg)  q,  ngp ! q, and number of G vectors for
                                  ! eigenfunction expansion at this q
            read (ifiqgc) qx, ngc ! q, and number of G vectors for
                                  ! expansion of the Coulomb interaction
            if (abs(sum(q-qx)) > 1d-10) then
              print *, q
              print *, qx
              call rx(' sugw : abs(sum(q-qx))>1d-10')
            endif
            lwvxc = isw(lwvxc>0 .and. iq<=nnn)
            irr = 1             ! Generate bands for every qp
          else
            read (ifiqg)  q,  ngp, irr ! q, and number of G vectors for
                                       ! eigenfunction expansion at this q
            if (cmdopt('--wevec:gw',10,0,strn) .and. iqibz>nqibz) then
              lwvxc = 2*isw(lwvxc>0 .and. iqibz<=nqi)
            else
              lwvxc = isw(lwvxc>0 .and. iqibz<=nqibz)
            endif
          endif
          if (irr == 1) iqibz = iqibz+1
          if ((lwsig==LW9 .or. lwsig==LW19) .and. iqibz>nqibz) exit

          if (allocated(ngvecp)) deallocate(ngvecp)
          allocate(ngvecp(3,max(ngp,1)))
          read (ifiqg)  ngvecp
          if (gwcode == 0) then
            allocate(ngvecc(3,max(ngc,1),1))
            read (ifiqgc) ngvecc
            if (job /= 1) deallocate(ngvecp, ngvecc)
          else
            if (job /= 1) deallocate(ngvecp)
          endif
C         Continue only for procid associated with this qp
          if (irr==0 .or. iq<kpproc(procid) .or. iq>=kpproc(procid+1)) cycle

          iprocq(iqibz) = procid

        elseif (gwcode == 1) then

          lwvxc = 1
          if (cmdopt('--novxc',7,0,strn)) lwvxc = 0

          ifi = fopnx('kpts',2,1,-1)
          call pshpr(1)
          call spex_read_k(ifi,qlat,qpscale,q,xx(1))
          call poppr

C         debugging
C         q = (/1d0,0.5d0,0d0/); print *, 'q',q

C         Get ngp for this qp
          call pshpr(1)
          call gvlst2(alat,plat,q,0,0,0,0d0,gcutb,0,0,1,ngp,dum,dum,dum,dum)
          call rx('sugw: check sugvec')
          inn = 0
          call sugvec(s_lat,64,q,0d0,gcutb,inn,0,ngp)
          call poppr

C         Get ngvecp for this qp
          if (job /= 1) then
          else
            allocate(ngvecp(3,max(ngp,1)))
            call iinit(ngvecp,3*max(ngp,1))
            allocate(kv(3*max(ngp,1)))
            call pshpr(1)
            call gvlst2(alat,plat,q,0,0,0,0d0,gcutb,0,002,1,ngp,kv,xx,xx,ngvecp)
            call poppr
            deallocate(kv)
          endif
        else !
          call rx('gwcode not recognized')
        endif

 1021   continue  ! Re-entry point for jobb=5

C   --- Possibly shorten q vector ---
C       For complications regarding APWs and q vector shortening,
C       see comments before call to pwmat.
        lsapw = .true.
        if (s_ctrl%lfp/2/=0 .and. .not. cmdopt('--shorbz=no',11,0,strn)) then
C         call shorbz(q,qp,qlat,plat)
          call shorps(1,qlat,(/72,2,2/),q,qp)
          if (ipr > 41 .and. dlength(3,q-qp,1) > 1d-8) write (stdo,578) iq,q,qp
  578     format(' iq=',i4,'  q=',3f7.3,'  shortened to',3f7.3)
        else
          qp = q
          if (mod(pwmode/10,10) == 1) lsapw = .false.
        endif

C   --- For this qp, G vectors for PW basis and hamiltonian dimension ---
        if (pwemax > 0 .and. mod(pwmode,10) > 0) then
          pwgmin = dsqrt(pwemin)
          pwgmax = dsqrt(pwemax)
          call dpzero(xx,3)
          if (mod(pwmode/10,10) == 1) call dpcopy(qp,xx,1,3,1d0)
          call pshpr(iprint()-10)
          call sugvec(s_lat,100000+64+16+2,xx,pwgmin,pwgmax,0,0,napw)
          s_lat%napw = napw
          call poppr
          ndimh = ldim + napw
          if (mod(pwmode,10) == 2) ndimh = napw
          if (ndimh > ndham) then
            call fexit2(-1,111,'%N Exit -1 : SUGW: ndimh=%i exceeds ndham=%i.'//
     .        '  Try increasing input NPWPAD',ndimh,ndham)
          endif
        else
          ndimh = ldim
C         nullify(s_lat%igv2)
        endif
        ndimhx = ndimh*nspc

C       Allocate various arrays.  In the SO case, still a loop isp=1..2
        if (nspc3 > nspc) then
          allocate(ham(ndimh,ndimh,3),ovl(ndimh,ndimh,3))
          call zinit(ham,ndimh**2*3) ! isp=3 holds L+S-
          call zinit(ovl,ndimh**2*3)
          allocate(evec(ndimh,ndimh),vxc(ndimh,ndimh,nspc3))
          allocate(cphi(ndima,ndimh,nsp),cphin(2,ndimh,nsp))
          call zinit(cphi,ndima*ndimh*nsp)
          call dpzero(cphin,2*ndimh*nsp)
        else
          allocate(ham(ndimhx,ndimhx,1),ovl(ndimhx,ndimhx,1))
          call zinit(ham,ndimhx**2)
          call zinit(ovl,ndimhx**2)
          allocate(evec(ndimhx,ndimhx),vxc(ndimh,ndimh,nspc3))
          allocate(cphi(ndima,ndimhx,nsp),cphin(2,ndimhx,nsp))
          call zinit(cphi,ndima*ndimhx*nsp)
          call dpzero(cphin,2*ndimhx*nsp)
        endif
        if (bandmode .and. jobb == 0) then
          allocate(geig(max(ngp,1),ndimh,nsp))
        endif

C   ... For each spin, do
        do  isp = 1, nsp

        ispc = min(isp,nspc3)    ! index to where h,s,vxc are stored (hambls)

C   --- Read LDA vxc from vxc file ---
        if (lwsig == LW19) then
          ifi = fopna('vxc',-1,4)
          read(ifi) i,j,qx ! shortened q
          if (i/=ndimh .or. j/=ldim .or. dlength(3,qx-qp,1)>1d-6) call rx('sugw vxc mismatch')
          read(ifi) qx,vxc(:,:,ispc) ! original q, vxc(q)

C   --- Calculate LDA vxc for given density ---
        else
C     ... vxc <- LDA Hamiltonian without vxc for this qp
          alfa = 0
          if (nspc == 2) call rx('SO=1 not implemented for QSGW ... try SO=3')
          call hambl(100,s_site,s_spec,s_lat,s_ham,isp,qp,k1,k2,k3,
     .      s_pot%smpoth,s_pot%smvcnst,s_pot%lcplxp,alfa,ndimh,napw,
     .      s_lat%igv2,vxc(1,1,ispc),ovl(1,1,ispc),xx)
C         call zprm('h-vxc',12,vxc(1,1,ispc),ndimh,ndimh,ndimh)
          call dscal(ndimh**2*2,-1d0,vxc(1,1,ispc),1)

C     ... LDA Hamiltonian and overlap matrices for this qp ---
          call hambl(0,s_site,s_spec,s_lat,s_ham,isp,qp,k1,k2,k3,
     .      s_pot%smpot,s_pot%smvcnst,s_pot%lcplxp,alfa,ndimh,napw,s_lat%igv2,
     .      ham(1,1,ispc),ovl(1,1,ispc),xx)
C         call zprm('ham',12,ham(1,1,ispc),ndimh,ndimh,ndimh)
C         call zprm('ovl',2,ovl(1,1,ispc),ndimh,ndimh,ndimh)
C     ... vxc <- LDA vxc
          call daxpy(ndimh**2*2,1d0,ham(1,1,ispc),1,vxc(1,1,ispc),1)
        endif

C   --- Copy vxc to holding array or write matrix elments of vxc to disk (Faleev May 2002) ---
        if (lwsig==LW9 .or. lwsig==LW19) then
          call findqbz(nqibz,qpgw,plat,1d-5,qp,is)
          if (is < 0) call rx('sugw: qp does not match any in GW list')
          call dcopy(2*ndham*ndham,vxc(1,1,ispc),1,vxcsig(1,1,is,isp),1)
          cycle                 ! no GW driver files in this mode

        elseif (lwvxc==1 .and. (gwcode == 0 .or. gwcode == 2)) then
          ifi = fopna('vxc',-1,4)
C         write(ifi) ndimh  ! added Mar 2011, for updated hqpe_sc
          write(ifi) ndimh, ldim,qp !Add ldim sep2012
          write(ifi) q,vxc(:,:,ispc)
!         print *, 'vxcq',sngl(q)
C         call zprm('1000 vxc',2,1000*vxc,ndimh,ndimh,ndimh)
        endif

C   --- Optionally overwrite vxc with vxc + (sigm-vxc) ---
C       This branch is also used for LW9 (generate vxc and write to vxcsig file)
        if (cmdopt('--vxcsig',8,0,strn)) then
          if (mod(lso,10) == 1) call rx('sugw: cannot yet generate sigma with SO')
          if (lrsig == 0) call rx('sugw: no sigma to generate')
          lpdiag = 0
          ispc = min(isp,nspc3)
          i = 5000 + lrsig*10 + 1
C         call zprm('vxc',2,vxc,ndimh,ndimh,ndimh)
C         Copy ham and ovl into dummy arrays testc and evec to preserve originals
          allocate(testc(ndimhx,ndimhx))
          call zcopy(ndimhx**2,ham(1,1,ispc),1,testc,1)
          call zcopy(ndimhx**2,ovl(1,1,ispc),1,evec,1)
          call hambls(i,s_site,s_spec,s_lat,s_ham,nbas,isp,1,qp,k1,k2,k3,s_ham%qsig,nqsig,
     .      s_pot%smpot,s_pot%smvcnst,s_pot%lcplxp,0,alfa,ndimh,testc,evec,xx,i2,nevl)
C         call zprm('sigm-vxc',2,evec,ndimh,ndimh,ndimh)
C         vxc = vxc + Bloch-summed sigm
          call daxpy(2*ndimhx**2,1d0,evec,1,vxc(1,1,ispc),1)

C     --- Write sigma to file ---
          deallocate(testc)
        endif

C   --- LDA eigenvectors, LMTO basis ---
C        Using LDA evecs to rotate GW sigma doesn't work well... symmetry violated
C        if (s_gw%lsigint == 1 .and. lwvxc>0) then
C          if (nspc == 2) then
C            call rx('sugw not ready for evecl, spin coupled case')
C          endif
C          allocate(pwz(ndimhx,ndimhx),pwh(ndimhx,ndimhx))
C          allocate(ww(ndimhx*ndimhx+ndimhx))
C          call zcopy(ndimhx**2,ham(1,1,ispc),1,pwh,1)
C          call zcopy(ndimhx**2,ovl(1,1,ispc),1,pwz,1)
C          call zhevx(nlmto,ndimh,pwh,pwz,1,.true.,nlmto,1d60,nev,
C     .      ww(1+ndimhx),.false.,ww,ndimh,evec)
CC         call setpr(60)
CC         call prtev(evec,ndimh,ww,ndimh,1d60,nev)
C          deallocate(pwz,pwh,ww)
C          ifi = fopna('evecl',-1,4)
C          write(ifi) q, evec(1:nlmto,1:nlmto)
CC         call zprm('evecl',2,evec,ndimh,nlmto,nlmto)
C        endif

C   --- LDA + sigma Hamiltonian for this qp ---
        lpdiag = 0
        i = lrsig*10 + 1
        if (lso /= 0) i = lrsig*10
        ispc = min(isp,nspc3)
C       print *, '!!'; i = i+2 ! This should not affect the result

        passl = .false.
C        if (.false.) then
        if (nlmto/=ndham .and. .not. passl .and. lwvxc>0) then
          passl = .true.
          ndimhs = ndimh
          napws = napw
          ndimhxs = ndimhx
          napw = 0
          ndimh = nlmto
          ndimhx = ndimh*nspc
          s_lat%napw = 0
          i = lrsig*10
        endif
   10   continue  ! Re-entry point for PMT hamiltonian

        call hambls(i,s_site,s_spec,s_lat,s_ham,nbas,isp,ispc,qp,k1,k2,k3,s_ham%qsig,nqsig,
     .    s_pot%smpot,s_pot%smvcnst,s_pot%lcplxp,lso,alfa,ndimh,ham,ovl,xx,i2,nevl)
CML        call hambls(i,s_site,s_spec,s_lat,s_ham,nbas,isp,ispc,qp,
CML     .    k1,k2,k3,s_ham%qsig,nqsig,smpot,vconst,lcplxp,lso,alfa,ndimh,
CML     .    ham,ovl,xx,i2,nevl)

        if (nspc3 > nspc) then
          if (isp == 1) cycle
        elseif (ispc/=nspc) then
          cycle
        endif

C       Noncollinear case or lso=3 => H now available for both spins
C       For the rest of the isp loop:
C         jsp=isp in the collinear case
C         jsp=1   in the full noncollinear, nspc=2
C         jsp=1,2 in the pert noncollinear, nspc3=2 and nspc=1
C       Thus jsp should be used in place of isp.
C       isp serves as a flag for the noncollinear case
C       lso = 1 should also work ... substitutes for sopert branch below
C       if (lso == 3 .and. i /= -1) then
        if (lso == 4) call rx('sugw not ready for lso=4')
        if ((lso == 1 .or. lso == 3) .and. i /= -1) then
          call sopert3(10*lso,s_ham,ndimh,ham,ovl,xx)
          nevl = ndimh
          i = -1
        endif

C       Re-entry point for loop over jsp=1,2 (nspc3=2 and nspc=1)
        jsp = isp                 ! Evals,etc go into channel jsp
        if (nspc3 == 2) jsp = 1
   20   continue

C   ... Special handling of evals made by hambls
        if (i == -1) then
          lpdiag = 2 ! evals made by hambls
          if (.not. allocated(nevls)) then
            allocate(nevls(1,1))
            nevls = 0
          endif
          nevls(1,1) = nevl
          if (.not. passl) mnevl = min(nevl,mnevl)
C         nevl = ndimh
        endif

C   --- Branch job = 1 : make cphi, matrix elements ---
        if (job == 1) then

C   --- Diagonalize ---
C       call zprm('ham',2,ham,ndimh,ndimh,ndimh)
C       call zprm('ovl',2,ovl,ndimh,ndimh,ndimh)
        if (mod(iq,10) /= 1) call pshpr(iprint()-6)
        call info5(30,0,0,' sugw:  kpt %i of %i, k=%3:2,5;5d',iq,nqtot,qp,0,0)
        if (lpdiag == 1) then
          call rx('sugw: parallel diagonalization not implemented')
        elseif (lpdiag == 2) then
          if (nevls(1,1) /= ndimh) call info2(30,0,0,' Ham dim reduced to %i',nevls(1,1),0)
C         evec = ovl
          call zcopy(ndimhx**2,ovl,1,evec,1)
          call phmbls(2,ndimhx,ndimhx,evl(1,jsp),xx,xx,xx,xx,xx,ham)
          nev = ndimh
          call prtev(evec,ndimh,evl(1,jsp),ndimh,9d9,nev)
          if (.not. passl) etop = max(etop,evl(nev,jsp))
        else
          if (nspc == 2) then
            allocate(ww(ndimhx**2))
            call sopert(0,ndimh,nspc,ww,ham,ham)
            call sopert(0,ndimh,nspc,ww,ovl,ovl)
            deallocate(ww)
          endif
          allocate(ww(11*ndimhx))
          if (epsovl == 0 .and. ovncut == 0) then
            call zhev(ndimhx,ham,ovl,.true.,.true.,ndimh,1d60,nev,
     .        ww,.false.,-1,evl(1,jsp),evec)
            if (.not. passl) etop = max(etop,evl(nev,jsp))
            if (.not. passl) mnevl = min(nev,mnevl)
          else
            nevl = -1
            call dvset(ww,1,1,199d0)
            call zhevo(ndimh,ndimh,ham,ovl,ndimh,1d60,epsovl,
     .        ovncut,nevl,nev,evl(1,jsp),ww,ndimh,evec)
            if (.not. passl) then
            eomin = dval(ww,1)
            call info5(30,0,0,
     .        ' Overlap''s smallest eigenvalue: %;3g.  '//
     .        '%?#(n>0)#H dim reduced from %i to %i#H dim not reduced#',
     .        eomin,ndimh-nevl,ndimh,nevl,0)
            mnevl = min(nevl,mnevl)
            etop = max(etop,evl(nevl,jsp))
C           nev = min(nev,nevl)
            endif
          endif
          call prtev(evec,ndimh,evl(1,jsp),ndimh,1d60,nev)
          deallocate(ww)
        endif

C       Pad evals between ndimh and ndham with a large positive number
C       to avoid mixing up integration routines
        if (ndham > nev) then
          call dvset(evl(1,jsp),1+nev,ndham,199d0)
          do  i  = 1, ndham
            evl(i,jsp) = min(199d0,evl(i,jsp))
          enddo
        endif
C       call zprm('evec',2,evec,ndimh,ndimh,ndimh)
C       call prmx('eval',evl(1,jsp),ndham,ndimh,1)

C       Write LMTO evecs; redo with full hamitonian
        if (passl) then
          if (mod(iq,10) /= 1) call poppr
          allocate(pwz(ndimhx,ndimhx)) ! copy to work array since evec's dimensions are wrong
          call zcopy(ndimhx**2,evec,1,pwz,1)
C         print *, 'writing evecl',iq,ndimhx
          ifi = fopna('evec',-1,4)
          write(ifi) q, pwz
C         call zprm('zl',2,pwz,ndimh,ndimh,ndimh)
          deallocate(pwz)
          allocate(evl_p(nlmto,1))
          call dcopy(nlmto,evl(1,jsp),1,evl_p,1)
          passl = .false.
          ndimh = ndimhs
          ndimhx = ndimhxs
          napw = napws
          s_lat%napw = napw
          i = lrsig*10
          goto 10
        else if (nlmto/=ndham .and. lwvxc>0) then
          if (ipr > 40) then
          call info0(41,1,0,' eigenvalues, compare PMT to LMTO basis')
          call arrprt('        ev(L)     ev(A)-ev(L)',
     .      '%,4i%;12,6D%;12,6D',
     .      'Idd',nlmto,0,3,0,'  | ',xx,evl_p,
     .      evl(1:nlmto,jsp)-evl_p(1:nlmto,1),xx,xx,xx,xx,xx)
          endif
          deallocate(evl_p)
        endif

        ebot = min(ebot,evl(1,jsp))

        if (bandmode .and. jobb == 5) then
          write(ifeigen) evl(1:ndham,jsp)
          if (mod(iq,10) /= 1) call poppr
          goto 30
        endif

        if (mod(iq,10) /= 1) call poppr

C   ... Write evecs to file
        if (lwvxc>0) then
          ifi = fopna('evec',-1,4)
          if (nev /= ndimhx) call rx('sugw oops')
          write(ifi) q, ndimhx, nev
          call dpdump(evl(1,jsp),nev,-ifi)
          call dpdump(evec,ndimhx*ndimhx*2,-ifi)
C         call zprm('z',2,evec,ndimhx,ndimhx,ndimhx)
        endif

C   ... Evecs from LMTO part of hamiltonian (OVERWRITES ham,ovl)
C        if (gwcode==2 .and. nlmto/=ndham .and. lwvxc>0) then
CC         Construct effective hamiltonian, overlap corresponding to (evl,evec)
CC         Inverse z^-1, where z = eigenvectors
C          allocate(pwz(ndimhx,ndimhx)) ! a work arry
C          call zcopy(ndimhx**2,evec,1,pwz,1)
C          call zqinv('n',pwz,ndimh,-ndimh**2,ndimh,ham,ndimh,i)
CC         call zprm('z^-1',2,pwz,ndimh,ndimh,ndimh)
C
CC         Hamiltonian
CC         call prmx('evals',evl,ndimh,ndimh,1)
C          do  i2 = 1, ndimh
C            do  i1 = 1, ndimh
C              ovl(i1,i2,1) = evl(i1,jsp)*pwz(i1,i2)
C            end do
C          end do
CC         call zprm('e*z^-1',2,ovl,ndimh,ndimh,ndimh)
C          call zgemm('C','N',ndimh,ndimh,ndimh,one,pwz,ndimh,ovl,
C     .      ndimh,zer,ham,ndimh)
CC         call zprm('ham',2,ham,ndimh,ndimh,ndimh)
C
CC         Overlap
C          call zgemm('C','N',ndimh,ndimh,ndimh,one,pwz,ndimh,pwz,
C     .      ndimh,zer,ovl,ndimh)
CC         call zprm('ovl',2,ovl,ndimh,ndimh,ndimh)
C
CC         Eigenvectors from LMTO part of basis
C          allocate(ww(ndimhx*ndimhx+ndimhx))
C          call zhevx(nlmto,ndimh,ham,ovl,1,.true.,nlmto,1d60,i2,
C     .      ww(1+ndimhx),.false.,ww,ndimh,pwz)
CC         call zprm('evecs',2,pwz,ndimh,nlmto,nlmto)
CC          if (ipr >= 41) then
CC          call info0(41,1,0,' eigenvalues, compare PMT to LMTO basis')
CC          call arrprt('        evl(P)      evl(L)','%,4i%;12,6D%;12,6D',
CC     .      'Idd',nlmto,0,3,0,'  | ',xx,ww,ww(1:nlmto)-evl(1:nlmto,jsp),
CC     .      xx,xx,xx,xx,xx)
CC          endif
C          write(ifi) q, pwz(1:nlmto,1:nlmto)
C          deallocate(ww,pwz)
CC         pause
C        endif

C  ...  spex mode: save for this qp 3 records:
C       iq,jsp,ngp,nev
C       ngvecp
C       evl
        if (gwcode == 1) then
          ifi = fopnx('evals',2,4,-1)
          write(ifi) iq,jsp,max(ngp,1),nev
          write(ifi) ngvecp
C         Convert evl from Ry to Hartree for spex
          call dscal(nev,0.5d0,evl,1)
          write(ifi) evl(1:nev,jsp)
C         Restore evl to Ry
          call dscal(nev,2d0,evl,1)
        endif

C   --- Project wf into augmentation spheres, Kotani conventions ---
        nlmax = nglob('mxorb') / nglob('nkaph')
        allocate(aus(nlmax,ndhamx,nphimx,nsp,nbas)); call dpzero(aus,2*size(aus))
        if (gwcode == 0 .or. gwcode == 2) i = 1  ! fpgw requires real spherical harmonics
        if (gwcode == 1) i = 11 ! spex requires complex spherical harmonics
        call makusq(i,s_site,s_spec,s_lat,s_ham,nbas,nbas,0,nlmax,0,ndham,nphimx,ndimh,napw,
     .    s_lat%igv2,nev,nsp,nspc,nsp,jsp,1,qp,evec,ppn,aus,xx)
        call gwcphi(s_site,s_spec,jsp,nsp,nlmax,ndham,nphimx,nev,nbas,ipb,lmxax,
     .    nlindx,ndima,ppn,aus,cphi(1,1,jsp),cphin(1,1,jsp))
        deallocate(aus)

C   --- Overlap of IPWs, PW expansion of eigenfunctions pwz ---
C       The IPW basis consisting of PWs with holes knocked out of spheres,
C       IPWs must be orthogonalized: IPW -> IPWbar; see PRB 76, 165106.
C         |IPWbar_G> = sum_G2 |IPW_G2> O^-1_G2,G1, where O_G1,G2=<IPW_G1|IPW_G2>
C       Definitions
C     * ppovl = overlap of IPWs (Generated by pwmat and pwmat2)
C         ppovl_G1,G2 = O_G1,G2 = <IPW_G1 IPW_G2>
C     * pwh = PW expansion of basis function (Generated by pwmat2 only)
C         basis_j> = sum_G2 PWH_G2,j |IPW_G2>
C     * Matrix elements (overlap) of IPW and basis function (Generated by pwmat only)
C         phovl_G1,j = sum_G2 ppovl_G1,G2 pwh'_G2,j  (matrix form PHOVL = O * PWH')
C         Note: phovl is only used as an intermediate construction, pwmat branch
C     * Note: pwh' is expanded to the LMTO cutoff gmax while
C             pwh  is expanded to the GW cutoff QpGcut_psi
C       Thus O^-1 PHOVL will not identically recover PWH.
C       The original branch (pwmat) uses effectively PWH'; pwmat2 uses PWH.
C       This is a major distinction between the two (see Remarks)
C     * PW expansion of eigenfunction:
C         |psi_n> = sum_j z_jn |basis_j>
C     * Define pwz_G,n = sum_j PWH_G2,j z_jn  (in matrix form: PWZ = PWH Z)
C       Then
C         |psi_n> = sum_j,G2 z_jn PWH_G2,j |IPW_G2> = sum_G2 PWZ_G2,n |IPW_G2>
C       Overlap of IPW and eigenfunction:
C         PZOVL_G1,n = <IPW(G1) psi_n> = sum_G2 O_G1_G2 PWZ_G2,n
C         PZOVL = O * PWZ (matrix form) --- old
C         Note: pzovl is only used as an intermediate construction, old branch
        allocate(ppovl(ngp,ngp),pwz(ngp,ndimh))
        if (ngp > 0) then

C Takao Apr 2009 correct for shortening of q vector
C In pwmat, G vector ig of APW basis is specified by igv2(ig)
C The true basis vector is q+G, and the vector is specified by igv2(ig)
C         But q may be shortened to qp.  The basis vector index changes to
C           igv2[ig] + qlat^-1*(qp-q)
C         The following indicates when qlat^-1*(qp-q) should be added to igv2:
C         APW   q shortened before call to sugvec    q not shortened
C          G             yes                            yes
C         q+G            yes                            no
C         If 'yes' => lsapw=T.  Pass to pwmat:
C         (lsapw=T) inn = qlat^-1*(qp-q) = plat^T*(qp-q)  (lsapw=F) inn=0
          if (lsapw) then
            call shorps(1,qlat,(/72,2,2/),q,xx)
            call dgemm('T','N',3,1,3,1d0,plat,3,xx(1:3)-q,3,0d0,dnn,3)
            inn = nint(dnn)
          else
            inn = 0
          endif
C Debugging:check against takao's orginal version qlat^-1*(qp-q)
C         call dinv33(qlat,0,qlatinv,dum)
C         call rtoint(matmul(qlatinv,qp-q),inn,3)
C         inn = inn - nint(dnn)
C         if (inn(1)**2+inn(2)**2+inn(3)**2) stop 'something wrong'
C     ... Old convention: call pwmat
          if (lnwpwm == 0) then
C           i = idalloc('phovl',allocvb()+2,ngp,ndimh)
            allocate(phovl(ngp,ndimh))
            call pwmat(s_lat,s_site,s_spec,2,nbas,nlmax,ndimh,
     .        s_ham%iprmb,q,ngp,ngp,ngvecp,gmax,inn,ppovl,phovl)
C           PZOVL = PHOVL Z stored in pwz
            call zgemm('N','N',ngp,ndimh,ndimh,(1d0,0d0),phovl,ngp,
     .        evec,ndimh,(0d0,0d0),pwz,ngp)
C           i = idalloc('phovl',allocvb()+4,ngp,ndimh)
            deallocate(phovl)
C           call zprm('ppovl',2,ppovl,ngp,ngp,ngp)
C           call zprm('pzovl = ppovl * pwz',2,pwz,ngp,ngp,ndimh)
            if (lchk >= 1) then
              allocate(pzovl(ngp,ndimh))
              pzovl = pwz
              allocate(ppovld(ngp)) ! extract diagonal before ppovl overwritten
              do  i = 1, ngp
                ppovld(i) = ppovl(i,i)
              enddo
            endif
            allocate(wk(ngp,129))
C           PWZ <- PPOVL^-1 PHOVL Z = PWH Z
            call zqinvb('hl',ppovl,ngp,ngp,ndimh,wk,ngp,wk,pwz,ngp,ierr)
            if (ierr /= 0) call rx('zqinvb failed to invert ppovl')
            deallocate(wk)
C           call zprm('pwz',2,pwz,ngp,ngp,ndimh)

C     ... New convention: call pwmat2
          else
            allocate(pwh(ngp,ndimh))
            call pwmat2(s_lat,s_site,s_spec,3,nbas,nlmax,ndimh,
     .        s_ham%iprmb,q,ngp,ngvecp,inn,ppovl,pwh)
C           call zprm('pwh',2,pwh,ngp,ngp,ndimh)
C           Make PWZ = PWZ * Z
            call zgemm('N','N',ngp,ndimh,ndimh,(1d0,0d0),pwh,ngp,
     .        evec,ndimh,(0d0,0d0),pwz,ngp)
            deallocate(pwh)
C           call zprm('pwz',2,pwz,ngp,ngp,ndimh)
C           Diagonal part of ppovl
            if (lchk >= 1) then
              allocate(ppovld(ngp))
              do  i = 1, ngp
                ppovld(i) = ppovl(i,i)
              enddo
            endif
          endif
        endif

C   --- File output, job=1 ---
        if (gwcode == 0 .or. gwcode == 2) then
          ifi = fopna('gwb',-1,4)

C          allocate(evec_(ndimh,ndimh),evl_(ndimh,nsp),
C     .      cphi_(ndima,ndimh,nsp))
C          allocate( ngvecp_(3,ngp), ngvecc_(3,max(ngc,1)) )
C          allocate(pwz_(ngp,ndimh))
C          print *, '!!', iq
C          read(jfi) qx
C          read(jfi) evec_,evl_(1:ndimh,jsp),cphi_(:,:,jsp)
C          read(jfi)
C          read(jfi) ngvecp_, ngvecc_, pwz_
C          if (sum (qx(:) - q(:)) /= 0) then
C            print *, 'oops 0'
C          endif
C          if (sum (evec_(:,:) - evec(:,:)) /= 0) then
C            print *, 'oops 1'
C          endif
C          if (sum (evl_(1:ndimh,:) - evl(1:ndimh,:)) /= 0) then
C            print *, 'oops 2'
C          endif
C          if (sum (cphi_(:,:,:) - cphi(:,:,:)) /= 0) then
C            print *, 'oops 3'
C          endif
C          if (sum (ngvecp_(:,:) - ngvecp(:,:)) /= 0) then
C            print *, 'oops 4'
C          endif
C          if (sum (ngvecc_(:,:) - ngvecc(:,:)) /= 0) then
C            print *, 'oops 5'
C          endif
C          if (sum (pwz_(:,:) - pwz(:,:)) /= 0) then
C            print *, 'oops 6'
C          endif
C          deallocate(evec_,evl_,cphi_,ngvecp_,ngvecc_,pwz_)

          write (ifi) q, ndimh, iq
          write (ifi) evl(1:ndimh,jsp),cphi(:,:,jsp)
          if (gwcode == 0) then
            write (ifi) ngp,ngc
            write (ifi) ngvecp, ngvecc, pwz
          else
            write (ifi) ngp
            write (ifi) ngvecp, pwz
          endif

          ifi = fopna('gw1',-1,4)
          write(ifi) q, (evl(i,jsp),i=1,ndimh)
C         call prmx('e(H+sigma-vxc)',evl,ndimh,ndimh,1)

        else ! gwcode = 1
          ifi = fopnx('evcof',2,4,-1)
          write(ifi) iq,jsp,ngp,nev,q
          write(ifi) ngvecp
          write(ifi) pwz(:,1:nev) * dsqrt(s_lat%vol)
          write(ifi) cphi(:,1:nev,jsp)
        endif

C   ... Overlap checking.   Define:
C       Interstitial part of eigenfunction overlap:
C         <psi_n||psi_n'>
C         = sum_G1,G2 (pwz_G1,n|IPW_G1>)+  (pwz_G2,n'|IPW_G2>)
C         = sum_G1,G2 (pwz_G1,n)+ ppovl_G1,G2 (PWZ_G2,n')
C         = (PWZ)+ O (PWZ) = (PZOVL)+ (PWZ)  (old style)
        if (lchk >= 1 .and. ngp > 0) then

          allocate(testc(ndimh,ndimh),testcd(ndimh))
          if (lnwpwm == 1) then
            allocate(pzovl(ngp,ndimh))
            call zgemm('N','N',ngp,ndimh,ngp,dcmplx(1d0,0d0),
     .        ppovl,ngp,pwz,ngp,dcmplx(0d0,0d0),pzovl,ngp)
          endif
          call zgemm('C','N',ndimh,ndimh,ngp,(1d0,0d0),
     .      pzovl,ngp,pwz,ngp,(0d0,0d0),testc,ndimh)
          deallocate(pzovl)

C          call zprm('(PWZ)+^-1 O_i^-1 (PWZ)',2,testc,ndimh,ndimh,
C     .      ndimh)

          do  i = 1, ndimh
            testcd(i) = sum(dconjg(pwz(:,i))*ppovld*pwz(:,i))
          enddo
          deallocate(ppovld)

C         xx(1) = sum over all augmentation w.f.  cphi+ ovl cphi
C         xx(2) = sum over augmentation phi only.
C         xx(3) = IPW contribution to phi+ phi
C         xx(4) = IPW contribution to phi+ phi, using diagonal part only
          ifi = fopna('normchk',-1,0)
          if (abs(sum(q-qp)) > 1d-10) then
            write(ifi,555) iq,q,qp,inn
          else
            write(ifi,555) iq,q
          endif
  555     format('# iq',i5,'   q',3f11.6:'  shortened q',3f11.6,
     .      '  inn=',3i3)
          do  i1 = 1, ndimh
          xx(1) = cphin(1,i1,jsp)
          xx(2) = cphin(2,i1,jsp)
          do  i2 = 1, ndimh
C         xx(1) = sum(dconjg(cphi(1:ndima,i1,jsp))*cphi(1:ndima,i2,jsp))
C         xx(2) = sum(dconjg(cphi(1:nchan,i1,jsp))*cphi(1:nchan,i2,jsp))
          xx(3) = testc(i1,i2)
          xx(4) = testcd(i1)
          if (i1 == i2) then
            write(ifi,'(f12.5,5f14.6)')
     .        evl(i1,jsp),xx(3),xx(4),xx(1),xx(2),xx(1)+xx(3)
C         else
C           write(ifi,'(5f14.6)') xx(3),xx(4),xx(1),xx(2),xx(1)+xx(3)
          endif
          enddo
          enddo
          deallocate(testc,testcd)
          write(ifi,*)
C         write(198,*)
C         if (iq == 4) call rx0('done')

C   ... Band mode
        if (bandmode) then
          geig(:,:,jsp)= pwz
          if (jsp == 1) then
            if (iq == 1) q_p=q
            qpos = qpos + sqrt( sum((q-q_p)**2) )
            if (endofline) then
              iline = iline + 1
              endofline=.false.
            endif
            if (sum(abs(q-qq2(:,iline)))<1d-6) endofline = .true.
          endif

          if (iq == 1) then
            do  j = 1, ndimh
              ibidx(j,jsp) = j
            enddo
C           Should not be necessary, but avoids a bug in the DEC alpha compiler
            ngp_p = ngp
          else
            call tcn('bndconn')
            call bndconn_v2( alat,plat,qlat,
     i        nbas, rmt, bas, ndimh, ndima,
     i        evl(1,jsp),  ngp, ngp_p, ngvecp,ngvecp_p,
     i        geig(1,1,jsp),   geig_p(1,1,jsp),
     i        cphi(1,1,jsp), cphi_p(1,1,jsp), ovvx(1,1,jsp),
     o        iiyf,ovv)
C           Continuous band index:
            ibidx(1:ndimh,jsp) = iiyf(ibidx(1:ndimh,jsp))
            write(96+jsp,'(" ",    255i4)') iq,(j,      j=1,ndimh)
            write(96+jsp,'("     ",255i4)') (iiyf(j),j=1,ndimh)
            write(96+jsp,'("     ",255i4)')
     .        (int(10*ovv(iiyf(iix),iix)),iix=1,ndimh)
            call tcx('bndconn')
          endif
c----------------
c         write(95,"(' iline iq=',2i4 )") iline,iq
c         do ibr=1,ndimh  !takao for plot
c           write(95,"(i2,3i4,3f10.5, f16.7)") iline,iq,ibr,ibidx(ibr),
c     .     q(1:3),evl(ibidx(ibr))
c         enddo
c         write(95,*)
ccccccccccccccccccccccccccccccc
          write(995,"(i2,3f9.5,' ',f9.5,' ',255(i3,f10.5))") iline,
     .      q(1:3), qpos,
     .      (ibidx(ibr,jsp),evl(ibidx(ibr,jsp),jsp), ibr=1,ndimh)
c         print *,'--- ndimh=',ndimh
cccccccccccccccccccccccccccccccc

          write(iflband(jsp)) iline, q(1:3), qpos
     .      ,(ibidx(ibr,jsp),evl(ibidx(ibr,jsp),jsp),ibr=1,ndimh)

c         write(996,*)'iq=',iq, ' sum ibidx=',sum(ibidx(1:ndimh))

C     --- Save eigenfunctions of previous loop ---
          if(iq/=1 .and. jsp==nsp) deallocate(geig_p, ngvecp_p)
          if (jsp == nsp) then
            allocate(geig_p(ngp,ndimh,nsp), ngvecp_p(3,ngp))
            cphi_p = cphi
            geig_p = geig
            evl_p  = evl
            ngvecp_p = ngvecp
            ngp_p    = ngp
            q_p      = q
          endif
        endif                   ! end of band mode
        endif                   ! end of lchk=1

        deallocate(ppovl,pwz)
        if (jsp == nsp)  then
          if (gwcode==0) deallocate(ngvecp,ngvecc)
          if (gwcode == 1 .or. gwcode==2) deallocate(ngvecp)
        endif

C   --- Write out vxc information ---
        if (gwcode == 0 .or. gwcode == 2) then   ! fpgw

C     ... Subtract <psi|vxc|psi> from starting evl=e(lda+sigma-vxc)
C         evl should contain e(lda+sigma-vxc)
C         If --vxcsig is set, <psi|sigm-vxc+vxc|psi> is subtracted
          allocate(testc(ndimh,ndimh))
          call zgemm('C','N',ndimh,ndimh,ndimh,(1d0,0d0),
     .      evec,ndimh,vxc,ndimh,(0d0,0d0),testc,ndimh)
          do  i1 = 1, ndimh
            do  i2 = 1, ndimh
              evl(i1,jsp) = evl(i1,jsp) - testc(i1,i2) * evec(i2,i1)
            end do
          end do
C         call prmx('e(H+sigma-vxc-vxc)',evl,ndimh,ndimh,1)
C     ... Save to file gw2 energies e(lda+sigma-vxc-vxc)
C         If --vxcsig is set, <psi|vxc|psi> is subtracted
          ifi = fopna('gw2',-1,4)
          write(ifi) q, (evl(i,jsp),i=1,ndimh)
          deallocate(testc)

        elseif (gwcode == 1) then ! spex reads vxc in eigenfunction basis
C     ... Overwrite vxc with Z+ vxc Z
          allocate(testc(ndimh,ndimh))
C         call zprm('z',2,evec,ndimh,ndimh,ndimh)
C         call zprm('vxc',2,vxc,ndimh,ndimh,ndimh)
          call zgemm('C','N',ndimh,ndimh,ndimh,(1d0,0d0),
     .      evec,ndimh,vxc,ndimh,(0d0,0d0),testc,ndimh)
          call zgemm('N','N',ndimh,ndimh,ndimh,(1d0,0d0),
     .      testc,ndimh,evec,ndimh,(0d0,0d0),vxc,ndimh)
          deallocate(testc)
C         Convert vxc from Ry to Hartree for spex
          call dscal(ndimh**2*2,0.5d0,vxc,1)
          ifi = fopnx('vxc',2,4,-1)
          write(ifi) iq,jsp,ndimh,q
          write(ifi) vxc
C         call zprm('new vxc',2,vxc,ndimh,ndimh,ndimh)

        endif

        else
          call rx('sugw: job not recognized')
        endif

   30 continue
      if (jsp == 1 .and. nspc == 1 .and. nspc3 == 2) then
        jsp = 2
        call zcopy(ndimh**2,ham(1,1,2),1,ham,1)
        call zcopy(ndimh**2,ovl(1,1,2),1,ovl,1)
        call zcopy(ndimh**2,vxc(1,1,2),1,vxc,1)
        goto 20
      endif

      enddo ! Loop over spins
      deallocate(ham,ovl,evec,vxc,cphi,cphin)
      if (bandmode .and. jobb == 0) deallocate(geig)
      enddo ! Loop over qp

      if (lwsig==LW9 .or. lwsig==LW19) then
        ifi = fopna('vxcsig',-1,4); rewind ifi
        call iosigh(0,mod(lwsig,10),nsp,nspc,ndimh,nlmto,s_gw%nkabc(1),s_gw%nkabc(2),s_gw%nkabc(3),
     .    nnn,nnn,0,0,0,-ifi,0*s_ham%eseavr)
        do  isp = 1, nsp
          do  iq = 1, nqibz
            write(ifi) qpgw(1:3,iq),0d0
            if (vxcsig(1,1,iq,isp) == NULLI) call rxi('vxcsig not generated for qp',iq)
            write(ifi) vxcsig(:,:,iq,isp)
          enddo
        enddo
        call rx0('lmfgw mode=2 (write vxcsig)')
      endif

      if (lwvxc>0) then ! Mark end-of-file
        ifi = fopnx('vxc',2,4,-1)
        write(ifi) -1,-1,-1,q
      endif

      if (job == 1) then
        call info0(10,0,0,' ')
        call mpibc2(iprocq,size(iprocq),2,3,.false.,'sugw',iprocq)

        if (rank0) then
          ifi = fopnx('mpiqlst',2,2,-1)
          call fextg(ext)
          write(ifi,354) trim(ext),nqtot,size(iprocq),nproc
  354     format('# distribution of k by thread'/1x,a,3i6,
     .      "  #  ext nqtot nqirr nproc")
C         write(ifi,"(15i6)") kpproc  ! Not needed
          write(ifi,"(15i6)") iprocq
          call fclose(ifi)
        endif
      endif
      deallocate(kpproc,iprocq)

      if (job == 1 .and. mnevl < ndham) then
        call info2(10,0,0,' sugw: minimum reduced hilbert space = %i'//
     .    '%?#(n==1)# ... check NBAND in spex.inp# ... check nband_chi0 in GWinput#',
     .    mnevl,gwcode)
      endif
      if (job == 1 .and. cmdopt('--wrange',8,0,strn)) then
        call info2(10,0,0,' sugw: writing file erange:  ebot=%;3d  etop=%;3d',ebot,etop)
        ifi = fopna('erange',-1,0)
        write(ifi,"(2f20.12)") ebot, etop
        call fclose(ifi)
      endif

C --- Cleanup ---
      deallocate(evl,nlindx)

      if (gwcode == 0 .or. gwcode == 2) then
        if (jobb /= 5) then
          call fclr(' ',ifiqg)
          if (gwcode == 0) call fclr(' ',ifiqgc)
        endif
        if (.not. bandmode) then
          ifi = fopna('gwb',-1,4)
          call fclose(ifi)
        endif

        if (bandmode) then
          if (jobb == 5) call rx0('lmfgw mode=5 (Qeigval--->eigval)')
          if (job  == 1) call rx0('lmfgw mode=4 (bandmode)')
        endif
      else
        ifi = fopnx('evals',2,4,-1)
        write(ifi) -1,-1,-1,-1 ! Flags no more records in this file
        call fclr(' ',ifi)
        ifi = fopnx('evcof',2,4,-1)
        write(ifi) -1,-1,-1,-1 ! Flags no more records in this file
        call fclr(' ',ifi)
        call fclr('kpts',fopnx('kpts',2,1,-1))
      endif

      call fclr('gw1',fopna('gw1',-1,4))
      call fclr('gw2',fopna('gw2',-1,4))
      call fclr('gwb',fopna('gwb',-1,4))
      if (.not. cmdopt('--novxc',7,0,strn)) then
      if (lwvxc>0) then
        call fclr('vxc',fopna('vxc',-1,4))
        call fclr('evec',fopna('evec',-1,4))
      endif
      endif

      call tcx('sugw')

      return
  998 continue
      call rx(' sugw: missing QP or data from QIBZ')

      end

      subroutine ioaindx(npqn,lmxax,nbas,ndima,nlindx,ifi)
C-  File I/O of NlAindx
C ----------------------------------------------------------------------
Ci Inputs
Ci   npqn  :leading dimension of nlindx
Ci   lmxax :second dimension of nlindx
Ci   nbas  :size of basis
Ci   ndima :number of augmentation channels
Ci   ifi   :file logical unit, but >0 for read, <0 for write
Co Inputs/Outputs
Cio  nlindx:pointer to augmentation channels by site
Cio        :(ifi>0) input
Cio        :(ifi<0) output
Cr Remarks
Cr
Cu Updates
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer npqn,lmxax,nbas,ndima,ifi,nlindx(npqn,0:lmxax,nbas)
C ... Local parameters
      character outs*80
      integer i,ipqn,l,ib,ii

C --- File read ---
      if (ifi > 0) then
        nlindx = -1
        rewind ifi
        read(ifi,'(a)') outs
        read(ifi,*) i
C       If passed ndima>0, check that it matches file value
        if (ndima > 0 .and. i /= ndima)
     .    call rx('ioaindx: file mismatch NLAindx')
        ndima = i
        do  i = 1, ndima
          read(ifi,'(a)',err=101,end=101) outs
          read(outs,*) ipqn,l,ib,ii
          nlindx(ipqn,l,ib) = ii
        enddo
  101 continue

C --- File write ---
      else
        call rx('ioaindx: file write not implemented')
      endif

      end

      subroutine wsymops(mode,ifi,ngrp,s_sym)
C- Write file containing symmetry operations
C ----------------------------------------------------------------------
Ci Inputs
Ci   mode  :0 format for fpgw v033a5
Ci         :1 format for spex v02.04
Ci   ifi   :file logical unit, >0 for read, <0 for write
Ci   ngrp  :number of group operations
Ci   s_sym
Ci     Elts read: rg pag
Co     Stored:    *
Co     Passed to: *
Co Outputs
Cr Remarks
Cr   fpgw case:
Cr     Requires only the point group.
Cr     Point group operations are written in cartesian coordinates
Cr   spex case:
Cr     Requires the full space group.
Cr     Point group operations are written in units of plat; see mks_sym.f
Cu Updates
Cu   03 May 12 Modified to use s_sym structure
Cu   09 Jul 09 Extended to include mode=1.  Altered argument list
C ----------------------------------------------------------------------
      use structures
      implicit none
C ... Passed parameters
      integer mode,ngrp
C ... Local parameters
      integer i,ig,ifi
C ... For structures
!      include 'structures.h'
      type(str_symops)::  s_sym(ngrp)

C ... fpgw output
      if (mode == 0) then
        write(ifi,*) ngrp
        do  ig = 1, ngrp
          write(ifi,*) ig
          do i = 1, 3
            write(ifi,"(3e24.16)") s_sym(ig)%rg(i,1:3)
          enddo
        enddo

C ... spex output
      elseif (mode == 1) then
        write(ifi,"(2i4,L4)") ngrp, ngrp, .false.
        do  ig = 1, ngrp
          write(ifi,"('!',i4)") ig
          do  i = 1, 3
            write(ifi,"(3i4,f20.15)")
     .        s_sym(ig)%prg(i,1:3), s_sym(ig)%pag(i)
          enddo
        enddo

C ... Error
      else
        call rxi('wsymops: mode not recognized, mode=',mode)
      endif
      end

      subroutine wlattc(mode,ifi,jfi,s_site,s_spec,alat,plat,nbas,nat,
     .  maxcor,GcutH,ipb,ipcx,lmxax,bas,lmxa,nsp,konf)
C- Write LATTC (or lattice) file
C ----------------------------------------------------------------------
Ci Inputs
Ci   mode  :0 format for fpgw v033a5
Ci         :1 format for spex v02.05
Ci   ifi   :file handle for lattice data
Ci   jfi   :file handle for lmto data
Ci  s_site :struct for site-specific data; see structures.h
Ci    Elts read: spec pos pnu pz ov0 clabel
Ci    Stored:    *
Ci    Passed to: *
Ci  s_spec :struct for species-specific data; see structures.h
Ci    Elts read: lmxa pz p idxdn a nr z rmt
Ci    Stored:    *
Ci    Passed to: *
Ci   alat  :length scale of lattice and basis vectors, a.u.
Ci         :Written to disk (modes 0,1)
Ci   plat  :primitive lattice vectors, in units of alat
Ci         :Written to disk (modes 0,1)
Ci   nbas  :size of basis, including floating orbitals sites
Ci   nat   :size of true basis (exclude floating orbitals sites)
Ci         :Written to disk (modes 0,1)
Ci   maxcor:(1) = largest number of core radial functions in system
Ci         :(2) = largest l for which a core state exists
Ci   GcutH :G cutoff for eigenfunctions
Ci         :Written to disk (mode 1)
Ci   ipb   :index to reduced basis (excluding floating orbitals)
Ci         :given site index including those orbitals
Ci         :Written to disk (modes 0,1)
Ci   z     :Nuclear charge
Ci         :Written to disk (mode 1)
Ci   ipcx  :class index: site ib belongs to class ipcx(ib)
Ci         :Written to disk (mode 1)
Ci   lmxax :global maximum of lmxa
Ci         :Written to disk (modes 0,1)
Ci   bas   :site positions, Cartesian coordinates, units of alat
Ci         :Written to disk (mode 1)
Ci   lmxa  :augmentation l-cutoff for each site
Ci         :Written to disk (modes 0,1)
Ci   nsp   :2 for spin-polarized case, otherwise 1
Ci         :Written to disk (mode 1)
Ci   konf  :principal quantum numbers
Ci         :Written to disk (modes 0,1)
Co Outputs
Co   data is written to file logical unit ifi
Cl Local variables
Cl  maxradv:Maximumum number of radial functions describing partial waves
Cl         :for a given l (2 for phi,phidot; 3 if any local orbitals)
Cl         :Written to disk (mode 1)
Cr Remarks
Cr   fpgw mode writes to a single file (mixeed data)
Cu Updates
Cu   10 Nov 11 Begin migration to f90 structures
Cu   07 Jul 09 New mode; altered argument list
Cu   05 Jul 05 handle sites with lmxa=-1 -> no augmentation
C ----------------------------------------------------------------------
      use structures
      implicit none
C ... Passed parameters
      integer mode,ifi,jfi,nbas,nat,nsp,lmxax,maxcor(2)
      integer ipb(nbas),ipcx(nbas),lmxa(nbas),konf(0:lmxax,nbas)
      double precision plat(3,3),alat,GcutH,bas(3,nbas)
C ... For structures
!      include 'structures.h'
      type(str_site)::  s_site(*)
      type(str_spec)::  s_spec(*)
C ... Local parameters
      integer n0,nrmx,maxrad
      parameter (n0=10,nrmx=5001)
      double precision qlat(3,3),xx,posp(3),tol,roundp,z,a,rmt,pz(n0,2)
      integer i,l,ib,is,ic,isp,nclasx,mxint,nlod,iclbas,nr,nrl,nglob,
     .  llo(n0),iplo(n0)
      character slabl*2,spid*8,fmt*80,strn*100
C     integer,allocatable:: lmxa2(:),ipc2(:)

      tol = 1d-6
      nclasx = mxint(nbas,ipcx)

C      allocate(lmxa2(nat),ipc2(nat))
C      ia = 0
C      do  ib = 1, nbas
C        if (lmxa(ib) > -1) then
C          ia = ia+1
C          lmxa2(ia) = lmxa(ib)
C          ipc2(ia) = ipcx(ib)
C        endif
C      enddo

C --- spex format ---
      if (mode == 1) then
        if (nglob('lpz') > 0) then
           maxrad = 3
         else
           maxrad = 2
         endif
        call awrit3(' nat=%i nclass=%i alat=%;8d',' ',
     .    80,ifi,nat,nclasx,alat)
        nlod = nglob('lpz')/1000
        call awrit8('%x nat=%i nsp=%i nclass=%i lmxax=%i maxloc=%i '//
     .    'maxradv=%i maxradc=%i maxcorl=%i',strn,len(strn),0,
     .    nat,nsp,nclasx,lmxax,nlod,maxrad,maxcor(1),maxcor(2))
        call awrit1('%a gcuth=%;3d',strn,len(strn),-jfi,GcutH)

C   ... Lattice vectors are extended to 12 digits
        write(ifi,"(' plat:')")
        do  ic = 1, 3
          do  ib = 1, 3
            posp(ib) = roundp(plat(ib,ic),tol)
C           posp(ib) = plat(ib,ic)
          enddo
          write(ifi,"(3f18.12,'  (P',i1,')')") posp,ic
        enddo

C   ... Class data
        write(ifi,"(' Class data:'/'  ic    Z    Symbol')")
        write(jfi,345)
  345   format(' Class data:')
        call awrit2('%x  ic    Z        rmt        a       nr   lmxa'//
     .    '    %?#n#llo  %nfilo%-1j%nf   ##konf',fmt,len(fmt),jfi,nlod,
     .    3*nlod-3)

C       fortran format for writing class line
        fmt = '(i4,f8.2,f12.7,f10.6,2i5,3x,'
        call awrit1('%a%?#n#%-1j%ii3,2x,%-1j%ii3,3x,##99i3)',
     .    fmt,len(fmt),0,nlod)
        do  ic = 1, nclasx
          ib = iclbas(ic,ipcx,size(ipcx))
          if (ib == 0) cycle
          is = s_site(ib)%spec
          z = s_spec(is)%z
          a = s_spec(is)%a
          nr = s_spec(is)%nr
          rmt = s_spec(is)%rmt
          call mshnrl(1,rmt,a,nr,nrmx,nrl)
          pz = s_spec(is)%pz
          i = 0
          llo = -1
          iplo = 0
          do  l = 0, lmxa(ib)
            if (pz(l+1,1) /= 0) then
              i = i+1
              llo(i) = l
              iplo(i) = int(pz(l+1,1))
            endif
          enddo
          if (i > nlod)
     .      call rx('wlattc: number of local orbitals > nlod')
C         print *, is, sngl(pz(1:3)),llo(1:4)
C         z = s_spec(is)%z
          call zslabl(-1,slabl,iabs(nint(z)))
C         write(jfi,"(i4,f8.2,f12.7,f10.6,i5,i5,3x,99i4)")
          write(jfi,fmt) ic,z,rmt,a,nrl,lmxa(ib),
     .      (llo(i),i=1,nlod),(iplo(i),i=1,nlod),konf(0:lmxa(ib),ib)
          write(ifi,"(i4,f8.2,3x,a)") ic,z,slabl
        enddo

C   ... Site data.  Positions in unit of plat ... expanded to 12 digits
C       qlat = (plat+)^-1
        call dinv33(plat,1,qlat,xx)
        write(ifi,"(' Site data:'/
     .    '  ib  ic',15x,'pos (units of plat)',22x,'spid')")
        do  ib = 1, nbas
C         call spacks(0,'site clabel',ssite,spid,ib,ib)
          spid = s_site(ib)%clabel
          if (lmxa(ib) > -1) then
C           posp+ = (plat)^-1 pos+
            call dgemm('T','N',3,1,3,1d0,qlat,3,bas(1,ib),3,0d0,posp,3)
            do  ic = 1, 3
              posp(ic) = roundp(posp(ic),tol)
            enddo
            write(ifi,"(2i4,3f18.12,3x,a)") ipb(ib),ipcx(ib),posp,
     .        trim(spid)
          endif
        enddo

        return

C --- fpgw format --
      else

        write(ifi,"(e24.16)") alat
        write(ifi,"(3e24.16)") plat(1:3,1)
        write(ifi,"(3e24.16)") plat(1:3,2)
        write(ifi,"(3e24.16)") plat(1:3,3)
        write(ifi,*)
     .    ' -1d10 ! dummy entry. True QpGcut_psi is in GWinput'
        write(ifi,*) ' ------------------------------------------- '
        write(ifi,"(2i4,' ! nbas lmxax (max l for argumentaion)')")
     .    nat,lmxax
        write(ifi,*) ' ------------------------------------------- '
        do  isp = 1, nsp
          write(ifi,"(' -- ibas lmxa konf(s) konf(p) konf(d)... ', ' isp=',2i2)") isp
          do  ib = 1, nbas
            if (lmxa(ib) > -1) then
              write(ifi,"('   ',99i4)") ipb(ib),lmxa(ib),konf(0:lmxa(ib),ipb(ib))
            endif
          enddo
        enddo

      endif

      end
C      subroutine fmain
CC- debugs pvsug1
C      implicit none
C
C      integer nbas
C      parameter (nbas=8)
C      integer ipc(nbas),lmxa(nbas),ipcx(nbas)
C      data ipc/3,1,4,3,2,6,5,1/
C      data lmxa/-1,1,4,-1,2,6,-1,1/
C
C      call pvsug1(nbas,lmxa,ipc,ipcx)
C
C      end
      subroutine pvsug1(nbas,lmxa,ipc,ipcx)
C- Remakes class table, expunging classes with floating orbitals.
C ----------------------------------------------------------------------
Ci Inputs
Ci   nbas  :size of basis
Ci   lmxa  :augmentation l-cutoff
Ci   ipc   :class table: site ib belongs to class ipc(ib)
Co Inputs/Outputs
Co   ipcx  :expunged class table: classes with lmxa=-1 are expunged
Co         :and the remaining classes are sequentially renumbered
Co         :preserving the order of the remaining classes.
Cl Local variables
Cl         :
Cr Remarks
Cr
Cu Updates
Cu   27 Mar 07 First created
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer nbas,lmxa(nbas),ipc(nbas),ipcx(nbas)
C ... Local parameters
      integer i,ibp,ic,ipskip,nelim
      integer prm(nbas)

      call ivshel(1,nbas,ipc,prm,.true.)
C      do  i = 1, nbas
C        prm(i) = prm(i)+1
C      enddo

C     nelim = number of classes that have been eliminated so far
      nelim = 0
C     ipskip is the number of the last class that was skipped.
C     Multiple occurrences of a skipped class must still only
C     reduce the net number of classes by one.
C     We must avoid incrementing nelim when multiple sites
C     correspond to a skipped class.
      ipskip = 0
C     Loop over sites in order of increasing class index, ibp
      do  i = 1, nbas
        ibp = prm(i)+1
        ic = ipc(ibp)
C       Test whether this class should be purged
        if (lmxa(ibp) < 0) then
          if (ipskip /= ic) nelim = nelim+1
          ipskip = ic
          ipcx(ibp) = -1
        else
          ipcx(ibp) = ic - nelim
        endif
      enddo

      end

      subroutine spex_read_k(ifi,qlat,qpscale,q,wt)
C- Read a k-point from spex input file
C ----------------------------------------------------------------------
Ci Inputs
Ci   ifi   :file handle
Ci  qpscale:scale k-point by reciprocal of qpscale
Co Outputs
Ci   q     :k-point, in units of 2*pi/a
Cl Local variables
Cl         :
Cr Remarks
Cr   File contains rows of 4 columns.
Cr   cols 1:3 are q in units of qpscale*qlat
Cr   col  4 is k-point weight.
Cu Updates
Cu   10 Jun 12 q returned in Cartesian coordinates
Cu   15 Jul 09 First created
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer ifi
      double precision qlat(3,3),qpscale,q(3),wt
C ... Local parameters
      double precision xx(4)

      read(ifi,*) xx
C     q = xx(1:3)/qpscale
      q = matmul(qlat,xx(1:3))/qpscale
      wt = xx(4)
C     call shorps(1,qlat,(/72,2,2/),q,q)

      call info5(40,0,0,'%3:2;9,6D  %3:2;9,6D%2f%,3i',xx,q,int(wt),0,0)

      end

