      subroutine mkfrpf(s_site,nl,nbas,ipc,ipdc,lhdim,pfdim,indxsh,iopt,
     .  pp,pprel,ksop,pfz,vshft,z,P)
C- Relativistic potential functions parameterized from pot pars
C-----------------------------------------------------------------------
Ci Inputs
Ci   nl    :(global maximum l) + 1
Ci   nbas  :size of basis
Ci   ipc   :class index: site ib belongs to class ipc(ib) (mksym.f)
Ci   ipdc  :hash (class control) array for CPA
Ci   lhdim :number of lower+intermediate+higher orbitals
Ci   pfdim :leading dimension for the P arrays (different from lhdim in CPA)
Ci   indxsh:permutations ordering orbitals in l+i+h blocks (makidx.f)
Ci   iopt  :a compound of digits determining what is generated:
Ci         100s digit
Ci           1 make P for bare representation (alpha=0)
Ci           2 make P for gamma representation (alpha=gamma)
Ci           3 make P for gamma representation averaged over spins
Ci          10s digit determines whether to make P or some derivative:
Ci           0 P <- potential function P
Ci           1 P <- P-dot
Ci           2 P <- -1/2 P-dotdot/P-dot
Ci           3 P <- sqrt(P-dot), choosing abs(sqrt(delta))
Ci           4 P <- P^alpha/P^gamma
Ci           5 P <- (gamma-alpha)
Ci          1s digit
Ci           0 second-order P
Ci           1 third-order P
Ci           2 first-order P
Ci   pp    :potential parameters, real, by class (atomsr.f)
Ci         :needed only to extract parameter alpha
Ci   pprel :relativistic potential parameters, real, by class (atomsr.f)
Ci         :pprel(1,l,mu,isp,jsp) cgamma(l,mu,isp,jsp) 
Ci         :pprel(2,l,mu,isp,jsp) gamma(l,mu,isp,jsp)
Ci         :pprel(3,l,mu,isp,jsp) delta(l,mu,isp,jsp)
Ci         :pprel(4,l,mu,isp,jsp) pgamma(l,mu,isp,jsp)
Ci   sop   :sop(l,is1,is2,i=1..3) : matrix elements between orbitals
Ci         :of spin is1 and is2 for quantum number l.
Ci   pfz   :potential parameters, complex, downfolding order (makpfz.f)
Ci   vshft :array of site potential shifts
Ci   z     :complex energy
Co Outputs
Co   P:  some potential function, depending on iopt
Cr Remarks
Cr   This is a relativstic analog of mkfrpf, which see
Cu Updates
Cu   19 Aug 13 Temporary patch of original version until CPA version works
Cu   18 Jun 04 (A Chantis) working version
Cu   17 Mar 03 (A Chantis) first created
C-----------------------------------------------------------------------
      implicit none
C Passed parameters
      integer nl,nbas,ipc(nbas),lhdim,indxsh(lhdim),iopt
      integer pfdim,ipdc(*)
      integer npfz,nsp
      parameter (npfz=8,nsp=2)
      double precision pp(6,nl,nsp,*),pprel(4,nl,2*nl,2,2,*),
     .                 vshft(nbas),ksop(0:nl-1,nsp,nsp,9,*)
      double complex z,P(lhdim,2,2),pfz(npfz,lhdim,nsp)
C ... For structures
      include 'structures.h'
      type(str_site)::  s_site(*)
C Local parameters
      integer lmr,ibas,l,ic,ipr,lgunit,modeP,irep,stdo,nglob
      double precision alp,alpg,gam,gam2,enu,enum(2,2)
      double complex zz,ep,epp,eppp
      logical order1,order3,orderi
C ... Dirac-specific
      integer imu,m1,m2,ms1,ms2,i,j
      double precision crel(2,2),gamrel(2,2),delrel(2,2),unit(2,2)
      double precision mu,u,clebsh(2,2),zmcir(2,2),
     .  zmcii(2,2),delt(2,2),pprel1(2,2),pprel1g(2,2),pprel2(2,2),
     .  dela(2,2),temp2(2,2),temp1(2,2)
      double complex zmat(2,2),zmatp(2,2),zmatpp(2,2),zmc(2,2),
     .  zmci(2,2),dzmcd(2,2),tempc(2,2),tempc1(2,2),tempc2(2,2),
     .  reskmu(2,2),dzmcdg(2,2),z1p(2,2),z2p(2,2),z3p(2,2),
     .  reslms(-(nl-1):(nl-1),-(nl-1):(nl-1),2,2),zenu(2,2),
     .  ztmp1(2,2),ztmp2(2,2),pgam(2,2)

C --- Setup and printout  ---
      call getpr(ipr)
C     ipr    = 60
      stdo   = nglob('stdo')
      irep   = mod(iopt/100,10)
      modeP  = mod(iopt/10,10)
C      order1 = mod(iopt,10) == 2
       order3 = mod(iopt,10) == 1
C      orderi = mod(iopt,10) == 3
cc       if (order3) then 
cc       print*, 'P3 functions'
cc       endif
cc       if (order3) then
cc       if (irep == 1 .or. irep == 0) then   
cc        call rx('at the moment P3 for orthog. rep. only')
cc       endif 
cc       endif 
C ... z, z_dot and z_dot_dot (2nd order potential fun)
      zz = z

      if (ipr >= 55) then
        write(stdo,333)
  333   format(' Relativistic potential functions:'/
     .    ' site l',10x,'P(1,1)',14x,'P(2,1)',14x,'P(1,2)',14x,'P(2,2)')
      endif

      do ms1 = 1, 2
       do ms2 = 1, 2 
       if (ms1 == ms2) then
        zmat(ms1,ms1) = zz
        zmatp(ms1,ms2) = 1.d0
        unit(ms1,ms2) = 1.d0
       else 
        zmat(ms1,ms2) = 0
        zmatp(ms1,ms2) = 0
        unit(ms1,ms2) = 0
       endif
       zmatpp(ms1,ms2) = 0
       enddo
      enddo

C --- For each site, make P or related function ---
      lmr = 0
      do  ibas = 1, nbas
        ic = ipc(ibas)
        do  l = 0, nl-1
          if (indxsh(lmr+1) > lhdim) then
            lmr = lmr + 2*l+1
            goto 2
          endif

C         enu is used only for 3d order potential functions
          if (order3) then
C           enu1 = pp(1,l+1,1,ic) + vshft(ibas)
C           enu2 = pp(1,l+1,2,ic) + vshft(ibas)
            enu = 0.5d0*(pp(1,l+1,1,ic)+pp(1,l+1,2,ic))
          endif

C         gam = pp(5,l+1,1,ic)
          gam2= (pp(5,l+1,1,ic) + pp(5,l+1,nsp,ic))/2
          alp = pp(6,l+1,1,ic)
          if (irep == 3 .or. irep == 2) then
           if (modeP == 4 .or. modeP == 5) alpg = alp
          endif  
          if (irep == 1) alp = 0
          if (irep == 2) alp = gam2
          if (irep == 3) alp = gam2

C          print *, ic
C          call prmx('sop',ksop(0,1,1,1,ic),nl*4,nl*4,6)

          do  imu = 1, 2*(l+1)

C    ...  enu used for 3d order potential functions
          if (order3) then
            if (imu == 1) then
              enum(1,1) = -0.5d0*dble((l+1))*ksop(l,1,1,1,ic)
     .                    + pp(1,l+1,1,ic)
              enum(2,2) = 0.5d0*dble(l)*ksop(l,1,1,1,ic)
     .                    + pp(1,l+1,1,ic)        
            else
              if (imu == 2*(l+1)) then
                enum(1,1) = -0.5d0*dble((l+1))*ksop(l,2,2,1,ic)
     .                      + pp(1,l+1,2,ic)
                enum(2,2) = 0.5d0*dble(l)*ksop(l,2,2,1,ic)
     .                      + pp(1,l+1,2,ic)  
              else
                enum(1,1) = -0.5d0*dble((l+1))*(ksop(l,1,1,1,ic) +
     .            ksop(l,2,2,1,ic))*0.5d0 + enu
                enum(2,2) = 0.5d0*dble(l)*(ksop(l,1,1,1,ic) + 
     .            ksop(l,2,2,1,ic))*0.5d0 + enu  
              endif
            endif
            enum(1,2)=0d0
            enum(2,1)=0d0
          endif

C     ... Extract pp(alpha)
C         enu1 = pp(1,l+1,1,ic) + vshft(ibas)

          do ms1 = 1, 2
            do ms2 = 1, 2
              crel(ms1,ms2)   = pprel(1,l+1,imu,ms1,ms2,ic)
              gamrel(ms1,ms2) = pprel(2,l+1,imu,ms1,ms2,ic)
              delrel(ms1,ms2) = pprel(3,l+1,imu,ms1,ms2,ic)

              if (order3) then
                pgam(ms1,ms2) = dcmplx(pprel(4,l+1,imu,ms1,ms2,ic),0.d0)
                if (ms1 == ms2) then
C                 zenu(ms1,ms2) = zz - 0.5d0*(enu1+enu2)
                  zenu(ms1,ms2) = zz - enum(ms1,ms2)  
                else
                  zenu(ms1,ms2) = 0   
                endif
              endif
              
            enddo
          enddo

c           if (irep == 2) then
c             if (modeP /= 4 .and. modeP /= 5) then 
c              alp = 0.0d0
c              do ms1 = 1, 2
c                 do ms2 = 1, 2
c                    gamrel(ms1,ms2) = 0.d0
c                 enddo
c              enddo
c           endif
c           endif
c           if (irep == 3) then
c            if (modeP /= 4 .and. modeP /= 5) then   
c           alp = 0.0d0
c              do ms1 = 1, 2
c                 do ms2 = 1, 2
c                    gamrel(ms1,ms2) = 0.d0
c                 enddo
c              enddo 
c           endif
c           endif
c           if (irep == 2) alp = 0.5d0*(gamrel(1,1)+gamrel(2,2))
c           if (irep == 3) alp = 0.5d0*(gamrel(1,1)+gamrel(2,2))
C           ... z --> f(z)= z + p (z - enu)**3, f_dot(z) 
C           ... and f_dot_dot(z) (used for 3d order potential fun)
          if(order3) then   
            call zmpy22(zenu,zenu,ztmp1)
            call zmpy22(zenu,ztmp1,ztmp2)
            call zmpy22(zenu,pgam,z1p)
            call zmpy22(ztmp1,pgam,z2p)
            call zmpy22(ztmp2,pgam,z3p)
            do ms1 = 1, 2
              do ms2 = 1, 2 
                zmat(ms1,ms1) = zz + z3p(ms1,ms1)
                zmatp(ms1,ms2) = unit(ms1,ms2) + 3.d0*z2p(ms1,ms2)
                zmatpp(ms1,ms2) = 6.d0*z1p(ms1,ms2)
              enddo
            enddo
          endif

C            call prmx('crel',crel,2,2,2)
C            call prmx('gamrel',gamrel,2,2,2)
C            call prmx('delrel',delrel,2,2,2)


C     ... Setup for rotation of kappa-mu to lms rep'sn
          mu= dble(imu-l) - 1.5d0
          u = mu/(dble(l)+0.5d0)
          clebsh(1,1) = dsqrt(0.5d0*(1d0+u))
          clebsh(1,2) = -dsqrt(0.5d0*(1d0-u))
          clebsh(2,2) = clebsh(1,1)
          clebsh(2,1) = -clebsh(1,2)

C           zmc <- z-C; and local copy of D+ and D, where (D+) D = delta
          do i = 1, 2
            do j = 1, 2
c             dela(i,j) = delrel(i,j)
c             delt(i,j) = delrel(j,i)
              delt(i,j) = delrel(i,j)
              dela(i,j) = delrel(j,i)
              zmc(i,j) = zmat(i,j) - (crel(i,j) + vshft(ibas))
            enddo
          enddo

C           call zprm('z-C',2,zmc,2,2,2)
C           call prmx('deltrelt',delt,2,2,2)
C           call prmx('deltra',dela,2,2,2)

C           zmci <- (z-C)^-1
          call zinv22(zmc,zmci)
C           call zprm('(z-C)^-1',2,zmci,2,2,2)
          do i = 1, 2
            do j = 1, 2
              zmcir(i,j) = dble(zmci(i,j))
              zmcii(i,j) = dimag(zmci(i,j))
            enddo
          enddo
          call dmpy22(delt,zmcir,temp1)
          call dmpy22(temp1,dela,pprel1)
          call dmpy22(delt,zmcii,temp2)
          call dmpy22(temp2,dela,pprel2)

C    ...  D+ (z-C)^-1 D + gamma-alpha, where D+ D = delta
          do i = 1, 2
            do j = 1, 2
              pprel1(i,j) = pprel1(i,j) + gamrel(i,j)
              if (irep == 3 .or. irep == 2) then
                if (modeP == 4 .or. modeP == 5) then
                  pprel1g(i,j) = pprel1(i,j) 
                endif
              endif
            enddo
            if (irep == 3 .or. irep == 2) then
              if (modeP == 4 .or. modeP == 5) then   
                pprel1g(i,i) = pprel1g(i,i) - alpg
              endif
            endif
            pprel1(i,i) = pprel1(i,i) - alp
          enddo
C         pprel1(1,1) =  pprel1(1,1) -  alp
C         pprel1(2,2) =  pprel1(2,2) -  alp
          do i = 1, 2
            do j = 1, 2
              dzmcd(i,j) = dcmplx(pprel1(i,j),pprel2(i,j))
              if (irep == 3 .or. irep == 2) then
                if (modeP == 4 .or. modeP == 5) then
                  dzmcdg(i,j) = dcmplx(pprel1g(i,j),pprel2(i,j))
                endif
              endif
            enddo
          enddo

C         call zprm('del (z-C)^-1 del + gam-alp',2,dzmcd,2,2,2)

C     --- Make Pot fun or related object in kappa-mu rep ---

C     ... modeP = 0: P = (D+ (z-C)^-1 D + gamma-alpha)^-1
          if (modeP == 0) then
            call zinv22(dzmcd,reskmu)

C       ... modeP = 0: P_dot
          elseif (modeP == 1) then
            call pdotfr(dzmcd,zmc,zmatp,zmatpp,delt,dela,1,reskmu)

C     ... modeP = 2: -1/2*(P_dot_dot)*(P_dot)^(-1)
          elseif (modeP == 2) then                  
            call pdotfr(dzmcd,zmc,zmatp,zmatpp,delt,dela,1,reskmu)
            call pdotfr(dzmcd,zmc,zmatp,zmatpp,delt,dela,2,tempc)
            call zinv22(reskmu,tempc1)
            call zmpy22(tempc,tempc1,reskmu)
            call dscal(8,-0.5d0,reskmu,1)

C            if (irep == 2 .or. irep == 3) then
C              do i = 1, 2
C                do j = 1, 2
C                  reskmu(i,j) = 0.0d0
C                enddo
C              enddo
C            endif
C
C            do i=1,2
C              do j=1,2
C                print*, reskmu(i,j)
C              enddo
C            enddo
C            print*,'--------------------------------'
C
CC       ... Test: construct [z-C + W^T(g-a)^(-1)W]^(-1).
C            if (irep /= 2 .and. irep /= 3) then
C              do i = 1, 2
C                do j = 1, 2
C                  temp1(i,j) = gamrel(i,j)
C                enddo
C              enddo
C              do i = 1, 2
C                temp1(i,i) = temp1(i,i) - alp
C              enddo
C              call dinv22(temp1,temp2)
C              call dmpy22(temp2,delt,temp1)
C              call dmpy22(dela,temp1,temp2)
C              do i = 1, 2
C                do j = 1, 2
C                  tempc(i,j)=zmc(i,j)+dcmplx(temp2(i,j),0d0)
C                enddo
C              enddo 
C              call zinv22(tempc,reskmu)  
C              do i=1,2
C                do j=1,2   
C                  print*, reskmu(i,j)
C                enddo
C              enddo
C              print*, '=============================='
C            endif
C       ... modeP = 3: sqrt(P_dot)
            elseif (modeP == 3) then
c              call pdotfr(dzmcd,zmc,zmatp,zmatpp,delt,dela,1,tempc)
c              call sqr2x2(tempc,reskmu)
c             do i=1,2
c              do j=1,2
c               print*, tempc(i,j)
c              enddo
c              enddo
c              print*,'--------------------------------'

C     ... Test: construct the normalization function:
C          sqrt(2/w)*N = sqrt(f_dot)*(z-C)^-1*dela*P=
c            call zinv22(dzmcd,tempc)
c            call dmpy22(zmcir,dela,temp1)
c            call dmpy22(zmcii,dela,temp2)
c            do i = 1, 2
c               do j = 1 ,2
c               tempc1(i,j) = dcmplx(temp1(i,j),temp2(i,j))
c               enddo
c            enddo   
c              call zmpy22(tempc1,tempc,tempc2)
c              call sqr2x2(zmatp,tempc1)
c              call zmpy22(tempc1,tempc2,reskmu)
c             ... The other convention
              call zinv22(dzmcd,tempc)
              call dmpy22(delt,zmcir,temp1)
              call dmpy22(delt,zmcii,temp2)
              do i = 1, 2
                do j = 1 ,2
                  tempc1(i,j) = dcmplx(temp1(i,j),temp2(i,j))
                enddo
              enddo   
              call zmpy22(tempc,tempc1,tempc2)
              call sqr2x2(zmatp,tempc1)
              call zmpy22(tempc2,tempc1,reskmu)  
c         ... In gamma rep this must be equal to dela^(-1), check.
c             call dinv22(dela,temp1)
c             do i=1,2
c             do j=1,2   
c              print*, temp1(i,j)
c             enddo
c             enddo
c             print*, '-----------------------------'
c             do i=1,2
c              do j=1,2   
c               print*, reskmu(i,j)
c              enddo
c              enddo
c               print*, '=============================='
c              do i=1,2
c                 do j=1,2
c                    reskmu(i,j)=-reskmu(i,j)
c                 enddo
c              enddo   
C          ... Make the transpose of sqrt(2/w)*N 
c              do i=1,2
c                 do j=1,2
c                    tempc1(i,j)=reskmu(j,i)
c                 enddo
c              enddo
C          ... Multiply (2/w)*N^T*N, check if it is equal to P_dot   
c              call zmpy22(tempc1,reskmu,tempc2)
c              do i=1,2
c              do j=1,2   
c               print*, tempc2(i,j)
c              enddo
c              enddo
c              print*, '=============================='

C       ... modeP = 4: P^alpha/P^gamma
            elseif (modeP == 4) then
              call zinv22(dzmcdg,tempc)
              call zmpy22(dzmcd,tempc,reskmu)

C       ... modeP = 5: (gamma-alpha)*P^alpha/P^gamma
             elseif (modeP == 5) then
                do i = 1, 2
                   do j = 1, 2
                      tempc(i,j) = gamrel(i,j)
                   enddo
                   tempc(i,i) = tempc(i,i) - alpg
                enddo
              call zinv22(dzmcdg,tempc1)
              call zmpy22(dzmcd,tempc1,tempc2)
c              call zmpy22(tempc,tempc2,reskmu)

C        ...Use order that does not rely on any commutations

              call zmpy22(tempc2,tempc,reskmu)

            endif


C       --- Rotate to lms rep'sn from kappa-mu rep'sn  ---
            do ms1 = 1, 2
            do ms2 = 1, 2
              m1 = int(mu - (ms1-1.5d0))
              m2 = int(mu - (ms2-1.5d0))
              if (iabs(m1) <= l .and. iabs(m2) <= l) then

                reslms(m1,m2,ms1,ms2) =
     .            clebsh(1,ms1)*reskmu(1,1)*clebsh(1,ms2) +
     .            clebsh(1,ms1)*reskmu(1,2)*clebsh(2,ms2) +
     .            clebsh(2,ms1)*reskmu(2,1)*clebsh(1,ms2) +
     .            clebsh(2,ms1)*reskmu(2,2)*clebsh(2,ms2)

C       --- Test rotate C,gamma,delt to lms rep'sn from kappa-mu rep'sn  ---
C                reslms(m1,m2,ms1,ms2) =
C     .            clebsh(1,ms1)*crel(1,1)*clebsh(1,ms2) +
C     .            clebsh(1,ms1)*crel(1,2)*clebsh(2,ms2) +
C     .            clebsh(2,ms1)*crel(2,1)*clebsh(1,ms2) +
C     .            clebsh(2,ms1)*crel(2,2)*clebsh(2,ms2)

C                reslms(m1,m2,ms1,ms2) =
C     .            clebsh(1,ms1)*gamrel(1,1)*clebsh(1,ms2) +
C     .            clebsh(1,ms1)*gamrel(1,2)*clebsh(2,ms2) +
C     .            clebsh(2,ms1)*gamrel(2,1)*clebsh(1,ms2) +
C     .            clebsh(2,ms1)*gamrel(2,2)*clebsh(2,ms2)

C                reslms(m1,m2,ms1,ms2) =
C     .            clebsh(1,ms1)*delrel(1,1)*clebsh(1,ms2) +
C     .            clebsh(1,ms1)*delrel(1,2)*clebsh(2,ms2) +
C     .            clebsh(2,ms1)*delrel(2,1)*clebsh(1,ms2) +
C     .            clebsh(2,ms1)*delrel(2,2)*clebsh(2,ms2)

              else
                reslms(m1,m2,ms1,ms2) = 0d0
              endif

            enddo
            enddo

C       ... Poke into P (ms1 is -1/2 and ms2 is +1/2)

            do  ms1 = 1, 2
            do  ms2 = 1, 2
              m1 = int(mu - (ms1-1.5d0))
              m2 = int(mu - (ms2-1.5d0))
              if (iabs(m1) <= l .and. iabs(m2) <= l) then
              lmr = nl*nl*(ibas-1) + (l+1)**2 - (2*l+1) + (l+m1) + 1
C............fix lmr: order (1,0,-1) instead of (-1,0,1)
C             lmr = lmr-2*m1
              if (ms1 == ms2)
     .           P(indxsh(lmr-2*m1),ms1,ms2) = reslms(m1,m2,ms1,ms2)
              if (ms1 /= ms2)
     .          P(indxsh(lmr-2*m1),ms1,ms2) = reslms(m1,m2,ms1,ms2)
              endif
            enddo
            enddo

C     ... Loop over imu
          enddo

          if (ipr >= 55) then
            write(stdo,334) ibas,l,
     .        ((P(indxsh(lmr),ms1,ms2), ms1=1,2),ms2=1,2)
  334       format(2i4,8f10.5)
          endif

C   ... Loop over l
        enddo
    2   continue
C ... Loop over ibas
      enddo
C      ipr=60
c   ...Use for Debugging
c      if (ipr >= 60 .and. modeP == 0) then
c      if (irep == 3) then 
c         open(218,file='grel1',status='unknown')
c      do ms1=1,2
c       do lmr=1,lhdim  
c         write(218,*) irep,',',lmr,':',P(lmr,ms1,ms1)
c       enddo
c      enddo 
c      call zprm('P-f.rel',2,P,lhdim,lhdim,4)
c      close(218)
c      endif
c      if (irep == 0) then
c      open(217,file='grel2',status='unknown')
c      do ms1=1,2
c       do lmr=1,lhdim  
c         write(217,*) irep,',',lmr,':',P(lmr,ms1,ms1)
c       enddo
c      enddo 
c      call zprm('P-f.rel',2,P,lhdim,lhdim,4)
c      close(217)
c      endif
c      endif

      end

      subroutine pdotfr(pp,zeng,zengp,zengpp,dellt,della,mode,result)
C- Builds P_dot or P_dot_dot depending on mode
      implicit none
      double precision zre(2,2),zim(2,2),pp1(2,2),pp2(2,2),pp3(2,2),
     .                 pp4(2,2),tempor1(2,2),tempor2(2,2),tempor3(2,2),
     .                 tempor4(2,2),della(2,2),dellt(2,2)
      double complex pp(2,2),zeng(2,2),zengp(2,2),zengpp(2,2),
     .               result(2,2),temporc(2,2),temporc1(2,2),pinv(2,2),
     .               temporc2(2,2),temporc8(2,2),temporc9(2,2),
     .               temporc3(2,2),temporc4(2,2),zeng1(2,2),
     .               temporc5(2,2),temporc6(2,2),temporc7(2,2),
     .               zeng3(2,2),temporc10(2,2),result0(2,2)
      integer i, j, mode


C   ... pinv=P(z), temporc=(f(z)-C)^(-1) 
        call zinv22(pp,pinv)
        call zinv22(zeng,temporc)
        do i=1, 2
          do j=1, 2
            zre(i,j) = dble(temporc(i,j))
            zim(i,j) = dimag(temporc(i,j))
          enddo
        enddo

C   ... zeng1=(sqrt(D))^T*(f(z)-C)^(-1)
        call dmpy22(dellt,zre,tempor1)
        call dmpy22(dellt,zim,tempor3)
        do i=1, 2
          do j=1, 2
            zeng1(i,j)=dcmplx(tempor1(i,j),tempor3(i,j))
          enddo
        enddo

C ... temporc1=(sqrt(D))^T*(f(z)-C)^(-1)*f_dot  
        call zmpy22(zeng1,zengp,temporc1)
C ... temporc2=(sqrt(D))^T*(f(z)-C)^(-1)*f_dot*(f(z)-C)^(-1)
        call zmpy22(temporc1,temporc,temporc2)
        do i=1, 2
          do j=1, 2
            zre(i,j) = dble(temporc2(i,j))
            zim(i,j) = dimag(temporc2(i,j))
          enddo
        enddo

        call dmpy22(zre,della,tempor2)
        call dmpy22(zim,della,tempor4)
C ...  zeng3=(sqrt(D))^T*(f(z)-C)^(-1)*f_dot*(f(z)-C)^(-1)*(sqrt(D))
        do i=1, 2
          do j=1, 2
            zeng3(i,j)=dcmplx(tempor2(i,j),tempor4(i,j))
          enddo
        enddo

C ...  result=P(z)*(sqrt(D))^T*(f(z)-C)^(-1)*f_dot*(f(z)-C)^(-1)*(sqrt(D))*P(z)
        call zmpy22(pinv,zeng3,temporc4)
        call zmpy22(temporc4,pinv,result0)

      if (mode == 1) then
         do i = 1, 2
            do j = 1, 2
               result(i,j) = result0(i,j)
            enddo
         enddo
         goto 401
      endif

C ... Nulify all temporary matrices
      do i = 1, 2
         do j = 1, 2
            zre(i,j) = 0d0
            zim(i,j) = 0d0
            zeng1(i,j) = 0d0
            tempor1(i,j) = 0d0
            tempor2(i,j) = 0d0
            tempor3(i,j) = 0d0
            tempor4(i,j) = 0d0
            temporc1(i,j) = 0d0
         enddo
      enddo   

C   ... temporc1=P(z)*sqrt(D)^T*[f(z)-C]^(-1)*f_dot*[f(z)-C]^(-1)*sqrt(D)*P_dot
        call zmpy22(temporc4,result0,temporc1)

C   ... zeng1=sqrt(D)^T*[f(z)-C]^(-1)*f_dot*[f(z)-C]^(-1)*sqrt(D)
        do i=1, 2
          do j=1, 2
            zre(i,j) = dble(temporc2(i,j))
            zim(i,j) = dimag(temporc2(i,j))
          enddo
        enddo

        call dmpy22(zre,della,tempor1)
        call dmpy22(zim,della,tempor2)

        do i=1, 2
          do j=1, 2
            zeng1(i,j)=dcmplx(tempor1(i,j),tempor2(i,j))
          enddo
        enddo

C   ... temporc5=P_dot*sqrt(D)^T*[f(z)-C]^(-1)*f_dot*[f(z)-C]^(-1)*sqrt(D)*P
        call zmpy22(zeng1,pinv,temporc3)
        call zmpy22(result0,temporc3,temporc5)

C   ... zeng3=[f(z)-C]^(-1)*sqrt(D)
        do i=1, 2
          do j=1, 2
            zre(i,j) = dble(temporc(i,j))
            zim(i,j) = dimag(temporc(i,j))
          enddo
        enddo

        call dmpy22(zre,della,tempor3)
        call dmpy22(zim,della,tempor4)

        do i=1, 2
          do j=1, 2
            zeng3(i,j)=dcmplx(tempor3(i,j),tempor4(i,j))
          enddo
        enddo

C ... temporc8=P(z)*sqrt(D)^T*[f(z)-C]^(-1)*f_dot*[f(z)-C]^(-1)*f_dot
C              *[f(z)-C]^(-1)*sqrt(D)*P(z)

        call zmpy22(zeng3,pinv,temporc3)
        call zmpy22(zengp,temporc3,temporc6)
        call zmpy22(temporc2,temporc6,temporc7)
        call zmpy22(pinv,temporc7,temporc8)

C ... temporc9=[f(z)-C]^(-1)*f_dot_dot*[f(z)-C]^(-1)*sqrt(D)*P(z) 
        call zmpy22(zengpp,temporc3,temporc6)
        call zmpy22(temporc,temporc6,temporc9)

        do i=1, 2
          do j=1, 2
            zre(i,j) = dble(temporc9(i,j))
            zim(i,j) = dimag(temporc9(i,j))
          enddo
        enddo

        call dmpy22(dellt,zre,tempor1)
        call dmpy22(dellt,zim,tempor2)

C ... zeng3=sqrt(D)^T*[f(z)-C]^(-1)*f_dot_dot*[f(z)-C]^(-1)*sqrt(D)*P(z)
        do i=1, 2
          do j=1, 2
            zeng3(i,j)=dcmplx(tempor1(i,j),tempor2(i,j))
          enddo
        enddo

C ... temporc10=P*sqrt(D)^T*[f(z)-C]^(-1)*f_dot_dot*[f(z)-C]^(-1)*sqrt(D)*P
        call zmpy22(pinv,zeng3,temporc10)

C ... result=temporc10+temporc5+temporc1-2*temporc8
        do i=1, 2
          do j=1, 2
          result(i,j) = temporc10(i,j) + temporc5(i,j) + 
     .                  temporc1(i,j) - 2d0*temporc8(i,j)

          enddo
        enddo

 401  continue

      end

      subroutine sqr2x2_newton(mat0,mat)
C  ...Takes the square root of a complex 2x2 matrix.
C     Uses modified Newton's algorithm (Mathematics of
C     Computation, Volume 46, Issue 174, (1986), 537-549
C     Formulas at page 544 (4.1), (4.2)

      implicit none
      double complex q0(2,2),mat0(2,2),q(2,2),mat(2,2),qn(2,2),
     .               pn(2,2),matinv(2,2),qinv(2,2),testc(2,2),
     .               testc1(2,2),testc2(2,2)
      double precision rep(2,2),imp(2,2),req(2,2),imq(2,2),
     .                 repn(2,2),impn(2,2),reqn(2,2),imqn(2,2)
      integer i,j,nit

C      do i=1, 2
C       do j=1, 2
C        print*, mat0(i,j)
C       enddo
C      enddo

C      mat0(1,1)=dcmplx(98.8006190037678,-6.85158876278541)
C      mat0(1,2)=dcmplx(-36.2759661516989,3.57466063430072)
C      mat0(2,1)=dcmplx(-36.2759661516989,3.57466063430072)
C      mat0(2,2)=dcmplx(98.8006190037678,-6.85158876278541)

      q0(1,1)=dcmplx(1.0d0,0d0)
      q0(2,2)=dcmplx(1.0d0,0d0)
      q0(1,2)=dcmplx(0d0,0d0)
      q0(2,1)=dcmplx(0d0,0d0)

      do i=1, 2
         do j=1, 2
            mat(i,j) = mat0(i,j)
            q(i,j) = q0(i,j)
         enddo
      enddo

      nit=0

 5    do i=1, 2
         do j=1, 2
            call zinv22(mat,matinv)
            call zinv22(q,qinv)
            pn(i,j)=0.5d0*(mat(i,j)+qinv(i,j))
            qn(i,j)=0.5d0*(q(i,j)+matinv(i,j))
         enddo
      enddo

      do i=1, 2
         do j=1, 2
            repn(i,j)=dble(pn(i,j))
            impn(i,j)=dimag(pn(i,j))
            reqn(i,j)=dble(qn(i,j))
            imqn(i,j)=dimag(qn(i,j))

            rep(i,j)=dble(mat(i,j))
            imp(i,j)=dimag(mat(i,j))
            req(i,j)=dble(q(i,j))
            imq(i,j)=dimag(q(i,j))
         enddo
      enddo

C      print*, nit

      if(dabs(repn(1,1)-rep(1,1)) - dabs(repn(1,1))*1d-05) 6,6,10
 6    if(dabs(repn(2,2)-rep(2,2)) - dabs(repn(2,2))*1d-05) 7,7,10
 7    if(dabs(repn(1,2)-rep(1,2)) - dabs(repn(1,2))*1d-05) 8,8,10
 8    if(dabs(repn(2,1)-rep(2,1)) - dabs(repn(2,1))*1d-05) 9,9,10

 9    if(dabs(impn(1,1)-imp(1,1)) - dabs(impn(1,1))*1d-05) 11,11,10
 11   if(dabs(impn(2,2)-imp(2,2)) - dabs(impn(2,2))*1d-05) 12,12,10
 12   if(dabs(impn(1,2)-imp(1,2)) - dabs(impn(1,2))*1d-05) 13,13,10
 13   if(dabs(impn(2,1)-imp(2,1)) - dabs(impn(2,1))*1d-05) 14,14,10


 14   if(dabs(reqn(1,1)-req(1,1)) - dabs(reqn(1,1))*1d-05) 15,15,10
 15   if(dabs(reqn(2,2)-req(2,2)) - dabs(reqn(2,2))*1d-05) 16,16,10
 16   if(dabs(reqn(1,2)-req(1,2)) - dabs(reqn(1,2))*1d-05) 17,17,10
 17   if(dabs(reqn(2,1)-req(2,1)) - dabs(reqn(2,1))*1d-05) 18,18,10

 18   if(dabs(imqn(1,1)-imq(1,1)) - dabs(imqn(1,1))*1d-05) 19,19,10
 19   if(dabs(imqn(2,2)-imq(2,2)) - dabs(imqn(2,2))*1d-05) 20,20,10
C     Temporary fix of numerical absurd instability
 20   if(nit >= 20) goto 22
      if(dabs(imqn(1,2)-imq(1,2)) - dabs(imqn(1,2))*1d-05) 21,21,10
 21   if(dabs(imqn(2,1)-imq(2,1)) - dabs(imqn(2,1))*1d-05) 22,22,10


 10   do i=1, 2
         do j=1, 2
            mat(i,j)=dcmplx(repn(i,j),impn(i,j))
            q(i,j)=dcmplx(reqn(i,j),imqn(i,j))
         enddo
      enddo

      nit = nit + 1

      if(nit > 200) then
         call rx('matrix square root cannot be found')
C         call partofmkfrpf(mat0,mat)
      endif

      goto 5

 22   continue

C ...Test if it worked
      call zmpy22(mat,mat,testc1)
      call zinv22(testc1,testc2)
      call zmpy22(testc2,mat0,testc)

      if(dabs(dble(testc(1,1))-1.0d0) > 1d-06 
     .     .or. dabs(dble(testc(2,2))-1d0) > 1d-06) then
      call rx('matrix square root cannot be found')
      endif

C      print*,'...Start Test'      
C      do i=1, 2
C         do j=1, 2
C         print*, testc(i,j)
C         enddo
C      enddo
C      print*,'...End Test'

       do i=1, 2
         do j=1, 2
            mat0(i,j)=dcmplx(0d0,0d0)
            q0(i,j)=dcmplx(0d0,0d0)
            pn(i,j)=dcmplx(0d0,0d0)
            qn(i,j)=dcmplx(0d0,0d0)
         enddo
      enddo

      end

      subroutine sqr2x2(mir,mat0)
C  ...Takes the square root of a complex non-symetric2x2 matrix.
C     Uses diagonalization (sqrt(A)=U^(-1)*sqrt(diag(A))*U)
C     Comment: Only a positive definite matrix has one and only
C     square root
      implicit none
        double complex mir(2,2), lamba(2),u(2,2),uinv(2,2) 
        double complex a, b, c, d,a1(2), b1(2), ort
        double precision norma1(2), mira(2,2), Herm(2,2) 
        double complex eigen(2,2), mat(2,2), mat0(2,2)
        double complex mat2(2,2), mat2inv(2,2), rez(2,2)
        integer k
        
C       print*, 'mir(1,1)=', mir(1,1)
C       print*, 'mir(1,2)=', mir(1,2)
C       print*, 'mir(2,1)=', mir(2,1)
C       print*, 'mir(2,2)=', mir(2,2)

        
c       mir(1,1)=dcmplx(11.4112541988960,-0.822938066313368)
c      mir(1,2)=dcmplx(-1.71357952953510,0.184011459476014)
c      mir(2,1)=dcmplx(-1.71357952953510,0.184011459476014)
c      mir(2,2)=dcmplx(11.4112541988960,-0.822938066313368)

c      mir(1,1)=dcmplx(4.,-2.)
c       mir(1,2)=dcmplx(-5.,3.)
c       mir(2,1)=dcmplx(10.,1)
c       mir(2,2)=dcmplx(2.,10.)
        
C ... Case of diagonal matrix
      if(dabs(dble(mir(1,2))) <= 1d-10 .and. dabs(dimag(mir(1,2))) 
     . <= 1d-10) then
        if(dabs(dble(mir(2,1))) <= 1d-10 .and. dabs(dimag(mir(2,1))) 
     . <= 1d-10) then

         mat0(1,1)=sqrt(mir(1,1))
         mat0(1,2)=0d0
         mat0(2,1)=0d0
         mat0(2,2)=sqrt(mir(2,2))

         goto 401
        endif
        endif 

C ...  Case of non-diagonal matrix. Eigenvalues and eigenvectors of mir
        a=1.0d0 
      b=mir(2,2)+mir(1,1)
        c=(mir(1,1)*mir(2,2)-mir(2,1)*mir(1,2))
        d=b**2-4d0*a*c
        lamba(1)=(b-sqrt(d))/(2d0*a)
      lamba(2)=(b+sqrt(d))/(2d0*a)
      
C ...   Tests
c       print*, d, sqrt(d), (sqrt(d))**2
c       print*,'l1=',lamba(1)
c       print*,'l2=',lamba(2)
c       print*, 'test', lamba**2-b*lamba+c
      
C ...  Check for degeneracy
       if(lamba(1) == lamba(2)) then
C       print*,'HEHEHEHE'   
       b1(1) = dcmplx(1.d0,0.5d0)   
       a1(1) = -(mir(1,2)/(mir(1,1)-lamba(1)))*b1(1)
       b1(2) = dcmplx(1.d0,0.5d0)
       a1(2) = ((lamba(2)-mir(2,2))/mir(2,1))*b1(2)

       else

         do  10  k=1, 2

C      ... Choose one of the infinite set of eigenvectors
           b1(k) = dcmplx(1.d0*k,0.5d0)
           a1(k)=-(mir(1,2)/(mir(1,1)-lamba(k)))*b1(k)

C     ...  Normalization of eigenvectors
           norma1(k)=a1(k)*dconjg(a1(k))+b1(k)*dconjg(b1(k))
           a1(k)=a1(k)/dsqrt(norma1(k))
           b1(k)=b1(k)/dsqrt(norma1(k))
        
C     ... Test
c         print*, mir(1,1)*a1(k)+mir(1,2)*b1(k)-lamba(k)*a1(k)
c         print*, mir(2,1)*a1(k)+mir(2,2)*b1(k)-lamba(k)*b1(k)
C         print*, a1(k)*dconjg(a1(k))+b1(k)*dconjg(b1(k))

   10    continue 
       endif
C ...  Orthogonality check
C        ort = dconjg(a1(1))*a1(2) + dconjg(b1(1))*b1(2)
        
C        print*, 'ort=', ort
C ...  Gram-Schmidt orthogonalization
C        a1(2) = -ort*a1(1) + a1(2)
C        b1(2) = -ort*b1(1) + b1(2)

C        print*, 'ort=', dconjg(a1(1))*a1(2) + dconjg(b1(1))*b1(2)

       u(1,1) = a1(1)
       u(1,2) = a1(2)
       u(2,1) = b1(1)
       u(2,2) = b1(2)

C       print*, 'u(1,1)=', u(1,1)
C       print*, 'u(1,2)=', u(1,2)
C       print*, 'u(2,1)=', u(2,1)
C       print*, 'u(2,2)=', u(2,2)

       call zinv22(u,uinv)

       eigen(1,1) = sqrt(lamba(1))
       eigen(1,2) = 0d0
       eigen(2,1) = 0d0
       eigen(2,2) = sqrt(lamba(2))

       call zmpy22(u,eigen,mat)
       call zmpy22(mat,uinv,mat0)
       
c       print*, 'mat0(1,1)=', mat0(1,1)
c       print*, 'mat0(1,2)=', mat0(1,2)
c       print*, 'mat0(2,1)=', mat0(2,1)
c       print*, 'mat0(2,2)=', mat0(2,2)

  401  continue
       call zmpy22(mat0,mat0,mat2) 
       call zinv22(mat2,mat2inv)
       call zmpy22(mat2inv,mir,rez)

c       print*, '----------------------------------' 
C       print*, 'rez(1,1)=', rez(1,1)
C       print*, 'rez(1,2)=', rez(1,2)
C       print*, 'rez(2,1)=', rez(2,1)
C       print*, 'rez(2,2)=', rez(2,2)
c       print*, '----------------------------------'
       
      if(dabs(dble(rez(1,1))-1d0) >= 1d-6 .or. 
     .   dabs(dble(rez(2,2))-1d0) >= 1d-6) then
         call rx('square root of matrix cannot be found')
      endif
        
      end
