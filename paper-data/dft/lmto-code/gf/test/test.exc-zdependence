#!/bin/tcsh -f

# A shell script testing operation of Greens function lmgf
# set verbose

alias call 'set retcall = \!\!:2 ; set callarg = \!\!:3 ; goto \!\!:1'
alias runjob 'set retcall = \!\!:1; set outfile = \!\!:2 ; set callarg = \!\!:3 ; goto runjob'
alias runrdcmd 'set retcall = \!\!:1; set rdcmdfmt = \!\!:2 ; set outfile = \!\!:3 ; set callarg = \!\!:4 ; goto runrdcmd'
alias findcmd  'set retcall = \!\!:1 ; set prog_cmd = \!\!:2 ; set path_name = \!\!:3 ; set make_path = \!\!:4 ; goto findcmd'
alias compare_res 'set retcall = \!\!:1; set keyword = \!\!:2 ; set testvar = \!\!:3 ; set refvar = \!\!:4 ; set tol = \!\!:5 ; set passvar = \!\!:6 ; goto compare_res'
alias compare_res_0 'set retcall = \!\!:1; set keyword = \!\!:2 ; set testvar = \!\!:3 ; set tol = \!\!:4 ; set passvar = \!\!:5 ; goto compare_res_0'
alias cnvt_d_fmt  'set retcall = \!\!:1; set testvar = \!\!:2 ; set testval = \!\!:3 ; goto cnvt_d_fmt'
alias query 'set retcall = \!\!:1 ; set retcall2 = \!\!:2 ; set callarg = \!\!:3 ; goto query'

set allargs = ($argv)
set a
set slow
set testfile = $0
set testdir = $testfile:h
set topdir  = `cd $testdir/../..; pwd`
set maindir = $topdir/main
set space = '        '
set failed = 0

set filel = "mn.mnpt pt.mnpt vshft.mnpt log.mnpt mixm.mnpt"
set cplst = "gf/test/ctrl.mnpt gf/test/mn.mnpt gf/test/pt.mnpt"
set ext = mnpt
set nkj = 12
set lmargs5 = "-vnk=$nkj -vbzj=0 -vccor=f -vnit=1 -vgamrep=t"
set gfargs5 = "-vnk=$nkj -vbzj=0 -vccor=f -vnit=1 -vgamrep=t -vidx=2"

echo HA
goto chk5c

echo "$space ... set up ASA strux and starting potential."
echo "$space rm -f $filel"
             rm -f $filel
echo "$space cp $cplst ."
             cp $cplst .
echo "$space cp $cplst ."
echo "$space ... use EMESH for energy integration along real axis"
echo "$space cat gf/test/ctrl.mnpt | awk '"'{if (match($1,"EMESH=.*") && $2 == "10") next; else print}'"' >ctrl.mnpt"
             cat gf/test/ctrl.mnpt | awk '{if (match($1,"EMESH=.*") && $2 == "10") next; else print}' >ctrl.mnpt

runjob chk52 /dev/null "lmstr $ext -vnit=0 $lmargs5"
chk52:
echo "$space ... run band program to find the Fermi level"
echo "$space lm $ext $lmargs5 -vnit=0 --iactiv >out.lm"
             lm $ext $lmargs5 -vnit=0 --iactiv <<END >out.lm
1

q
END
set retval = $status
if ($retval != 0) goto cleanup
echo "$space Program lm returned successfully; output is in file out.lm"
set fermi = `grep '  ef ' log.$ext | tail -1 | awk '{print $7}'`
echo "$space efermi level generated by lm program = $fermi"

echo "$space ... run GF program, mode 1 to illustrate trapezoidal integration of N(E)"
runjob chk53 out.job1 "lmgf $ext $gfargs5 -vgfmod=1 --no-iactiv -vef=$fermi"
chk53:

echo "$space ... run GF program, mode 10 and 11 to illustrate J(E)"
runjob chk54a out.job10 "lmgf $ext $gfargs5 -vgfmod=10 --no-iactiv -vef=$fermi"
chk54a:
runjob chk54b out.job11 "lmgf $ext $gfargs5 -vgfmod=11 --no-iactiv -vef=$fermi"
chk54b:

cat <<EOF
Integration of charges, J by elliptical integration at successive endpoints
Starting at ef=-0.116282
#    E-Ef     q-q(ef) J(Mn)-J(ef)  J(Pt)-J(ef)
     0.000    0.0000     000.       000.
     0.002    0.0764     134.       004.
     0.004    0.1600     208.       009.
     0.006    0.2635     260.       021.
     0.008    0.3690     292.       033.
     0.010    0.4637     259.       043.
     0.012    0.5463     121.       053.
     0.014    0.6235    -102.       065.
     0.016    0.7066    -426.       081.
EOF

chk5c:
echo ' '
call diffiles chk55 "$testout.job10 $refout.job10"
chk55:


# ---------------- runjob --------------
exit
runjob:
  set quitjob=$retcall
  if ($outfile == ".") then
    echo "$space $callarg"
    echo " "
    $callarg
    set retval = $status
    if ($retval != 0) goto cleanup
    goto $quitjob
  endif

  if (`echo $outfile | awk '{print substr($1,1,2)}'` == '>>') then
    set appfile = `echo $outfile | awk '{print substr($1,3)}'`
    echo "$space $callarg  >> $appfile"
    $callarg >> $appfile
    set retval = $status
  else
    echo "$space $callarg  > $outfile"
    $callarg > $outfile
    set retval = $status
  endif
  if ($retval != 0) goto cleanup
  goto $quitjob

# ---------------- findcmd --------------
# Finds an executable program within the supplied path
# Usage: findcmd return_label executable_command path_name make_path
# If $executable_command is not found, findcmd does one of the following:
# If make_path = 'no' : returns silently.
# Otherwise findcmd aborts with a message, which assumes
# $make_path is the path where $executable_command is made.
exit
findcmd:
set found = 'no'
foreach ac_dir ($path_name)
 if (-x $ac_dir/$prog_cmd) then
   set $prog_cmd = $ac_dir/$prog_cmd
   set found = 'yes'
   break
 endif
end
if (! $?quiet) then
  if ($found == 'yes') echo "$space ... using executable $ac_dir/$prog_cmd"
  if ($found == 'no')  echo "$space ... executable $prog_cmd not found in path"
endif
if ($found == 'no' && $make_path != "no") then
  echo "  "
  echo "  Sorry, $testfile cannot find program '"$prog_cmd"' it needs to execute."
  echo "  '"$prog_cmd"' was not found in supplied path, or in the following:"
  echo "        $topdir $maindir"
# echo "  ... This script ($testfile) requires binary "'"rdcmd"'" to run."
  echo "  You must create or put '"$prog_cmd"' in your path before invoking this script."
  echo "  Normally '"$prog_cmd"' is created as part of the installation process."
  echo "  Invoking '"make $prog_cmd"' in $make_path should create it."
  echo "  $testfile aborting ..."
  exit -1
endif
goto $retcall

# ---------------- cleanup --------------
exit
cleanup:
  if ($retval != 0) echo "$space job returned with error status $retval"
  if ($retval != 0) echo "$space ... $testfile aborting"
  exit $retval

# ---------------- diffiles --------------
exit
diffiles:
  set quitjob=$retcall
  if ($?quiet) goto $quitjob
  set files = "$callarg"
  query diff11 $quitjob "compare $files"
diff11:
  diff $files | sed -n 1,50p
  goto $quitjob

# ---------------- zdiffiles --------------
exit
zdiffiles:
  set quitjob=$retcall
  if ($?quiet) goto $quitjob
  set files = "$callarg"
  query zdiff11 $quitjob "compare $files"
zdiff11:
  zdiff $files | sed -n 1,50p
  goto $quitjob

# ---------------- zcmpnfiles --------------
# Compares two files, treating each field as a number.
# call arguments should contain 3 strings: no-digits test-file reference-file
# Files with .gz or .Z extensions are assumed to be gzipped.
# Example :  call zcmpnfiles chk25 "6 dos-cls.$ext $testdir/dos-cls.$ext.gz"
# Creates temporary files $testdir/tmp1 $testdir/tmp2
exit
zcmpnfiles:
  set quitjob=$retcall
  set zcmpnargs = ($callarg)
  set digits = $zcmpnargs[1]
  set a = ' { for (i = NF; i > 0; --i) printf " %.'$digits'f", $i; printf "\n" }'

  set fn1 = $testdir/tmp1
  set fn2 = $testdir/tmp2
  if ("$zcmpnargs[2]:e" == 'gz' || "$zcmpnargs[2]:e" == 'Z') then
    set cat1 = 'gunzip -c'
  else
    set cat1 = cat
  endif
  if ("$zcmpnargs[3]:e" == 'gz' || "$zcmpnargs[3]:e" == 'Z') then
    set cat2 = 'gunzip -c'
  else
    set cat2 = cat
  endif

  $cat1  $zcmpnargs[2] | awk "$a" > $fn1
  $cat2  $zcmpnargs[3] | awk "$a" > $fn2
  set ncharfile = `wc $fn1 | awk '{print $3}'`
  cmp $fn1 $fn2 >/dev/null
  set retval = $status

  if ($retval == 0) then
    rm -f $fn1 $fn2
    goto $quitjob
  endif

  set retval = `cmp -l $fn1 $fn2 |& grep -v EOF | wc | awk '{printf "%d", $1}'`
  if ($retval == 0) set retval = '-1'
  rm -f $fn1 $fn2
  goto $quitjob

# ---------------- compare_res --------------
# Compares two numbers $testvar-$refvar and unsets $passvar if |testvar-refvar|<tol
# usage: compares_res retcall keyword testvar refvar tol passvar
#   keyword      : label (for printout)
#   testvar      : first number
#   refvar       : second number
#   tol          : tolerance
#   passvar      : $passvar is unset if |testvar-refvar|<tol
exit
compare_res:
  set quitjob=$retcall
# echo $retcall $keyword $testvar $refvar $tol $passvar
  echo -n "$space $keyword ($testvar) within tol ($tol) of reference ($refvar)? ... "
  if (`echo $testvar $refvar | awk -v tol=$tol '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k<=tol)}'`) then
    echo yes
  else
    echo no
    unset $passvar
  endif
  goto $quitjob

# ---------------- compare_res_0 --------------
# Compares a number $testvar and unsets $passvar if |testvar|<tol
# usage: compares_res_0 retcall keyword testvar tol passvar
#   keyword      : label (for printout)
#   testvar      : first number
#   tol          : tolerance
#   passvar      : $passvar is unset if |testvar|<tol
exit
compare_res_0:
  set quitjob=$retcall
#  echo $retcall $keyword $testvar $tol $passvar
 echo -n "$space $keyword ($testvar) smaller than tol ($tol)? ... "
  if (`echo $testvar 0 | awk -v tol=$tol '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k<=tol)}'`) then
    echo yes
  else
    echo no
    unset $passvar
  endif
  goto $quitjob

# ---------------- qprint (print only quiet not set) --------------
exit
qprint:
  set quitjob=$retcall
  if ($?quiet) goto $quitjob
  echo "$callarg"
  goto $quitjob

# ---------------- showout --------------
exit
showout:
  set quitjob=$retcall
  if ($?quiet) goto $quitjob
  echo ' '
  echo "$space ... Compare $callarg to line in file $refout":
  grep $callarg $testout
  if (`cat $testout | grep $callarg | wc | awk '{print $1}'` > 1) echo ' ---'
  gunzip -c $refout | grep $callarg
  goto $quitjob

# ---------------- query --------------
exit
query:
  unset skip
  if ($?slow != 0) then
    echo "$space"'*'"hit <return> to $callarg, s <return> to skip it."
    set a = ($<)
    if ($a == "") goto $retcall
    switch ($a)
      case "quit":
      case "q":
      case "a":
        exit
      case "i":
        unset slow
        breaksw
      case "s":
        set skip
        breaksw
      case "t":
        time
        goto query
      default:
        echo 'q to quit; i unsets slow; s skips this job, t shows time'
        goto query
    endsw
  endif
  if ($?skip) goto $retcall2
  goto $retcall

# ---------------- usage: --------------
usage:
cat <<EOF
 usage: test.gf [switches] [file-extension] [testcase-list]
        e.g., "test.gf co 1 2"
        If file-extension is missing, test.gf uses co
        Switches:
        --no-iactive runs tests without prompting user
        --quiet runs tests with minimal output and without prompting user
        --all   runs all tests available to test.gf
#       --verbose    script prints out extra information
EOF
exit -1

echo -.8 1 5 10 | plbnds -fplot -lt=1 -spin2 -dat=spin2 mnn
echo -.8 1 5 10 | plbnds -fplot -lt=1 -spin1 -dat=spin1 mnn
cat plot.plbnds | awk '{print;if ($7 == "-qr") {ncnt += 1; print "",$1,$2,$3,$4,$5, "2 -qr bnd" ncnt ".spin2";}}' >plot.plbnds2
