      program hsfp0_sc
      use m_readqg,only: readqg,readngmx
      use m_readeigen,only: init_readeigen,init_readeigen2,readeval,lowesteval
      use m_read_bzdata,only: read_bzdata,
     .  nqbz,nqibz,nqbzw,nteti,ntetf
     &  ,n1,n2,n3,qbas,ginv,qbz,wbz,qibz,wibz,qbzw,idtetf,ib1bz,idteti
     &  ,nstar,irk,nstbz,ngrp2=>ngrp
      use m_genallcf_v3,only: genallcf_v3,
     &     nclass,natom,nspin,nl,nn,nnv,nnc, ngrp,
     &     nlmto,nlnx,nlnxv,nlnxc,nlnmx,nlnmxv,nlnmxc, nctot,niw,nw,
     &     alat,ef, diw,dw,delta,deltaw,esmr,symgrp,clabl,iclass,nindxv,nindxc,ncwf,
     &     invg, il, in, im, ilnm, nlnm, ilv,inv,imv,  ilnmv, nlnmv,
     &     ilc,inc,imc,  ilnmc, nlnmc,nindx,konf,icore,ncore,
     &     occv,unoccv ,occc,unoccc, nocc, nunocc, plat, pos,z,ecore, freq, symgg ! symgg=w(igrp)
      use keyvalue,only: getkeyvalue

      use mpi_mod, rank=>mpi_rank
      use fcugw
      implicit none
!     ! =  Calculates the  self-energy \Sigma in GW approximation, including Off-diagonal components. =
!     !
c     SEx(q,itp,itpp) = <psi(q,itp) |SEx| psi(q,itpp)>
c     SEc(q,itp,itpp) = <psi(q,itp) |SEc| psi(q,itpp)>
c
c     where, SEc(r,r';w) = (i/2pi) < [w'=-inf,inf] G(r,r';w+w') Wc(r,r';w') >
c
c     This routine requirs a number from standard Input.
c     Look into script calling this routine ecalj/fpgw/exec/gwsc. E.g, this gwsc calls echo 2|../exec/hsfp0_sc >lsc when mode=2.
c
c     mode= 1: exchange    mode SEx, the exchange part of the self-energy
c     mode= 2: correlation mode SEc, the correlated part of the self-energy
c     mode= 3: core exchange mode SEXcore
c     !mode= 4: plot spectrum function ---See manual ---> this is in hsfp0.
c
c     iSigMode parameter which determines approximation for self-energy is given by GWinput file as iSigMode.
c     iSigMode=iSigMode
c     iSigMode==0 SE_nn'(ef)+image integr:delta_nn'(SE_nn(e_n)-SE_nn(ef))
c     iSigMode==1 SE_nn'(ef)+delta_nn'(SE_nn(e_n)-SE_nn(ef))
c     iSigMode==2 SE_nn'((e_n+e_n')/2)
c     iSigMode==3 (SE_nn'(e_n)+SE_nn'(e_n'))/2  <--- this is mainly used
c     iSigMode==5 delta_nn' SE_nn(e_n)
c     output file should contain hermitian part of SE for energies to be real
c     (for example, hermitian conjugate of SE_nn'(e_n) means SE_n'n(e_n')^* )
c
c     This version (Aug 14) requires PPOVL and PPOVL0 for matrix elements.
c     No other PPOVL files are needed.
c
c     Apr 2002 takao kotani. multiple augmentation waves per l.
c     This hsfp0 is build from hsec10.f by F.Aryasetiawan.
!     ! -----------------------------------------------------------------------------------

c     real(8),parameter :: ua  = 1d0    ! constant in w(0)exp(-ua^2*w'^2) to take care of peak around w'=0

c     test switches to calculate the self-energy based on an another separation of \Sigma.
!     \Sigma = \Sigma_{sx} + \Sigma_{coh} + \Sigma_{img axis} + \Sigma_{pole} by Hedin PR(1965)A785
!     I found COH term has inevitably poor accuracy.
      logical ::tetra, tetra_hsfp0,
     &     screen = .false.,    ! \Sigma_{sx} for mode 1 and
                                ! \Sigma_{img axis} + \Sigma_{pole} for mode 2
     &     cohtest= .false.     ! \Sigma_{coh}. mode swich is not required.
c     &  , tetra  = .false.  ! test switch for tetrahedron method test.
!     tetra=T is only effective for exchange=T case.
!     Tetrahedron mehod for correlation is a bit
!     difficult and I gave up for a while.
!     If you want to calculate with tetra=T for exchange, you
!     have to uncomment tetra related part in
!     sxcf.f, and a part calling sxcf in this routine. Note wtet wtetef!
!     They sometimes cause array destruction if you run tetra=T without comment them.

!      real(8) :: shtw
      integer:: ixc,iopen,ifhbed,nprecb,mrecb,mrece,nband,
     .  ibas,ibasx,ngpmx,nxx,ngcmx,nbloch,ifqpnt,ifwd,izl,
     .  nprecx,mrecl,nblochpmx2,nwp,niwt,nqnum,mdimx,nblochpmx,
     .  noccxv,maxocc,noccx,ifvcfpout,iqall,iaf,ntq,
     .  i,k,nspinmx,nq,is,ip,iq,idxk,ifoutsex,iclose,nq0i,ig,
     .  mxkp,nqibzxx,ntet,nene,iqi,ix,iw,ifi,ifsec(2),ifxc(2),ifsex(2),
     .  ifphiv(2),ifphic(2),ifec,ifexsp(2),ifsex2(2),ifsec2(2),ifsecomg(2),
     .  nlnx4,irot,invr,invrot,ivsum,ifoutsec,ndble=8

      real(8) :: pi,tpia,vol,voltot,rs,alpha,qfermi,efx,valn,efnew,
     .  edummy,efz,qm,xsex,egex,edummyd(1),zfac1,zfac2,dscdw1,dscdw2,dscdw,zfac

      logical lqall,laf
      integer,allocatable :: itq(:)
      real(8),allocatable    :: q(:,:)

      integer nthreads,omppid
      real(8):: cpusec,walltime0,dwtime

c     takao
      integer,allocatable :: ngvecpB(:,:,:), !ngveccB(:,:,:),
     &     ngvecp(:,:), ngvecc(:,:),iqib(:), !ngcni(:),
     &     kount(:,:), nx(:,:),nblocha(:),lx(:) !,ngveccBr(:,:,:)
      real(8),allocatable:: vxcfp(:,:,:),
     &     wqt(:), wgt0(:,:),q0i(:,:),
     &     ppbrd (:,:,:,:,:,:,:),cgr(:,:,:,:),eqt(:),
     &     ppbrdx(:,:,:,:,:,:,:), !aaa(:,:), symope(:,:,:), !qibz(:,:),
     &     ppb(:), eq(:),       !,pdb(:),dpb(:),ddb(:)
     &     eqx(:,:,:),eqx0(:,:,:),ekc(:),coh(:,:)
      complex(8),allocatable:: geigB(:,:,:,:) ,zsec(:,:,:)
c
      logical :: exchange, legas
      real(8) ::  rydberg,hartree
      real(8):: qreal(3), ntot,nocctotg2,tripl,xxx(3,3)
      logical ::nocore
      integer :: verbose,iverbose,idalloc

c     space group infermation
      integer,allocatable :: iclasst(:), invgx(:), miat(:,:)
      real(8),allocatable    :: tiat(:,:,:),shtvg(:,:)

c     tetra
      real(8),allocatable :: qz(:,:),qbzxx(:),wbzxx(:),wtet(:,:,:,:),
     &     eband(:,:,:), ene(:) !,ecore(:,:)
      integer,allocatable ::idtetx(:,:),idtet(:,:),ipq(:)
     &     ,iene(:,:,:),ibzx(:) !,nstar(:)
c     real(8) :: qbasmc(3,3)
      integer ::ib,iqx,igp,iii,ivsumxxx,isx,iflegas, iqpntnum
c
      real(8),allocatable   :: eex1(:,:,:),exsp1(:,:,:),qqex1(:,:,:,:)
      integer,allocatable:: nspex(:,:),ieord(:),itex1(:,:,:)
      real(8)    :: qqex(1:3), eex,exsp,eee, exwgt,deltax0
      integer :: itmx,ipex,itpex,itex,nspexmx,nnex,isig,iex,ifexspx
     &     ,ifexspxx ,ifefsm, nq0ix,ifemesh,nz
      character(3)  :: charnum3
      character(12) :: filenameex
      logical :: exspwrite=.false.
      character*8 xt

      integer,parameter :: NULLI=-99999
      integer :: iSigMode,ifinin ,idummy !iwini,iwend       !sf 21May02

      real(8),allocatable:: omega(:) !sf 21May02
c     real(8) ::  omegamax,dwplot,omegamaxin
c     logical :: sergeys     !sf 21may02

c     real(8)   :: ebmx
c     integer:: nbmx
      real(8)   :: ebmx(2)
      integer:: nbmx(2)

      real(8):: volwgt

      integer::nwin, incwfin
      real(8)::efin
      integer,allocatable::imdim(:)
      real(8),allocatable::freqx(:),freqw(:),wwx(:) !,expa(:)

      integer:: ngpn1,mrecg,ngcn1
      real(8)   :: wgtq0p,quu(3)

      character(2):: soflag
      integer:: ifianf

      logical ::smbasis
      integer:: ifpomat,nkpo,nnmx,nomx,ikpo,nn_,no,ivec(10)
      real(8):: q_r(3)
      real(8),allocatable:: qrr(:,:)
      integer,allocatable:: nnr(:),nor(:)
      complex(8),allocatable:: pomatr(:,:,:),pomat(:,:)
      logical allq0i
      integer:: nw_i
      logical:: exonly
      real(8):: wex
!     ! newaniso mode
      real(8),allocatable:: vcousq(:),dmlx(:,:),epinvq0i(:,:),wklm(:),vcoud(:)
      complex(8),allocatable:: zcousq(:,:)
C     logical:: newaniso
      integer:: ifvcoud,lxklm,ifidmlx,iqq

      integer,allocatable,target:: nrkip_all(:,:,:,:),irkip_all(:,:,:,:)
      integer,pointer:: irkip(:,:,:,:),nrkip(:,:,:,:)
      integer:: irank,nrank

!     !
      integer,allocatable:: neibz(:),nwgt(:,:),ngrpt(:),igx(:,:,:),igxt(:,:,:),eibzsym(:,:,:)
      integer:: iqxend,iqxini
      integer:: l2nl,igrp,kx,kr
      logical :: iprintx,tiii,timereversal, eibz4sig,tiiiout

      integer:: ifevec,ifvxc,nsym,nhdim,it,nblk,iband,napw,ldim,ierr,ispx,nbsize,nbsizemx
     &     ,iblk1,iblk2,ii1,ii2,ie1,ie2,ne1,ne2,iqxx, ndimhx, nspx,nnnx
      integer,allocatable::iblki(:),iblke(:),nbandmx(:,:)
      complex(8),allocatable:: evec(:,:),evec_inv(:,:),evecrot(:,:),rmatjj(:,:,:)
      real(8),allocatable::evaliq(:)
      real(8)::tolry=1d-4,qqqx(3),qtarget(3)
      complex(8),allocatable::zsect(:,:)

      logical MPIinitexists
      logical :: selectqp=.false.,diagonly=.false.,mpi__root=.true.
      integer:: ret,dest,nnn !,ifiwqfac
      character(128) :: ixcc
      real(8):: eftrue,esmref !jan2013

      integer:: procid,nqcalc,nrankv,ifigwb_,ifigwx1_,ifigwx2_,ifvxc_,ifevec_
      character*256:: extn,ext
      character*256,allocatable:: extp(:)
      integer, allocatable :: iprocq(:) ! procid that generated data for given iq
      integer, allocatable :: ifevec__(:),ifvxc__(:)  ! procid-dependent file pointers

      character(len=2) :: mode
! modes:
! no: not given, so ask interactively (interactive input is 1,2 or 3), same applies to anything other than the following
! xc: exchange mode     (old 1)
! cr: correlation mode  (old 2)
! cx: core exchange     (old 3)
! dmt

      call mpi_start
      walltime0 = dwtime()
C$OMP parallel
      nthreads = omppid(0)
C$OMP end parallel

C ... Enter mode from stdin
      call getjobmode(ixc); nz=0
      if (cohtest) then
        screen = .true.
        ixc = 2; nz=0
        if( rank == 0) open(671,file='COH')
      else if (ixc == NULLI) then
        if (rank == 0) then
          call parse_cmd_args(mode)
          if (mode == 'xc') then
              ixc = 1
          else if (mode == 'cr') then
              ixc = 2
          else if (mode == 'xc') then
              ixc = 3
          else
              write(6,*) ' Select from one of the following modes :'
              write(6,*) ' Sx(1) Sc(2) ScoreX(3)'
              write(6,*) ' [option --- (+ QPNT.{number} ?)] '
              write(6,*) ' Add 1000, eg, 1001 is diagonal only mode for one-shot Z=1'
              write(6,"('  mode =? '$)")
              call readin5(ixc,nz,idummy)
          end if
        endif
      endif
#ifdef USE_MPI
      call MPI_Bcast(ixc, 1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
      call MPI_Bcast(nz,  1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
#endif
      if (rank == 0) then
        call headver('hsfp0_sc',ixc)
        write(6,*) ' ixc nz=',ixc, nz
      endif
      if (ixc<0) call rx('Choose computational mode with --job=#')
      if (ixc>1000) then         !selected QP
        ixc=mod(ixc,1000)
        selectqp=.true.
        diagonly=.true.
      endif

      if (rank == 0) then
        inquire(file='MPI.init',EXIST=MPIinitexists)
        if (MPIinitexists) then
          open(100,file="MPI.init", err=1234 )
          read(100,*) mpi_N1, mpi_N2
          close(100)
        else
          mpi_N1 = mpi_size
          mpi_N2 = 1
        endif
      endif
#ifdef USE_MPI
      call MPI_Bcast(mpi_N1, 1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
      call MPI_Bcast(mpi_N2, 1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
#endif
 1234 continue
#ifdef USE_MPI
      if(rank == 0) write(6,*) "MPI initialization done."
#endif

      hartree=2d0*rydberg()


!     ! ===  readin BZDATA. See gwsrc/rwbzdata.f ===
!     ! See use m_read_bzdata,only: at the top of this routine
c--------readin data set when you call read_BZDATA ---------------
c     integer::ngrp,nqbz,nqibz,nqbzw,nteti,ntetf
c     integer:: n1,n2,n3
c     real(8):: qbas(3,3),ginv(3,3),qbasmc(3,3)
c     real(8),allocatable:: qbz(:,:),wbz(:),qibz(:,:)
c     &    ,wibz(:),qbzw(:,:)
c     integer,allocatable:: idtetf(:,:),ib1bz(:),idteti(:,:)
c     &    ,nstar(:),irk(:,:),nstbz(:)
c-----------------------------------------------------------------
      call read_BZDATA()
      call pshprt(60)
!     ! -----------------------------------------------------------

!     ! === readin GWIN and LMTO, then allocate and set datas. ===
!     ! See use m_genallcf_v3,only: at the top of this routine
      nwin   = 0                !Readin nw from NW file
      efin=-999d0               !not readin EFERMI
      if(ixc==3) then; incwfin= -2 !core exchange mode
      else           ; incwfin= -1 !use 7th colmn for core at the end section of GWIN
      endif
      call genallcf_v3(nwin,efin,incwfin) !in module m_genallcf_v3
      if(ngrp/= ngrp2) call rx( 'ngrp inconsistent: BZDATA and LMTO GWinput')
c---  These are allocated and setted by genallcf_v3
c     integer::  nclass,natom,nspin,nl,nn,nnv,nnc, ngrp,
c     o  nlmto,nlnx,nlnxv,nlnxc,nlnmx,nlnmxv,nlnmxc, nctot,niw,nw
c     real(8) :: alat,ef, diw,dw,delta,deltaw,esmr
c     character(120):: symgrp
c     character(6),allocatable :: clabl(:)
c     integer,allocatable:: iclass(:)
c     &  ,nindxv(:,:),nindxc(:,:),ncwf(:,:,:) ,
c     o    invg(:), il(:,:), in(:,:), im(:,:),   ilnm(:),  nlnm(:),
c     o    ilv(:),inv(:),imv(:),  ilnmv(:), nlnmv(:),
c     o    ilc(:),inc(:),imc(:),  ilnmc(:), nlnmc(:),
c     o    nindx(:,:),konf(:,:),icore(:,:),ncore(:),
c     &    occv(:,:,:),unoccv(:,:,:)
c     &   ,occc(:,:,:),unoccc(:,:,:),
c     o    nocc(:,:,:),nunocc(:,:,:)
c     real(8), allocatable::
c     o  plat(:,:),pos(:,:),z(:),  ecore(:,:), freq(:), symgg(:,:,:) ! symgg=w(igrp)
!     ! -----------------------------------------------------------
      esmref=esmr

!     ! reading self-energy mode parameter from file 'GWinput'

      if (rank == 0) then
        call readd_iSigma_en(ifinin,iSigMode)
c       Get nbmx,ebmx
        call getnemx8(nbmx,ebmx)
      endif
#ifdef USE_MPI
      call MPI_Bcast(iSigMode, 1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
      call MPI_Bcast(nbmx,     2, MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
      call MPI_Bcast(ebmx,     2, MPI_DOUBLE_PRECISION, 0, MPI_COMM_WORLD, ierror)
#endif

!! forget ebmx2 nbmx2
      nbmx(2)=9999999
      ebmx(2)=1d10
ccccccccccccccccccccccccccccc
      write(6,"('  nbmx ebmx from GWinput=',2i8,2d13.5)") nbmx,ebmx
!     !     See sxcf_fal2z--------
!     !     nbmx1 ebmx1: to set how many bands of <i|sigma|j>  do you calculate.
!     !     nbmx2 ebmx2: to restrict num of bands of G to calculate G \times W

c-------------------------------------------------------------------
c     if (nclass > mxclass) stop ' hsfp0: increase mxclass'
!!!!  WE ASSUME iclass(iatom)= iatom !!!!!!!!!!!!!!!!!!!!!!!!!
      if (nclass /= natom ) call rx( ' hsfp0: nclass /= natom ')
      if(rank == 0) print *,' hsfp0: end of genallcf_v3'

      call pshprt(30)
      pi   = 4d0*datan(1d0)
      tpia = 2d0*pi/alat
C      call dinv33(plat,1,xxx,vol)
C      voltot = dabs(vol)*(alat**3)
      voltot = abs(alat**3*tripl(plat,plat(1,2),plat(1,3)))
c     shtw = 0d0
c     if(esmr<1d-5) shtw=0.01d0 ! Ferdi's shift to avoid resonance effect(maybe) !I had this until sep2012
      tetra= tetra_hsfp0()

c---  ef is taken as rs for the empty-sphere test case of legas=T case -------------
      legas = .false.
      if(rank == 0) INQUIRE (FILE = 'LEGAS', EXIST = legas)
#ifdef USE_MPI
      call MPI_Bcast(legas,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierror)
#endif
      if(legas) then            !!! test for electron gas case.
        print *,' find LEGAS. legas =',legas
        iflegas = 2101

        if(rank == 0) then
          open (iflegas,file='LEGAS')
          read(iflegas,*)rs
          close(iflegas)
        endif
#ifdef USE_MPI
        call MPI_Bcast(rs,1,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ierror)
#endif
        alpha = (9*pi/4d0)**(1d0/3d0)
        qfermi = alpha/rs
        efx  = qfermi**2
        valn = efx**1.5d0*voltot/3d0/pi**2
        if(rank == 0) then
          write (6,*)'  #### egas test mode  legas=T #### given rs =',rs
          write (6,*)' egas  Exact Fermi momentum  qf  =', qfermi
          write (6,*)' egas  Exact Fermi energy    Ef  =', efx
          if(tetra) call rx( 'legas You have to give ef of  tetrahedron')
        endif
      endif

      ifexsp=0
      if(ixc==1) then
        exchange=.true.
        write(6,"(/' --- Exchange mode --- ')")
        if(rank == 0) then
          ifxc(1)  = iopen('XCU'//xt(nz),1,-1,0)
          ifsex(1) = iopen('SEXU'//xt(nz),1,-1,0)
          ifsex2(1)= iopen('SEX2U',0,-1,0) !out SEX_nn'
          if (nspin == 2) then
            ifxc(2)  = iopen('XCD'//xt(nz),1,-1,0)
            ifsex(2) = iopen('SEXD'//xt(nz),1,-1,0)
            ifsex2(2)= iopen('SEX2D',0,-1,0) !out SEX_nn'
          endif
        endif

C        INQUIRE (FILE = 'EXspTEST', EXIST = exspwrite)
C        if(exspwrite) then
C          print *,'--- Find EXspTEST ExspectrumWrite=',exspwrite
C          print *,'--- esmr is chosen to be 2d0 Ry'
C          esmr= 2d0
C          do is=1,nspin
C            ifexsp(is)  = iopen('EXSP.'//char(48+is),1,-1,0)
C          enddo
C        endif

      elseif(ixc==2) then
        exchange=.false.
        if(rank == 0) then
          write(6,"(/' --- Correlation mode --- ')")
          if(cohtest) write(6,*) ' COH calculation mode. Results in COH'
          ifsec(1) = iopen('SECU'//xt(nz),1,-1,0) ! output files
          ifsec2(1) = iopen('SEC2U',0,-1,0) !out SEC_nn'
          if (nspin == 2) then
            ifsec(2) = iopen('SECD'//xt(nz),1,-1,0)
            ifsec2(2) = iopen('SEC2D',0,-1,0) !out SEC_nn'
          endif
        endif
      elseif(ixc==3) then
        exchange=.true.
        esmr = 0d0
        if(rank == 0) then
          write(6,"(/' --- Core Exchange mode --- ')")
          ifsex(1) = iopen('SEXcoreU'//xt(nz),1,-1,0)
          ifsex2(1) = iopen('SEXcore2U',0,-1,0) !out SEXcore_nn'
          if (nspin == 2) then
            ifsex(2) = iopen('SEXcoreD'//xt(nz),1,-1,0)
            ifsex2(2) = iopen('SEXcore2D',0,-1,0) !out SEXcore_nn'
          endif
        endif
      else
        call rxi( ' hsfp0_sc: mode not recognized, ',ixc)
      endif
#ifdef CUD
      call init_cublas()
#endif
      if (rank == 0) then
      write(6,"(/' Frequency parameters:')")
      write(6,"('   frequencies on Im omega axis =',i5)") niw
      write(6,"('   frequencies on Re omega axis =',i5)") nw
      write(6,"('   mesh spacing along Real axis =',f12.6,' Ha')") dw
      write(6,"('   Broadening in the poles of G =',f12.6)") esmr
      write(6,"('   deltaw (to get Z factor)     =',f12.6)") deltaw

      ifhbed = iopen('hbe.d',1,0,0)
      read (ifhbed,*) nprecb,mrecb,mrece,i,i,nband,mrecg
      if (nprecb == 4) call rx('hsfp0: b,hb must be double precision')

      write(6,"(/' Dimensioning parameters:')")
      write(6,"('   number of augmentation channels =',i5)") nlmto
      write(6,"('   maximum hamiltonian dimension   =',i5)") nband

      endif
#ifdef USE_MPI
      call MPI_Bcast(nprecb,   1,  MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
      call MPI_Bcast(mrecb,    1,  MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
      call MPI_Bcast(mrece,    1,  MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
      call MPI_Bcast(nband,    1,  MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
      call MPI_Bcast(mrecg,    1,  MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
#endif

      call init_readeigen(ginv,nspin,nband,mrece) !initialization of readEigen

C --- Get space group information ---
c     Need true class information in order to determine the space group
c     because the class in the generated GW file is dummy.(iclass(ibas)=ibas should be kept).
      allocate(iclasst(natom),invgx(ngrp),miat(natom,ngrp),tiat(3,natom,ngrp),shtvg(3,ngrp))
      if(rank == 0) then
        open (102,file='CLASS')
        do ibas = 1,natom
          read(102,*) ibasx, iclasst(ibas)
          write(6, "(2i10)") ibasx, iclasst(ibas)
        enddo
      endif
#ifdef USE_MPI
      call MPI_Bcast(ibasx,  1,     MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
      call MPI_Bcast(iclasst,natom, MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
#endif

c     Get space-group transformation information. See header of mptaouof.
      call mptauof(symgg,ngrp,plat,natom,pos,iclasst,miat,tiat,invgx,shtvg )

C      if(verbose()>=40) write (*,*)' hsfp0.sc.m: end of mptauof'

c     Get array size to call rdpp
      if (rank == 0) call getsrdpp2( nclass,nl,nxx)
      call readngmx('QGpsi',ngpmx)
      call readngmx('QGcou',ngcmx)
#ifdef USE_MPI
!      write(0,'("[",I4,"] nxx (before) = ",I8)') rank, nxx
!      write(0,'("[",I4,"] Broadcasting nxx, ngpmx and ngcmx")') rank
!      write(0,'("[",I4,"] nxx = ",2I8)') rank, nxx, ierror
      call MPI_Bcast(nxx,   1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
      call MPI_Bcast(ngpmx, 1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
      call MPI_Bcast(ngcmx, 1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
#endif

      allocate( nx(0:2*(nl-1),nclass), nblocha(nclass),lx(nclass),
     &     ppbrd ( 0:nl-1, nn, 0:nl-1,nn, 0:2*(nl-1),nxx, nspin*nclass),
     &     cgr(nl**2,nl**2,(2*nl-1)**2,ngrp))

C --- Readin plane wave parts, and radial integrals ppbrd. MPI handled inside rdpp_v3
!     ppbrd = radial integrals
!     cgr   = rotated cg coeffecients.
!     geigB = eigenfunction's coefficiens for planewave.
!     ngvecpB (in 1stBZ) contains G vector for eigen function.
!     ngveccB (in IBZ)   contains G vector for Coulomb matrix.
      call rdpp_v3(nxx,nl,ngrp,nn,nclass,nspin,symgg,qbas,nblocha,lx,nx,ppbrd,mdimx,nbloch,cgr)
c     nblochpmx = nbloch + ngcmx !not use this oct2005

      if (rank == 0) then
        allocate(ngvecp(3,ngpmx),ngvecc(3,ngcmx))
        call readqg('QGpsi',qibz(1:3,1),ginv, quu,ngpn1, ngvecp)
        call readqg('QGcou',qibz(1:3,1),ginv, quu,ngcn1, ngvecc)
        deallocate(ngvecp,ngvecc)
      endif
#ifdef USE_MPI
!ML   this might not be necessary !!
      call MPI_BCast(ngcn1, 1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
      call MPI_BCast(ngpn1, 1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
      call MPI_BCast(quu, 9, MPI_REAL8, 0, MPI_COMM_WORLD, ierror)
#endif
      call pshprt(60)

C --- Readin WV.d
      if (.not.exchange.or.(exchange.and.screen)) then !screen means screened exchange case
        if(rank == 0) then
          ifwd = iopen('WV.d',1,-1,0) !direct access files WVR and WVI which include W-V.
          read (ifwd,*) nprecx,mrecl,nblochpmx,nwp,niwt,nqnum,nw_i
          ifwd = iclose('WV.d')
          write(6,"(' Readin WV.d =', i3,i10,2i6,3i5)") nprecx,mrecl,nblochpmx,nwp,niwt,nqnum,nw_i
          call checkeq(nprecx,ndble)
          nw = nwp
          if (niwt /= niw) call rx('hsfp0: wrong niw')
         endif ! rank == 0
#ifdef USE_MPI
         call MPI_BCast(nblochpmx, 1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
         call MPI_BCast(nwp ,  1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
         call MPI_BCast(niwt,  1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
         call MPI_BCast(nqnum, 1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
         call MPI_BCast(nw_i,  1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
#endif
      endif

      if(tetra) goto 201

!! == Determine Fermi energy ef for given valn (legas case) or corresponding charge given by z and konf.==
!!    When esmr is negative, esmr is given automatically by efsimplef.
      call efsimplef2a(nspin,wibz,qibz,ginv,nband,nqibz,
     .  konf,z,nl,natom,iclass,nclass,
     .  valn, legas, esmref, !!! valn is input for legas=T, output otherwise.
     i  qbz,nqbz,efnew)
      if(ixc/=3) ef = efnew
      eftrue = efnew
c     check total electron number
      ntot  = nocctotg2(nspin, ef,esmr, qbz,wbz, nband,nqbz)
      print *,' ef    =',ef
      print *,' esmr  =',esmr
      print *,' valn  =',valn
      print *,' ntot  =',ntot
      print *,' eftrue=',eftrue

!! == Core-exchange case. ef means just below the valence eigenvalue (to take only core in sxcf).==
      if(ixc==3) then
         ef = lowesteval() -1d-3 !lowesteigen(nspin,nband,qbz,nqbz) - 1d-3 !lowesteb was
         if(rank == 0) call getkeyvalue("GWinput","EXonly",wex,default=0d0)
#ifdef USE_MPI
         call MPI_BCast(wex,  1, MPI_DOUBLE_PRECISION, 0, MPI_COMM_WORLD, ierror)
#endif
         if(wex==0d0) then
            exonly=.false.
         else
            exonly=.true.
          if(rank == 0) print *,' exonly=T ecore shift: ecore---> ecore-100'
            ecore = ecore-100.0
         endif
         if (maxval(ecore(:,1:nspin))>ef) then ! If core level is above bottom of valence ...
           ivec(1:2) = maxloc(ecore(:,1:nspin))
           if (rank == 0) then
             print 333, ivec(1),ivec(2), ecore(ivec(1),ivec(2)), ef
  333        format(' hsfp0 core level ecore(',i3,',',i1,
     .         ') =',f9.4,' lies above bottom of valence band =', f9.4/
     .         ' core levels:')
            do is=1,nspin
               do ix=1,nctot
                  write(6,"(2i4,1pd13.5)") ix,is,ecore(ix, is)
               enddo
            enddo
          endif
          call rx( 'hsfp0 ixc=3: ecore>evalence')
        endif
      endif

c-------------------------
 201  continue
c-------------------------
!ML   needs to run on all nodes
      call init_readeigen2(mrecb,nlmto,mrecg) !initialize m_readeigen
c     the coulomb matrix for exchange.
!     if((.not.newaniso()).and.exchange) ifvcfpout = iopen('VCCFP',0,-1,0)

!!    read q-points and states
!     if(selectqp .and. mpi__root) then
      if(selectqp .and. rank == 0) then
        call getkeyvalue("GWinput","<QPNT>",unit=ifqpnt,status=ret)
        lqall      = .false.
        laf        = .false.
        call readx   (ifqpnt,10)
        read (ifqpnt,*) iqall,iaf
        if (iqall == 1) lqall = .true.
        if (iaf   == 1)   laf = .true.
        call readx   (ifqpnt,100)
c         read (ifqpnt,*) ntq
c         allocate( itq(ntq) )
c         read (ifqpnt,*) (itq(i),i=1,ntq)
        if (lqall) then         !all q-points case
          nq         = nqibz
          allocate(q(3,nq))
          call dcopy   (3*nqibz,qibz,1,q,1)
        else
          call readx   (ifqpnt,100)
          read (ifqpnt,*) nq
          allocate(q(3,nq))
          do k = 1,nq
            read (ifqpnt,*) i,q(1,k),q(2,k),q(3,k)
          enddo
        endif
        nspinmx = nspin
        if (laf) nspinmx =1
        close(ifqpnt)
      else
!     q-points. bzcase()=1
C        if(bzcase()==1)then
          nq = nqibz
          allocate(q(3,nq))
          call dcopy   (3*nqibz,qibz,1,q,1)
C        else
C          nq = nqibz_r
C          allocate(q(3,nq))
C          do iq= 1,nqibz_r
C            q(:,iq)=qibz_r(:,iq)
C          enddo
C        endif
      endif
!
C      call MPI__Broadcast(nq)
C      if(mpi__root) then
C        do dest=1,mpi__size-1
C          call MPI__REAL8send(q,3*nq,dest)
C        enddo
C      else
C        call MPI__REAL8recv(q,3*nq,0)
C      endif

!! == Determine ntq = max number of bands to calculate for all qp. ==
!!    ntq should be common for all ixc modes.
!!    See also ntqxx in sxcf_fal.sc.F
!     if(mpi__root) then
      if(rank == 0) then
        allocate(eqt(nband))
        ntq=0
        do is = 1,nspin
          do ip = 1,nq
            call readeval(qibz(1,ip),is, eqt)
            do iband=1,nband
              ntq = max(iband,ntq)
              if(eqt(iband)-eftrue>ebmx(1)) exit
            enddo
          enddo
        enddo
C       See if ntq needs increasing to include degeneracy at gamma
        do is = 1,nspin
          do ip = 1,nq
            if (ntq == nband) exit
            call readeval(qibz(1,ip),is, eqt)
            if (abs(eqt(ntq+1)-eqt(ntq)) < 1d-4) ntq=ntq+1
          enddo
        enddo
        ntq = min(ntq, nbmx(1))
        deallocate(eqt)
C       write(*,"(' nband ntq ef eftrue=', 2i5,2f9.4)")nband,ntq,ef,eftrue
        write(*,321) nband,ntq,ef,eftrue
  321   format(' calculate sigma for at most',i4,' bands out of',i4,' available.',
     .    '  ef  =',f10.6,'  eftrue  =',f10.6)
      endif
!     call MPI__Broadcast(ntq)

      allocate (itq(ntq))
      do  i = 1, ntq
        itq(i) = i              !itq is used also in hsfp0.m.F
      enddo
      do  iq = 1, nq
        write(6,'(" Target iq q=",i5,3f9.4)')iq,q(:,iq)
      enddo

!! ANF mode ---> not so much used now... need to revise it in future.
      nspinmx = nspin
      laf = .false.
!     inquire(file='ANFcond',EXIST=laf)
      if(laf) then
         ifianf = 211
         open(ifianf,file='ANFcond')
         read(ifianf,*) soflag
         if(soflag=='SO') then
            print *,' ANFcond found. but SO case is not implimented. Not using ANF symm'
            goto 889            !SO case is not implimented
         endif
         print *, 'Find ANFcond--- up only'
         nspinmx =1
      endif
 889  continue

!!
      allocate(omega(ntq))
!     ! read LDA eigenvalues
      allocate(eqx(ntq,nq,nspin),eqx0(ntq,nq,nspin),eqt(nband))
      do is = 1,nspin
         do ip = 1,nq
            call readeval(q(1,ip),is,eqt)
            eqx0(1:ntq,ip,is) = eqt(itq(1:ntq))
            eqx (1:ntq,ip,is) = rydberg()*(eqt(itq(1:ntq))- eftrue)
         enddo
      enddo
      deallocate(eqt)
      if(rank == 0) call winfo(6,nspin,nq,ntq,is,nbloch,ngpn1,ngcn1,nqbz,nqibz,ef,deltaw,alat,esmr)

c-------------------------
c     LDA exchange-correlation
c-------------------------
c     - takao Vxc is readin from VXCFP
      if(ixc==1) then
         allocate(  vxcfp(ntq,nq,nspin) )
         call rsexx(nspin,itq,q,ntq,nq, ginv, vxcfp) !add ginv july2011
!        if(mpi__root) then
         if(rank == 0) then
           do is = 1,nspinmx
             write (ifxc(is),*) '==================================='
             write (ifxc(is),"(' LDA exchange-correlation : is=',i3)")is
             write (ifxc(is),*) '==================================='
             call winfo(ifxc(is),nspin,nq,ntq,is,nbloch
     &            ,ngpn1,ngcn1,nqbz,nqibz,ef,deltaw,alat,esmr)
             write (ifxc(is),*)' ***'
             write (ifxc(is),"(a)") ' jband   iq ispin
     &            qvec
     &            eigen-Ef (in eV)
     &            LDA XC (in eV)'
             ifoutsex = ifxc(is)
             write(6,*)
             do ip = 1,nq
               do i  = 1,ntq
                 write(ifoutsex,"(3i5,3d24.16,3x,d24.16,3x,d24.16)")
     &                  itq(i),ip,is, q(1:3,ip), eqx(i,ip,is),
     &                  vxcfp(i,ip,is)
                 if(eqx(i,ip,is) <1d20.and.vxcfp(i,ip,is)/=0d0) then !takao june2009. See lmf2gw (evl_d=1d20; in Ry.. but eqx is in eV. no problem for inequality).
                      write(6,"(' j iq isp=' i3,i4,i2,'  q=',3f8.4,
     &                     '  eig=',f10.4,'  Sxc(LDA)=',f10.4)")
     &                     itq(i),ip,is, q(1:3,ip), eqx(i,ip,is),
     &                     vxcfp(i,ip,is)
                 endif
               end do ! i
             end do ! ip
             if(is==1) isx = iclose('XCU'//xt(nz))
             if(is==2) isx = iclose('XCD'//xt(nz))
           enddo !     end of spin-loop
         endif ! rank == 0
         deallocate(vxcfp)
      endif

c     q near zero
      if(rank == 0) then
        print *, 'reading QOP'
        open (101,file='Q0P')
        read (101,"(i5)") nq0i
        if(.not.exchange) call checkeq(nqibz+nq0i-1, nqnum)
        write(6,*) ' *** nqibz nq0i_total=', nqibz,nq0i
      endif
#ifdef USE_MPI
      call MPI_Bcast(nqibz, 1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
      call MPI_Bcast(nq0i,  1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
#endif

      allocate( wqt(1:nq0i),q0i(1:3,1:nq0i) )
      if(rank == 0) then
c       read (101,"(d24.16,3x, 3d24.16)" )( wqt(i),q0i(1:3,i),i=1,nq0i)
        nq0ix = nq0i
        do i=1,nq0i
          read (101,* ) wqt(i),q0i(1:3,i)
          if(wqt(i)==0d0 ) nq0ix = i-1
        enddo
        nq0i = nq0ix ! New nq0i July 2001
        write(6,*) ' Used k number in Q0P =', nq0i
        write(6,"(i3,f14.6,2x, 3f14.6)" )(i, wqt(i),q0i(1:3,i),i=1,nq0i)
        close(101)
      endif
#ifdef USE_MPI
      call MPI_Bcast(nq0i,  1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
      call MPI_BARRIER (MPI_COMM_WORLD, ierror)
      call MPI_Bcast(wqt, nq0i, MPI_DOUBLE_PRECISION, 0, MPI_COMM_WORLD, ierror)
      call MPI_Bcast(q0i, 3*nq0i, MPI_DOUBLE_PRECISION, 0, MPI_COMM_WORLD, ierror)
#endif

      allocate( wgt0(nq0i,ngrp) )
C     Sergey's 1stFeb2005
c     call q0iwgt2(symgg,ngrp,wqt,q0i,nq0i,
c     o            wgt0)

      if(rank == 0) call getkeyvalue("GWinput","allq0i",allq0i,default=.false.) !S.F.Jan06
#ifdef USE_MPI
      call MPI_Bcast(allq0i, 1, MPI_LOGICAL, 0, MPI_COMM_WORLD, ierror)
#endif
      call q0iwgt3(allq0i,symgg,ngrp,wqt,q0i,nq0i,wgt0)
C--------------------------

      if (nq0i/=0 ) then
        if (rank == 0) write(6,*) ' *** tot num of q near 0   =', 1/wgt0(1,1)
      endif
      if(rank == 0) write(6,"('  sum(wgt0) from Q0P=',d14.6)")sum(wgt0)

C      if(bzcase()==2) then
C         wgt0= wgt0*wgtq0p()/dble(nqbz)
C        if(rank == 0) write(6,"('bzcase=2:  sum(wgt0_modified )=',d14.6)")sum(wgt0)
C      endif

c
c     do i =1,nq0i
c     do ig=1,ngrp
c     write(66,'(2i3,f12.5)')i,ig,wgt0(i,ig)
c     enddo
c     enddo


c     pointer to optimal product basis
c     call defi    (iimdim,natom)
      allocate(imdim(natom))
      call indxmdm (nblocha,nclass,
     i     iclass,natom,
     o     imdim )
      if(niw/=0) then
c       Gaussian quadrature between (0,1) for integration Im w and w=(1-x)/x
!        write(0,'("[",I4,"] nwi = ",I8)') rank,niw
         allocate(freqx(niw),freqw(niw),wwx(niw)) !,expa(niw))
         call freq01x  (niw,    !ua,
     o        freqx,freqw,wwx)  !,expa)
      endif
c     ------ write energy mesh ----------
c     ifemesh = iopen('emesh.hsfp0'//xt(nz),1,-1,0)
c     deltax0 = 0d0
c     call writeemesh(ifemesh,freqw,niw,freq,nw,deltax0)


!     ! === readin Vcoud and EPSwklm for newaniso()=T ===
C     if(newaniso()) then

        if(rank == 0) then
          ifidmlx = iopen('EPSwklm',0,0,0)
          read(ifidmlx) nq0ix,lxklm
        endif
#ifdef USE_MPI
        call MPI_Bcast(nq0ix,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)
        call MPI_Bcast(lxklm,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)
#endif

        if(nq0i/=nq0ix) then
          print *,'nq0i from EPSwklm /= nq0i',nq0i,nq0ix
            call rx( 'nq0i from EPSwklm /= nq0i')
         endif
         allocate( dmlx(nq0i,9))
         allocate( epinvq0i(nq0i,nq0i) )
         allocate( wklm((lxklm+1)**2))

         if(rank == 0) then
         read(ifidmlx) dmlx, epinvq0i
         read(ifidmlx) wklm
         ifidmlx = iclose('EPSwklm')
      endif
#ifdef USE_MPI
      call MPI_Bcast(dmlx,    9*nq0i,    MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ierror)
      call MPI_Bcast(epinvq0i,nq0i*nq0i, MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ierror)
      call MPI_Bcast(wklm,(lxklm+1)**2,  MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ierror)
#endif
C      endif

c---------------------------------------------
      if(tetra) then
c     --- get tetrahedron
c     mxkp = n1*n2*n3
c     allocate( qbzxx(3*mxkp),wbzxx(mxkp),ipq(mxkp) )
c     call bzmesh (plat,qbasmc,n1,n2,n3,w(igrp),ngrp,ipq,
c     .               qbzxx,wbzxx,nqibzxx,mxkp)
c     allocate(idtetx(0:4,mxkp*6))
c     call tetirr(qbasmc,n1,n2,n3,ipq,nqibz,ntet,
c     .              idtetx)
c     allocate(idtet(0:4,ntet))
c     idtet(0:4,1:ntet) = idtetx(0:4,1:ntet)
c     deallocate(idtetx,qbzxx,wbzxx,ipq)
c
c     nene = ntq*nq*nspin ! for energy points.
c     if(exchange) nene=0
c     allocate(wtet(nband,nspin,nqibz,0:3*nene),
c     &    eband(nband,nspin,nqibz), qz(3,nqibz),nstar(nqibz),
c     &    iene(3*ntq,nq,nspin), ene(0:3*nene) ) ! pointer for
        allocate(wtet(nband,nspin,nqibz,0:0),
     &        eband(nband,nspin,nqibz), qz(3,nqibz) ) ! pointer for
        call dcopy (3*nqibz,qibz,1,qz,1)
        do  is  = 1,nspin !Readin eband
          do  iqi = 1,nqibz
c           iq = idxk (qz(1:3,iqi),qbz,nqbz)
c           call rwdd1 (ifev(is), iq, nband, eband(:,is,iqi))
c           MPI case: readeval must run on all nodes.
            call readeval(qz(1:3,iqi),is, eband(:,is,iqi))
          enddo
        enddo
c     wtet(nband,nsp,nqibz,iene) where
c     the energy pointer as iene(itp,ip,ispin) corresponding its energy value.
c     ene(0) = ef
c     if(.not.exchange) then
c     ix =0
c     do is = 1,nspin
c     do ip = 1,nq
c     do i  = 1,ntq
c     do iw = -1,1
c     ix  = ix+1
c     iene(3*i+iw-1,ip,is) = ix
c     ene(ix) = eqx0(i,ip,is) + 2.d0*(dble(iw)-shtw)*deltaw
c     enddo
c     enddo
c     enddo
c     enddo
c     endif
c     do ix = 0,3*nene
c     ene(ix) = ene(ix)-1d-15  ! to avoid coincidence
c     call bzints2(n1,n2,n3,eband,wtet(:,:,:,ix),nqibz,nband,nband,
c     .                nspin,edummy,edummy,edummy,1,ene(ix),2,ntet,idtet)
c     enddo
         volwgt = (3d0 - nspin) / ntetf ! ntetf was =6*n1*n2*n3
         call bzints2x(volwgt,eband,wtet(:,:,:,0),nqibz,nband,nband,
c     ,dum,nkp,ldim,nbmax,
     .        nspin,edummy,edummy,edummyd,1,ef,2,nteti,idteti)

c
         ntot= sum(wtet)

        if(rank == 0) then
         if(legas) then
            write(6,"(' tetra=T ef ntot nexact ratio=',15f12.6)") ef,ntot
     &           , ef**1.5d0/3d0/pi**2*voltot, ef**1.5d0 /3d0/pi**2*voltot/ntot
         else
            write(6,"(' tetra=T ef nvalence)=',15f12.6)") ef,ntot
         endif
        endif

         if(nspin==1) wtet = wtet/2d0
c     call icopy(nqibz,w(instar),nstar)
         do iqi = 1,nqibz
            wtet(:,:,iqi,:) = wtet(:,:,iqi,:)/nstar(iqi)
         enddo

c     do ix = 1,3*nene
c     if( ene(ix)> ef) then
c     wtet(:,:,:,ix) = wtet(:,:,:,ix) - wtet(:,:,:,0)
c     else
c     wtet(:,:,:,ix) = wtet(:,:,:,0)  - wtet(:,:,:,ix)
c     endif
c     enddo
         deallocate( eband, qz, ene ) ! pointer for
c     -- ibzx denote the index of k{FBZ for given k{1BZ.
         allocate(ibzx(nqbz))
c     call invkibzx(w(iirk),nqibz,ngrp,nqbz,
         call invkibzx(irk,nqibz,ngrp,nqbz,
     o        ibzx)
c     print *,' *** wtet sum 1=', sum( wtet)
c     stop ' -------------test end------------- '
c     call cputid(0)
      else
         allocate(wtet(1,1,1,1), iene(1,1,1)) !dummy
      endif
c     -end of tetra section --------------------------------------------


C...  Read pomatr
      if(smbasis()) then
         print *,' smooth mixed basis : augmented zmel'
         ifpomat = iopen('POmat',0,-1,0) !oct2005
         nkpo = nqibz+nq0i
         nnmx=0
         nomx=0
         if(rank == 0) then
           print *,' smooth mixed basis : augmented zmel'
           ifpomat = iopen('POmat',0,-1,0) !oct2005
           do ikpo=1,nkpo
             read(ifpomat) q_r,nn_,no,iqx !readin reduction matrix pomat
             if(nn_>nnmx) nnmx=nn_
             if(no>nomx) nomx=no
             allocate( pomat(nn_,no) )
             read(ifpomat) pomat
             deallocate(pomat)
           enddo
           isx = iclose("POmat")
         endif
#ifdef USE_MPI
         call MPI_Bcast(nomx,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)
         call MPI_Bcast(nnmx,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)
#endif
        allocate( pomatr(nnmx,nomx,nkpo),qrr(3,nkpo),nor(nkpo),nnr(nkpo) )
        if(rank == 0) then
          ifpomat = iopen('POmat',0,-1,0) !oct2005
          do ikpo=1,nkpo
            read(ifpomat) qrr(:,ikpo),nn_,no,iqx !readin reduction matrix pomat
            nnr(ikpo)=nn_
            nor(ikpo)=no
            read(ifpomat) pomatr(1:nn_,1:no,ikpo)
          enddo
         isx = iclose("POmat")
         write(6,*)"Read end of POmat ---"
        endif
#ifdef USE_MPI
        call MPI_Bcast(qrr,   3*nkpo,         MPI_DOUBLE_PRECISION, 0, MPI_COMM_WORLD,ierror)
        call MPI_Bcast(pomatr,nnmx*nomx*nkpo ,MPI_DOUBLE_COMPLEX,   0, MPI_COMM_WORLD,ierror)
        call MPI_Bcast(nor ,nkpo ,MPI_INTEGER,   0, MPI_COMM_WORLD,ierror)
        call MPI_Bcast(nnr ,nkpo ,MPI_INTEGER,   0, MPI_COMM_WORLD,ierror)
#endif
      else                      ! normal branch (no smbasis)
        nkpo = 1
        nnmx =1
        nomx =1
        allocate( pomatr(nnmx,nomx,nkpo), qrr(3,nkpo),nor(nkpo),nnr(nkpo) )
      endif
c-------------------------------------
      iii=ivsumxxx(irk,nqibz*ngrp)
      if(rank == 0) write(6,*) " sum of nonzero iirk=",iii, nqbz

c-----------------------------------------------------------
c     calculate the the self-energy SEx(ip) or SEc(ip)
c-----------------------------------------------------------
!     ! EIBZ symmetrization
      if(eibz4sig()) then
        allocate(nwgt(nqbz,1:nq),igx(ngrp*2,nqbz,nq),igxt(ngrp*2,nqbz,nq), eibzsym(ngrp,-1:1,nq))
        iprintx=.false.
C       if(rank == 0) write(6,"('TimeReversal switch = ',l1)") timereversal()
         iqxini=1
         iqxend=nq
c         call eibzgen(nq,symgg,ngrp,q(:,iqxini:iqxend),
c     &        iqxini,iqxend,qbz,nqbz,timereversal(),ginv,iprintx,
c     o        nwgt,igx,igxt,eibzsym,tiii)
!     ! Check timereversal is required for symmetrization operation or not. If tiii=timereversal=F is enforced,
!     ! the symmetrization procedure in x0kf_v4h becomes a little time-consuming.
cccccccccccccccccccc
         tiii=.false.    !Enforce no time reversal. time reversal not yet...
         print *,'NOTE:TimeReversal not yet implemented in hsfp0.sc.m.F'
         write(6,"('=== goto eibzgen === used timereversal=',l1)")tiii
         iprintx=.false.
         if(rank == 0) iprintx=.true.
         call eibzgen(nq,symgg,ngrp,q(:,iqxini:iqxend),
     &        iqxini,iqxend,qbz,nqbz,tiii,ginv,iprintx,
     o        nwgt,igx,igxt,eibzsym,tiiiout)
c     call PBindex(natom,lx,l2nl,nx) !all input. this returns requied index stored in arrays in m_pbindex.
                                ! PBindex: index for product basis.  We will unify this system; still similar is used in ppbafp_v2.
c     call readqgcou() !no input. Read QGcou and store date into variables.
c     call Spacegrouprot(symgg,ngrp,plat,natom,pos) ! all inputs.

C         do iq=iqxini,iqxini
C         do ibz=1,200
C           if(nwgt(ibz,iq)/=0) then
C             write(6,"('yyy1: ',i8,2x,25(i3,i2))") ibz,(igx(i,ibz,iq),igxt(i,ibz,iq),i=1,nwgt(ibz,iq))
C           endif
C         enddo
C         enddo
      endif

!     ! == irkip control paralellization  ==
!     ! We have to distribute non-zero irkip into processes (nrank).
!     ! When irkip(nqibz,ngrp,nq,nspinmx)/=0, we expect grain-size
!     ! for each job of (iqibz,igrp,iq,isp) is almost the same.
!     ! Our pupose is to calculate zsec(itp,itpp,iq).
!     ! Thus we need to set up communicator (grouping) MPI__COMM_iqisp(iq,isp) to do all_reduce.
!     ! (for given zsec(iq,isp), we take sum on zsec for (iqibz,igrp) by all_reduce.)
!     ! ---
!     ! NOTE: in future, we will further extend irkip for itp and itpp
      if(eibz4sig()) then
        allocate(irkip_all(nqibz,ngrp,nq,nspinmx)) !this is global
        allocate(nrkip_all(nqibz,ngrp,nq,nspinmx)) !this is global
         nrkip_all=0
         irkip_all=0
         is=1                   ! not spin dependent
         do iqq=1,nq
c         irkip_all(:,:,iqq,is)=irk
           do kx=1,nqibz
             do igrp=1,ngrp
               kr = irk(kx,igrp) !ip_all(is,kx,igrp,iqq) !kr is index for qbz (for example, nonzero # of kr is 64 for 4x4x4)
               if(kr==0) cycle
               if(nwgt(kr,iqq)/=0) then
                irkip_all(kx,igrp,iqq,is)= irk(kx,igrp)
                nrkip_all(kx,igrp,iqq,is)= nwgt(kr,iqq)
               endif
             enddo !igrp
           enddo !kx
         enddo !iqq

C          do iqq=1,nq
C             write(6,"('iq=',i4,' # of EIBZ: Used(TimeR 1 or -1)=',i3,'=',i3,'+',i3)")
C     .            iqq,sum(eibzsym(:,:,iqq)),sum(eibzsym(:,1,iqq)),sum(eibzsym(:,-1,iqq))
C             write(6,"('eibz: iqq sum(nrkip_all)=nqbz  ',i3,3f11.5,3i8)")
C     .           iqq,q(:,iqq),sum(nrkip_all(is,:,:,iqq)),nqbz
C             do kx=1,nqibz
C                do igrp=1,ngrp
C                   kr = irkip_all(is,kx,igrp,iqq) !kr is index for qbz
C                   if(kr/=0) write(6,"('      ',i8,3f11.5,i8,2x,25(i4,i2))")
C     .                kr,qbz(:,kr),nrkip_all(is,kx,igrp,iqq),(igx(i,kr,iqq),igxt(i,kr,iqq),i=1,nwgt(kr,iqq))
C                enddo
C             enddo
C!     !   Probably partial group symmetrization is enough. But it may not reduce computational time so much.
C         enddo

         if(nspinmx==2) then
          irkip_all(:,:,:,2)=irkip_all(:,:,:,1)
          nrkip_all(:,:,:,2)=nrkip_all(:,:,:,1)
         endif
      else ! not eibz4sig
         do is = 1,nspinmx
            do iqq=1,nq
            irkip_all(:,:,iqq,is)=irk
            enddo
         enddo
      endif

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!! test for single rank case
!      nrank=1 !total number of rank
!      irank=0 !rank for local process
      nrkip => nrkip_all         !we don't need to change this for MPI case. It just need to distribute non-zero irkip.
      irkip => irkip_all
!      allocate(irkip(nqibz,ngrp,nq,nspinmx)) !local
!ML      call MPI_sxcf_rankdivider(nrank,nspinmx,nqibz,ngrp,nq,irkip_all, irank,irkip)

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

!     ! nrkip is weight corresponding to irkip for a node.
!     nrkip = nrkip_all         !we don't need to change this for MPI case. It just need to distribute non-zero irkip.
!     ! ----------------------------------------
      nlnx4    = nlnx**4        ! niwx     = max0 (nw+1,niw) !nw --->nw+1 feb2006
      allocate( ppb(nlnmx*nlnmx*mdimx*nclass),
     &     kount(nqibz,nq),zsec(ntq,ntq,nq), coh(ntq,nq),nbandmx(nq,nspinmx) ) !eq(nband),
c     loop over spin ----------------------------------------------------
      nbandmx = 0
      do 2000 is = 1,nspinmx

        if(rank == 0) then
        if(exchange) then
           write(ifsex2(is)) nspin, nq, ntq,nqbz,nqibz, n1,n2,n3
           write(ifsex(is),*) '======================================='
           write(ifsex(is),"('Self-energy exchange SEx(q,t): is=',i3)") is
           write(ifsex(is),*) '======================================='
           call winfo(ifsex(is),nspin,nq,ntq,is,nbloch,ngpn1,ngcn1,nqbz,nqibz,ef,deltaw,alat,esmr)
           write (ifsex(is),*)' *** '
           write (ifsex(is),"(a)") ' jband   iq ispin                  '//
     &          '           qvec            eigen-Ef (in eV)           exchange (in eV)'
        elseif(ixc==2) then
           write(ifsec2(is)) nspin, nq, ntq ,nqbz,nqibz  ,n1,n2,n3
           write(ifsec(is),*) '=========================================='
           write(ifsec(is),"('Self-energy correlated SEc(qt,w): is=',i3)") is
           write(ifsec(is),*) '=========================================='
           call winfo(ifsec(is),nspin,nq,ntq,is,nbloch,ngpn1,ngcn1,nqbz,nqibz,ef,deltaw,alat,esmr)
           write (ifsec(is),*)' *** '
           write (ifsec(is),"(a)") ' jband   iq ispin                  '//
     &          '           qvec            eigen-Ef (in eV)           Re(Sc) 3-points (in eV)                        '//
     &          '           In(Sc) 3-points (in eV)                Zfactor(=1)'
        endif
        endif

C       Initialise secq and kount
        zsec  = 0d0
        coh   = 0d0
        kount = 0
        if(ixc==3.and.nctot==0) goto 2001 !make dummy SEXcore

        if (.not. allocated(ecore)) allocate(ecore(1,nspinmx))

        call sxcf_sc(q,nq,itq,ntq,nbandmx(1,is),qbas,qibz,qbz,wbz,nstbz,irkip,nrkip,
     .    nqibz,nqbz,nctot,nl,nnc,nclass,natom,nband,nlmto,nspin,is,
     .    iclass,nblocha,nlnmv,nlnmc,nblochpmx,icore,ncore,imdim,ecore(:,is),
     .    ppb,nlnmx,mdimx,nbloch,wgt0,nq0i,q0i,ngrp,symgg,shtvg,tiat,miat,
     .    invg,il,in,im,nlnm,nn,lx,nx,nxx,cgr,ppbrd,
     .    exchange,ifexsp(is),screen,cohtest,
     .    wklm,lxklm,iSigMode,nbmx,ebmx,niw,freqx,wwx,dw,
     .    ef,esmr,diagonly,eftrue,
     o    zsec,coh)

         if (exchange) then
             do iq = 1, nq
               do i = 1, ntq
                 do it = i+1, ntq
                   zsec(it,i,iq) = conjg(zsec(i,it,iq))
                 end do
               end do
             end do
         end if

c---------------------------------
!!     electron gas bare exchange (exact)
        if (legas.and.exchange) then
          efz=(ntot*3*pi**2/voltot)**(2d0/3d0) ! ef is calculated from ntot.
          pi         = 4.d0*datan(1.d0)
          tpia       = 2.d0*pi/alat
          qfermi= dsqrt(efz)
          alpha = (9*pi/4d0)**(1d0/3d0)
          if(rank == 0) then
          write (6,*)' --- exact electron gas bare exchange --- '
          write (6,*)' density parameter rs= ', alpha/qfermi
          write (6,*)' kf= ',qfermi
          endif
          do  ip = 1,nq
            qreal =  tpia*q(1:3,ip)
            qm    = dsqrt ( sum(qreal**2) )
            xsex  = hartree * egex (qm,efz)
            if (rank == 0) then
              write (6,*)
              write (6,"(' True qm-ef Sx=',2f14.6,' q/qf=',f14.6)")
     &             rydberg()*(qm**2-efz), xsex, qm/qfermi
              write (6,"(' Num  qm-ef Sx=',2f14.6)")
     &             eqx(1,ip,is),        hartree*dreal(zsec(1,1,ip)) !sf 21May02
              write (6,"(' === diff     =',2f14.6)")
     &             rydberg()*(qm**2-efz)-eqx(1,ip,is)
     &             , xsex - hartree*dreal(zsec(1,1,ip)) !sf 21May02
              write (661,"(' qm True qm-ef Sx=',3f14.6)")
     &             qm,rydberg()*(qm**2-efz), xsex
              write (662,"(' qm Num  qm-ef Sx=',3f14.6)")
     &             qm,eqx(1,ip,is),     hartree*dreal(zsec(1,1,ip)) !sf 21May02
              write (663,"(2f14.6)") qm/qfermi, qfermi
             endif
          end do
        endif
 2001   continue                ! entry point for exchange only

!!   --- symmetrize zsec for eibz4sig mode. Sep2012 -----------------
!!       Rotate zsec(itp,itp)
        allocate(zsect(ntq,ntq))

!! init_readeigen init_readeigen2 are already called.--> we can use rotwvigg
!! zsec(ntq,ntq,nq)
        if (verbose()>=20) call cputid2(' start symmetrizing zsec',0)

C   ... Read extension, number of threads, thread block array
        allocate(evaliq(nband),iblki(nband),iblke(nband))
        if(rank == 0) then
          ifi=4001
          open(unit=ifi,file='mpiqlst',status='old')
          rewind ifi
          read(ifi,*) ext
          read(ifi,*) ext, ix, nqcalc, nrankv
          print "(' hsfp0_sc: read evecs from evec',a,i5,' qp made by',i4, ' thread(s)')", trim(ext), nqcalc, nrankv
          allocate(iprocq(nqcalc))
          read(ifi,*) iprocq
          close(unit=ifi)

C         Make extensions for threads other than the master thread
          allocate(extp(0:nrankv-1),ifvxc__(0:nrankv-1),ifevec__(0:nrankv-1))
          extp(0) = trim(adjustl(ext))
          ix=5001
          do  procid = 0, nrankv-1
            if (procid > 0) then  ! Make extension for MPI lmfgwd
              write(extn,"(i10)") procid
              write(extp(procid),"(a,i6)")
     .          trim(extp(0))//'_'//trim(adjustl(extn))
            endif
            ix=ix+1
            open(ix,file='vxc'//trim(extp(procid)),form='unformatted')
            ifvxc__(procid)=ix
            ix=ix+1
            open(ix,file='evec'//trim(extp(procid)),form='unformatted')
            ifevec__(procid)=ix
          enddo

          ifvxc_ = ifvxc__(0)  !0 is root
          ifevec_= ifevec__(0)
C         read(ifevec_)  ndimhx, nspx,nnnx,iq,izl
          call iosigh(2,5,nspx,iq,ndimhx,izl,iq,iq,iq,nnnx,iq,iq,iq,iq,ifevec_,xxx)

          read(ifvxc_)            !skip ndimhx, nspx,nnnx
          if(nnnx/=nq) call rx('hsfp0_sc: readin number of qibz from evec is not equal to nq')
        endif

        do 3020 iq=1,nq         !nq q for which we will calculate sigma.  Same as calculated in lmfgw
          do 3030 ispx=1,nspinmx !ispx loop is to find isx=is
            if(ispx==is) then
              if(rank == 0) then
                ifvxc_  = ifvxc__ (iprocq(iq))
                ifevec_ = ifevec__(iprocq(iq))
                read(ifvxc_)  nhdim,ldim
                read(ifvxc_)
              endif
#ifdef USE_MPI
              call MPI_Bcast(nhdim, 1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
              call MPI_Bcast(ldim,  1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
#endif
              allocate( evec(nhdim,nhdim), evec_inv(nhdim,nhdim),evecrot(nhdim,nhdim))
C             if (izl /= 0) read(ifevec_)
              read(ifevec_) qqqx, i, it
              if (i /= nhdim .and. it /= nhdim) call rx('hsfp0_sc: problem with evec file')
              read(ifevec_)   ! eigenvalues not needed
              call dpdump(evec,nhdim**2*2,ifevec_)
              zsect = 0d0
            else                !skip isx/=is. Need access to sequential files evec and v_xc.
              if(rank == 0) then
                ifvxc_  = ifvxc__ (iprocq(iq))
                ifevec_ = ifevec__(iprocq(iq))
                read(ifvxc_); read(ifvxc_)
                read(ifevec_) qqqx; read(ifevec_); read(ifevec_)
              endif
              cycle
            endif
            do i=1,nnnx         !nq     !qqqx from evec v_xc.
              if (sum(abs(qqqx-q(:,i)))<1d-6) then
                iqxx=i
                goto 3011
              endif
            enddo
            deallocate(evec,evec_inv,evecrot,extp)
            call rx( 'hsfp0_sc: can not find q')
 3011       continue

            if(tiii) call rx( 'timereversal is not yet implemented')
            call readeval(q(:,iqxx), is, evaliq)
            evec_inv = evec
            call matcinv(nhdim,evec_inv)
            nsym = sum(eibzsym(:,:,iqxx))
!ML         write(0,'("[",I4,"] iq = ",I3," evec_inv = ",10f12.5)') rank,iq,(evec_inv(i,i),i=1,min(5,nhdim))

            do it=1,1        !no-time reversal yet !it=1,-1,-2 !c.f. x0kf_v4h
              do igrp=1,ngrp   !A-rotator
                if( eibzsym(igrp,it,iqxx)==0) cycle
                nblk=0
                iblki=0
                iblke=0
                iblki(1)=1
!! Degeneracy divider for evaliq.
!! Is this procedure really make speed up so much?
                tolry= 0.2d0 !Degeneracy tol. if tolry is large,
                             ! larger tolry is safer, although a little inefficient.
                             ! If tolry is too small to divide degenerated values to different blocks --> then we have wrong results.
                            !(NOTE that Hamiltonian can be not so symmetric in some reasons)
                nbsizemx=0
!               write(0,'("[",I4,"] nband = ",I5," nbandmx(",I5,I5,") = ",I12)') rank, nband, iqxx,is,nbandmx(iqxx,is)
                do iband=2,nbandmx(iqxx,is)
                                 ! nbandmx is the number of bands for which we calculate self-energy.
                                 ! We assume nbandmx(iqxx,is) is well separated for degeneracy.
                  if(evaliq(iband) > evaliq(iband-1)+tolry .or. iband==nbandmx(iqxx,is)) then
                    nblk=nblk+1
                    if(nblk>=2) iblki(nblk)=iblke(nblk-1)+1
                    if(iband==nbandmx(iqxx,is)) then
                      iblke(nblk)=iband
                    else
                      iblke(nblk)=iband-1
                    endif
                    nbsize = iblke(nblk)- iblki(nblk)+1
                    if( nbsize>nbsizemx ) nbsizemx = nbsize
                  endif
                enddo           ! iband
!! rotation of evec. Generate evecrot. (Within degenerated block, evec are mapped.)
                allocate(rmatjj(nbsizemx,nbsizemx,nblk))
                napw=nhdim-ldim
!               write(0,'("[",I4,"] iq = ",I3," nblk = ",I8," iblki = ",10I8)') rank,iq, nblk,(iblki(i),i=1,min(10,nblk))
!               write(0,'("[",I4,"] iq = ",I3," nblk = ",I8," iblke = ",10I8)') rank,iq, nblk,(iblke(i),i=1,min(10,nblk))
!               if(q_comm%ID == 0) write(0,'("[",I4,"] iq = ",I3," nblk = ",I8)') rank,iq, nblk
                do iblk1=1,nblk
                  ii1=iblki(iblk1)
                  ie1=iblke(iblk1)
                  ne1=ie1-ii1+1
                  call rotwvigg(igrp,q(:,iqxx),q(:,iqxx),nhdim,
     &                 napw,ne1,evec(:,ii1:ie1),evecrot(:,ii1:ie1),ierr )
                  rmatjj(1:ne1,1:ne1,iblk1) =
     &                 matmul(evec_inv(ii1:ie1,:),evecrot(:,ii1:ie1))
                enddo          ! iblk1
!               if(rank == 0) then
!                 write(0,'("[",I4,"] iq = ",I3," iblk1 = ",I5," rmatjj = ",10f12.5)') rank,iq,iblk1,
!     .                 (rmatjj(i,i,iblk1),i=1,min(5,ne1))
!               endif
                do iblk1=1,nblk
                  do iblk2=1,nblk
                    ii1=iblki(iblk1)
                    ie1=iblke(iblk1)
                    ne1=ie1-ii1+1
                    ii2=iblki(iblk2)
                    ie2=iblke(iblk2)
                    ne2=ie2-ii2+1
                    zsect(ii1:ie1,ii2:ie2) = zsect(ii1:ie1,ii2:ie2) +
     .                matmul(dconjg(transpose(rmatjj(1:ne1,1:ne1,iblk1))),
     .                matmul(zsec(ii1:ie1,ii2:ie2,iqxx),rmatjj(1:ne2,1:ne2,iblk2)) )
                  enddo        ! iblk2
                enddo          ! iblk1
                deallocate(rmatjj)
              enddo             ! igrp
            enddo               ! it
            deallocate(evec, evec_inv, evecrot)
            zsec(:,:,iqxx) = zsect(:,:)/dble(nsym)
 3030     continue              ! ispx
 3020   continue                ! iq
        deallocate(iprocq,extp )
        if(rank == 0) deallocate(ifvxc__,ifevec__)

        ix=5001
        do procid=0,nrankv-1
          ix=ix+1
          close(unit=ix)
          ix=ix+1
          close(unit=ix)
        enddo
        deallocate(iblki,iblke)
        deallocate(evaliq)
        deallocate(zsect)

        if(mpi__root) then
          if(exchange) then
            ifoutsex=ifsex(is)
            write(6,*)
            do ip = 1,nq
              do i  = 1,ntq
              write(ifoutsex,"(3i5,3d24.16,3x,d24.16,3x,d24.16)")
     &                 itq(i),ip,is, q(1:3,ip), eqx(i,ip,is),
     &                 hartree*dreal(zsec(i,i,ip)) !sf 21May02
              if( eqx(i,ip,is)<1d20.and.abs(zsec(i,i,ip))/=0d0 ) then !takao june2009
                write(6,"(' j iq isp=' i3,i4,i2,'  q=',3f8.4,
     &                    '  eig=',f10.4,'  Sx=',f10.4)")
     &                 itq(i),ip,is, q(1:3,ip), eqx(i,ip,is),
     &                 hartree*dreal(zsec(i,i,ip)) !sf 21May02
              endif
              end do
              write(ifsex2(is)) is, q(1:3,ip), zsec(1:ntq,1:ntq,ip) !SEC_nn' out
            end do
          elseif(ixc==2) then
            ifoutsec=ifsec(is)
            write(6,"(/' state iq isp',10x,'q',16x,'eval',11x,' SE')")
            do ip = 1, nq
              do i  = 1, ntq
                if( eqx(i,ip,is)<1d20.and.abs(zsec(i,i,ip))/=0d0 ) then !takao june2009
C                  write(6,"(' j iq isp=' i3,i4,i2,'  q=',3f8.4,
C     &            '  eig=',f8.4,'  Re(Sc) =',f8.4,'  Img(Sc) =',f8.4 )") !sf 21May02
C     &            itq(i),ip,is, q(1:3,ip), eqx(i,ip,is),
C     &            hartree*dreal(zsec(i,i,ip)), !sf 21May02
C     &            hartree*dimag(zsec(i,i,ip)) !,zfac,zfac1,zfac2  !sf 21May02
                  write(6,"(i4,i5,i3,3f8.4,2x,f8.4,2x,2f8.4)")
     &            itq(i),ip,is, q(1:3,ip), eqx(i,ip,is),
     &            hartree*dreal(zsec(i,i,ip)), hartree*dimag(zsec(i,i,ip))
                endif
                write(ifoutsec,   !,zfac,zfac1,zfac2  !sf 21May02 !sf 21May02
     .            "(3i5,3d24.16,3x,d24.16,3x,d24.16, 3x,d24.16)")itq(i),
     .            ip,is, q(1:3,ip), eqx(i,ip,is),hartree*dreal(zsec(i,i,
     .            ip)),hartree*dimag(zsec(i,i,ip))
              end do
              write(ifsec2(is)) is, q(1:3,ip), zsec(1:ntq,1:ntq,ip) !SEC_nn' out
            end do
          endif                 !ixc
        endif                   !mpi__root
 2000 continue                  !end of spin-loop

c$$$!!   --- EXspectrum ... see hsfp0.m.F  ----------------------------------------------------
c$$$c     This section is similar to efsimplef.f
c$$$      if(sum(ifexsp(1:nspin))/=0) then
c$$$        do is = 1,nspin
c$$$          print *,' --- Goto ExSpectrum section --- is=',is
c$$$          rewind (ifexsp(is))
c$$$          itmx = 0
c$$$          do
c$$$            read(ifexsp(is),*,end=1215)ipex,itpex,itex,qqex(1:3), eex,exsp
c$$$            if(itex>itmx) itmx=itex
c$$$          enddo
c$$$ 1215     continue
c$$$          nspexmx = itmx*(nqbz+nq0i*ngrp) !Maximum number of ex spectra
c$$$c
c$$$          allocate( eex1(nspexmx,ntq,nq), exsp1(nspexmx,ntq,nq),
c$$$     &           nspex(ntq,nq) ,
c$$$     &           itex1(nspexmx,ntq,nq),
c$$$     &           qqex1(3,nspexmx,ntq,nq) )
c$$$          print *,' max number of spectra =',nspexmx
c$$$c
c$$$          rewind (ifexsp(is))
c$$$          nspex = 0
c$$$          do
c$$$            read(ifexsp(is),*,end=1216) ipex,itpex,itex,qqex(1:3),eex,exsp
c$$$            nspex(itpex,ipex) = nspex(itpex,ipex)+1
c$$$            iex  = nspex(itpex,ipex)
c$$$            eex1  (iex,itpex,ipex) = eex
c$$$            exsp1 (iex,itpex,ipex) = exsp
c$$$            itex1 (iex,itpex,ipex) = itex
c$$$            qqex1(:,iex,itpex,ipex)= qqex
c$$$          enddo
c$$$ 1216     continue              !Get eex1(1:nspex) exsp1(1:nspex) for itp ip.
c$$$          print *,' nspex(1 1)=',nspex(1,1)
c$$$c
c$$$          do ipex = 1,nq
c$$$            do itpex=1,ntq
c$$$              write(6,*)' is itq ip =',is,itq,ip
c$$$              nnex = nspex(itpex,ipex)
c$$$              allocate( ieord(1:nnex) )
c$$$              call sortea( eex1(1:nnex,itpex,ipex),ieord, nnex,isig)
c$$$              eex1 (1:nnex,itpex,ipex)  = eex1  (ieord(1:nnex),itpex,ipex)
c$$$              exsp1 (1:nnex,itpex,ipex) = exsp1 (ieord(1:nnex),itpex,ipex)
c$$$              itex1 (1:nnex,itpex,ipex) = itex1 (ieord(1:nnex),itpex,ipex)
c$$$              qqex1(:,1:nnex,itpex,ipex)= qqex1 (:,ieord(1:nnex),itpex,ipex)
c$$$
c$$$              filenameex = 'EXSP'//charnum3(ipex)//charnum3(itpex)
c$$$     &                 //'.'//char(48+is)
c$$$              ifexspx=4111
c$$$              open(ifexspx,file=filenameex)
c$$$
c$$$              filenameex = 'EXSS'//charnum3(ipex)//charnum3(itpex)
c$$$     &                 //'.'//char(48+is)
c$$$              ifexspxx=4112
c$$$              open(ifexspxx,file=filenameex)
c$$$
c$$$              do i=1,nnex
c$$$                write(ifexspx, "(2d14.6, i4, 3f14.6)")
c$$$     &            eex1  (i,itpex,ipex), exsp1 (i,itpex,ipex),
c$$$     &            itex1 (i,itpex,ipex), qqex1 (1:3,i,itpex,ipex)
c$$$              enddo
c$$$c
c$$$              eee  =-1d99
c$$$              exwgt= 0d0
c$$$              do i=1,nnex
c$$$                if(eex1(i,itpex,ipex) > eee+1d-4 .or. i==nnex) then
c$$$                  if(i/=1) write(ifexspxx, "(2d23.15)")
c$$$     &                       eee, exwgt*hartree
c$$$                  eee  = eex1(i,itpex,ipex)
c$$$                  exwgt= exsp1 (i,itpex,ipex)
c$$$                else
c$$$                  exwgt= exwgt + exsp1 (i,itpex,ipex)
c$$$                endif
c$$$              enddo
c$$$c
c$$$              deallocate( ieord )
c$$$              close(ifexspx)
c$$$              close(ifexspxx)
c$$$            enddo
c$$$          enddo
c$$$          deallocate( eex1, exsp1, nspex, itex1, qqex1 )
c$$$        enddo
c$$$        print *,' End of ExSpectrum section ---'
c$$$      endif
!       isx = iclose ('wc.d')
!       isx = iclose ('wci.d')
      isx = iclose ('hbe.d')

      if (verbose()>=40) then
        i = idalloc(' ',11,1,1)
      else
        i = idalloc(' ',1,1,1)
        write(*,"(/' Max dynamic allocation sxcf_fal3_scz:',i7,' MB'/)") i
      endif

      call cputid(0)
!     call MPI__Finalize
      if (nthreads > 1) then
        print 131, (dwtime() - walltime0)/60, cpusec()/60, nthreads
      else
        print 131, (dwtime() - walltime0)/60, cpusec()/60
      endif
  131 format(' hsfp0_sc :  Wall clock time',f9.1,'m','  Processor time',f9.1,'m':,i4,' threads')

#ifdef CUD
      call stop_cublas()
#endif

      if(ixc==1 ) call rx0( ' OK! hsfp0_sc: Exchange mode')
      if(ixc==2 ) call rx0( ' OK! hsfp0_sc: Correlation mode')
      if(ixc==3 ) call rx0( ' OK! hsfp0_sc: Core-exchange mode')

      contains

        function keyval(s,k,l) result(v)
            character(len=*), intent(in) :: s, k
            integer, intent(in) :: l
            character(len=l) :: v
            integer :: i,j

            v = ''
            i = index(s,k//'=')
            if (i/=0) then
                i = i+len(k)+1
                j = index(s(i:),' ')

                if (j/=0) then
                    v = s(i:j+i-1)
                else
                    v = s(i:)
                end if
            end if
        end function keyval

        subroutine parse_cmd_args(mode)
            character(len=2), intent(out) :: mode

            character(len=2048) :: cmdl, tmps
            integer :: l

            mode = 'no'

            call get_command(cmdl)
            call get_command_argument(0,length=l)
            cmdl = cmdl(l+1:)

            tmps=keyval(cmdl,'mode',2);if(tmps/='')read(tmps,*)mode
        end subroutine parse_cmd_args


      end program hsfp0_sc
