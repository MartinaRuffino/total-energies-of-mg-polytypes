      subroutine w0w0i(q_comm_id,lw0w0i,llw,llwi,nw_i,nw,nq0i,niw,freq_r,freq_i,q0i,w0,w0i,llmat)
C- W(0) divergent part and non-analytic constant part
C ----------------------------------------------------------------------
Ci Inputs
Ci   q_comm_ID : MPI communicator ID; passed to getw0l
Ci   lw0w0i: if .true., make file W0W0I
Ci   llw   : <qhat|L|qhat> (eq.36 in Friedrich paper) expanded in YL
Ci   llwI  : llw on imaginary axis
Ci   nw_i  : Starting frequency on real axis
Ci   nw    : Number of frequencies on real axis
Ci   nq0i  : Number of offset gamma points
Ci   niw   : Number of frequencies on imaginary axis
Ci   q0i   : Offset gamma points
Co Outputs
Co   w0    : diagonal element at Gamma point
Co   w0i   : diagonal element at Gamma point
Co   llmat : L matrix and omega=0
Cs Command-line switches
Cl Local variables
Cl         :
Cr Remarks
Cr    Special treatment of the coulomb singularity at q=0 (iq=1)
Cr    The singularity goes as 1/q^2, but it is integrable resulting in finite G*W
Cr    This code is based on Eq. 33 in J. Phys. Soc. Jpn. 83, 094711 (2014)
Cr    Coefficients w_L are defined in Eq. 28 for F_L, Eq. 39.
Cr    w_L and the other contents of EPSwklm are generated by qg4gw (see mkqg.F)
Cr
Cr    NOTE: w_L is expanded to lxklm.  lxklm=0 omits local fields.
Cr    Generally the higher lxklm, the more accurate in principle, but less stable for a finite k mesh.
Cr    EPSwklm is generated in gwsrc/mkqg.F
Cr    We usually only use lxklm=1 --> this should be stable.
Cu Updates
Cu   26 Apr 19  Adapted from hx0fp0.sc.m.F and Takao's m_w0w0i
C ----------------------------------------------------------------------
      use m_read_bzdata,only: wbz
      use keyvalue,only: getkeyvalue
      implicit none
      logical :: lw0w0i
      integer :: q_comm_ID,ixc,nw_i,nw,nq0i,niw
      real(8),intent(in):: q0i(1:3,1:nq0i),freq_r(nw_i:nw),freq_i(niw)
      complex(8),intent(inout):: llw(nw_i:nw,nq0i),llwi(niw,nq0i)
      complex(8),intent(out) :: w0(nw_i:nw),w0i(niw),llmat(3,3)
C     Local
      integer :: i,ifidmlx,iopen,iclose,lxklm,nlxklm,ifw0w0i
      real(8),allocatable:: wklm(:)
      real(8),allocatable:: dmlx(:,:),epinvq0i(:,:),epinv(:,:,:) !,epinvq0i_m1(:,:),qeibz(:,:,:)
      logical:: readw0w0itest
      complex(8):: llmatdum(3,3)
C     phonon correction factor
      integer iq0,iphon,ntphon,itl,ifiphon,ret,itx,nphon(nq0i),nq0i_l
      real(8),allocatable:: wtl(:,:)

      print *, '==== Divergent part of W(q=0) ===='

      ifidmlx = iopen('EPSwklm',0,0,0)
      read(ifidmlx) nq0i_l,lxklm
      if (nq0i_l /= nq0i) stop 'nq0i from EPSwklm does not match argument!'
      nlxklm = (lxklm+1)**2
      allocate(dmlx(nq0i,9),epinvq0i(nq0i,nq0i),epinv(3,3,nq0i),wklm(nlxklm))
      read(ifidmlx) dmlx,epinv,epinvq0i
      read(ifidmlx) wklm
      ifidmlx = iclose('EPSwklm')

C     read in phonon transverse and longitudinal frequencies for each inequivalent q-direction
      call getkeyvalue("GWinput","<PHONON>",unit=ifiphon,errstop='off',status=ret)
      ntphon=0
      if (ret < 0) then
        allocate(wtl(2,1))
      else
        read(ifiphon,*) (nphon(iq0),iq0=1,nq0i)
        do  iq0 = 1, nq0i
          ntphon = ntphon + nphon(iq0)
        enddo
        allocate(wtl(2,ntphon))
        itx = 0
        do iq0 = 1, nq0i
          read(ifiphon,*) ((wtl(itl,itx+iphon),itl=1,2),iphon=1,nphon(iq0))
          print *, 'transverse and longitudinal phonons in cm^-1 for direction',iq0
          print *, ((wtl(itl,itx+iphon),itl=1,2),iphon=1,nphon(iq0))
C         Convert from cm-1 to hartrees
          do iphon=1,nphon(iq0)
            do itl=1,2
              wtl(itl,itx+iphon)=wtl(itl,itx+iphon)*0.91126705048073d-5/2d0
            enddo
          enddo
          itx=itx+nphon(iq0)
        enddo
        close(ifiphon)
      endif

!!    Starting from llw(iw,iq0),llwI(iw,iq0)
!!    <qhat|L|qhat> (eq.36 in Friedrich paper) is expanded in YL and stored as llw
!!    wbz(1) is the weight for q=0 = 1/(n1*n2*n3)
!!    Takao added llmat July2016. llw is calculated at iw=0 when nw_i<=0
      call getw0l(q_comm_id,llw,nw_i,nw,nq0i,dmlx,epinvq0i,wklm,wbz(1),lxklm,nphon,ntphon,wtl,freq_r,1,epinv,w0,llmat)
      call getw0l(q_comm_id,llwi, 1,niw,nq0i,dmlx,epinvq0i,wklm,wbz(1),lxklm,nphon,ntphon,wtl,freq_i,0,epinv,w0i,llmatdum)
      deallocate(wtl)

      if (q_comm_ID == 0 .and. lw0w0i) then
        ifw0w0i = iopen('W0W0I',0,-1,0)
        write(ifw0w0i) nw_i,nw,niw,nq0i
        write(ifw0w0i) llw(nw_i:nw,1:nq0i)
        write(ifw0w0i) llwI(1:niw,1:nq0i)
        write(ifw0w0i) w0(nw_i:nw)
        write(ifw0w0i) w0i(1:niw)
        ifw0w0i = iclose('W0W0I')
      endif

C      do i = nw_i, nw
C        write(6,"('w0 =',i4,2f13.4)") i,w0(i)
C      enddo
C      do i = 1, niw
C        write(6,"('w0i=',i4,2f13.4)") i,w0i(i)
C      enddo

      end subroutine w0w0i
