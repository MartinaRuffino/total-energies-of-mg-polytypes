#!/bin/tcsh -f
# Shell script for GW calculation.
# Total energy mode also requires script extract_elda_from_log_file
# Required inputs are (with fpgw)
#  ctrl.ext rst.ext used or created by lmf
#  GWinput
# Required inputs are (with spex used with fleur)
#  inp spex.inp potcoul pottot ecore sym.out
#  Note: these files are also needed: gwa LATTC
#        If they do not exist, they are generated by invoking fleur.
#        Also these fleur-generated files affect the result: enpara
#
# Required inputs are (with spex used with lmf)
#  ctrl.ext rst.ext used or created by lmf
#  spex.inp
#
# Use with fpgw:
#  Invoke with --ht for Faleev's mode generating real weights from Hilbert transform
#  Invoke with --sc for Faleev's self-consistent mode
#  Invoke with --scrho to make density self-consistent before GW pass
#
# Use with BSE
# three modes of operation of Brian Cunningham's bethesalpeter code are provided
# 1) RPA dielectric matrix (using M.E. provided by lmf's optics routines)
#    - q vector specified in GWinput variable: Qvec_bse
#    - single-shot
#    - invoke using: lmgw --ht --bserpa
# 2) BSE dielectric matrix (using M.E. provided by lmf's optics routines)
#    - q vector specified in GWinput variable: Qvec_bse
#    - single-shot
#    - invoke using: lmgw --ht --bse
# 3) BSE (ladder) contributions to W
#    - the complete set of q-vectors as setup by lmfgwd (i.e. in GWinput)
#    - self-consistent use only
#    - call lmgwsc normally: WBSE activated by ctrl.ext flag: GW_USEBSEW = 1
#      (which is read by lmfgwd and written to GWinput, which is read by his script)
#    - WVR,WVI.* files from hx0fp0 renamed RPA_WVI.* : new WVR,WVI.* contain BSE W.
#
#  Updates
#    06 Apr 18  (Jerome Jackson) single-shot and sc calls for BSE optics and W
#    30 Jun 14  new --mpi=*
#    20 Apr 09  first attempt at interface between lmf and spex
#     1 Jul 09  started work on using lmf with spex
#    12 Apr 09  new --lmv6
#     3 Jan 08  new --openmp
#     3 Mar 07  new --stop=x0  --stop=sig
#     6 Jan 06  changes for updated dielectric function calculation
#    23 Sep 05  --big removes gwa,gwb,gw1,gw2 when no longer needed
#    30 Jun 05  Added --version switch
#    29 Jun 05  Patch for Takao.  To make:
#               ccomp '-c#' -e -dTAKAO lmgw | grep -v "define TAKAO" > lmgw.takao
#    13 Feb 05  Added --sym switch
#    30 Sep 04  Added automatic change of GWinput to track --exonly
#    30 Sep 04  Added switch --exonly
#     9 May 04  Added switches --start=x0 and --start=sig
#    28 Mar 04  Added --multitet switch
#---------------------------------------------

set lmgw = $0:h
echo $lmgw | grep / > /dev/null
if ($status == 1) set lmgw = .
#set nfpgw = /export/home/users/tnkotan/bin
set nfpgw = $lmgw
set noexec = 0
set nocc = 0
set varlst
set retzero
set lmf = lmf
set lmfa = lmfa
set lmfgwd = lmfgwd
set lmf2gw = lmf2gw
# empty value => no additional switches
set lmv6
set lmfgwdargs
set lmargs
set fleurx = fleur.x
set spexx = spex
# Darwin workaround
if (`uname` == Darwin) then
  ulimit
else
  unlimit
endif
alias findcmd  'set retcall = \!\!:1 ; set prognam = \!\!:2 ; set prog_cmd = \!\!:3 ; set path_name = \!\!:4 ; set make_path = \!\!:5 ; goto findcmd'
alias walltime  'set retcall = \!\!:1; set time_var = \!\!:2 ; set time_start = \!\!:3; goto walltime'
alias pdtime  'set retcall = \!\!:1; set time_start = \!\!:2; goto pdtime'
set space = '        '
#set vsn
set fleur ; unset fleur
set gwcode = 2
set openmp
set rdata4gw_arg
set bselmfargs = "--revec:gw --opt:woptmc,permqp"

# these are used as markers for configure.py
set mpirun
set mpirun1
set mpirunn

test ! -r $lmgw/mpicmd || source $lmgw/mpicmd
test ! -r mpicmd || source mpicmd

( [ -z "$mpirun" ] || [ "$mpirun" = "env" ] ) || set mpirun1 = "$mpirun -n 1"
( [ -z "$mpirun" ] || [ "$mpirun" = "env" ] ) || set mpirunn = "$mpirun -n 1"

[ "$mpirun" != "env" ] || set mpirun1 = "env"
[ "$mpirun" != "env" ] || set mpirunn = "env"

if (! $?OMPI_MCA_hwloc_base_binding_policy) setenv OMPI_MCA_hwloc_base_binding_policy "none"

walltime w00x tstartlmgw 0
w00x:

# set verbose
# sleep 8
# pdtime w00xb $tstartlmgw
# w00xb:
# exit

while (`echo $1 | sed -e 's/\(.\).*/\1/' `  ==  "-")
  set arg1 = ($1); shift

  switch ($arg1[1])
    case "--metal":
      set metal
      breaksw

    case "--etot":
      set etot
      breaksw

    case "--insul=*":
      set nocc=`echo $arg1 | sed s/--insul=//`
      set insul=`echo $arg1 | sed s/--insul=//`
      breaksw

    case "--getsigp":
      set getesig = 1
      set getnk = 1
      if (! $?getmtet) then
        set getmtet = 0
      endif
      if (! $?exonly) then
        set exonly = 0
      endif
      breaksw

    case "--getesig":
      set getesig = 1
      breaksw

    case "--erange":
      set erange
      breaksw

    case "--wt":
      set pwtime
      breaksw

    case "--getnk":
      set getnk = 1
      breaksw

    case "--sig0":
      set writesig0
      breaksw

    case "--vxcsig":
      set lmfgwdargs = ($lmfgwdargs --vxcsig)
      breaksw

    case "--rhoc":
      set lmfgwdargs = ($lmfgwdargs --rhoc)
      set rdata4gw_arg = "--rhoc"
      breaksw

    case "--fixlat":
      set lmfgwdargs = ($lmfgwdargs --fixlat)
      breaksw

    case "--code0":
      set gwcode = 1
      breaksw

    case "--code2":
      set gwcode = 2
      breaksw

    case "--sep12":
      set gwcode = 2
      set sep12
      breaksw

    case "--spex":
    case "-spex":
      set spex = 1
      set spexx = lmspex
      breaksw

    case "--spexi":
    case "-spexi":
      set spex = 1
      set spexx = lmspex.inv
      breaksw

    case "--spexf":
    case "-spexf":
      set spex = 1
      set fleur = 1
      unset lmfgwd
      breaksw

    case "--spexfi":
    case "-spexfi":
      set spex = 1
      set fleur = 1
      set spexx = spex.inv
      set fleurx = fleur.inv.x
      unset lmfgwd
      breaksw

    case "--mpi=*":
#    number of arguments
     set narg = `echo $arg1 | sed s/--mpi=// | awk '{print split($0, a, "," )}'`
     if ($narg < 1 || $narg > 2) then
       echo 'lmgw (abort): bad argument list to mpi=..'
       exit -1
     endif
#    extract nmpi from argument
     set nmpi = `echo $arg1 | sed s/--mpi=// | awk '{split($0, a, "," ); print a[1]}'`
#    check to ensure argument is a valid integer
     @ nmpi = $nmpi
#    extract openmp from argument
     if ($narg > 1) then
       set openmp = `echo $arg1 | sed s/--mpi=// | awk '{split($0, a, "," ); print a[2]}'`
#      check to ensure argument is a valid integer
       @ openmp = $openmp
     endif

# i seem to be at odds with the weird tcsh 'if sytax'...
     [ "$mpirun" != "env" ] || echo "    lmgw:  mpi mode not configured."
     [ "$mpirun" = "env" ] || set mpirunn = "env OMP_NUM_THREADS=1 MKL_NUM_THREADS=1 $mpirun -n $nmpi"
# for compatibility with the old setup
     [ -n "$mpirun" ] || set mpirunn = "env OMP_NUM_THREADS=1 MKL_NUM_THREADS=1 mpirun -n $nmpi"
     [ "$mpirun" = "env" ] || echo "    lmgw:  mpi mode, running lmf and lmfgwd with :  $mpirunn ..."

     breaksw

    case "--openmp=*":
      set openmp = `echo $arg1 | sed s/--openmp=//`
#     check to ensure argument is a valid integer
      @ openmp = $openmp
      breaksw

    case "--openmp":
      if (! $?OMP_NUM_THREADS) then
        echo "lmgw (abort): --openmp specified but environment variable OMP_NUM_THREADS not set"
        exit -1
      endif
      set openmp = $OMP_NUM_THREADS
      breaksw

    case "--bserpa":
      set bserpa
      breaksw

    case "--bse=*":
      set bse
      set bselmfargs = ($bselmfargs `echo $arg1 | sed s/--bse=//`)
      breaksw

    case "--bse":
      set bse
      breaksw

    case "--multitet=no":
      set getmtet = 0
      breaksw

    case "--multitet":
      set getmtet = 1
      breaksw

    case "--nbando":
      set nbando = 1
      breaksw

    case "--noexec":
      set noexec = 1
      breaksw

    case "--extest=no":
      set extest = 0
      breaksw

    case "--extest":
      set extest = 1
      breaksw

    case "--nfp":
      set nfpjob
      breaksw

    case "--ht":
      set htransform
      breaksw

    case "--scrho":
      set scrho
      breaksw

    case "--scrho0":
      set scrho0
      set scrho
      breaksw

    case "--sc:sym":
    case "--sc":
      set sc
#  echo $arg1
      if ("$arg1" == "--sc:sym") set sym
      breaksw

#    No longer needed
#     case "--big":
#       set lmf = lmf-big
#       set lmfgwd = lmfgwd-big
#       set big
#       breaksw

    case "--eps":
      set eps
      breaksw

    case "--epsNLF":
      set epsNLF
      breaksw

    case "--chix":
      set chix
      breaksw

    case "--chixNLF":
      set chixNLF
      breaksw

    case "--bin=*":
    case "-bin=*":
      set lmgw=`echo $arg1 | sed s/--bin=// | sed s/-bin=//`
      set nfpgw=$lmgw
      breaksw

    case "--lmbin=*":
    case "-lmbin=*":
      set lmgw=`echo $arg1 | sed s/--lmbin=// | sed s/-lmbin=//`
      breaksw

    case "--lmargs=*":
    case "-lmargs=*":
      set lmargs=`echo $arg1 | sed s/--lmargs=// | sed s/-lmargs=//`
      breaksw

    case "--gwbin=*":
    case "-gwbin=*":
      set nfpgwx=`echo $arg1 | sed s/--gwbin=// | sed s/-gwbin=//`
      breaksw

    case "--mixsig=*":
    case "-mixsig=*":
      set mixsig=`echo $arg1 | sed s/--mixsig=// | sed s/-mixsig=//`
      breaksw

    case "--noclean":
      set noclean
      breaksw

    case "--band*":
      set bnds=$arg1
      breaksw

#      case "--hsfp0:*":
#        set hsfp0=`echo $arg1 | sed s/--hsfp0:// | sed s/-hsfp0://`
#        breaksw

#      case "--hsfp0":
#        set hsfp0
#        breaksw

    case "-v*=*":
      set varlst=($varlst $arg1)
      breaksw

    case "--start=setup":
      set start = setup
      breaksw

    case "--start=x0":
      set start = x0
      breaksw

    case "--start=sig":
      set start = sig
      breaksw

    case "--start=qpe":
      set start = qpe
      breaksw

    case "--start=bse":
      set start = bse
      breaksw

    case "--stop=setup":
      set lstop = setup
      breaksw

    case "--stop=x0":
      set lstop = x0
      breaksw

    case "--stop=sig":
      set lstop = sig
      breaksw

    case "--exonly=no":
      set exonly = 0
      breaksw

    case "--exonly":
      set exonly = 1
      breaksw

    case "--lmv6=no":
      set lmv6
      breaksw

    case "--lmv6":
      set lmv6='--lmv6'
      breaksw

    case "--help":
    case "--h":
      goto usage

    case "--version":
      set vsn
      breaksw

    default:
      echo unrecognized switch $arg1
      goto usage
  endsw
end

# Set directory for location of GW codes (nfpgw)
if ($gwcode == 1) then
  set nfpgw = $nfpgw/code0
  if ($?nfpgwx) then
    set nfpgw = $nfpgwx
  endif
  set lmfgwdargs = (--gwcode=0 $lmfgwdargs $lmv6)
  set lmf2gw = lmf2gw_0
else if ($gwcode == 2) then
  set lmfgwdargs = (--gwcode=2 $lmfgwdargs $lmv6)
##ifdef# TAKAO
#  set nfpgw = $nfpgw/code2.takao
#  set lmf2gw = code2.takao/lmf2gw
#  set lmfgwd = code2.takao/lmfgw
##else
  if ($?sep12) then
    set nfpgw = $nfpgw/code2.sep12
  else
    set nfpgw = $nfpgw/code2
  endif
  if ($?nfpgwx) then
    set nfpgw = $nfpgwx
  endif
  set lmf2gw = lmf2gw_2
##endif
endif

setenv PATH "${nfpgw}:${lmgw}:${PATH}"
echo "    lmgw: using executables from ${nfpgw}:${lmgw}"

if ($noexec == 1) then
 set pwtime
 unset pwtime
endif

set nonewln
if ($?pwtime && $?start == 0) set nonewln = -n

set lmfgwdargs = ($lmargs $lmfgwdargs $lmv6)
# check for existence of executables
if ($?fleur) then
  if (! -x $fleurx || ! -x $spexx) then
    echo "lmgw (abort) one or more of the following is missing from $lmgw, or is not executable:"
    echo "  $fleurx $spexx"
    exit -1
  endif
else if ($?spex) then
  if (! -x $spexx || ! -x $lmgw/$lmfgwd) then
    echo "lmgw (abort) one or more of the following is missing from $lmgw, or is not executable:"
    echo "  $lmfgwd $spexx"
    exit -1
  endif
else
  if (! -x $lmgw/$lmf || ! -x $lmgw/$lmfgwd || ! -x $lmgw/$lmf2gw) then
    echo "lmgw (abort) one or more of the following is missing from $lmgw, or is not executable:"
    echo "  $lmf $lmfgwd $lmf2gw"
    exit -1
  endif
  if (! -d $nfpgw) then
    echo " (abort) directory for gw executables is missing: $nfpgw"
    exit -1
  endif
  pushd $nfpgw >& /dev/null
  if (! -x $nfpgw/hbasfp0 || ! -x $nfpgw/hvccfp0 || ! -x $nfpgw/hx0fp0 || ! -x $nfpgw/hsfp0 || ! -x $nfpgw/hqpe || ! -x $nfpgw/hchknw || ! -x $nfpgw/qg4gw || ! -x $nfpgw/heftet || ! -x $nfpgw/rdata4gw_v2 || ! -x $nfpgw/hx0fp0_sc || ! -x $nfpgw/hsfp0_sc || ! -x $nfpgw/hqpe_sc) then
    if ($noexec) then
      echo "lmgw (warning) one or more of the following is missing from $nfpgw, or is not executable:"
      echo "  hbasfp0 hvccfp0 hx0fp0 hsfp0 hqpe hchknw qg4gw heftet rdata4gw_v2 hx0fp0_sc hsfp0_sc hqpe_sc"
      else
      echo "lmgw (abort) one or more of the following is missing from $nfpgw, or is not executable:"
      echo "  hbasfp0 hvccfp0 hx0fp0 hsfp0 hqpe hchknw qg4gw heftet rdata4gw_v2 hx0fp0_sc hsfp0_sc hqpe_sc"
      exit -1
    endif
  endif
  popd >& /dev/null
endif

# --- Handle --version switch ---
# set fpgwversion = 032e
# set fpgwversion = 032f3
# set fpgwversion = 032f7nb
set fpgwversion = `echo -9999| $mpirun1 hx0fp0 |& grep VerNum= | awk '{print $3}'`
set fleurversion = v25c_3
set spexversion = 02.05
if ($?vsn && $?spex && $?fleur) then
  echo "spex $spexversion"
  echo "fleur $fleurversion"
  exit
else if ($?vsn && $?spex) then
  echo "spex $spexversion"
  echo "lmf  `$mpirun1 $lmf --version`"
  exit
else if ($?vsn && $gwcode == 2) then
  echo "fpgw aug14"
  set  GWversion = `grep GWversion GWinput | awk '{print $2}'`
  echo " GWversion $GWversion"
  echo "lmf  `$mpirun1 $lmf --version`"
  exit
else if ($?vsn) then
  echo "fpgw $fpgwversion"
  echo "lmf  `$mpirun1 $lmf --version`"
  exit
endif

if ($gwcode == 0 || $gwcode == 2) then
  if (! -e GWinput) then
     echo "  (abort) missing GWinput"
     exit -1
  endif
 endif
if ($gwcode == 2) then
   grep GWversion GWinput >& /dev/null
   if ($status != 0) then
     echo '  Please add "GWversion #" to your GWinput file (#=0 for September 12 defaults) '
     echo "  (abort) missing GWversion in GWinput"
     exit -1
   endif
endif

if ($?sc && $?eps) then
  echo "    lmgw: oops! incompatible switches --sc and --eps ... aborting "
  exit -1
endif
if ($?bnds && ($?eps || $?epsNLF)) then
  echo "    lmgw: oops! incompatible switches --band and --eps ... aborting "
  exit -1
endif
if ($?sc && $?etot) then
  echo "    lmgw: oops! incompatible switches --sc and --etot ... aborting "
  exit -1
endif
if ($?eps && $?etot) then
  echo "    lmgw: oops! incompatible switches --eps and --etot ... aborting "
  exit -1
endif
if ($?sc && $?epsNLF) then
  echo "    lmgw: oops! incompatible switches --sc and --epsNLF ... aborting "
  exit -1
endif
if ($?eps && $?epsNLF) then
  echo "    lmgw: oops! choose only one of --eps and --epsNLF ... aborting "
  exit -1
endif

if ($?eps || $?epsNLF) then
  grep QforEPS GWinput >/dev/null
  if ($status) then
     echo "    lmgw: oops! $lmf returned with nonzero exit status."
     echo "          missing QforEPS in file GWinput ... aborting "
     exit -1
  endif

#   grep EPSrange GWinput >/dev/null
#   if ($status) then
#      echo "    lmgw: oops! $lmf returned with nonzero exit status."
#      echo "          missing EPSrange in file GWinput ... aborting "
#      exit -1
#   endif
#   grep EPSdw GWinput >/dev/null
#   if ($status) then
#      echo "    lmgw: oops! $lmf returned with nonzero exit status."
#      echo "          missing EPSdw in file GWinput ... aborting "
#      exit -1
#   endif
endif

# turn on noexec until appropriate start
if ($noexec == 1 && $?start) then
  unset start
endif

if ($?start) then
  set noexec = 1
endif

if ($#argv != 1) goto usage
setenv LMJOB $argv[1]

# --- Some checks on input files ---
if ($?fleur) then
  if (! -e inp) then
    echo "    lmgw (abort) ... missing fleur input file inp"
    exit -1
  endif
  if (! -e sym.out) then
    echo "    lmgw (abort) ... missing fleur input file sym.out"
    exit -1
  endif
  if (! -e pottot) then
    echo "    lmgw (abort) ... missing fleur input file pottot"
    exit -1
  endif
  if (! -e potcoul) then
    echo "    lmgw (abort) ... missing fleur input file potcoul"
    exit -1
  endif
  if (! -e enpara) then
    echo "    lmgw (warning) ... missing fleur file enpara"
    exit -1
  endif
  if (! -e ecore) then
    echo "    lmgw (abort) ... missing fleur input file ecore"
    exit -1
  endif
else if (! -e ctrl.$argv[1]) then
  echo "    lmgw (abort) ... missing file ctrl.$argv[1]"
  exit -1
endif
if ($?spex) then
  if (! -e spex.inp) then
    echo "    lmgw (abort) ... missing spex input file spex.inp"
    exit -1
  endif
else if (! -e GWinput) then
  echo '    lmgw (abort) ... missing GWinput'
  exit -1
endif

if ($?mixsig) then
  set mixsig = --mixsig=$mixsig
else
  set mixsig
endif
set gwargs = ($mixsig $varlst $LMJOB)
if (-e switches-for-lm) then
  set gwargs = "$mixsig $varlst $lmargs `head -1 switches-for-lm` $LMJOB"
endif
set gwargs_lmfgwd = "$gwargs"
if ($?erange) set gwargs_lmfgwd = "$gwargs --wrange"

# --- Extract appropriate energy cutoff for hsfp0 (alters GWinput) ---
if ($?getesig && $?scrho && ! $?spex) then
  echo -n "    lmgw : extracting SIGP_EMAX ... "
# v6
# echo "$lmf --show --quit=show --no-iactive $gwargs | grep SIGP: | tail -1 | awk ..."
  echo "$mpirun1 $lmf --show --quit=show --no-iactive $gwargs | grep SIGP_EMAX | tail -1 | awk ..."
  if ($noexec == 0) then
# v6
#   $lmf --show --quit=show --no-iactive $gwargs | grep SIGP: | tail -1 | awk '{match($0,"emax=\([^ ]\)*"); print substr($0,RSTART+5,RLENGTH-5)}' >/dev/null
    $mpirun1 $lmf --show --quit=show --no-iactive $gwargs | grep SIGP_EMAX | awk '{print $8}' >/dev/null
    if ($status) then
      echo "    lmgw: oops! $lmf returned with nonzero exit status ... aborting "
      exit -1
    endif
# v6
#   set emax = `$lmf --show --quit=show --no-iactive $gwargs | grep SIGP: | tail -1 | awk '{match($0,"emax=\([^ ]\)*"); print substr($0,RSTART+5,RLENGTH-5)}'`
    set emax = `$mpirun1 $lmf --show --quit=show --no-iactive $gwargs | grep SIGP_EMAX | awk '{print $8}' `
    set emaxs = `awk -vemax=$emax 'BEGIN {print emax+.5}'`
    echo "found emax = $emax ... use emaxs = $emaxs"
    if (-e GWinput) then
      echo "           copying file GWinput to GWinput~"
      cp GWinput GWinput~
      set src = GWinput~
      set dest = GWinput
      echo "           writing file $dest created from $src, changing ESIGCUT line to $emaxs"
      awk -v "emaxs=$emaxs" '{if ($1 == "emax_sigm") {print "emax_sigm", emaxs,"  ! Energy cutoff for Sigma, Ry (Optional)"} else {print}}' $src >$dest
    endif
  else
     echo "nothing extracted (noexec)"
  endif
endif

# --- Turn on or off multitet (alters GWinput) ---
if ($?getmtet && ! $?spex) then
  if ($getmtet == 0) then
     echo -n "    lmgw : removing multitet ... "
     cat GWinput | sed 's/^ *multitet/! multitet/' >GWinput~
  else
     echo -n "    lmgw : adding multitet ... "
     cat GWinput | sed 's/^! *multitet/multitet/' >GWinput~
  endif

  cmp GWinput GWinput~ >/dev/null
  if ($status == 0) then
    echo "nothing to change"
  else if ($noexec) then
    echo "nothing altered (noexec)"
  else
    echo file changed.
#      diff GWinput GWinput~
    mv GWinput~ GWinput
  endif
endif

# --- Turn on or off EXonly (alters GWinput) ---
if ($?exonly && ! $?spex) then
  if ($exonly == 0) then
     echo -n "    lmgw : removing EXonly ... "
     cat GWinput | sed 's/^ *EXonly/! EXonly/' >GWinput~
  else
     echo -n "    lmgw : adding EXonly ... "
     cat GWinput | sed 's/^! *EXonly/EXonly/' >GWinput~
  endif

  cmp GWinput GWinput~ >/dev/null
  if ($status == 0) then
    echo "nothing to change"
  else if ($noexec) then
    echo "nothing altered (noexec)"
  else
    echo file changed.
#      diff GWinput GWinput~
    mv GWinput~ GWinput
  endif
else
  set exonly = 0
endif

# --- Sanity check for Ex-only mode ---
if (! $?spex) then
if ($exonly == 1) then
  egrep -E ^EXonly GWinput >/dev/null
  if ($status) then
     echo "    lmgw: oops! missing EXonly in file GWinput ... aborting "
     echo "          "
     exit -1
  endif
  echo "    lmgw: exchange-only mode : EXonly = "`egrep -E ^EXonly GWinput | sed s/EXonly//`
else
  egrep -E ^EXonly GWinput >/dev/null
  if ($status == 0) then
     echo "    lmgw: oops! EXonly in GWinput should not be present ... aborting "
     echo "          "
     exit -1
  endif
endif
endif

# --- Extract number of k divisions (alters GWinput) ---
if ($?getnk && ! $?spex && ($?sc || $?eps || $?epsNLF)) then
  echo "    lmgw : extracting GW_NKABC= ... from ctrl file"
#v6
# echo 'set nkabc = (`'"$lmfgwd $lmfgwdargs --show --quit=show --no-iactive $gwargs | grep NKABC | tail -1 | sed s/NKABC=//"'`)'
  echo "$space   set nkabc = " '(`'"$mpirun1 $lmfgwd $lmfgwdargs --show --quit=show --no-iactive $gwargs | grep GW_NKABC | tail -1 ... "'`)'
  if ($noexec == 0) then
    $mpirun1 $lmfgwd $lmfgwdargs --show --quit=show --no-iactive $gwargs >/dev/null
    if ($status) then
      echo "    lmgw: oops! $lmf returned with nonzero exit status ... aborting "
      exit -1
    endif
#v6
#   set nkabc = (`$lmfgwd $lmfgwdargs --show --quit=show --no-iactive $gwargs | grep NKABC | tail -1 | sed s/NKABC=//`)
    set nkabc = (`$mpirun1 $lmfgwd $lmfgwdargs --show --quit=show --no-iactive $gwargs | grep GW_NKABC | tail -1 | awk '{print $(NF-2), $(NF-1), $(NF)}' `)

    echo "$space   extracted raw GW_NKABC as :   $nkabc"
    if ($nkabc[3] == '--') then
      echo "$space lmgw: GW_NKABC apparently missing from ctrl file"
      echo "$space       Restart with GW_NKABC in ctrl file, or do not use --getsigp or --getnk"
      echo "$space lmgw aborting ..."
      exit -1
    else if ($nkabc[2] == '--') then
      set nkabc = ($nkabc[3] $nkabc[3] $nkabc[3])
    else if ($nkabc[1] == '--') then
      set nkabc = ($nkabc[2] $nkabc[3] $nkabc[3])
    endif
    echo "$space   using for nkabc: $nkabc"


    if (-e GWinput) then
      echo "           copying file GWinput to GWinput~"
      cp GWinput GWinput~
      set src = GWinput~
      set dest = GWinput
      echo "           writing file $dest created from $src, changing n1n2n3 line to `echo $nkabc | sed 's/ /  /g'`"
      awk -v "nkabc= `echo $nkabc | sed 's/ /  /g'`"  '{if ($1 == "n1n2n3") {printf "n1n2n3 %s ! for GW BZ mesh\n", nkabc} else {print}}' $src >$dest
    endif
  else
     echo "nothing extracted (noexec)"
  endif
endif

# --- OPENMP setup ---
set hx0fp0    = hx0fp0
set hx0fp0_sc = hx0fp0_sc
set hsfp0     = hsfp0
set hsfp0_sc  = hsfp0_sc
if ($?openmp) then
  if ($openmp > 0) then
    echo "$space setenv OMP_NUM_THREADS $openmp"
    setenv OMP_NUM_THREADS $openmp
    echo "$space setenv MKL_NUM_THREADS $openmp"
    setenv MKL_NUM_THREADS $openmp
#    echo "$space setenv KMP_AFFINITY 'scatter,granularity=fine'"
#    setenv KMP_AFFINITY 'scatter,granularity=fine'
    set hx0fp0    = hx0fp0_om
    set hsfp0     = hsfp0_om
    set hx0fp0_sc = hx0fp0_sc_om
    set hsfp0_sc  = hsfp0_sc_om
  endif
endif

# --- Self-consistency in the density ---
if ($?scrho) then
  echo "           rm -f mixm.$argv[1]"
                   rm -f mixm.$argv[1]
  if (! -e rst.$argv[1]) echo "    lmgw:  missing file rst.$argv[1] ... start from free-atom densities"
  if (! -e rst.$argv[1]) set scrho0
  if (  -z rst.$argv[1]) echo "    lmgw:  file rst.$argv[1] has zero size ... start from free-atom densities"
  if (  -z rst.$argv[1]) set scrho0
  if ($?scrho0) then
    echo "           rm -f rst.$argv[1]"
    echo "    lmgw `date +%T` : invoking $mpirun1 $lmfa --no-iactive $lmargs $gwargs >llmf"
    if ($noexec == 0) then
      rm -f rst.$argv[1]
      $mpirun1 $lmfa $lmargs --no-iactive $gwargs >llmf
      if ($status) then
        echo "    lmgw: oops! $lmfa returned with nonzero exit status ... aborting "
        exit -1
      endif
    endif
    unset scrho0
  endif

  echo "    lmgw `date +%T` : invoking $mpirunn $lmf --no-iactive $lmargs $gwargs >llmf"
  if ($noexec == 0) then
    $mpirun1 $lmf --showp --no-iactive $gwargs >ctrl.preprocessed.$argv[1]
    $mpirunn $lmf --no-iactive $lmargs $gwargs >llmf
    if ($status) then
      echo "    lmgw: oops! $lmf returned with nonzero exit status ... aborting "
      exit -1
    endif
  endif
endif

# --- GW setup fleur/spex mode ---
if ($?fleur && $?spex) then

# Modify inp file if it does not contain gw=2
  set restoreinp; unset restoreinp
  echo -n "    lmgw : modify inp file to read gw=2 ... "
  grep pot8=T,gw=2 inp > /dev/null
  set retval = $status
  if ($retval == 0) then
    echo "nothing to change"
  else if ($noexec) then
    echo "nothing altered (noexec)"
  else
    cat inp | sed 's/pot8=[fF]/pot8=T/' | sed 's/gw=[01]/gw=2/' >inp.tmp
    diff -I pot8=.,gw=. inp inp.tmp > /dev/null
    set retval = $status
    if ($retval != 0) then
      echo "replacement failed '!'.  Compare inp, inp.tmp; goto error"
    endif
    cp inp.tmp inp
    set restoreinp
    echo "file changed (original in inp.tmp)"
  endif

# Use fleur to generate missing input files, if needed
  echo -n "    lmgw : checking for files gwa, LATTC, fl7para ..."
  if (! -e gwa || ! -e LATTC || ! -e fl7para) then
    echo ""
    echo "    lmgw : generating gwa, LATTC, fl7para using $fleurx"
    echo "    lmgw : rm -f fl7para vxc abcoeff eig stars"
    if ($noexec == 0) then
      rm -f fl7para vxc abcoeff eig stars
    endif
    echo "    lmgw   `date +%T` : invoking $fleurx >& lfleur"
    if ($noexec == 0) then
      if (-e cdn1) mv cdn1 cdn1.tmp
      $mpirun1 $fleurx >& lfleur
      if (-e cdn1.tmp) mv cdn1.tmp cdn1
    endif
  else
    echo " files found."
  endif

# Set k-points file
  echo "    lmgw : setting k-points file from spex.inp ..."
  echo "           cp -p spex.inp spex.inp.tmp"
  echo "           echo WRTKPT > spex.inp"
  echo "           grep -v WRTKPT spex.inp.tmp >> spex.inp"
  echo "           rm -f kpts.new"
  echo "           $spexx > lksetup"
  echo "           cp kpts.new kpts"
  echo "           cp -p spex.inp.tmp spex.inp"
  if ($noexec == 0) then
     cp -p spex.inp spex.inp.tmp
     echo WRTKPT > spex.inp
     grep -v WRTKPT spex.inp.tmp >> spex.inp
     rm -f kpts.new
     $mpirun1 $spexx >& lksetup
     if (! -e kpts.new) then
        echo "    lmgw: oops! $spexx failed to generate kpts.new ... aborting "
        exit -1
     endif
     cp kpts.new kpts
     cp -p spex.inp.tmp spex.inp
  endif

  echo "    lmgw : rm -f fl7para vxc abcoeff eig"
  echo "    lmgw   `date +%T` : invoking $fleurx >& lfleur"
  if ($noexec == 0) then
    rm -f fl7para vxc abcoeff eig
    $mpirun1 $fleurx >& lfleur
    if (! -e eig) then
      echo "    lmgw : fleur failed to write eig file ... aborting"
      exit -1
    endif
  endif

# --- GW setup lmf/spex mode ---
else if ($?lmfgwd && $?spex) then

  if ($noexec == 0) rm -f NoCore QPU QPD
  echo "    lmgw  `date +%T` : invoking $lmfgwd --job=0 $lmfgwdargs --no-iactive $gwargs >llmfgw00"
  if ($noexec == 0) then
    $mpirun1 $lmfgwd $lmfgwdargs --showp --no-iactive $gwargs >ctrl.preprocessed.$argv[1]
    $mpirun1 $lmfgwd --job=0 $lmfgwdargs --no-iactive $gwargs >llmfgw00
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
  endif

# use spex to set k-points file
  echo "    lmgw : setting k-points file from spex.inp ..."
  echo "           cp -p spex.inp spex.inp.tmp"
  echo "           echo WRTKPT > spex.inp"
  echo "           rm -f kpts.new"
  echo "           cat spex.inp.tmp >> spex.inp"
  echo "           $spexx >& lksetup"
  echo "           cp spex.inp.tmp spex.inp"
  echo "           cp kpts.new kpts"
  if ($noexec == 0) then
     cp -p spex.inp spex.inp.tmp
     echo WRTKPT > spex.inp
     rm -f kpts.new
     cat spex.inp.tmp >> spex.inp
     $mpirun1 $spexx >& lksetup
     cp -p spex.inp.tmp spex.inp
     if (! -e kpts.new) then
        echo "    lmgw: oops! $spexx failed to generate kpts.new ... aborting "
        exit -1
     endif
     cp kpts.new kpts
  endif

# lmto eigenvalues and eigenfunctions for spex
  echo $nonewln "    lmgw  `date +%T` : invoking echo 1 | $mpirun1 $lmfgwd $lmfgwdargs --no-iactive $gwargs >llmfgw01"
  if ($noexec == 0) then
    walltime w111 tstart 0
    w111:
    echo 1 | $mpirun1 $lmfgwd $lmfgwdargs --no-iactive $gwargs >llmfgw01
    set retval = $status
    if ($?pwtime) then
      pdtime w111b $tstart
      w111b:
    endif
    if ($retval != 0 && $?retzero) goto error
#   adjust NBAND in spex.inp
    grep NBAND spex.inp > /dev/null
    if ($status == 0) then
      set nband_spex = `grep NBAND spex.inp  | awk '{print $2}'`
      set nband = `grep 'minimum reduced'  llmfgw01 | awk '{print $7}'`
      if ($nband_spex > $nband) then
        echo -n "    lmgw : reduce NBAND in spex.inp to $nband ... "
        cat spex.inp.tmp | sed "s/NBAND *[0-9][0-9]*/NBAND $nband/" > spex.inp
        echo -n "spex.inp now modified to read : "
        grep NBAND spex.inp
      endif
    endif
  endif

# --- GW setup lmf/fpgw mode ---
else

if ($noexec == 0) rm -f NoCore QPU QPD erange erange.fe
echo "    lmgw `date +%T` : invoking $mpirun1 $lmfgwd --job=0 $lmfgwdargs --no-iactive $gwargs >llmfgw00"
if ($noexec == 0) then
  $mpirun1 $lmfgwd $lmfgwdargs --showp --no-iactive $gwargs >ctrl.preprocessed.$argv[1]
  $mpirun1 $lmfgwd $lmfgwdargs --job=0 --no-iactive $gwargs >llmfgw00
  set retval = $status
  if ($retval != 0 && $?retzero) goto error
  if (-e rhoc.$argv[1]) then
    echo "           ln -s -f rhoc.$argv[1] rhoc"
                     ln -s -f rhoc.$argv[1] rhoc
  endif
endif

# ... this branch runs qg4gw to make Q0P
if ($?eps || $?epsNLF) then
  echo "    lmgw `date +%T` : setup Q0P for epsilon"
  echo "    lmgw `date +%T` : invoking $mpirun1 qg4gw --job=2 >lqg4gw02"
  if ($noexec == 0) then
    $mpirun1 qg4gw --job=2 >lqg4gw02
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
  endif

else if ($?chix || $?chixNLF) then
  set inputp = 4 ; if ($gwcode == 1) set inputp = 2
  echo "    lmgw `date +%T` : invoking echo $inputp | $mpirun1 qg4gw >lqg4gw02"
  if ($noexec == 0) then
    echo $inputp| $mpirun1 qg4gw  >lqg4gw02
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
  endif

else if ($?bnds && ! $?sc) then

  echo "    lmgw `date +%T` : setup Q0P for band mode 1-shot GW"
  echo "    lmgw `date +%T` : invoking $mpirun1 qg4gw --job=3 >lqg4gw"
  if ($noexec == 0) then
    $mpirun1 qg4gw --job=3 >lqg4gw
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
  endif

else

# qg4gw mode 1: makes Q0P
  echo "    lmgw `date +%T` : invoking $mpirun1 qg4gw --job=1 >lqg4gw"
  if ($noexec == 0) then
    $mpirun1 qg4gw --job=1 >lqg4gw
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
  endif

endif

# --- eigenvalues for micro-tetrahedron method ---
grep -E ^multitet GWinput >& /dev/null
set retval = $status
if (-e Qmtet || ($noexec && $retval == 0)) then
  echo "    mv Qmtet Qeigval"
  echo $nonewln "    lmgw `date +%T` : invoking echo 5 | $mpirun1 $lmfgwd $lmfgwdargs --no-iactive $gwargs_lmfgwd >llmfgw_eigval"
  if ($noexec == 0) then
    mv Qmtet Qeigval
    walltime w121 tstart 0
    w121:
    echo 5 | $mpirun1 $lmfgwd $lmfgwdargs --no-iactive $gwargs_lmfgwd >llmfgw_eigval
    set retval = $status
    if ($?pwtime) then
      pdtime w121b $tstart
      w121b:
    endif
  endif
  echo "    mv eigval eigmtet"
  if ($noexec == 0) then
    mv eigval eigmtet
  endif
  set gwargs_lmfgwd = "$gwargs"
endif

# ... this branch runs lmfgwd for evals, evecs
if ($?bnds && ! $?sc) then
  echo $nonewln "    lmgw `date +%T` : invoking   echo 4 | $mpirun1 $lmfgwd $lmfgwdargs --no-iactive $gwargs >llmfgw04"
  if ($noexec == 0) then
    walltime w122 tstart 0
    w122:
    echo 4 | $mpirun1 $lmfgwd $lmfgwdargs --no-iactive $gwargs >llmfgw04
    set retval = $status
    if ($?pwtime) then
      pdtime w122b $tstart
      w122b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif

  echo "    lmgw `date +%T` : creating bands from LBAND.UP, LBAND.DN"
  foreach ext (UP DN)
  if(-e LBAND.$ext) then
    echo "    lmgw `date +%T` : cp LBAND.$ext LBAND"
    echo "    lmgw `date +%T` : cp TOTE2.$ext TOTE2"
    echo "    lmgw `date +%T` : invoking   $mpirun1 hbndout  >lbndout.$ext"
    echo "    lmgw `date +%T` : invoking   $mpirun1 bandplot"
    echo "    lmgw `date +%T` : copy files BandLDA BandQP1 BandQP2 BandGWpoint BandQpoint to .$ext"
    if ($noexec == 0) then
      cp LBAND.$ext LBAND
      if(-e TOTE2.$ext) cp TOTE2.$ext TOTE2
      $mpirun1 hbndout  >lbndout.$ext
      $mpirun1 bandplot
      foreach fin (BandLDA BandQP1 BandQP2 BandGWpoint BandQpoint)
        if(-e $fin ) mv $fin $fin.$ext
      end
      foreach fout (BandLDA BandQP1 BandQP2)
        if(-e $fout.ps) mv $fout.ps $fout.$ext.ps
      end
    endif
  endif
  end
  if(-e LBAND) rm LBAND
  if(-e TOTE2) rm TOTE2
  exit

else

##ifdef# TAKAO
#  echo "echo 1 | $mpirunn $lmfgwd  $lmfgwdargs --no-iactive $gwargs_lmfgwd >llmfgw01"
##else
  echo $nonewln "    lmgw `date +%T` : invoking $mpirunn $lmfgwd --job=1 $lmfgwdargs --no-iactive $gwargs_lmfgwd >llmfgw01"
##endif

  if ($noexec == 0) then
    walltime w131 tstart 0
    w131:
##ifdef# TAKAO
#    echo 1 | $mpirunn $lmfgwd  $lmfgwdargs --no-iactive $gwargs_lmfgwd >llmfgw01
##else
    $mpirunn $lmfgwd --job=1 $lmfgwdargs --no-iactive $gwargs_lmfgwd >llmfgw01
##endif
    set retval = $status
    if ($?pwtime) then
      pdtime w131b $tstart
      w131b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
  if (-e erange.$LMJOB) cp erange.$LMJOB erange

# --- Set nband_chi0 (alters GWinput) ---
  if ($?nbando && ! $?spex) then

    grep 'sugw: largest reduced hilbert space' llmfgw01 >/dev/null
    if ($status == 0) then
      echo -n "    lmgw : llmfgw01 returned nband_chi0 = "
      set nb = `grep 'sugw: largest reduced hilbert space' llmfgw01 | awk '{print $7'} | sed 's/\.//'`
      @ testn = $nb
      if ($status == 1) then
        echo "    lmgw: oops! llmfgw01 has funny nband_chi0 ... aborting"
        exit -1
      endif
      echo -n $nb "... "
#     cat GWinput | sed "s/^! *nband_chi0 *[0-9]*/nband_chi0 $nb/" >GWinput~
      cat GWinput | sed "s/^nband_chi0 *[0-9]*/nband_chi0 $nb/" | sed "s/^! *nband_chi0 *[0-9]*/nband_chi0 $nb/"  >GWinput~
      cmp GWinput GWinput~ >/dev/null
      if ($status == 0) then
        echo "nothing to change"
      else if ($noexec) then
        echo "nothing altered (noexec)"
      else
        echo file changed.
        mv GWinput~ GWinput
      endif
    endif
  endif

endif  # end of lmfgwd

if ($?sc) then
  echo "           rm -f v_xc evec"
                   rm -f v_xc evec
  echo "           ln -s vxc.$argv[1] v_xc"
                   ln -s vxc.$argv[1] v_xc
  echo "           ln -s evec.$argv[1] evec"
                   ln -s evec.$argv[1] evec
# this is used by hqpe_sc when isigma_en==5
  if (! -e evec0) then
    echo "           cp evec.$argv[1] evec0"
    if ($noexec == 0) then
                     cp evec.$argv[1] evec0
    endif
  endif
endif

if ($noexec == 0) then
  @ exinfo = `tail llmfgw01 | grep Exit | head -1 | awk '{print $2}'`
  if($exinfo == 0 ) then
#    echo " OK! lmfgwd mode=1 "
  else
    echo `tail -3 llmfgw01 `
  endif
endif

echo "    lmgw `date +%T` : invoking $mpirun1 $lmf2gw $LMJOB >llmf2gw"
if ($noexec == 0) then
  $mpirun1 $lmf2gw $LMJOB >llmf2gw
  set retval = $status
  if ($retval != 0 && $?retzero) goto error
endif

if ($?big) then
echo "    lmgw `date +%T` : removing files {gwa,gwb,gw1,gw2}.$LMJOB"
if ($noexec == 0) then
  rm {gwa,gwb,gw1,gw2}.$LMJOB
endif
endif

if ($?lstop) then
  if ($lstop == "setup") then
    echo "    lmgw `date +%T` : stopping execution after setup ..."
    exit
  endif
endif
if ($?start) then
  if ($start == "setup") then
    echo "    lmgw `date +%T` : starting execution after setup ..."
    set noexec = 0; if ($?pwtime) set nonewln = -n
    unset start
  endif
endif

if ($?chix || $?chixNLF) then
  echo "    lmgw `date +%T` : invoking $mpirun1 rdata4gw_v2 --job=1 $rdata4gw_arg >lrdata4gw"
  if ($noexec == 0) then
    $mpirun1 rdata4gw_v2 --job=1 $rdata4gw_arg > lrdata4gw
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
  endif
else
  echo "    lmgw `date +%T` : invoking $mpirun1 rdata4gw_v2 --job=0  $rdata4gw_arg >lrdata4gw"
  if ($noexec == 0) then
    $mpirun1 rdata4gw_v2 --job=0 $rdata4gw_arg >lrdata4gw
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
  endif
endif

if ($?big) then
echo "    lmgw `date +%T` : removing file CphiGeig"
if ($noexec == 0) then
  rm CphiGeig
endif
endif

#--- get EFERMI ---
echo "    lmgw `date +%T` : invoking $mpirun1 heftet --job=1 >leftet"
if ($noexec == 0) then
  $mpirun1 heftet --job=1 >leftet
  set retval = $status
  if ($retval != 0 && $?retzero) goto error
endif

endif  # end of setup mode

# ------------- Dielectric function calculation, bethesalpeter ----------------
#JJ calls bethesalpeter's mode -1
#JJ RPA dielectric function using LDA/qsGW eigenvectors/values
# only in non-sc mode
if ( (! $?sc) && $?bserpa) then
  echo    "    lmgw `date +%T` : invoking $mpirunn $lmfgwd --job=6 $lmfgwdargs --no-iactive $gwargs_lmfgwd >llmfgw02"
  if($noexec == 0) then
    $mpirunn $lmfgwd --job=6 $lmfgwdargs --no-iactive $gwargs_lmfgwd >llmfgw02
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
  endif

  echo    "    lmgw `date +%T` : invoking $mpirunn $lmf --opt:woptmc,rdqp $lmargs $gwargs >llmf02"
  if ($noexec == 0) then
    $mpirunn $lmf $bselmfargs $lmargs $gwargs >llmf02
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
    # we don't know the extension!  amazing!
    mv optdatac.* optdatabse
  endif

  # for PPB*, etc
  echo    "    lmgw `date +%T` : invoking $mpirun1 hbasfp0 --job=0 >lbas"
  if ($noexec == 0) then
    $mpirun1 hbasfp0 --job=0 >lbas
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
  endif

  # for the NW file...
  echo "    lmgw `date +%T` : invoking $mpirun1 hchknw --job=0 >lchknw"
  if ($noexec == 0) then
    $mpirun1 hchknw --job=0 >lchknw
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
  endif

  echo    "    lmgw `date +%T` : invoking $mpirun1 bethesalpeter --job=-1 >lbserpa"
  if($noexec == 0) then
    $mpirun1 bethesalpeter --job=-1 >lbserpa
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
  endif
  exit
endif


# ------------- Dielectric function calculation, fpgw ----------------
if ($?eps && $?spex) then

  echo epsilon not ready for spex mode
  exit

# ------------- Dielectric function calculation, fpgw ----------------
else if ($?eps && ! $?spex) then
  set basfp0sw
  # set basfp0sw = --addpb~delta=.02
  # set basfp0sw = --addpb~vnucl=.01
  echo    "    lmgw `date +%T` : invoking $mpirun1 hbasfp0 --job=0 $basfp0sw >lbas"
  if ($noexec == 0) then
    $mpirun1 hbasfp0 --job=0 $basfp0sw >lbas
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
  endif
# ... Coulomb matrix
  echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 hvccfp0 --job=202 >lvcc"
  if ($noexec == 0) then
    walltime w311 tstart 0
    w311:
    $mpirun1 hvccfp0 --job=202 >lvcc
    set retval = $status
    if ($?pwtime) then
      pdtime w311b $tstart
      w311b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
# ... Dielectric function, including local fields

  if ($?lstop) then
    if ($lstop == "x0") then
      echo "    lmgw `date +%T` : stopping execution before hx0fp0 ..."
      exit 0
    endif
  endif
  if ($?start) then
    if ($start == "x0") then
      echo "    lmgw `date +%T` : starting execution at hx0fp0 ..."
      set noexec = 0; if ($?pwtime) set nonewln = -n
      unset start
    endif
  endif

  if ($?htransform) then
    echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 $hx0fp0 --job=203 >lx0"
    if ($noexec == 0) then
      walltime w312 tstart 0
      w312:
      rm -f WVI WVR
      $mpirun1 $hx0fp0 --job=203 >lx0
      set retval = $status
      if ($?pwtime) then
        pdtime w312b $tstart
        w312b:
      endif
      if ($retval != 0 && $?retzero) goto error
    endif
  else
    echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 $hx0fp0 --job=3 >lx0"
    if ($noexec == 0) then
      walltime w314 tstart 0
      w314:
      rm -f WVI WVR
      $mpirun1 $hx0fp0 --job=3 >lx0
      set retval = $status
      if ($?pwtime) then
        pdtime w314b $tstart
        w314b:
      endif
      if ($retval != 0 && $?retzero) goto error
    endif
  endif

# finished
  exit
endif

if ($?epsNLF) then
  echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 hbasfp0 --job=4 >lbas"
  if ($noexec == 0) then
    walltime w315 tstart 0
    w315:
    $mpirun1 hbasfp0 --job=4 >lbas
    set retval = $status
    if ($?pwtime) then
      pdtime w315b $tstart
      w315b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
# ... Coulomb matrix
  echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 hvccfp0 --job=202 >lvcc"
  if ($noexec == 0) then
    walltime w316 tstart 0
    w316:
    $mpirun1 hvccfp0 --job=202 >lvcc
    set retval = $status
    if ($?pwtime) then
      pdtime w316b $tstart
      w316b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif

  if ($?lstop) then
    if ($lstop == "x0") then
      echo "    lmgw `date +%T` : stopping execution before hx0fp0 ..."
      exit 0
    endif
  endif
  if ($?start) then
    if ($start == "x0") then
      echo "    lmgw `date +%T` : starting execution at hx0fp0 ..."
      set noexec = 0; if ($?pwtime) set nonewln = -n
      unset start
    endif
  endif

# ... Dielectric function, no local fields
  if ($?htransform) then
    echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 $hx0fp0 --job=202 >lx0"
    if ($noexec == 0) then
      walltime w317 tstart 0
      w317:
      rm -f WVI WVR
      $mpirun1 $hx0fp0 --job=202 >lx0
      set retval = $status
      if ($?pwtime) then
        pdtime w317b $tstart
        w317b:
      endif
      if ($retval != 0 && $?retzero) goto error
    endif
  else
    echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 $hx0fp0 --job=2 >lx0"
    if ($noexec == 0) then
      walltime w318 tstart 0
      w318:
      rm -f WVI WVR
      $mpirun1 $hx0fp0 --job=2 >lx0
      set retval = $status
      if ($?pwtime) then
        pdtime w318b $tstart
        w318b:
      endif
      if ($retval != 0 && $?retzero) goto error
    endif
  endif

# finished
  exit
endif

# ------------- Transverse spin susceptibility calculation, spex ----------------
if ($?chix && $?spex || $?chixNLF && $?spex) then

  echo transverse chi not ready for spex mode
  exit

# ------------- Transverse spin susceptibility calculation, fpgw ----------------
else                # chix fpgw mode
if ($?chix || $?chixNLF) then
  echo "    lmgw `date +%T` : invoking $mpirun1 hbasfp0 --job=8 >lbas"
  if ($noexec == 0) then
    $mpirun1 hbasfp0 --job=8 >lbas
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
  endif
# ... Coulomb matrix
  echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 hvccfp0 --job=202 >lvcc"
  if ($noexec == 0) then
    walltime w321 tstart 0
    w321:
    $mpirun1 hvccfp0 --job=202 >lvcc
    set retval = $status
    if ($?pwtime) then
      pdtime w321b $tstart
      w321b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
# finished
#  exit
endif

if ($?chix) then
  if ($?lstop) then
    if ($lstop == "x0") then
      echo "    lmgw `date +%T` : stopping execution before hx0fp0 ..."
      exit 0
    endif
  endif
  if ($?start) then
    if ($start == "x0") then
      echo "    lmgw `date +%T` : starting execution at hx0fp0 ..."
      set noexec = 0; if ($?pwtime) set nonewln = -n
      unset start
    endif
  endif

# ... Dielectric function, no local fields
  if ($?htransform) then
    echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 $hx0fp0 --job=223 >lx0"
    if ($noexec == 0) then
      walltime w331 tstart 0
      w331:
      rm -f WVI WVR
      $mpirun1 $hx0fp0 --job=223 >lx0
      set retval = $status
      if ($?pwtime) then
        pdtime w331b $tstart
        w331b:
      endif
      if ($retval != 0 && $?retzero) goto error
    endif
  else
    echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 $hx0fp0 --job=223 >lx0"
    if ($noexec == 0) then
      walltime w332 tstart 0
      w332:
      rm -f WVI WVR
      $mpirun1 $hx0fp0 --job=223 >lx0
      set retval = $status
      if ($?pwtime) then
        pdtime w332b $tstart
        w332b:
      endif
      if ($retval != 0 && $?retzero) goto error
    endif
  endif
# finished
  exit
endif

if ($?chixNLF) then
  if ($?lstop) then
    if ($lstop == "x0") then
      echo "    lmgw `date +%T` : stopping execution before hx0fp0 ..."
      exit 0
    endif
  endif
  if ($?start) then
    if ($start == "x0") then
      echo "    lmgw `date +%T` : starting execution at hx0fp0 ..."
      set noexec = 0; if ($?pwtime) set nonewln = -n
      unset start
    endif
  endif

# ... Dielectric function, no local fields
  if ($?htransform) then
    echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 $hx0fp0 --job=222 >lx0"
    if ($noexec == 0) then
      walltime w341 tstart 0
      w341:
      rm -f WVI WVR
      $mpirun1 $hx0fp0 --job=222 >lx0
      set retval = $status
      if ($?pwtime) then
        pdtime w341b $tstart
        w341b:
      endif
      if ($retval != 0 && $?retzero) goto error
    endif
  else
    echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 $hx0fp0 --job=222 >lx0"
    if ($noexec == 0) then
      walltime w342 tstart 0
      w342:
      rm -f WVI WVR
      $mpirun1 $hx0fp0 --job=222 >lx0
      set retval = $status
      if ($?pwtime) then
        pdtime w342b $tstart
        w342b:
      endif
      if ($retval != 0 && $?retzero) goto error
    endif
  endif
# finished
  exit
endif

endif                # chix

# ----------------------------- Setup for GW pass, spex mode -----------------------------
if ($?spex) then    # GW pass spex mode

# ----------------------------- Setup for GW pass, fpgw mode -----------------------------
else                # GW pass fpgw mode
#--- hchknw only calculates NW, which contains the number of nw corresponding to QPNT ---
if ($noexec == 0) rm -f NW


if ($?etot) then
    echo "    echo 0 >NW"
  if ($noexec == 0) then
    echo 0 >NW
  endif
else if ($?sc == 0) then
  echo "    lmgw `date +%T` : invoking $mpirun1 hchknw --job=0 >lchknw"
  if ($noexec == 0) then
    $mpirun1 hchknw --job=0 >lchknw
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
  endif
else
  echo "    lmgw `date +%T` : invoking $mpirun1 hchknw --job=1 >lchknw"
  if ($noexec == 0) then
    $mpirun1 hchknw --job=1 >lchknw
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
  endif
endif
if ($noexec == 0 && ! -e NW) then
  echo "no file NW created ... aborting"
  exit -1
endif
if ($noexec == 0) then
if ($noexec == 0 && `head -1 NW | awk '{print ($1>0)?1:0}'` < 0) then
  echo "first line in file NW < 0 ... aborting"
  exit -1
endif
endif
endif     # GW pass fpgw mode

# ----------------------------- Total energy branch, spex mode -----------------------------
if ($?spex && $?etot) then    # GW pass spex mode

  echo total energy not ready for spex mode
  exit

# ----------------------------- Total energy branch, fpgw mode -----------------------------
else if ($?etot) then

# --- Core-core exchange ---
echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 hbasfp0 --job=5  >lexxCC"
if ($noexec == 0) then
  walltime w411 tstart 0
  w411:
  $mpirun1 hbasfp0 --job=5  >lexxCC
  set retval = $status
  if ($?pwtime) then
    pdtime w411b $tstart
    w411b:
  endif
  echo ' --- Ex(core-core)   in TEEXXcc = ' `head -5  TEEXXcc | tail -1|awk '{print $1}'`  'eV'
endif

# --- Core-valence exchange ---
echo "    lmgw `date +%T` : invoking $mpirun1 hbasfp0 --job=6  >lbasCV"
echo "                    $mpirun1 hvccfp0 --job=0  >lvccCV"
echo "                    $mpirun1 $hsfp0 --job=6   >lexxCV"
if ($noexec == 0) then
  $mpirun1 hbasfp0 --job=6  >lbasCV
  $mpirun1 hvccfp0 --job=0  >lvccCV
  $mpirun1 $hsfp0 --job=6   >lexxCV
  echo ' --- 2*Ex(core-val) in TEEXXcv = ' `head -5  TEEXXcv | tail -1|awk '{print 2*$1}'` 'eV'
endif

# --- Valence-valence exchange ---
echo "    lmgw `date +%T` : invoking $mpirun1 hbasfp0 --job=7 >lbasVV"
echo "                    $mpirun1 hvccfp0 --job=0 >lvccVV"
echo "                    $mpirun1 $hsfp0 --job=5   >lexxVV"
if ($noexec == 0) then
  $mpirun1 hbasfp0 --job=7 >lbasVV
  $mpirun1 hvccfp0 --job=0 >lvccVV
  $mpirun1 $hsfp0 --job=5   >lexxVV
  echo ' --- Ex(val-val)    in TEEXXvv = ' `head -5  TEEXXvv | tail -1|awk '{print $1}'` 'eV'
endif

# --- Correlation energy ---
echo "    lmgw `date +%T` : invoking $mpirun1 hbasfp0 --job=0  >lbas_cor"
echo "                    $mpirun1 hvccfp0 --job=0  >lvcc_cor"
if ($?htransform) then
echo "                    $mpirun1 $hx0fp0 --job=12  >lx0_cor"
else
echo "                    $mpirun1 $hx0fp0 --job=101 >lx0_cor"
endif
echo "                    $mpirun1 hecor           >lecor"

if ($noexec == 0) then
  $mpirun1 hbasfp0 --job=0  >lbas_cor
  $mpirun1 hvccfp0 --job=0  >lvcc_cor
if ($?htransform) then
  walltime w412 tstart 0
  w412:
  $mpirun1 $hx0fp0 --job=12 >lx0_cor
  set retval = $status
  if ($?pwtime) then
    pdtime w412b $tstart
    w412b:
  endif
else
  walltime w413 tstart 0
  w413:
  $mpirun1 $hx0fp0 --job=101 >lx0_cor
  set retval = $status
  if ($?pwtime) then
    pdtime w413b $tstart
    w413b:
  endif
endif
  $mpirun1 hecor           >lecor
  echo ' --- Ec             in TEECORR = ' `head -5  TEECORR | tail -1|awk '{print $1}'` 'eV'
endif

# --- Get LDA part of energies ---
echo " "
echo "    lmgw `date +%T` : Generate LDA part of total energies (file log.$argv[1])"
echo "           rm -f log.$argv[1]"
echo "    lmgw `date +%T` : invoking         $mpirun1 $lmf --etot --no-iactive $gwargs >llmf_elda"
if ($noexec == 0) then
  rm -f log.$argv[1]
  $mpirun1 $lmf --etot --no-iactive $gwargs >llmf_elda
  if ($status) then
    echo "    lmgw: oops! $lmf returned with nonzero exit status ... aborting "
    exit -1
  endif
endif

echo "    lmgw `date +%T` : Extract LDA part of total energies (generate ETOTLDA and RoVxcLDA from file log.$argv[1])"
echo "           rm -f ETOTLDA RoVxcLDA"
echo "           $mpirun1 extract_elda_from_log_file $argv[1]"
echo "           $mpirun1 eout"

if ($noexec == 0) then
                 rm -f ETOTLDA RoVxcLDA
                 $mpirun1 extract_elda_from_log_file $argv[1]
                 set retval = $status
                 if ($retval != 0 && $?retzero) goto error
                 $mpirun1 eout
endif

exit
endif
endif         # End of Total energy branch

# ----------------------------- GW pass, spex mode -----------------------------
if ($?spex) then    # GW pass spex mode

  echo "    lmgw  `date +%T` : invoking $spexx &> lspex"
  if ($noexec == 0) then

    touch spex.sf sex.sew spex.sec
    rm -f spex.sf* sex.sew* spex.sec*

    $spexx >& lspex
    echo "    lmgw  `date +%T` : spex completed"
#   abort if no QP levels printed out
    grep 'Quasiparticle energy' lspex > /dev/null
    if ($status) then
      echo "    lmgw: oops! $spexx did not generate any QP levels ... aborting "
      exit -1
    endif

    if ($?fleur && $?restoreinp) then
      echo "    lmgw `date +%T` : restore inp file: mv inp.tmp inp"
      if ($noexec == 0) then
        mv inp.tmp inp
      endif
    endif
  endif

# ----------------------------- GW pass, fpgw mode -----------------------------
else
# ... Core exchange
#... product basis for core
# if ($exonly == 1) then
# else

echo "    lmgw `date +%T` : invoking $mpirun1 hbasfp0 --job=3 >lbasC"
if ($noexec == 0) then
  $mpirun1 hbasfp0 --job=3 >lbasC
  set retval = $status
  if ($retval != 0 && $?retzero) goto error
endif

# ... Coulomb matrix
echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 hvccfp0 --job=0 >lvccC"
if ($noexec == 0) then
  walltime w521 tstart 0
  w521:
  $mpirun1 hvccfp0 --job=0 >lvccC
  set retval = $status
  if ($?pwtime) then
    pdtime w521b $tstart
    w521b:
  endif
  if ($retval != 0 && $?retzero) goto error
endif

# ... Self energy from core1
if ($?sc) then
  echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 $hsfp0_sc --job=3 >lsxC"
  if ($noexec == 0) then
    walltime w522 tstart 0
    w522:
    $mpirun1 $hsfp0_sc --job=3  >lsxC
    set retval = $status
    if ($?pwtime) then
      pdtime w522b $tstart
      w522b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
else
  echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 $hsfp0 --job=3 >lsxC"
  if ($noexec == 0) then
    walltime w523 tstart 0
    w523:
    $mpirun1 $hsfp0 --job=3   >lsxC
    set retval = $status
    if ($?pwtime) then
      pdtime w523b $tstart
      w523b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
endif
# endif

# ... Valence part of the self-energy
set basfp0sw
# set basfp0sw = --addpb~delta=.02
# set basfp0sw = --addpb~vnucl=.01
echo "    lmgw `date +%T` : invoking $mpirun1 hbasfp0 --job=0 $basfp0sw >lbas"
if ($noexec == 0) then
  $mpirun1 hbasfp0 --job=0 $basfp0sw >lbas
  set retval = $status
  if ($retval != 0 && $?retzero) goto error
endif
# ... Coulomb matrix
echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 hvccfp0 --job=0 >lvcc"
if ($noexec == 0) then
  walltime w530 tstart 0
  w530:
  $mpirun1 hvccfp0 --job=0 >lvcc
  set retval = $status
  if ($?pwtime) then
    pdtime w530b $tstart
    w530b:
  endif
  if ($retval != 0 && $?retzero) goto error
endif

# ... Exchange self energy from valence core2+valence electrons
if ($?sc) then
  echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 $hsfp0_sc --job=1 >lsx"
  if ($noexec == 0) then
    walltime w531 tstart 0
    w531:
    $mpirun1 $hsfp0_sc --job=1 >lsx
    set retval = $status
    if ($?pwtime) then
      pdtime w531b $tstart
      w531b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
else if ($?htransform) then
  echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 $hsfp0 --job=11 >lsx"
  if ($noexec == 0) then
    walltime w532 tstart 0
    w532:
    $mpirun1 $hsfp0 --job=11   >lsx
    set retval = $status
    if ($?pwtime) then
      pdtime w532b $tstart
      w532b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
else
  echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 $hsfp0 --job=1 >lsx"
  if ($noexec == 0) then
    walltime w533 tstart 0
    w533:
    $mpirun1 $hsfp0 --job=1   >lsx
    set retval = $status
    if ($?pwtime) then
      pdtime w533b $tstart
      w533b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
endif

if ($?lstop) then
  if ($lstop == "x0") then
    echo "    lmgw `date +%T` : stopping execution before hx0fp0 ..."
    exit 0
  endif
endif
if ($?start) then
  if ($start == "x0") then
    echo " "
    echo "    lmgw `date +%T` : starting execution at hx0fp0 ..."
    set noexec = 0; if ($?pwtime) set nonewln = -n
    unset start
  endif
endif

# ... Screened coulomb interaction
if ($exonly == 1) then
else

if ($?lstop) then
  if ($lstop == "x0") then
    echo "    lmgw `date +%T` : stopping execution before hx0fp0 ..."
    exit 0
  endif
endif
if ($?start) then
  if ($start == "x0") then
    echo "    lmgw `date +%T` : starting execution at hx0fp0 ..."
    set noexec = 0; if ($?pwtime) set nonewln = -n
    unset start
  endif
endif

if ($?sc) then
  echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 $hx0fp0_sc --job=11 >lx0"
  if ($noexec == 0) then
    walltime w541 tstart 0
    w541:
    rm -f WVI WVR
    $mpirun1 $hx0fp0_sc --job=11 >lx0
    set retval = $status
    if ($?pwtime) then
      pdtime w541b $tstart
      w541b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif

else if ($?htransform) then
  echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 $hx0fp0 --job=11 >lx0"
  if ($noexec == 0) then
    walltime w542 tstart 0
    w542:
    rm -f WVI WVR
    $mpirun1 $hx0fp0 --job=11 >lx0
    set retval = $status
    if ($?pwtime) then
      pdtime w542b $tstart
      w542b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
else
  echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 $hx0fp0 --job=1 >lx0"
  if ($noexec == 0) then
    walltime w543 tstart 0
    w543:
    rm -f WVI WVR
    $mpirun1 $hx0fp0 --job=1  >lx0
    set retval = $status
    if ($?pwtime) then
      pdtime w543b $tstart
      w543b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
endif
endif

# ------------- Dielectric function calculation, bethesalpeter ----------------
#JJ calls bethesalpeter's mode 0
#JJ BSE dielectric function using LDA/qsGW eigenvectors/values
if ($?start) then
  if ($start == "bse") then
    echo "    lmgw `date +%T` : starting execution at bse ..."
    set noexec = 0; if ($?pwtime) set nonewln = -n
    unset start
  endif
endif

if ( (! $?sc) && $?bse) then
    echo    "    lmgw `date +%T` : single-shot BSE calculation"
    echo    "    lmgw `date +%T` : invoking $mpirunn $lmfgwd --job=6 $lmfgwdargs --no-iactive $gwargs_lmfgwd >llmfgw02"
    if($noexec == 0) then
      $mpirunn $lmfgwd --job=6 $lmfgwdargs --no-iactive $gwargs_lmfgwd >llmfgw02
      set retval = $status
      if ($retval != 0 && $?retzero) goto error
    endif

    echo    "    lmgw `date +%T` : invoking $mpirunn $lmf $bselmfargs $lmargs $gwargs >llmf02"
    echo    "    lmgw `date +%T` : invoking  mv optdatac.$LMJOB optdatabse"
    if ($noexec == 0) then
      $mpirunn $lmf $bselmfargs $lmargs $gwargs >llmf02
      set retval = $status
      if ($retval != 0 && $?retzero) goto error
      mv optdatac.$LMJOB  optdatabse
    endif

    echo    "    lmgw `date +%T` : invoking $mpirun1 bethesalpeter --job=0 >lbse"
    if($noexec == 0) then
      $mpirun1 bethesalpeter --job=0 >lbse
      set retval = $status
      if ($retval != 0 && $?retzero) goto error
    endif
  exit
endif

# ------------- Dielectric function calculation, bethesalpeter ----------------
if ($?sc) then
# check GWinput for usebsew flag
# bethesalpeter executable/mode=3 returns immediately if not needed
  grep '^UseBSEW[[:space:]]*1[[:space:]].*' GWinput >/dev/null
  if ($status == 0) then
    set usebsew
  endif

# bethesalpeter invocation
  if ($?usebsew) then
    echo    "    lmgw `date +%T` : using BSE W"
    echo    "    lmgw `date +%T` : invoking $mpirun1 bethesalpeter --job=3 >lbse"
    if($noexec == 0) then
      $mpirun1 bethesalpeter --job=3 >lbse
      set retval = $status
      if ($retval != 0 && $?retzero) goto error

      # restart_q is problematic between qsGW iterations
      rm -f restart_q >/dev/null

      foreach file (WVR.* WVI.*)
	mv -v $file RPA_$file  >>lbse
        set retval = $status
        if ($retval != 0 && $?retzero) goto error
      end
      foreach file (WVRBSE*)
	set extn=`echo $file| sed 's/.*\.\(.*\)/\1/'`
	mv -v WVRBSE.$extn WVR.$extn >>lbse
        set retval = $status
        if ($retval != 0 && $?retzero) goto error
	mv -v WVIBSE.$extn WVI.$extn >>lbse
        set retval = $status
        if ($retval != 0 && $?retzero) goto error
      end
    endif
  endif
endif
# -----------------------------------------------------------------------------

# ... Correlation self-energy from valence core2+valence electrons
if ($?lstop) then
  if ($lstop == "sig") then
    echo "    lmgw `date +%T` : stopping execution before hsfp0 ..."
    exit 0
    set noexec = 1
    unset lstop
  endif
endif

if ($?start) then
  if ($start == "sig") then
    echo "    lmgw `date +%T` : starting execution at hsfp0 ..."
    set noexec = 0; if ($?pwtime) set nonewln = -n
    unset start
  endif
endif

hsfp0entry:
if ($exonly == 1) then
else
if ($?sc) then
  echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 $hsfp0_sc --job=2  >lsc"
  if ($noexec == 0) then
    walltime w551 tstart 0
    w551:
    $mpirun1 $hsfp0_sc --job=2  >lsc
    set retval = $status
    if ($?pwtime) then
      pdtime w551b $tstart
      w551b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
else if ($?htransform) then
  echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 $hsfp0 --job=12  >lsc"
  if ($noexec == 0) then
    walltime w552 tstart 0
    w552:
    $mpirun1 $hsfp0 --job=12  >lsc
    set retval = $status
    if ($?pwtime) then
      pdtime w552b $tstart
      w552b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
else
  echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 $hsfp0 --job=2 >lsc"
  if ($noexec == 0) then
    walltime w553 tstart 0
    w553: tstart 0
    $mpirun1 $hsfp0 --job=2   >lsc
    set retval = $status
    if ($?pwtime) then
      pdtime w553b $tstart
      w553b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
endif
endif

# ... Make summary, sigm file in sc case
if ($?lstop) then
  if ($lstop == "qpe") then
    echo "    lmgw `date +%T` : stopping execution before hqpe ..."
    exit 0
    set noexec = 1
    unset lstop
  endif
endif

if ($?start) then
  if ($start == "qpe") then
    echo "    lmgw `date +%T` : starting execution at hqpe ..."
    set noexec = 0; if ($?pwtime) set nonewln = -n
    unset start
  endif
endif


# ... Write file sig0
if ($?sc && $?writesig0) then
  echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 hqpe_sc $nocc 0 > lqpe0"
  if ($noexec == 0) then
    echo ' '
    rm -f -v sigm~ mixsigma~
    if (-e sigm) mv -v sigm sigm~
    if (-e mixsigma ) mv -v mixsigma mixsigma~
    ln -s -v sig0 sigm
    ln -s -v mixsig0 mixsigma

    walltime w560 tstart 0
    w560: tstart 0
    $mpirun1 hqpe_sc $nocc 0 > lqpe0
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
    if ($?pwtime) then
      pdtime w560b $tstart
      w560b:
    endif
    rm -f -v sigm mixsigma
    if (-e sigm~) mv -v sigm~ sigm
    if (-e mixsigma~ ) mv -v mixsigma~ mixsigma
  endif
endif

if ($?sc) then
  echo $nonewln "    lmgw `date +%T` : invoking $mpirun1 hqpe_sc $nocc >lqpe"
  if ($noexec == 0) then
    walltime w561 tstart 0
    w561: tstart 0
    $mpirun1 hqpe_sc $nocc >lqpe
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
    if ($?pwtime) then
      pdtime w561b $tstart
      w561b:
    endif
  endif
else if ($?metal) then
  echo "    lmgw `date +%T` : invoking $mpirun1 hqpe --job=0 >lqpe"
  if ($noexec == 0) then
    $mpirun1 hqpe --job=0 >lqpe
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
  endif
  echo "    lmgw `date +%T` : invoking $mpirun1 hqpemetal $argv[1] >lqpemetal"
  if ($noexec == 0) then
    $mpirun1 hqpemetal $argv[1] >lqpemetal
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
  endif
else
  echo "    lmgw `date +%T` : invoking $mpirun1 hqpe --job=$nocc >lqpe"
  if ($noexec == 0) then
    $mpirun1 hqpe --job=$nocc >lqpe
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
  endif
endif

# Soft link sigm file for subsequent uses by lmf
if ($?sc) then
  echo "           ln -s -f sigm sigm.$argv[1]"
  if ($noexec == 0) then
                   ln -s -f sigm sigm.$argv[1]
  endif
endif

endif         # GW pass

# Symmetrize sigma file
if ($?sym && $?sc) then
  echo "    lmgw `date +%T` : invoking         $mpirun1 $lmf --symsig --no-iactive --wsig --mixsig=1 $gwargs >llmf-sym"
  echo "                            cp sigm.$LMJOB sigm~"
  echo "                            cp sigm2.$LMJOB sigm.$LMJOB"
  if ($noexec == 0) then
    $mpirun1 $lmf --symsig --no-iactive --wsig --mixsig=1 $gwargs >llmf-sym
    if ($status) then
      echo "    lmgw: oops! $lmf returned with nonzero exit status ... aborting "
      exit -1
    endif
    cp sigm.$LMJOB sigm~
    cp sigm2.$LMJOB sigm.$LMJOB
    if ($status) then
      echo "    lmgw: oops! $lmf returned with nonzero exit status ... aborting "
      exit -1
    endif
  endif
endif

# --- Self-consistency in the density ---
if ($?bnds && $?sc) then
  echo "    lmgw `date +%T` : invoking         $mpirun1 $lmf --no-iactive $bnds $gwargs >llmf-bnds"
  if ($noexec == 0) then
    $mpirun1 $lmf --no-iactive $bnds $gwargs >llmf-bnds
    if ($status) then
      echo "    lmgw: oops! $lmf returned with nonzero exit status ... aborting "
      exit -1
    endif
  endif
#    if ($?insul && -e bnds.$argv[1]) then
#      set quiet
#      findcmd chk11a fixef change-bnds-ef "$path" "no"
#      chk11a:
#      if ($?fixef) then
#        echo "    lmgw `date +%T` : invoking         $fixef -n=$insul bnds.$argv[1]"
#        if ($noexec == 0) then
#          $fixef -n=$insul bnds.$argv[1]
#        endif
#      endif
#      exit
#    endif
endif

echo -n "    lmgw `date +%T` : exit with wall clock time"
pdtime w00xz $tstartlmgw
w00xz:


exit
# ---------------- findcmd --------------
# Finds an executable program within the supplied path
# Usage: findcmd return_label program-name executable_command path_name make_path
# If $executable_command is not found, findcmd does one of the following:
# If make_path = 'no' : returns silently.
# Otherwise findcmd aborts with a message, which assumes
# $make_path is the path where $executable_command is made.
exit
findcmd:
set found = 'no'
foreach ac_dir ($path_name)
 if (-x $ac_dir/$prog_cmd) then
   set $prognam = $ac_dir/$prog_cmd
   set found = 'yes'
   break
 endif
end
# if (! $?quiet) then
#   if ($found == 'yes') echo "$space ... using executable $ac_dir/$prog_cmd"
#   if ($found == 'no')  echo "$space ... no executable $prog_cmd found in path"
# endif
if ($found == 'no' && $make_path != "no") then
  echo "  "
  echo "  Sorry, $testfile cannot find program '"$prog_cmd"' it needs to execute."
  echo "  '"$prog_cmd"' was not found in supplied path, or in the following:"
  echo "        $topdir $maindir"
# echo "  ... This script ($testfile) requires binary "'"rdcmd"'" to run."
  echo "  You must create or put '"$prog_cmd"' in your path before invoking this script."
  echo "  Normally '"$prog_cmd"' is created as part of the installation process."
  echo "  Invoking '"make $prog_cmd"' in $make_path should create it."
  echo "  $testfile aborting ..."
  exit -1
endif
goto $retcall
exit

# ---------------- walltime --------------
# Returns wall-clock time.
# Usage: walltime return_label time_var time_start

walltime:
echo `date +%s` > datenow~; set datenow = `cat datenow~`
@ $time_var = ( $datenow - $time_start )
goto $retcall
exit

# ---------------- Prints out difference between current wall clock time and time_start --------------
# Returns wall-clock time
# Usage: if ($?pwtime) pdtime return_label time_start

pdtime:
set retcallp = $retcall
set time0 = $time_start
walltime pdtime2 deltat 0
pdtime2:
echo $deltat $time0 | awk '{printf(" ... %.1fm (%.1fh)\n",($1-$2)/60.,($1-$2)/3600.)}'
goto $retcallp
exit

usage:
echo 'usage : lmgw [--switches] extension'
echo '        switches:'
echo '          --help'
echo '          --h'
echo '            show this message'
echo ' '
echo '          --version'
echo '            Reports version to standard output and exits'
echo ' '
echo '          --metal'
echo ' '
echo '          --insul=# insulator, with # occupied bands (only affects QP* file)'
echo ' '
echo '          --ht'
echo  '             generate imaginary weights in hx0fp0 and'
echo  '             real weights from Hilbert transform (S. Faleev).'
echo ' '
echo '          --code0'
echo  '             use GW code 033a6'
echo ' '
echo '          --code2'
echo  '             use GW code Sep 2012'
echo ' '
echo '          --spex'
echo '          --spexi'
echo  '             use spex GW code (with or without inversion)'
echo ' '
echo '          --spexf'
echo '          --spexfi'
echo  '             use fleur LDA code (with or without inversion)'
echo  '             use spex GW code (with or without inversion)'
echo ' '
echo '          --scrho'
echo '          --scrho0'
echo  '             make density self-consistent before GW calculation'
echo  '             scrho uses existing rst file; scrho0 starts from free-atom densities'
echo ' '
echo '          --sc'
echo '          --sc:sym'
echo  '             make output sigma needed for self-consistency cycle'
echo  '             Option :sym symmetrizes sigma'
echo  '             NB: --sc implies --ht for now'
echo ' '
echo '          --etot'
echo  '             make LW total energy'
echo  '             NB: No self-energies are computed.  Not compatible with --sc or --eps'
echo ' '
echo '          --eps'
echo  '             make dielectric function'
echo  '             No self-energies are computed.  Not compatible with --sc or --etot'
echo ' '
echo '          --epsNLF'
echo  '             make dielectric function without local-field correction'
echo  '             No self-energies are computed'
echo ' '
echo '          --chix'
echo  '             make transverse susceptibility'
echo  '             No self-energies are computed.  Not compatible with --sc or --etot'
echo ' '
echo '          --chixNLF'
echo  '             make transverse susceptibility without local-field correction'
echo  '             No self-energies are computed'
echo ' '
echo '          --band[:args]'
echo  '             generate energy bands after GW pass'
echo  '             NB: In conjunction with --sc switch,  uses lmf --band:args'
echo  '                 Otherwise, uses band mode 4 of lmfgwd'
echo ' '
echo '          --sig0'
echo '             Write file sig0, which is the QSGW sigma without vxc subtracted'
echo ' '
echo '          --start=setup'
echo  '             start execution after setup'
echo '          --start=x0'
echo  '             start execution at hx0fp0'
echo '          --start=bse'
echo  '             start execution at BSE W maker'
echo '          --start=sig'
echo  '             start execution at hsfp0'
echo '          --start=qpe'
echo  '             start execution at hqpe'
echo ' '
echo '          --stop=setup'
echo  '             stop execution after setup'
echo '          --stop=x0'
echo  '             stop execution before hx0fp0'
echo '          --stop=sig'
echo  '             stop execution before hsfp0'
echo ' '
echo '          --bin=dir'
echo '           -bin=dir'
echo  '             combination of switches --lmbin and --gwbin'
echo ' '
echo '          --lmargs=string'
echo  '             Pass string as command line arguments to lmf and lmfgwd'
echo ' '
echo '          --lmbin=dir'
echo '           -lmbin=dir'
echo  '             take LDA binaries lmf, lmfgwd, and lmf2gw from directory "dir".'
echo  '             Default is directory containing this script ('"$0:h)"
echo ' '
echo '          --gwbin=dir'
echo '           -gwbin=dir'
echo  '             take GW binaries from directory "dir".'
echo  '             Default is directory containing this script ('"$0:h)"
echo ' '
echo '          --mpi=#1[,#2]'
echo  "             Use $lmfgwd and $lmf with #1 processors"
echo  '             Optional #2 is equivalent to --openmp=#2'
echo ' '
echo '          --openmp=#'
echo '          --openmp'
echo  '             Use OPENMP binaries and threaded libraries with # threads'
echo ' '
echo '          -vVAR=VAL'
echo  '             assign VAR to VAL, and pass to LDA programs lmf, lmfgwd'
echo ' '
echo '          --noexec'
echo  '             show what codes would execute without executing them'
# echo ' '
# echo '          --lmv6'
# echo  '             lmf uses lmv6 compatible source code.  lmv7 may have slight changes.'
echo ' '
echo '          --vxcsig'
echo  '             Subtract sigm-vxc + vxc (1-shot only: do 1-shot from QSGW potential)'
echo ' '
echo '          --mixsig=#'
echo  '             scale sigma-vxc by # when evaluating eigenfunctions (lmf,lmfgwd)'
echo ' '
echo '          --getsigp'
echo  '             (only used in conjunction with the --sc switch)'
echo  '             Get some parameters for GWinput file.'
echo  '             Equivalent to --getesig and --getnk and:'
echo  '             --multitet=no (if --multitet not specified)'
echo  '             --exonly=no   (if --exonly not specified)'
echo ' '
echo '          --getesig'
echo  '             Before execution, alter esigcut in file GWinput to the following:'
echo  '             Extract the contents of SIGP:emax and add 0.5 Ry.'
echo  '             NB: only used in conjunction with the --sc switch'
echo ' '
echo '          --getnk'
echo  '             Before execution, alter nk in file GWinput to the following:'
echo  '             Extract the contents of SIGP:emax and add 0.5 Ry.'
echo  '             NB: only used in conjunction with the --sc switch'
echo ' '
echo '          --multitet (--multitet=no)'
echo  '             Before execution, uncomment (comment) multitet line in file GWinput'
echo  '             NB: only used in conjunction with the --sc switch'
echo ' '
echo '          --nbando'
echo  '             After execution of lmfgwd, uncomment (comment) nband_chi0 line in file GWinput'
echo  '             if line largest reduced hilbert space can be found'
echo ' '
echo '          --exonly (--exonly=no)'
echo  '             Exchange only calculation'
echo  '             Before execution, uncomment (comment) EXonly line in file GWinput'
echo  '             NB: only used in conjunction with the --sc switch'
echo ' '
echo '          --erange'
echo  '             Generate file erange, to set bounds for dielectric fn screening'
echo ' '
echo '          --wt'
echo  '             For some programs print wall clock time'
echo ' '
echo '          --bserpa'
echo  '             Calculate RPA dielectric function at Qvec_bse (calls bethesalpeter)'
echo ' '
echo '          --bse'
echo  '             Calculate (one-shot) BSE dielectric function at Qvec_bse'
echo ' '
exit -1

error:
echo "lmgw (abort): program failed to return with zero value"
exit -1
