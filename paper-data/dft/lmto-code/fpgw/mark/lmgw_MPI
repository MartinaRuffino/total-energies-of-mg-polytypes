#!/bin/tcsh -f
# Shell script for GW calculation.
# Total energy mode also requires script extract_elda_from_log_file
# Required inputs are (with fpgw)
#  ctrl.ext rst.ext used or created by lmf
#  GWinput
# Required inputs are (with spex used with fleur)
#  inp spex.inp potcoul pottot ecore sym.out
#  Note: these files are also needed: gwa LATTC
#        If they do not exist, they are generated by invoking fleur.
#        Also these fleur-generated files affect the result: enpara
#
# Required inputs are (with spex used with lmf)
#  ctrl.ext rst.ext used or created by lmf
#  spex.inp
#
# Use with fpgw:
#  Invoke with --ht for Faleev's mode generating real weights from Hilbert transform
#  Invoke with --sc for Faleev's self-consistent mode
#  Invoke with --scrho to make density self-consistent before GW pass
#
#  Updates
#    20 Apr 09  first attempt at interface between lmf and spex
#     1 Jul 09  started work on using lmf with spex
#    12 Apr 09  new --lmv6
#     3 Jan 08  new --openmp
#     3 Mar 07  new --stop=x0  --stop=sig
#     6 Jan 06  changes for updated dielectric function calculation
#    23 Sep 05  --big removes gwa,gwb,gw1,gw2 when no longer needed
#    30 Jun 05  Added --version switch
#    29 Jun 05  Patch for Ocotillo.  To make:
#               cp lmgw lmgw.bk; ccomp '-c#' -e -dOCOTILLO lmgw.bk xx; grep -vE '^##define OCOTILLO' xx >lmgw
#    13 Feb 05  Added --sym switch
#    30 Sep 04  Added automatic change of GWinput to track --exonly
#    30 Sep 04  Added switch --exonly
#     9 May 04  Added switches --start=x0 and --start=sig
#    28 Mar 04  Added --multitet switch
#---------------------------------------------
##ifdef# OCOTILLO
#set lmgw = $HOME/bin
##else
set lmgw = $0:h
set lmgw_FE = $0:h
#set lmgw = `dirname $lmgwabs `
#set lmgw_FE = `dirname $lmgwabs `

echo $lmgw | grep / > /dev/null
if ($status == 1) set lmgw = .
##endif


echo $MPIRUN > lmgw.log
echo $MPIRUN1 >> lmgw.log

#set nfpgw = /export/home/users/tnkotan/bin
set nfpgw = $lmgw
set noexec = 0
set nocc = 0
set varlst
set retzero
set lmf = lmf
set lmfMPI = lmf
set lmf_FE = $lmgw_FE/lmf
set lmfa = lmfa
set lmfgwd = lmfgwd
set lmf2gw = lmf2gw
# empty value => no additional switches
set lmv6
set lmfgwdargs
set fleurx = $lmgw/fleur.x
set spexx = $lmgw/spex
unlimit
alias findcmd  'set retcall = \!\!:1 ; set prognam = \!\!:2 ; set prog_cmd = \!\!:3 ; set path_name = \!\!:4 ; set make_path = \!\!:5 ; goto findcmd'
alias walltime  'set retcall = \!\!:1; set time_var = \!\!:2 ; set time_start = \!\!:3; goto walltime'
alias pdtime  'set retcall = \!\!:1; set time_start = \!\!:2; goto pdtime'
set space = '        '
#set vsn
set fleur ; unset fleur
set gwcode = 1


findcmd chk00a have_dval dval "$path" "no"
chk00a:
findcmd chk00b have_bc bc "$path" "no"
chk00b:
if ($?have_bc) then
$have_bc -v > /dev/null
if ($status == 0) then
else
unset have_bc
endif
# echo XXX; unset have_bc


walltime w00x tstartlmgw 0
w00x:

# set verbose
# sleep 8
# pdtime w00xb $tstartlmgw
# w00xb:
# exit

# set verbose
# sleep 8
# pdtime w00xb $tstartlmgw
# w00xb:
# exit

while (`echo $1 | sed -e 's/\(.\).*/\1/' `  ==  "-")
  set arg1 = $1; shift

  switch ($arg1)
    case "--metal":
      set metal
      breaksw

    case "--etot":
      set etot
      breaksw

    case "--insul=*":
      set nocc=`echo $arg1 | sed s/--insul=//`
      set insul=`echo $arg1 | sed s/--insul=//`
      breaksw

    case "--getsigp":
      set getesig = 1
      set getnk = 1
      if (! $?getmtet) then
        set getmtet = 0
      endif
      if (! $?exonly) then
        set exonly = 0
      endif
      breaksw

    case "--getesig":
      set getesig = 1
      breaksw

    case "--erange":
      set erange
      breaksw

    case "--wt":
      set pwtime
      breaksw

    case "--getnk":
      set getnk = 1
      breaksw

    case "--vxcsig":
      set lmfgwdargs = ($lmfgwdargs --vxcsig)
      breaksw

    case "--code2":
      set gwcode = 2
      breaksw

    case "--spex":
    case "-spex":
      set spex = 1
      set spexx = $lmgw/lmspex
      breaksw

    case "--spexi":
    case "-spexi":
      set spex = 1
      set spexx = $lmgw/lmspex.inv
      breaksw

    case "--spexf":
    case "-spexf":
      set spex = 1
      set fleur = 1
      unset lmfgwd
      breaksw

    case "--spexfi":
    case "-spexfi":
      set spex = 1
      set fleur = 1
      set spexx = $lmgw/spex.inv
      set fleurx = $lmgw/fleur.inv.x
      unset lmfgwd
      breaksw

    case "--openmp=*":
      set openmp = `echo $arg1 | sed s/--openmp=//`
#     check to ensure argument is a valid integer
      @ openmp = $openmp
      breaksw

    case "--openmp":
      if (! $?OMP_NUM_THREADS) then
        echo "lmgw (abort): --openmp specified but environment variable OMP_NUM_THREADS not set"
        exit -1
      endif
      set openmp = $OMP_NUM_THREADS
      breaksw


    case "--multitet=no":
      set getmtet = 0
      breaksw

    case "--multitet":
      set getmtet = 1
      breaksw

    case "--nbando":
      set nbando = 1
      breaksw

    case "--noexec":
      set noexec = 1
      breaksw

    case "--extest=no":
      set extest = 0
      breaksw

    case "--extest":
      set extest = 1
      breaksw

    case "--nfp":
      set nfpjob
      breaksw

    case "--ht":
      set htransform
      breaksw

    case "--scrho":
      set scrho
      breaksw

    case "--scrho0":
      set scrho0
      set scrho
      breaksw

    case "--sc:sym":
    case "--sc":
      set sc
#  echo $arg1
      if ("$arg1" == "--sc:sym") set sym
      breaksw

    case "--big":
      set lmf = lmf-big
      set lmfgwd = lmfgwd-big
      set big
      breaksw

    case "--eps":
      set eps
      breaksw

    case "--epsNLF":
      set epsNLF
      breaksw

    case "--chix":
      set chix
      breaksw

    case "--chixNLF":
      set chixNLF
      breaksw

    case "--bin=*":
    case "-bin=*":
      set lmgw=`echo $arg1 | sed s/--bin=// | sed s/-bin=//`
      set nfpgw=$lmgw
      breaksw

    case "--lmbin=*":
    case "-lmbin=*":
      set lmgw=`echo $arg1 | sed s/--lmbin=// | sed s/-lmbin=//`
      breaksw

    case "--gwbin=*":
    case "-gwbin=*":
      set nfpgwx=`echo $arg1 | sed s/--gwbin=// | sed s/-gwbin=//`
      breaksw

    case "--mixsig=*":
    case "-mixsig=*":
      set mixsig=`echo $arg1 | sed s/--mixsig=// | sed s/-mixsig=//`
      breaksw

    case "--noclean":
      set noclean
      breaksw

    case "--band*":
      set bnds=$arg1
      breaksw

#      case "--hsfp0:*":
#        set hsfp0=`echo $arg1 | sed s/--hsfp0:// | sed s/-hsfp0://`
#        breaksw

#      case "--hsfp0":
#        set hsfp0
#        breaksw

    case "-v*=*":
      set varlst=($varlst $arg1)
      breaksw

    case "--start=setup":
      set start = setup
      breaksw

    case "--start=x0":
      set start = x0
      breaksw

    case "--start=sig":
      set start = sig
      breaksw

    case "--stop=setup":
      set lstop = setup
      breaksw

    case "--stop=x0":
      set lstop = x0
      breaksw

    case "--stop=sig":
      set lstop = sig
      breaksw

    case "--exonly=no":
      set exonly = 0
      breaksw

    case "--exonly":
      set exonly = 1
      breaksw

    case "--lmv6=no":
      set lmv6
      breaksw

    case "--lmv6":
      set lmv6='--lmv6'
      breaksw

    case "--help":
    case "--h":
      goto usage

    case "--version":
      set vsn
      breaksw

    default:
      echo unrecognized switch $arg1
      goto usage
  endsw
end


echo "switch detection done" >> lmgw.log

# Set directory for location of GW codes (nfpgw)
if ($?nfpgwx) then
  set nfpgw = $nfpgwx
else if ($gwcode == 1) then
  set nfpgw = $nfpgw/code0
else if ($gwcode == 2) then
  set lmfgwdargs = (--gwcode=2 $lmfgwdargs $lmv6)
  set nfpgw = $nfpgw/code2

endif
if ($gwcode == 1) set lmf2gw = lmf2gw_0
if ($gwcode == 2) set lmf2gw = lmf2gw_2

if ($noexec) then
 set pwtime
 unset pwtime
endif

if ($?pwtime) then
  set nonewln = -n
else
  set nonewln
endif

set lmfgwdargs = ($lmfgwdargs $lmv6)
# check for existence of executables
if ($?fleur) then
  if (! -x $fleurx || ! -x $spexx) then
    echo "lmgw (abort) one or more of the following is missing from $lmgw, or is not executable:"
    echo "  $fleurx $spexx"
    exit -1
  endif
else if ($?spex) then
  if (! -x $spexx || ! -x $lmgw/$lmfgwd) then
    echo "lmgw (abort) one or more of the following is missing from $lmgw, or is not executable:"
    echo "  $lmfgwd $spexx"
    exit -1
  endif
else
  if (! -x $lmgw/$lmf || ! -x $lmgw/$lmfgwd || ! -x $lmgw/$lmf2gw) then
    echo "lmgw (abort) one or more of the following is missing from $lmgw, or is not executable:"
    echo "  $lmf $lmfgwd $lmf2gw"
    exit -1
  endif
  if (! -d $nfpgw) then
    echo " (abort) directory for gw executables is missing: $nfpgw"
    exit -1
  endif
  pushd $nfpgw >& /dev/null
  if (! -x $nfpgw/hbasfp0 || ! -x $nfpgw/hvccfp0 || ! -x $nfpgw/hx0fp0 || ! -x $nfpgw/hsfp0 || ! -x $nfpgw/hqpe || ! -x $nfpgw/hchknw || ! -x $nfpgw/qg4gw || ! -x $nfpgw/heftet || ! -x $nfpgw/rdata4gw_v2 || ! -x $nfpgw/hx0fp0_sc || ! -x $nfpgw/hsfp0_sc || ! -x $nfpgw/hqpe_sc) then
    if ($noexec) then
    echo "lmgw (warning) one or more of the following is missing from $nfpgw, or is not executable:"
    echo "  hbasfp0 hvccfp0 hx0fp0 hsfp0 hqpe hchknw qg4gw heftet rdata4gw_v2 hx0fp0_sc hsfp0_sc hqpe_sc"
    else
    echo "lmgw (abort) one or more of the following is missing from $nfpgw, or is not executable:"
    echo "  hbasfp0 hvccfp0 hx0fp0 hsfp0 hqpe hchknw qg4gw heftet rdata4gw_v2 hx0fp0_sc hsfp0_sc hqpe_sc"
    exit -1
    endif
  endif
  popd >& /dev/null
endif

# --- Handle --version switch ---
# set fpgwversion = 032e
# set fpgwversion = 032f3
# set fpgwversion = 032f7nb
set fpgwversion = `echo -9999| $nfpgw/hx0fp0 |& grep VerNum= | awk '{print $3}'`
set fleurversion = v25c_3
set spexversion = 02.05

echo "start version detection" >> lmgw.log

$lmf_FE --version > tmp_version

echo "Version "`cat  tmp_version` >> lmgw.log

if ($?vsn && $?spex && $?fleur) then
  echo "spex $spexversion"
  echo "fleur $fleurversion"
  exit
else if ($?vsn && $?spex) then
  echo "spex $spexversion"
  echo "lmf  `cat tmp_version`"
  exit
else if ($?vsn && $gwcode == 2) then
  echo "fpgw sep12"
  echo "lmf  `cat tmp_version`"
  exit
else if ($?vsn) then
  echo "fpgw $fpgwversion"
  echo "lmf  `cat tmp_version`"
  exit
endif


if ($?sc && $?eps) then
  echo "    lmgw: oops! incompatible switches --sc and --eps ... aborting "
  exit -1
endif
if ($?bnds && ($?eps || $?epsNLF)) then
  echo "    lmgw: oops! incompatible switches --band and --eps ... aborting "
  exit -1
endif
if ($?sc && $?etot) then
  echo "    lmgw: oops! incompatible switches --sc and --etot ... aborting "
  exit -1
endif
if ($?eps && $?etot) then
  echo "    lmgw: oops! incompatible switches --eps and --etot ... aborting "
  exit -1
endif
if ($?sc && $?epsNLF) then
  echo "    lmgw: oops! incompatible switches --sc and --epsNLF ... aborting "
  exit -1
endif
if ($?eps && $?epsNLF) then
  echo "    lmgw: oops! choose only one of --eps and --epsNLF ... aborting "
  exit -1
endif

if ($?eps || $?epsNLF) then
  grep QforEPS GWinput >/dev/null
  if ($status) then
     echo "    lmgw: oops! $lmgw/$lmf returned with nonzero exit status."
     echo "          missing QforEPS in file GWinput ... aborting "
     exit -1
  endif

#   grep EPSrange GWinput >/dev/null
#   if ($status) then
#      echo "    lmgw: oops! $lmgw/$lmf returned with nonzero exit status."
#      echo "          missing EPSrange in file GWinput ... aborting "
#      exit -1
#   endif
#   grep EPSdw GWinput >/dev/null
#   if ($status) then
#      echo "    lmgw: oops! $lmgw/$lmf returned with nonzero exit status."
#      echo "          missing EPSdw in file GWinput ... aborting "
#      exit -1
#   endif
endif

# turn on noexec until appropriate start
if ($noexec == 1 && $?start) then
  unset start
endif

if ($?start) then
  set noexec = 1
endif

if ($#argv != 1) goto usage
setenv LMJOB $argv[1]

# --- Some checks on input files ---
if ($?fleur) then
  if (! -e inp) then
    echo "    lmgw (abort) ... missing fleur input file inp"
    exit -1
  endif
  if (! -e sym.out) then
    echo "    lmgw (abort) ... missing fleur input file sym.out"
    exit -1
  endif
  if (! -e pottot) then
    echo "    lmgw (abort) ... missing fleur input file pottot"
    exit -1
  endif
  if (! -e potcoul) then
    echo "    lmgw (abort) ... missing fleur input file potcoul"
    exit -1
  endif
  if (! -e enpara) then
    echo "    lmgw (warning) ... missing fleur file enpara"
    exit -1
  endif
  if (! -e ecore) then
    echo "    lmgw (abort) ... missing fleur input file ecore"
    exit -1
  endif
else if (! -e ctrl.$argv[1]) then
  echo "    lmgw (abort) ... missing file ctrl.$argv[1]"
  exit -1
endif
if ($?spex) then
  if (! -e spex.inp) then
    echo "    lmgw (abort) ... missing spex input file spex.inp"
    exit -1
  endif
else if (! -e GWinput) then
  echo '    lmgw (abort) ... missing GWinput'
  exit -1
endif

if ($?mixsig) then
  set mixsig = --mixsig=$mixsig
else
  set mixsig
endif
set gwargs = ($mixsig $varlst $LMJOB)
if (-e switches-for-lm) then
  set gwargs = "$mixsig $varlst `head -1 switches-for-lm` $LMJOB"
endif
set gwargs_lmfgwd = "$gwargs"
if ($?erange) set gwargs_lmfgwd = "$gwargs --wrange"

# --- Extract appropriate energy cutoff for hsfp0 (alters GWinput) ---
echo " --- Extract appropriate energy cutoff for hsfp0 (alters GWinput) --- " >> lmgw.log

if ($?getesig && $?scrho && ! $?spex) then
  echo -n "    lmgw : extracting SIGP_EMAX ... "
# v6
# echo "$lmgw/$lmf --show --quit=show --no-iactive $gwargs | grep SIGP: | tail -1 | awk ..."
  echo "$lmgw/$lmf --show --quit=show --no-iactive $gwargs | grep SIGP_EMAX | tail -1 | awk ..."
  echo "$lmgw/$lmf --show --quit=show --no-iactive $gwargs | grep SIGP_EMAX | tail -1 | awk ..." >> lmgw.log

  echo "noexec = $noexec"
  if ($noexec == 0) then
     echo "inside if noexec"
# v6
#   $lmgw/$lmf --show --quit=show --no-iactive $gwargs | grep SIGP: | tail -1 | awk '{match($0,"emax=\([^ ]\)*"); print substr($0,RSTART+5,RLENGTH-5)}' >/dev/null
    $lmgw_FE/$lmf --show --quit=show --no-iactive $gwargs | grep SIGP_EMAX | awk '{print $8}' >/dev/null
    if ($status) then
      echo "    lmgw: oops! $lmgw_FE/$lmf returned with nonzero exit status ... aborting "
      exit -1
    endif
# v6
#   set emax = `$lmgw/$lmf --show --quit=show --no-iactive $gwargs | grep SIGP: | tail -1 | awk '{match($0,"emax=\([^ ]\)*"); print substr($0,RSTART+5,RLENGTH-5)}'`
    $lmgw_FE/$lmf  --show --quit=show --no-iactive $gwargs | grep SIGP_EMAX | awk '{print $8}' > emax_tmp
#    set emax = `$lmgw/$lmf --show --quit=show --no-iactive $gwargs | grep SIGP_EMAX | awk '{print $8}' `
    set emax = `cat emax_tmp`
    set emaxs = `awk -vemax=$emax 'BEGIN {print emax+.5}'`
    echo found emax = $emax ... use emaxs = $emaxs
    if (-e GWinput) then
      echo "           copying file GWinput to GWinput~"
      cp GWinput GWinput~
      set src = GWinput~
      set dest = GWinput
      echo "           writing file $dest created from $src, changing ESIGCUT line to $emaxs"
      awk -v "emaxs=$emaxs" '{if ($1 == "emax_sigm") {print "emax_sigm", emaxs,"  ! Energy cutoff for Sigma, Ry (Optional)"} else {print}}' $src >$dest
    endif
  else
     echo "nothing extracted (noexec)"
  endif
endif

# --- Turn on or off multitet (alters GWinput) ---
if ($?getmtet && ! $?spex) then
  if ($getmtet == 0) then
     echo -n "    lmgw : removing multitet ... "
     cat GWinput | sed 's/^ *multitet/! multitet/' >GWinput~
  else
     echo -n "    lmgw : adding multitet ... "
     cat GWinput | sed 's/^! *multitet/multitet/' >GWinput~
  endif

  cmp GWinput GWinput~ >/dev/null
  if ($status == 0) then
    echo "nothing to change"
  else if ($noexec) then
    echo "nothing altered (noexec)"
  else
    echo file changed.
#      diff GWinput GWinput~
    mv GWinput~ GWinput
  endif
endif

# --- Turn on or off EXonly (alters GWinput) ---
if ($?exonly && ! $?spex) then
  if ($exonly == 0) then
     echo -n "    lmgw : removing EXonly ... "
     cat GWinput | sed 's/^ *EXonly/! EXonly/' >GWinput~
  else
     echo -n "    lmgw : adding EXonly ... "
     cat GWinput | sed 's/^! *EXonly/EXonly/' >GWinput~
  endif

  cmp GWinput GWinput~ >/dev/null
  if ($status == 0) then
    echo "nothing to change"
  else if ($noexec) then
    echo "nothing altered (noexec)"
  else
    echo file changed.
#      diff GWinput GWinput~
    mv GWinput~ GWinput
  endif
else
  set exonly = 0
endif

# --- Sanity check for Ex-only mode ---
if (! $?spex) then
if ($exonly == 1) then
  egrep -E "^EXonly" GWinput >/dev/null
  if ($status) then
     echo "    lmgw: oops! missing EXonly in file GWinput ... aborting "
     echo "          "
     exit -1
  endif
  echo "    lmgw: exchange-only mode : EXonly = "`egrep -E ^EXonly GWinput | sed s/EXonly//`
else
  egrep -E "^EXonly" GWinput >/dev/null
  if ($status == 0) then
     echo "    lmgw: oops! EXonly in GWinput should not be present ... aborting "
     echo "          "
     exit -1
  endif
endif
endif

# --- Extract number of k divisions (alters GWinput) ---
if ($?getnk && ! $?spex && ($?sc || $?eps || $?epsNLF)) then
  echo "    lmgw : extracting GW_NKABC= ... from ctrl file"
#v6
# echo 'set nkabc = (`'"$lmgw/$lmfgwd $lmfgwdargs --show --quit=show --no-iactive $gwargs | grep NKABC | tail -1 | sed s/NKABC=//"'`)'
  echo "$space   set nkabc = " '(`'"$lmgw_FE/$lmfgwd $lmfgwdargs --show --quit=show --no-iactive $gwargs | grep GW_NKABC | tail -1 ... "'`)'
  if ($noexec == 0) then
    $lmgw_FE/$lmfgwd $lmfgwdargs --show --quit=show --no-iactive $gwargs >/dev/null
    if ($status) then
      echo "    lmgw: oops! $lmgw/$lmf returned with nonzero exit status ... aborting "
      exit -1
    endif
#v6
#   set nkabc = (`$lmgw/$lmfgwd $lmfgwdargs --show --quit=show --no-iactive $gwargs | grep NKABC | tail -1 | sed s/NKABC=//`)
#    set nkabc = (`$lmgw/$lmfgwd $lmfgwdargs --show --quit=show --no-iactive $gwargs | grep GW_NKABC | tail -1 | awk '{print $(NF-2), $(NF-1), $(NF)}' `)
    $lmgw_FE/$lmfgwd $lmfgwdargs --show --quit=show --no-iactive $gwargs | grep GW_NKABC | tail -1 | awk '{print $(NF-2), $(NF-1), $(NF)}' > nkabc_tmp

    set nkabc = `cat nkabc_tmp`
    rm nkabc_tmp
    echo "$space   extracted raw GW_NKABC as :   $nkabc"
    if ($nkabc[3] == '--') then
      echo "$space lmgw: GW_NKABC apparently missing from ctrl file"
      echo "$space       Restart with GW_NKABC in ctrl file, or do not use --getsigp or --getnk"
      echo "$space lmgw aborting ..."
      exit -1
    else if ($nkabc[2] == '--') then
      set nkabc = ($nkabc[3] $nkabc[3] $nkabc[3])
    else if ($nkabc[1] == '--') then
      set nkabc = ($nkabc[2] $nkabc[3] $nkabc[3])
    endif
    echo "$space   using for nkabc: $nkabc"


    if (-e GWinput) then
      echo "           copying file GWinput to GWinput~"
      cp GWinput GWinput~
      set src = GWinput~
      set dest = GWinput
      echo "           writing file $dest created from $src, changing n1n2n3 line to `echo $nkabc | sed 's/ /  /g'`"
      awk -v "nkabc= `echo $nkabc | sed 's/ /  /g'`"  '{if ($1 == "n1n2n3") {printf "n1n2n3 %s ! for GW BZ mesh\n", nkabc} else {print}}' $src >$dest
    endif
  else
     echo "nothing extracted (noexec)"
  endif
endif

echo "start --- Self-consistency in the density --- " >> lmgw.log

# --- Self-consistency in the density ---

if ($?scrho) then
  echo "           rm -f mixm.$argv[1]"
                   rm -f mixm.$argv[1]
  if (! -e rst.$argv[1]) echo "    lmgw:  missing file rst.$argv[1] ... start from free-atom densities"
  if (! -e rst.$argv[1]) set scrho0
  if (  -z rst.$argv[1]) echo "    lmgw:  file rst.$argv[1] has zero size ... start from free-atom densities"
  if (  -z rst.$argv[1]) set scrho0
  if ($?scrho0) then
    echo "           rm -f rst.$argv[1]"
    echo "    lmgw : invoking         $lmgw/$lmfa --no-iactive $gwargs >llmf"
    if ($noexec == 0) then
      rm -f rst.$argv[1]
      $lmgw_FE/$lmfa --no-iactive $gwargs >llmf
      if ($status) then
        echo "    lmgw: oops! $lmgw_FE/$lmfa returned with nonzero exit status ... aborting "
        exit -1
      endif
    endif
    unset scrho0
  endif

  echo "LMFA done." >> lmgw.log

  echo "    lmgw " `date | awk '{print $4}'`" : invoking         $lmgw/$lmf --no-iactive $gwargs >llmf"
  if ($noexec == 0) then
    $lmgw_FE/$lmf --showp --no-iactive $gwargs >ctrl.preprocessed.$argv[1]
    echo "$lmgw_FE/$lmf --showp --no-iactive $gwargs >ctrl.preprocessed.$argv[1] done" >> lmgw.log
    $MPIRUN1 $lmgw/$lmfMPI --no-iactive $gwargs >llmf
    echo "$MPIRUN1 $lmgw/$lmfMPI --no-iactive $gwargs >llmf done" >> lmgw.log
    if ($status) then
      echo "    lmgw: oops! $lmgw/$lmf returned with nonzero exit status ... aborting "
      exit -1
    endif
  endif
endif

echo "after self-consistent in density" >> lmgw.log

# --- OPENMP setup ---
set hx0fp0    = hx0fp0
set hx0fp0_sc = hx0fp0_sc
set hsfp0     = hsfp0
set hsfp0_sc  = hsfp0_sc
if ($?openmp) then
  echo "$space setenv OMP_NUM_THREADS $openmp"
  setenv OMP_NUM_THREADS $openmp
  set hx0fp0    = hx0fp0_om
  set hsfp0     = hsfp0_om
  set hx0fp0_sc = hx0fp0_sc_om
  set hsfp0_sc  = hsfp0_sc_om
endif

# --- GW setup fleur/spex mode ---
if ($?fleur && $?spex) then

# Modify inp file if it does not contain gw=2
  set restoreinp; unset restoreinp
  echo -n "    lmgw : modify inp file to read gw=2 ... "
  grep pot8=T,gw=2 inp > /dev/null
  set retval = $status
  if ($retval == 0) then
    echo "nothing to change"
  else if ($noexec) then
    echo "nothing altered (noexec)"
  else
    cat inp | sed 's/pot8=[fF]/pot8=T/' | sed 's/gw=[01]/gw=2/' >inp.tmp
    diff -I pot8=.,gw=. inp inp.tmp > /dev/null
    set retval = $status
    if ($retval != 0) then
      echo replacement failed '!'.  Compare inp, inp.tmp; goto error
    endif
    cp inp.tmp inp
    set restoreinp
    echo "file changed (original in inp.tmp)"
  endif

# Use fleur to generate missing input files, if needed
  echo -n "    lmgw : checking for files gwa, LATTC, fl7para ..."
  if (! -e gwa || ! -e LATTC || ! -e fl7para) then
    echo ""
    echo "    lmgw : generating gwa, LATTC, fl7para using $fleurx"
    echo "    lmgw : rm -f fl7para vxc abcoeff eig stars"
    if ($noexec == 0) then
      rm -f fl7para vxc abcoeff eig stars
    endif
    echo "    lmgw  " `date | awk '{print $4}'`" : invoking $fleurx >& lfleur"
    if ($noexec == 0) then
      if (-e cdn1) mv cdn1 cdn1.tmp
      $fleurx >& lfleur
      if (-e cdn1.tmp) mv cdn1.tmp cdn1
    endif
  else
    echo " files found."
  endif

# Set k-points file
  echo "    lmgw : setting k-points file from spex.inp ..."
  echo "           cp -p spex.inp spex.inp.tmp"
  echo "           echo WRTKPT > spex.inp"
  echo "           grep -v WRTKPT spex.inp.tmp >> spex.inp"
  echo "           rm -f kpts.new"
  echo "           $spexx > lksetup"
  echo "           cp kpts.new kpts"
  echo "           cp -p spex.inp.tmp spex.inp"
  if ($noexec == 0) then
     cp -p spex.inp spex.inp.tmp
     echo WRTKPT > spex.inp
     grep -v WRTKPT spex.inp.tmp >> spex.inp
     rm -f kpts.new
     $spexx >& lksetup
     if (! -e kpts.new) then
        echo "    lmgw: oops! $spexx failed to generate kpts.new ... aborting "
        exit -1
     endif
     cp kpts.new kpts
     cp -p spex.inp.tmp spex.inp
  endif

  echo "    lmgw : rm -f fl7para vxc abcoeff eig"
  echo "    lmgw  " `date | awk '{print $4}'`" : invoking $fleurx >& lfleur"
  if ($noexec == 0) then
    rm -f fl7para vxc abcoeff eig
    $fleurx >& lfleur
    if (! -e eig) then
      echo "    lmgw : fleur failed to write eig file ... aborting"
      exit -1
    endif
  endif

# --- GW setup lmf/spex mode ---
echo "Start  --- GW setup lmf/spex mode ---" >> lmgw.log

else if ($?lmfgwd && $?spex) then

  if ($noexec == 0) rm -f NoCore QPU QPD
  echo "    lmgw  " `date | awk '{print $4}'`" : invoking echo 0 |$lmgw/$lmfgwd $lmfgwdargs --no-iactive $gwargs >llmfgw00"
  if ($noexec == 0) then
    $lmgw_FE/$lmfgwd $lmfgwdargs --showp --no-iactive $gwargs >ctrl.preprocessed.$argv[1]
    echo 0 |$lmgw_FE/$lmfgwd $lmfgwdargs --no-iactive $gwargs >llmfgw00
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
  endif

# use spex to set k-points file
  echo "    lmgw : setting k-points file from spex.inp ..."
  echo "           cp -p spex.inp spex.inp.tmp"
  echo "           echo WRTKPT > spex.inp"
  echo "           rm -f kpts.new"
  echo "           cat spex.inp.tmp >> spex.inp"
  echo "           $spexx >& lksetup"
  echo "           cp spex.inp.tmp spex.inp"
  echo "           cp kpts.new kpts"
  if ($noexec == 0) then
     cp -p spex.inp spex.inp.tmp
     echo WRTKPT > spex.inp
     rm -f kpts.new
     cat spex.inp.tmp >> spex.inp
     $spexx >& lksetup
     cp -p spex.inp.tmp spex.inp
     if (! -e kpts.new) then
        echo "    lmgw: oops! $spexx failed to generate kpts.new ... aborting "
        exit -1
     endif
     cp kpts.new kpts
  endif

# lmto eigenvalues and eigenfunctions for spex
  echo $nonewln "    lmgw  " `date | awk '{print $4}'`" : invoking echo 1 |$lmgw/$lmfgwd $lmfgwdargs --no-iactive $gwargs >llmfgw01"
  if ($noexec == 0) then
    walltime w111 tstart 0
    w111:
    echo 1 |$lmgw_FE/$lmfgwd $lmfgwdargs --no-iactive $gwargs >llmfgw01
    set retval = $status
    if ($?pwtime) then
      pdtime w111b $tstart
      w111b:
    endif
    if ($retval != 0 && $?retzero) goto error
#   adjust NBAND in spex.inp
    grep NBAND spex.inp > /dev/null
    if ($status == 0) then
      set nband_spex = `grep NBAND spex.inp  | awk '{print $2}'`
      set nband = `grep 'minimum reduced'  llmfgw01 | awk '{print $7}'`
      if ($nband_spex > $nband) then
        echo -n "    lmgw : reduce NBAND in spex.inp to $nband ... "
        cat spex.inp.tmp | sed "s/NBAND *[0-9][0-9]*/NBAND $nband/" > spex.inp
        echo -n "spex.inp now modified to read : "
        grep NBAND spex.inp
      endif
    endif
  endif

# --- GW setup lmf/fpgw mode ---
else

if ($noexec == 0) rm -f NoCore QPU QPD erange erange.fe
echo "    lmgw " `date | awk '{print $4}'`" : invoking echo 0 |$lmgw/$lmfgwd $lmfgwdargs --no-iactive $gwargs >llmfgw00"
if ($noexec == 0) then
  $lmgw_FE/$lmfgwd $lmfgwdargs --showp --no-iactive $gwargs >ctrl.preprocessed.$argv[1]
  echo 0 |$lmgw_FE/$lmfgwd $lmfgwdargs --no-iactive $gwargs >llmfgw00
endif

# ... this branch runs qg4gw to make Q0P
echo " ... this branch runs qg4gw to make Q0P" >> lmgw.log

if ($?eps || $?epsNLF) then
  echo "    lmgw " `date | awk '{print $4}'`" : setup Q0P for epsilon"
  echo "    lmgw " `date | awk '{print $4}'`" : invoking echo 2|$nfpgw/qg4gw >lqg4gw02"
  if ($noexec == 0) then
    echo 2 > tmp_job
    $MPIRUN1 $nfpgw/qg4gw <tmp_job >lqg4gw02
    set retval = $status
    rm tmp_job
    if ($retval != 0 && $?retzero) goto error
  endif

else if ($?chix || $?chixNLF) then
  echo "    lmgw " `date | awk '{print $4}'`" : invoking echo 2 |$nfpgw/qg4gw >lqg4gw02"
  if ($noexec == 0) then
    echo 2 > tmp_job
    $MPIRUN1  $nfpgw/qg4gw <tmp_job  >lqg4gw02
    set retval = $status
    rm tmp_job
    if ($retval != 0 && $?retzero) goto error
  endif

else if ($?bnds && ! $?sc) then

  echo "    lmgw " `date | awk '{print $4}'`" : setup Q0P for band mode 1-shot GW"
  echo "    lmgw " `date | awk '{print $4}'`" : invoking  echo 3 |  $nfpgw/qg4gw <tmp_job >lqg4gw"
  if ($noexec == 0) then
    echo 3 > tmp_job
    $MPIRUN1 $nfpgw/qg4gw <tmp_job >lqg4gw
    set retval = $status
    rm tmp_job
    if ($retval != 0 && $?retzero) goto error
  endif

else

# qg4gw mode 1: makes Q0P
echo " qg4gw mode 1: makes Q0P " >> lmgw.log

  echo "    lmgw " `date | awk '{print $4}'`" : invoking echo 1 | $nfpgw/qg4gw >lqg4gw"
  if ($noexec == 0) then
    echo 1 > tmp_job
    $MPIRUN1 $nfpgw/qg4gw <tmp_job >lqg4gw
    set retval = $status
    rm tmp_job
    if ($retval != 0 && $?retzero) goto error
  endif

endif

# --- eigenvalues for micro-tetrahedron method ---
echo " --- eigenvalues for micro-tetrahedron method --- ">>lmgw.log

grep -E ^multitet GWinput >& /dev/null
set retval = $status
if (-e Qmtet || ($noexec && $retval == 0)) then
  echo "    mv Qmtet Qeigval"
  echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 5 |$lmgw/$lmfgwd $lmfgwdargs --no-iactive $gwargs_lmfgwd >llmfgw_eigval"
  if ($noexec == 0) then
    mv Qmtet Qeigval
    walltime w121 tstart 0
    w121:
    echo 5 |$lmgw_FE/$lmfgwd $lmfgwdargs --no-iactive $gwargs_lmfgwd >llmfgw_eigval
    set retval = $status
    if ($?pwtime) then
      pdtime w121b $tstart
      w121b:
    endif
  endif
  echo "    mv eigval eigmtet"
  if ($noexec == 0) then
    mv eigval eigmtet
  endif
  set gwargs_lmfgwd = "$gwargs"
endif

# ... this branch runs lmfgwd for evals, evecs
if ($?bnds && ! $?sc) then
  echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking   echo 4 | $lmgw/$lmfgwd $lmfgwdargs --no-iactive $gwargs >llmfgw04"
  if ($noexec == 0) then
    walltime w122 tstart 0
    w122:
    echo 4 | $lmgw_FE/$lmfgwd $lmfgwdargs --no-iactive $gwargs >llmfgw04
    set retval = $status
    if ($?pwtime) then
      pdtime w122b $tstart
      w122b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif

  echo "    lmgw " `date | awk '{print $4}'`" : creating bands from LBAND.UP, LBAND.DN"
  foreach ext (UP DN)
  if(-e LBAND.$ext) then
    echo "    lmgw " `date | awk '{print $4}'`" : cp LBAND.$ext LBAND"
    echo "    lmgw " `date | awk '{print $4}'`" : cp TOTE2.$ext TOTE2"
    echo "    lmgw " `date | awk '{print $4}'`" : invoking   $nfpgw/hbndout  >lbndout.$ext"
    echo "    lmgw " `date | awk '{print $4}'`" : invoking   $nfpgw/bandplot"
    echo "    lmgw " `date | awk '{print $4}'`" : copy files BandLDA BandQP1 BandQP2 BandGWpoint BandQpoint to .$ext"
    if ($noexec == 0) then
      cp LBAND.$ext LBAND
      if(-e TOTE2.$ext) cp TOTE2.$ext TOTE2
      $nfpgw/hbndout  >lbndout.$ext
      $nfpgw/bandplot
      foreach fin (BandLDA BandQP1 BandQP2 BandGWpoint BandQpoint)
        if(-e $fin ) mv $fin $fin.$ext
      end
      foreach fout (BandLDA BandQP1 BandQP2)
        if(-e $fout.ps) mv $fout.ps $fout.$ext.ps
      end
    endif
  endif
  end
  if(-e LBAND) rm LBAND
  if(-e TOTE2) rm TOTE2
  exit

else
  echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 1 |$lmgw/$lmfgwd $lmfgwdargs --no-iactive $gwargs_lmfgwd >llmfgw01"
  if ($noexec == 0) then
    walltime w131 tstart 0
    w131:
    echo 1 |$lmgw_FE/$lmfgwd $lmfgwdargs --no-iactive $gwargs_lmfgwd >llmfgw01
    set retval = $status
    if ($?pwtime) then
      pdtime w131b $tstart
      w131b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
  if (-e erange.$LMJOB) cp erange.$LMJOB erange

# --- Set nband_chi0 (alters GWinput) ---
echo " --- Set nband_chi0 (alters GWinput) --- " >> lmgw.log

  if ($?nbando && ! $?spex) then

    grep 'sugw: largest reduced hilbert space' llmfgw01 >/dev/null
    if ($status == 0) then
      echo -n "    lmgw : llmfgw01 returned nband_chi0 = "
      set nb = `grep 'sugw: largest reduced hilbert space' llmfgw01 | awk '{print $7'} | sed 's/\.//'`
      @ testn = $nb
      if ($status == 1) then
        echo "    lmgw: oops! llmfgw01 has funny nband_chi0 ... aborting"
        exit -1
      endif
      echo -n $nb "... "
#     cat GWinput | sed "s/^! *nband_chi0 *[0-9]*/nband_chi0 $nb/" >GWinput~
      cat GWinput | sed "s/^nband_chi0 *[0-9]*/nband_chi0 $nb/" | sed "s/^! *nband_chi0 *[0-9]*/nband_chi0 $nb/"  >GWinput~
      cmp GWinput GWinput~ >/dev/null
      if ($status == 0) then
        echo "nothing to change"
      else if ($noexec) then
        echo "nothing altered (noexec)"
      else
        echo file changed.
        mv GWinput~ GWinput
      endif
    endif
  endif

endif  # end of lmfgwd

echo "end of lmfgwd" >> lmgw.log

if ($?sc) then
  echo "           rm -f v_xc evec"
                   rm -f v_xc evec
  echo "           ln -s vxc.$argv[1] v_xc"
                   ln -s vxc.$argv[1] v_xc
  echo "           ln -s evec.$argv[1] evec"
                   ln -s evec.$argv[1] evec
  echo "           ln -s evec.$argv[1] evec0"
                   ln -s evec.$argv[1] evec0
endif

if ($noexec == 0) then
  @ exinfo = `tail llmfgw01 | grep Exit | head -1 | awk '{print $2}'`
  if($exinfo == 0 ) then
    echo " OK! lmfgwd mode=1 "
  else
    echo `tail -3 llmfgw01 `
  endif
endif

echo "    lmgw " `date | awk '{print $4}'`" : invoking echo $LMJOB|$lmgw/$lmf2gw >llmf2gw"
if ($noexec == 0) then
  $MPIRUN1 echo $LMJOB | $lmgw_FE/$lmf2gw >llmf2gw
  set retval = $status
  if ($retval != 0 && $?retzero) goto error
endif

if ($?big) then
echo "    lmgw " `date | awk '{print $4}'`" : removing files {gwa,gwb,gw1,gw2}.$LMJOB"
if ($noexec == 0) then
  rm {gwa,gwb,gw1,gw2}.$LMJOB
endif
endif

if ($?lstop) then
  if ($lstop == "setup") then
    echo "    lmgw " `date | awk '{print $4}'`" : stopping execution after setup ..."
    exit
    set noexec = 1
    unset lstop
  endif
endif

if ($?start) then
  if ($start == "setup") then
    echo "    lmgw " `date | awk '{print $4}'`" : starting execution after setup ..."
    set noexec = 0
    unset start
  endif
endif

if ($?chix || $?chixNLF) then
  echo "    lmgw " `date | awk '{print $4}'`" : invoking echo 1 |$nfpgw/rdata4gw_v2 >lrdata4gw"
  if ($noexec == 0) then
    echo 1 > tmp_job
    $MPIRUN1  $nfpgw/rdata4gw_v2   <tmp_job   >lrdata4gw
    set retval = $status
    rm tmp_job
    if ($retval != 0 && $?retzero) goto error
  endif
else
  echo "    lmgw " `date | awk '{print $4}'`" : invoking echo 0 |$nfpgw/rdata4gw_v2 >lrdata4gw"
  if ($noexec == 0) then
    echo 0 > tmp_job
    $MPIRUN1 $nfpgw/rdata4gw_v2  <tmp_job    >lrdata4gw
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
  endif
endif

if ($?big) then
echo "    lmgw " `date | awk '{print $4}'`" : removing file CphiGeig"
if ($noexec == 0) then
  rm CphiGeig
endif
endif

#--- get EFERMI ---
echo "    lmgw " `date | awk '{print $4}'`" : invoking echo 1|$nfpgw/heftet   >leftet"
if ($noexec == 0) then
  echo 1 > tmp_job
  $MPIRUN1 $nfpgw/heftet <tmp_job   >leftet
  set retval = $status
  rm tmp_job
  if ($retval != 0 && $?retzero) goto error
endif

endif  # end of setup mode

# ------------- Dielectric function calculation, fpgw ----------------
if ($?eps && $?spex) then

  echo epsilon not ready for spex mode
  exit

# ------------- Dielectric function calculation, fpgw ----------------
else if ($?eps && ! $?spex) then
  echo    "    lmgw " `date | awk '{print $4}'`" : invoking echo 0|$nfpgw/hbasfp0 >lbas"
  if ($noexec == 0) then
    echo 0 > tmp_job
    $MPIRUN1 $nfpgw/hbasfp0 <tmp_job >lbas
    set retval = $status
    rm tmp_job
    if ($retval != 0 && $?retzero) goto error
  endif
# ... Coulomb matrix
  echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 202|$nfpgw/hvccfp0 >lvcc"
  if ($noexec == 0) then
    walltime w311 tstart 0
    w311:
    echo 202 > tmp_job
    $MPIRUN1 $nfpgw/hvccfp0 <tmp_job >lvcc
    set retval = $status
    rm tmp_job
    if ($?pwtime) then
      pdtime w311b $tstart
      w311b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
# ... Dielectric function, including local fields
  if ($?htransform) then
    echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 203|$nfpgw/$hx0fp0 >lx0"
    if ($noexec == 0) then
      walltime w312 tstart 0
      w312:
      rm -f WVI WVR
      echo 203 > tmp_job
      $MPIRUN1 $nfpgw/$hx0fp0 <tmp_job >lx0
      set retval = $status
      if ($?pwtime) then
        pdtime w312b $tstart
        w312b:
      endif
      if ($retval != 0 && $?retzero) goto error
    endif
  else
    echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 3|$nfpgw/$hx0fp0 >lx0"
    if ($noexec == 0) then
      walltime w314 tstart 0
      w314:
      rm -f WVI WVR
      echo 3 > tmp_job
      $MPIRUN1 $nfpgw/$hx0fp0 <tmp_job >lx0
      set retval = $status
      rm tmp_job
      if ($?pwtime) then
        pdtime w314b $tstart
        w314b:
      endif
      if ($retval != 0 && $?retzero) goto error
    endif
  endif

# finished
  exit
endif

if ($?epsNLF) then
  echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 4|$nfpgw/hbasfp0 >lbas"
  if ($noexec == 0) then
    walltime w315 tstart 0
    w315:
    echo 4 > tmp_job
    $MPIRUN1 $nfpgw/hbasfp0 <tmp_job >lbas
    set retval = $status
    rm tmp_job
    if ($?pwtime) then
      pdtime w315b $tstart
      w315b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
# ... Coulomb matrix
  echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 202|$nfpgw/hvccfp0 >lvcc"
  if ($noexec == 0) then
    walltime w316 tstart 0
    w316:
    echo 202 > tmp_job
    $MPIRUN1 $nfpgw/hvccfp0 <tmp_job >lvcc
    set retval = $status
    rm tmp_job
    if ($?pwtime) then
      pdtime w316b $tstart
      w316b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
# ... Dielectric function, no local fields
  if ($?htransform) then
    echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 202|$nfpgw/$hx0fp0 >lx0"
    if ($noexec == 0) then
      walltime w317 tstart 0
      w317:
      rm -f WVI WVR
      echo 202 > tmp_job
      $MPIRUN1 $nfpgw/$hx0fp0 <tmp_job >lx0
      set retval = $status
      rm tmp_job
      if ($?pwtime) then
        pdtime w317b $tstart
        w317b:
      endif
      if ($retval != 0 && $?retzero) goto error
    endif
  else
    echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 2|$nfpgw/$hx0fp0 >lx0"
    if ($noexec == 0) then
      walltime w318 tstart 0
      w318:
      rm -f WVI WVR
      echo 2 > tmp_job
      $MPIRUN1 $nfpgw/$hx0fp0 <tmp_job >lx0
      set retval = $status
      rm tmp_job
      if ($?pwtime) then
        pdtime w318b $tstart
        w318b:
      endif
      if ($retval != 0 && $?retzero) goto error
    endif
  endif

# finished
  exit
endif

# ------------- Transverse spin susceptibility calculation, spex ----------------
if ($?chix && $?spex || $?chixNLF && $?spex) then

  echo transverse chi not ready for spex mode
  exit

# ------------- Transverse spin susceptibility calculation, fpgw ----------------
else                # chix fpgw mode
if ($?chix || $?chixNLF) then
  echo "    lmgw " `date | awk '{print $4}'`" : invoking echo 8|$nfpgw/hbasfp0 >lbas"
  if ($noexec == 0) then
    echo 8 |$nfpgw/hbasfp0 >lbas
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
  endif
# ... Coulomb matrix
  echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 202|$nfpgw/hvccfp0 >lvcc"
  if ($noexec == 0) then
    walltime w321 tstart 0
    w321:
    echo 202 > tmp_job
    $MPIRUN1 $nfpgw/hvccfp0 <tmp_job >lvcc
    set retval = $status
    rm tmp_job
    if ($?pwtime) then
      pdtime w321b $tstart
      w321b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
# finished
#  exit
endif

if ($?chix) then
# ... Dielectric function, no local fields
  if ($?htransform) then
    echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 223|$nfpgw/$hx0fp0 >lx0"
    if ($noexec == 0) then
      walltime w331 tstart 0
      w331:
      rm -f WVI WVR
      echo 223 > tmp_job
      $MPIRUN1 $nfpgw/$hx0fp0 <tmp_job >lx0
      set retval = $status
      rm tmp_job
      if ($?pwtime) then
        pdtime w331b $tstart
        w331b:
      endif
      if ($retval != 0 && $?retzero) goto error
    endif
  else
    echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 223|$nfpgw/$hx0fp0 >lx0"
    if ($noexec == 0) then
      walltime w332 tstart 0
      w332:
      rm -f WVI WVR
      echo 223 >tmp_job
      $MPIRUN1 $nfpgw/$hx0fp0 <tmp_job >lx0
      set retval = $status
      rm tmp_job
      if ($?pwtime) then
        pdtime w332b $tstart
        w332b:
      endif
      if ($retval != 0 && $?retzero) goto error
    endif
  endif
# finished
  exit
endif

if ($?chixNLF) then
# ... Dielectric function, no local fields
  if ($?htransform) then
    echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 222|$nfpgw/$hx0fp0 >lx0"
    if ($noexec == 0) then
      walltime w341 tstart 0
      w341:
      rm -f WVI WVR
      echo 222 > tmp_job
      $MPIRUN1 $nfpgw/$hx0fp0 <tmp_job >lx0
      set retval = $status
      rm tmp_job
      if ($?pwtime) then
        pdtime w341b $tstart
        w341b:
      endif
      if ($retval != 0 && $?retzero) goto error
    endif
  else
    echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 222|$nfpgw/$hx0fp0 >lx0"
    if ($noexec == 0) then
      walltime w342 tstart 0
      w342:
      rm -f WVI WVR
      echo 222 >tmp_job
      $MPIRUN1 $nfpgw/$hx0fp0 <tmp_job >lx0
      set retval = $status
      rm tmp_job
      if ($?pwtime) then
        pdtime w342b $tstart
        w342b:
      endif
      if ($retval != 0 && $?retzero) goto error
    endif
  endif
# finished
  exit
endif

endif                # chix

# ----------------------------- Setup for GW pass, spex mode -----------------------------
if ($?spex) then    # GW pass spex mode

# ----------------------------- Setup for GW pass, fpgw mode -----------------------------
else                # GW pass fpgw mode
#--- hchknw only calculates NW, which contains the number of nw corresponding to QPNT ---
if ($noexec == 0) rm -f NW

if ($?etot) then
    echo "    echo 0 >NW"
  if ($noexec == 0) then
    echo 0 >NW
  endif
else if ($?sc == 0) then
  echo "    lmgw " `date | awk '{print $4}'`" : invoking echo 0|$nfpgw/hchknw >lchknw"
  if ($noexec == 0) then
    echo 0 > tmp_job
    $MPIRUN1 $nfpgw/hchknw <tmp_job        >lchknw
    set retval = $status
    rm tmp_job
    if ($retval != 0 && $?retzero) goto error
  endif
else
  echo "    lmgw " `date | awk '{print $4}'`" : invoking echo 1|$nfpgw/hchknw >lchknw"
  if ($noexec == 0) then
    #echo 1 > tmp_job
    #$MPIRUN1 $nfpgw/hchknw  <tmp_job       >lchknw
    echo 1|$nfpgw/hchknw >lchknw
    set retval = $status
    rm tmp_job
    if ($retval != 0 && $?retzero) goto error
  endif
endif
if ($noexec == 0 && ! -e NW) then
  echo "no file NW created ... aborting"
  exit -1
endif
if ($noexec == 0) then
if ($noexec == 0 && `head -1 NW | awk '{print ($1>0)?1:0}'` < 0) then
  echo "first line in file NW < 0 ... aborting"
  exit -1
endif
endif
endif     # GW pass fpgw mode

# ----------------------------- Total energy branch, spex mode -----------------------------
if ($?spex && $?etot) then    # GW pass spex mode

  echo total energy not ready for spex mode
  exit

# ----------------------------- Total energy branch, fpgw mode -----------------------------
else if ($?etot) then

# --- Core-core exchange ---
echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 5|$nfpgw/hbasfp0  >lexxCC"
if ($noexec == 0) then
  walltime w411 tstart 0
  w411:
  echo 5 > tmp_job
  $MPIRUN1 $nfpgw/hbasfp0 <tmp_job  >lexxCC
  set retval = $status
  rm tmp_job
  if ($?pwtime) then
    pdtime w411b $tstart
    w411b:
  endif
  echo ' --- Ex(core-core)   in TEEXXcc = ' `head -5  TEEXXcc | tail -1|awk '{print $1}'`  'eV'
endif

# --- Core-valence exchange ---
echo "    lmgw " `date | awk '{print $4}'`" : invoking echo 6|$nfpgw/hbasfp0  >lbasCV"
echo "                    echo 0|$nfpgw/hvccfp0  >lvccCV"
echo "                    echo 6|$nfpgw/$hsfp0   >lexxCV"
if ($noexec == 0) then
  echo 6 > tmp_job; $MPIRUN1 $nfpgw/hbasfp0 <tmp_job  >lbasCV; rm tmp_job
  echo 0 > tmp_job; $MPIRUN1 $nfpgw/hvccfp0 <tmp_job  >lvccCV; rm tmp_job
  echo 6 > tmp_job; $MPIRUN1 $nfpgw/$hsfp0 <tmp_job   >lexxCV; rm tmp_job
  echo ' --- 2*Ex(core-val) in TEEXXcv = ' `head -5  TEEXXcv | tail -1|awk '{print 2*$1}'` 'eV'
endif

# --- Valence-valence exchange ---
echo "    lmgw " `date | awk '{print $4}'`" : invoking echo 7|$nfpgw/hbasfp0 >lbasVV"
echo "                    echo 0|$nfpgw/hvccfp0 >lvccVV"
echo "                    echo 5|$nfpgw/$hsfp0   >lexxVV"
if ($noexec == 0) then
  echo 7 > tmp_job; $MPIRUN1 $nfpgw/hbasfp0 <tmp_job >lbasVV; rm tmp_job
  echo 0 > tmp_job; $MPIRUN1 $nfpgw/hvccfp0 <tmp_job >lvccVV; rm tmp_job
  echo 5 > tmp_job; $MPIRUN1 $nfpgw/$hsfp0  <tmp_job  >lexxVV; rm tmp_job
  echo ' --- Ex(val-val)    in TEEXXvv = ' `head -5  TEEXXvv | tail -1|awk '{print $1}'` 'eV'
endif

# --- Correlation energy ---
echo "    lmgw " `date | awk '{print $4}'`" : invoking echo 0|$nfpgw/hbasfp0  >lbas_cor"
echo "                    echo 0|$nfpgw/hvccfp0  >lvcc_cor"
if ($?htransform) then
echo "                    echo 12|$nfpgw/$hx0fp0  >lx0_cor"
else
echo "                    echo 101|$nfpgw/$hx0fp0 >lx0_cor"
endif
echo "                    $nfpgw/hecor           >lecor"

if ($noexec == 0) then
  echo 0 > tmp_job; $MPIRUN1 $nfpgw/hbasfp0  <tmp_job >lbas_cor; rm tmp_job
  echo 0 > tmp_job; $MPIRUN1 $nfpgw/hvccfp0  <tmp_job >lvcc_cor; rm tmp_job
if ($?htransform) then
  walltime w412 tstart 0
  w412:
  echo 12 > tmp_job; $MPIRUN1  $nfpgw/$hx0fp0 <tmp_job >lx0_cor; rm tmp_job
  set retval = $status
  if ($?pwtime) then
    pdtime w412b $tstart
    w412b:
  endif
else
  walltime w413 tstart 0
  w413:
  echo 101 > tmp_job; $MPIRUN1 $nfpgw/$hx0fp0 <tmp_job >lx0_cor; rm tmp_job
  set retval = $status
  if ($?pwtime) then
    pdtime w413b $tstart
    w413b:
  endif
endif
  $nfpgw/hecor           >lecor
  echo ' --- Ec             in TEECORR = ' `head -5  TEECORR | tail -1|awk '{print $1}'` 'eV'
endif

# --- Get LDA part of energies ---
echo " "
echo "    lmgw " `date | awk '{print $4}'`" : Generate LDA part of total energies (file log.$argv[1])"
echo "           rm -f log.$argv[1]"
echo "    lmgw " `date | awk '{print $4}'`" : invoking         $lmgw/$lmf --etot --no-iactive $gwargs >llmf_elda"
if ($noexec == 0) then
  rm -f log.$argv[1]
  $lmgw_FE/$lmf --etot --no-iactive $gwargs >llmf_elda
  if ($status) then
    echo "    lmgw: oops! $lmgw/$lmf returned with nonzero exit status ... aborting "
    exit -1
  endif
endif

echo "    lmgw " `date | awk '{print $4}'`" : Extract LDA part of total energies (generate ETOTLDA and RoVxcLDA from file log.$argv[1])"
echo "           rm -f ETOTLDA RoVxcLDA"
echo "           $nfpgw/extract_elda_from_log_file $argv[1]"
echo "           $nfpgw/eout"

if ($noexec == 0) then
                 rm -f ETOTLDA RoVxcLDA
                 $nfpgw/extract_elda_from_log_file $argv[1]
                 set retval = $status
                 if ($retval != 0 && $?retzero) goto error
                 $nfpgw/eout
endif

exit
endif
endif         # End of Total energy branch

# ----------------------------- GW pass, spex mode -----------------------------
if ($?spex) then    # GW pass spex mode

  echo "    lmgw  " `date | awk '{print $4}'`" : invoking $spexx &> lspex"
  if ($noexec == 0) then

    touch spex.sf sex.sew spex.sec
    rm -f spex.sf* sex.sew* spex.sec*

    $spexx >& lspex
    echo "    lmgw  " `date | awk '{print $4}'`" : spex completed"
#   abort if no QP levels printed out
    grep 'Quasiparticle energy' lspex > /dev/null
    if ($status) then
      echo "    lmgw: oops! $spexx did not generate any QP levels ... aborting "
      exit -1
    endif

    if ($?fleur && $?restoreinp) then
      echo "    lmgw " `date | awk '{print $4}'`" : restore inp file: mv inp.tmp inp"
      if ($noexec == 0) then
        mv inp.tmp inp
      endif
    endif
  endif

# ----------------------------- GW pass, fpgw mode -----------------------------
else
# ... Core exchange
#... product basis for core
# if ($exonly == 1) then
# else
echo "    lmgw " `date | awk '{print $4}'`" : invoking echo 3|$nfpgw/hbasfp0 >lbasC"
if ($noexec == 0) then
  echo 3> tmp_job; $MPIRUN1 $nfpgw/hbasfp0 <tmp_job >lbasC; rm tmp_job
  set retval = $status
  if ($retval != 0 && $?retzero) goto error
endif

# ... Coulomb matrix
echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 0|$nfpgw/hvccfp0 >lvccC"
if ($noexec == 0) then
  walltime w521 tstart 0
  w521:
  echo 0> tmp_job; $MPIRUN1 $nfpgw/hvccfp0 <tmp_job >lvccC; rm tmp_job
  set retval = $status
  if ($?pwtime) then
    pdtime w521b $tstart
    w521b:
  endif
  if ($retval != 0 && $?retzero) goto error
endif

# ... Self energy from core1
if ($?sc) then
  echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 3|$nfpgw/$hsfp0_sc >lsxC"
  if ($noexec == 0) then
    walltime w522 tstart 0
    w522:
    echo 3>tmp_job; $MPIRUN $nfpgw/$hsfp0_sc <tmp_job >lsxC; rm tmp_job
    set retval = $status
    if ($?pwtime) then
      pdtime w522b $tstart
      w522b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
else
  echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 3|$nfpgw/$hsfp0 >lsxC"
  if ($noexec == 0) then
    walltime w523 tstart 0
    w523:
    echo 3 > tmp_job; $MPIRUN1 $nfpgw/$hsfp0 <tmp_job  >lsxC; rm tmp_job
    set retval = $status
    if ($?pwtime) then
      pdtime w523b $tstart
      w523b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
endif
# endif

# ... Valence part of the self-energy
echo "    lmgw " `date | awk '{print $4}'`" : invoking echo 0|$nfpgw/hbasfp0 >lbas"
if ($noexec == 0) then
  echo 0 > tmp_job; $MPIRUN1 $nfpgw/hbasfp0 <tmp_job >lbas; rm tmp_job
  set retval = $status
  if ($retval != 0 && $?retzero) goto error
endif
# ... Coulomb matrix
echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 0|$nfpgw/hvccfp0 >lvcc"
if ($noexec == 0) then
  walltime w530 tstart 0
  w530:
  echo 0 > tmp_job; $MPIRUN1 $nfpgw/hvccfp0 <tmp_job >lvcc; rm tmp_job
  set retval = $status
  if ($?pwtime) then
    pdtime w530b $tstart
    w530b:
  endif
  if ($retval != 0 && $?retzero) goto error
endif

# ... Exchange self energy from valence core2+valence electrons
if ($?sc) then
  echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 1|$nfpgw/$hsfp0_sc >lsx"
  if ($noexec == 0) then
    walltime w531 tstart 0
    w531:
    echo 1 > tmp_job; $MPIRUN $nfpgw/$hsfp0_sc <tmp_job >lsx; rm tmp_job
    set retval = $status
    if ($?pwtime) then
      pdtime w531b $tstart
      w531b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
else if ($?htransform) then
  echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 11|$nfpgw/$hsfp0 >lsx"
  if ($noexec == 0) then
    walltime w532 tstart 0
    w532:
    echo 11 > tmp_job; $MPIRUN1 $nfpgw/$hsfp0  <tmp_job  >lsx; rm tmp_job
    set retval = $status
    if ($?pwtime) then
      pdtime w532b $tstart
      w532b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
else
  echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 1|$nfpgw/$hsfp0 >lsx"
  if ($noexec == 0) then
    walltime w533 tstart 0
    w533:
    echo 1 > tmp_job; $MPIRUN1 $nfpgw/$hsfp0 <tmp_job  >lsx; rm tmp_job
    set retval = $status
    if ($?pwtime) then
      pdtime w533b $tstart
      w533b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
endif

if ($?lstop) then
  if ($lstop == "x0") then
    echo "    lmgw " `date | awk '{print $4}'`" : stopping execution before hx0fp0 ..."
    exit 0
    set noexec = 1
    unset lstop
  endif
endif

if ($?start) then
  if ($start == "x0") then
    echo "    lmgw " `date | awk '{print $4}'`" : starting execution at hx0fp0 ..."
    set noexec = 0
    unset start
  endif
endif

# ... Screened coulomb interaction
if ($exonly == 1) then
else
if ($?sc) then
  echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 11|$nfpgw/$hx0fp0_sc >lx0"
  if ($noexec == 0) then
    walltime w541 tstart 0
    w541:
    rm -f WVI WVR
#     $MPIRUN "echo 11|$nfpgw/$hx0fp0_sc >lx0"
    echo 11 > tmp_job; $MPIRUN $nfpgw/$hx0fp0_sc < tmp_job >lx0; rm tmp_job

    foreach f ( WVR.*.00001 )
       set bn=`basename $f .00001`; echo $bn":"; cat  $bn.* > $bn
    end

    rm WVR.?????.?????


    set retval = $status
    if ($?pwtime) then
      pdtime w541b $tstart
      w541b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif

else if ($?htransform) then
  echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 11|$nfpgw/$hx0fp0 >lx0"
  if ($noexec == 0) then
    walltime w542 tstart 0
    w542:
    rm -f WVI WVR
    echo 11 > tmp_job; $MPIRUN1 $nfpgw/$hx0fp0 <tmp_job >lx0; rm tmp_job
    set retval = $status
    if ($?pwtime) then
      pdtime w542b $tstart
      w542b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
else
  echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 1|$nfpgw/$hx0fp0 >lx0"
  if ($noexec == 0) then
    walltime w543 tstart 0
    w543:
    rm -f WVI WVR
    echo 1 > tmp_job; $MPIRUN1 $nfpgw/$hx0fp0 <tmp_job >lx0; rm tmp_job
    set retval = $status
    if ($?pwtime) then
      pdtime w543b $tstart
      w543b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
endif
endif

# ... Correlation self-energy from valence core2+valence electrons
if ($?lstop) then
  if ($lstop == "sig") then
    echo "    lmgw " `date | awk '{print $4}'`" : stopping execution before hsfp0 ..."
    exit 0
    set noexec = 1
    unset lstop
  endif
endif

if ($?start) then
  if ($start == "sig") then
    echo "    lmgw " `date | awk '{print $4}'`" : starting execution at hsfp0 ..."
    set noexec = 0
    unset start
  endif
endif

hsfp0entry:
if ($exonly == 1) then
else
if ($?sc) then
  echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 2|$nfpgw/$hsfp0_sc  >lsc"
  if ($noexec == 0) then
    walltime w551 tstart 0
    w551:
    echo 2 > tmp_job; $MPIRUN $nfpgw/$hsfp0_sc  <tmp_job >lsc; rm tmp_job
    set retval = $status
    if ($?pwtime) then
      pdtime w551b $tstart
      w551b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
else if ($?htransform) then
  echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 12|$nfpgw/$hsfp0  >lsc"
  if ($noexec == 0) then
    walltime w552 tstart 0
    w552:
    echo 12 > tmp_job; $MPIRUN1 $nfpgw/$hsfp0 <tmp_job >lsc; rm tmp_job
    set retval = $status
    if ($?pwtime) then
      pdtime w552b $tstart
      w552b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
else
  echo $nonewln "    lmgw " `date | awk '{print $4}'`" : invoking echo 2|$nfpgw/$hsfp0 >lsc"
  if ($noexec == 0) then
    walltime w553 tstart 0
    w553: tstart 0
    echo 2 > tmp_job; $MPIRUN1 $nfpgw/$hsfp0 <tmp_job  >lsc; rm tmp_job
    set retval = $status
    if ($?pwtime) then
      pdtime w553b $tstart
      w553b:
    endif
    if ($retval != 0 && $?retzero) goto error
  endif
endif
endif

# ... Make summary, sigm file in sc case
if ($?sc) then
  echo "    lmgw " `date | awk '{print $4}'`" : invoking echo $nocc|$nfpgw/hqpe_sc >lqpe"
  if ($noexec == 0) then
    echo $nocc > tmp_job; $MPIRUN1  $nfpgw/hqpe_sc <tmp_job   >lqpe; rm tmp_job
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
  endif
else if ($?metal) then
  echo "    lmgw " `date | awk '{print $4}'`" : invoking echo 0|$nfpgw/hqpe >lqpe"
  if ($noexec == 0) then
    echo 0 > tmp_job; $MPIRUN1 $nfpgw/hqpe <tmp_job   >lqpe; rm tmp_job
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
  endif
  echo "    lmgw " `date | awk '{print $4}'`" : invoking $nfpgw/hqpemetal $argv[1] >lqpemetal"
  if ($noexec == 0) then
    $MPIRUN1 $nfpgw/hqpemetal $argv[1] >lqpemetal
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
  endif
else
  echo "    lmgw " `date | awk '{print $4}'`" : invoking echo $nocc | $nfpgw/hqpe >lqpe"
  if ($noexec == 0) then
    echo $nocc >tmp_job; $MPIRUN1  $nfpgw/hqpe  <tmp_job  >lqpe; rm tmp_job
    set retval = $status
    if ($retval != 0 && $?retzero) goto error
  endif
endif

# Soft link sigm file for subsequent uses by lmf
if ($?sc) then
  echo "           ln -s -f sigm sigm.$argv[1]"
  if ($noexec == 0) then
                   ln -s -f sigm sigm.$argv[1]
  endif
endif

endif         # GW pass

# Symmetrize sigma file
if ($?sym && $?sc) then
  echo "    lmgw " `date | awk '{print $4}'`" : invoking         $lmgw/$lmf --no-iactive --wsig --mixsig=1 $gwargs >llmf-sym"
  echo "                            cp sigm.$LMJOB sigm~"
  echo "                            cp sigm2.$LMJOB sigm.$LMJOB"
  if ($noexec == 0) then
    $MPIRUN1 $lmgw/$lmfMPI --no-iactive --wsig --mixsig=1 $gwargs >llmf-sym
    if ($status) then
      echo "    lmgw: oops! $lmgw/$lmf returned with nonzero exit status ... aborting "
      exit -1
    endif
    cp sigm.$LMJOB sigm~
    cp sigm2.$LMJOB sigm.$LMJOB
    if ($status) then
      echo "    lmgw: oops! $lmgw/$lmf returned with nonzero exit status ... aborting "
      exit -1
    endif
  endif
endif

# --- Self-consistency in the density ---
if ($?bnds && $?sc) then
  echo "    lmgw " `date | awk '{print $4}'`" : invoking         $lmgw/$lmf --no-iactive $bnds $gwargs >llmf-bnds"
  if ($noexec == 0) then
    $MPIRUN1 $lmgw/$lmfMPI --no-iactive $bnds $gwargs >llmf-bnds
    if ($status) then
      echo "    lmgw: oops! $lmgw/$lmf returned with nonzero exit status ... aborting "
      exit -1
    endif
  endif
#    if ($?insul && -e bnds.$argv[1]) then
#      set quiet
#      findcmd chk11a fixef change-bnds-ef "$path" "no"
#      chk11a:
#      if ($?fixef) then
#        echo "    lmgw " `date | awk '{print $4}'`" : invoking         $fixef -n=$insul bnds.$argv[1]"
#        if ($noexec == 0) then
#          $fixef -n=$insul bnds.$argv[1]
#        endif
#      endif
#      exit
#    endif
endif

echo -n "    lmgw " `date | awk '{print $4}'` : exit with wall clock time
pdtime w00xz $tstartlmgw
w00xz:


exit
# ---------------- findcmd --------------
# Finds an executable program within the supplied path
# Usage: findcmd return_label program-name executable_command path_name make_path
# If $executable_command is not found, findcmd does one of the following:
# If make_path = 'no' : returns silently.
# Otherwise findcmd aborts with a message, which assumes
# $make_path is the path where $executable_command is made.
exit
findcmd:
set found = 'no'
foreach ac_dir ($path_name)
 if (-x $ac_dir/$prog_cmd) then
   set $prognam = $ac_dir/$prog_cmd
   set found = 'yes'
   break
 endif
end
# if (! $?quiet) then
#   if ($found == 'yes') echo "$space ... using executable $ac_dir/$prog_cmd"
#   if ($found == 'no')  echo "$space ... no executable $prog_cmd found in path"
# endif
if ($found == 'no' && $make_path != "no") then
  echo "  "
  echo "  Sorry, $testfile cannot find program '"$prog_cmd"' it needs to execute."
  echo "  '"$prog_cmd"' was not found in supplied path, or in the following:"
  echo "        $topdir $maindir"
# echo "  ... This script ($testfile) requires binary "'"rdcmd"'" to run."
  echo "  You must create or put '"$prog_cmd"' in your path before invoking this script."
  echo "  Normally '"$prog_cmd"' is created as part of the installation process."
  echo "  Invoking '"make $prog_cmd"' in $make_path should create it."
  echo "  $testfile aborting ..."
  exit -1
endif
goto $retcall

# ---------------- walltime --------------
exit
# Returns wall-clock time.
# Usage: walltime return_label time_var time_start
# have_bc or have_dval should be set.
exit
walltime:
if ($?have_bc) then
  echo `date  +%d`'*24*60'+`date  +%H`'*60'+`date  +%M`+`date  +%S`/60   | $have_bc -l >datenow~; set datenow = `cat datenow~`
else if ($?have_dval) then
  dval -fd3 d=`date  +%d` h=`date  +%H` m=`date  +%M` s=`date  +%S` '(d*24+h)*60+m+s/60' >datenow~; set datenow = `cat datenow~`
else
  set $time_var = 0
  goto $retcall
endif
#cat datenow~
if ($time_start == 0) then
  set $time_var = $datenow
  goto $retcall
else
  if ($?have_bc) then
    set $time_var = `echo $datenow-$time_start | bc -l | awk '{printf("%.1f",$1)}'`
  else if ($?have_dval) then
    set $time_var = `dval -fd1 $datenow-$time_start`
  endif
endif
goto $retcall

# ---------------- Prints out difference between current wall clock time and time_start --------------
exit
# Returns wall-clock time
# Usage: if ($?pwtime) pdtime return_label time_start
# To work, have_bc or have_dval must be set.  Otherwise prints ' '
exit
pdtime:
set retcallp = $retcall
if ($?have_bc) then
  set time0 = $time_start
  walltime pdtime2 deltat 0
  pdtime2:
  echo $deltat $time0 | awk '{printf(" ... %.1fm (%.1fh)\n",$1-$2,($1-$2)/60.)}'
else if ($?have_dval) then
  set time0 = $time_start
  walltime pdtime3 deltat 0
  pdtime3:
  dval -a " ... %;1dm (%;2dh)"  $deltat-$time0 $deltat/60-$time0/60
else
#   echo ' ... (*)'
  echo
endif
goto $retcallp

exit
usage:
echo 'usage : lmgw [--switches] extension'
echo '        switches:'
echo '          --help'
echo '          --h'
echo '            show this message'
echo ' '
echo '          --version'
echo '            Reports version to standard output and exits'
echo ' '
echo '          --metal'
echo ' '
echo '          --insul=# insulator, with # occupied bands (only affects QP* file)'
echo ' '
echo '          --ht'
echo  '             generate imaginary weights in hx0fp0 and'
echo  '             real weights from Hilbert transform (S. Faleev).'
echo ' '
echo '          --code2'
echo  '             use GW code with symops (Sep 2012)'
echo ' '
echo '          --spex'
echo '          --spexi'
echo  '             use spex GW code (with or without inversion)'
echo ' '
echo '          --spexf'
echo '          --spexfi'
echo  '             use fleur LDA code (with or without inversion)'
echo  '             use spex GW code (with or without inversion)'
echo ' '
echo '          --scrho'
echo '          --scrho0'
echo  '             make density self-consistent before GW calculation'
echo  '             scrho uses existing rst file; scrho0 starts from free-atom densities'
echo ' '
echo '          --sc'
echo '          --sc:sym'
echo  '             make output sigma needed for self-consistency cycle'
echo  '             Option :sym symmetrizes sigma'
echo  '             NB: --sc implies --ht for now'
echo ' '
echo '          --etot'
echo  '             make LW total energy'
echo  '             NB: No self-energies are computed.  Not compatible with --sc or --eps'
echo ' '
echo '          --eps'
echo  '             make dielectric function'
echo  '             No self-energies are computed.  Not compatible with --sc or --etot'
echo ' '
echo '          --epsNLF'
echo  '             make dielectric function without local-field correction'
echo  '             No self-energies are computed'
echo ' '
echo '          --chix'
echo  '             make transverse susceptibility'
echo  '             No self-energies are computed.  Not compatible with --sc or --etot'
echo ' '
echo '          --chixNLF'
echo  '             make transverse susceptibility without local-field correction'
echo  '             No self-energies are computed'
echo ' '
echo '          --band[:args]'
echo  '             generate energy bands after GW pass'
echo  '             NB: In conjunction with --sc switch,  uses lmf --band:args'
echo  '                 Otherwise, uses band mode 4 of lmfgwd'
echo ' '
echo '          --start=x0'
echo  '             start execution at hx0fp0'
echo '          --start=sig'
echo  '             start execution at hsfp0'
echo ' '
echo '          --stop=setup'
echo  '             stop execution after setup'
echo '          --stop=x0'
echo  '             stop execution before hx0fp0'
echo '          --stop=sig'
echo  '             stop execution before hsfp0'
echo ' '
echo '          --bin=dir'
echo '           -bin=dir'
echo  '             combination of switches --lmbin and --gwbin'
echo ' '
echo '          --lmbin=dir'
echo '           -lmbin=dir'
echo  '             take LDA binaries lmf, lmfgwd, and lmf2gw from directory "dir".'
echo  '             Default is directory containing this script ('"$0:h)"
echo ' '
echo '          --gwbin=dir'
echo '           -gwbin=dir'
echo  '             take GW binaries from directory "dir".'
echo  '             Default is directory containing this script ('"$0:h)"
echo ' '
echo '          --big'
echo  '             use binaries lm-big and lmfgwd-big'
echo ' '
echo '          --openmp=#'
echo '          --openmp'
echo  '             Use binaries linked with open MP threaded libraries'
echo ' '
echo '          -vVAR=VAL'
echo  '             assign VAR to VAL, and pass to LDA programs lmf, lmfgwd'
echo ' '
echo '          --noexec'
echo  '             show what codes would execute without executing them'
# echo ' '
# echo '          --lmv6'
# echo  '             lmf uses lmv6 compatible source code.  lmv7 may have slight changes.'
echo ' '
echo '          --vxcsig'
echo  '             Subtract sigm-vxc + vxc (1-shot only: do 1-shot from QSGW potential)'
echo ' '
echo '          --mixsig=#'
echo  '             scale sigma-vxc by # when evaluating eigenfunctions (lmf,lmfgwd)'
echo ' '
echo '          --getsigp'
echo  '             (only used in conjunction with the --sc switch)'
echo  '             Get some parameters for GWinput file.'
echo  '             Equivalent to --getesig and --getnk and:'
echo  '             --multitet=no (if --multitet not specified)'
echo  '             --exonly=no   (if --exonly not specified)'
echo ' '
echo '          --getesig'
echo  '             Before execution, alter esigcut in file GWinput to the following:'
echo  '             Extract the contents of SIGP:emax and add 0.5 Ry.'
echo  '             NB: only used in conjunction with the --sc switch'
echo ' '
echo '          --getnk'
echo  '             Before execution, alter nk in file GWinput to the following:'
echo  '             Extract the contents of SIGP:emax and add 0.5 Ry.'
echo  '             NB: only used in conjunction with the --sc switch'
echo ' '
echo '          --multitet (--multitet=no)'
echo  '             Before execution, uncomment (comment) multitet line in file GWinput'
echo  '             NB: only used in conjunction with the --sc switch'
echo ' '
echo '          --nbando'
echo  '             After execution of lmfgwd, uncomment (comment) nband_chi0 line in file GWinput'
echo  '             if line largest reduced hilbert space can be found'
echo ' '
echo '          --exonly (--exonly=no)'
echo  '             Exchange only calculation'
echo  '             Before execution, uncomment (comment) EXonly line in file GWinput'
echo  '             NB: only used in conjunction with the --sc switch'
echo ' '
echo '          --erange'
echo  '             Generate file erange, to set bounds for dielectric fn screening'
echo ' '
echo '          --wt'
echo  '             For some programs print wall clock time (requires dval be installed)'
echo ' '
exit -1

error:
echo "lmgw (abort): program failed to return with zero value"
exit -1
