<!DOCTYPE html><html>

<head>
<title>ASA Magnetic Demo</title>
<style>

/* For hyperlinks */
a:link {color:#FF0000;}      /* unvisited link */
a:link {color:#222288;}      /* unvisited link */
a:visited {color:#228822;}  /* visited link */
a:hover {color:#FF00FF;}  /* mouse over link */
a:active {color:#0000FF;}  /* selected link */
a:link {text-decoration:none;}
a:visited {text-decoration:none;}
a:hover {text-decoration:underline;}
a:active {text-decoration:underline;}

body {
       background-color:#ffffgg;
     }
 h1 {
      color:#880000;
      text-align:center;
      font-size:12px;
    }
 h2 {
      color:#bb3300;
      font-size:120%;
      font-weight:normal;
      font-style:italic;
    }

 h3 {
      color:#33bb00;
      font-size:110%;
      font-weight:normal;
      font-style:italic;
      text-indent: 0.5em;
    }

 h4 {
      color:#000000;
      font-size:100%;
      font-weight:bold;
      text-indent: 1.0em;
    }

 h5 {
      color:#444488;
      font-size:100%;
      font-weight:bold;
      font-style:normal;
      text-indent: 1.5em;
    }

 hn {
      color:#000000;
      font-size:100%;
      font-weight:normal;
      font-style:normal;
      text-indent: 1.5em;
    }

  P {
<!--  font-family:"Times New Roman"; -->
<!--  font-size:12px; -->
<!--  color: red; -->
    }

  q {
      color: red;
    }

  a {
        color: blue;
    }

  tlarge {
       <font-size="+1">
    }

  p.pos_left
  {
  position:relative;
  left:-20px;
  }

  p.pos_right
  {
  position:relative;
  left:20px;
  right:520px;
  }

  div.ex
  {
  width:3in;
  padding:10px;
  border:5px solid gray;
  margin:0px;
  }

</style>

<!-- Enables the use of latex -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
    tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
  });
</script>

<!--
<script type="text/javascript"  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>
<script type="text/javascript" src="/Users/markvanschilfgaarde/MathJax/MathJax.js"></script>
-->

</head>

<h1><B><FONT size="+2">Demonstration of LDA-ASA calculation of a magnetic system (v7.11)</FONT></B></h1>

<h2><A name="intro"></A>Purpose</h2>

This tutorial carries out an LDA-ASA calculation for magnetic material CoPt in the L1<sub>2</sub> stucture.
<A href="Building_FP_input_file.html">starting from an <FONT size="+1"><tt>init</tt></FONT> file</A>, but in an ASA context.

<br> Magnetic exchange interactions are also demonstrated.

<P> This demo proceeds with the following sequence of &nbsp;<FONT size="+1"><tt>files</tt></FONT> + <b>programs</b>:
<OL>
<LI> <A href="#ctrl">LDA-ASA setup</A>:&nbsp; <FONT size="+1"><tt>init.copt</tt></FONT> + <b>blm</b> &rarr; <FONT size="+1"><tt>ctrl.copt</tt></FONT>  &nbsp;(make input file)
<LI> <A href="#ldaselfconsistency">LDA-ASA self-consistency</A>: <FONT size="+1"><tt>ctrl.copt</tt></FONT> + <b>lm</b> &rarr; <FONT size="+1"><tt>{co,pt}.copt</tt></FONT> &nbsp;(density)
<LI> Use of the <A href="#lmgf">Green's function program</A> to calculate <A href="#exchange">Magnetic Exchange Interactions</A>: <FONT size="+1"><tt>ctrl.copt</tt></FONT> + <b>lmgf</b> &rarr; <FONT size="+1"><tt>jr.copt</tt></FONT> &nbsp;(exchange interactions)

</OL>

<h2><A name="ctrl"></A>Create an initial <FONT size="+1"><tt>ctrl</tt></FONT> file</h2>

<P> To get started, copy <FONT size="+1"><tt>doc/demos/asa-copt/init.copt</tt></FONT> to your working directory.

Inspect the <FONT size="+1"><tt>init</tt></FONT> file and you will see it contains just the minimum structural information, apart from one line
<A href="#magneticstructure">supplying some information about the magnetic structure</A>.  Then use the <b>blm</b> tool
<pre>
   blm --mag --nk=8 --asa --gf copt
</pre>
<b>blm</b> should generate file <FONT size="+1"><tt>actrl.copt</tt></FONT>, which should be essentially the same as <FONT size="+1"><tt>doc/demos/asa-copt/ctrl.copt</tt></FONT>.
(If this is not the case, something is wrong with your configuration.  You should not continue if your template does not agree with the one supplied.)

<P> The input file itself is described in <A href="ASAtutorial.html">this tutorial</A> in an ASA context
(and <A href="fptutorial.html">here</A> in a full-potential context).

<A href="Building_FP_input_file.html">This web page</A> describes in detail how to generate input files using <b>blm</b>.
Even though it is written for the full-potential code <b>lmf</b>, much of the description also applies to the present context.
The present tutorial addresses ASA-specific aspects not covered there.
<!--  <A href="#asa">below</A>.   font-size:12px; -->

<P> The command-line arguments are not required, but they supply quantities <b>blm</b> cannot determine automatically, that you will have to supply at some point.
If you supply them on the command-line they are folded into the <FONT size="+1"><tt>ctrl</tt></FONT> file at the outset;
or, you can edit the <FONT size="+1"><tt>ctrl</tt></FONT> file  after it is generated.
Command-line switches <b>blm</b> recognizes are summarized in <A href="Building_FP_input_file.html#options">Building_FP_input_file.html</A>.
In particular,  for more discusssion of <FONT size="+1"><tt>--nk=..</tt></FONT>, which governs the <i>k</i>-point mesh, see the <A href="Demo_QSGW_Si.html#nk">this demo</A>.

<h3><A name="asa"></A>The <FONT size="+1"><tt>--asa</tt></FONT> switch</h2>

This switch tailors the <FONT size="+1"><tt>ctrl</tt></FONT> file for the ASA.
To see how it affects the <FONT size="+1"><tt>ctrl</tt></FONT> file, try running <b>blm</b> without <FONT size="+1"><tt>--asa</tt></FONT>.

<P> Note in particular this line in <FONT size="+1"><tt>SPEC</tt></FONT>:
<pre>
   SCLWSR=1 OMAX1=.20 .26 .24  OMAX2=.4 .6 .6  WSRMAX=3.3
</pre>
In the ASA, the
<A href="lmto.html#section8">sum of sphere volumes must match the unit cell volume</A>.
This one of the severest limitations of the ASA.  (In the present case packing
is not an issue, but it typically is for open structures.  In such a case you
must add empty spheres.)

<P>  <b>blm</b> finds sphere radii so that spheres touch, but do not overlap.
<FONT size="+1"><tt>SCLWSR=1</tt></FONT> <A href="lmto.html#section8">turns
on the automatic sphere resizer</A>, which in this case enlarges the
spheres until they fill space.
<A href="lmto.html#section8">This link</A> discusses sphere radii
in some detail, what <FONT size="+1"><tt>SCLWSR</tt></FONT> does and also
<FONT size="+1"><tt>OMAX1</tt></FONT>,
OMAX2, <FONT size="+1"><tt>WSRMAX</tt></FONT>, which add constraints
as the spheres are resized.

<P> These lines are also ASA-specific:
<pre>
% const ccor=t sx=f gamma=sx adnf=~sx scr=4
OPTIONS
        ASA[ CCOR={ccor} ADNF={adnf} GAMMA={gamma}] SCR={scr} SX={sx}
</pre>
This <FONT size="+1"><tt>ctrl</tt></FONT> file will result in
<FONT size="+1"><tt>SCR=4</tt></FONT>
(<A href="file-preprocessor.html#variables">variable scr</A> is declared with value &thinsp;<FONT size="+1"><tt>4</tt></FONT>).
To see quickly what
<A href="tokens.html#OPTIONScat"><FONT size="+1"><tt>SCR</tt></FONT></A> is used for, do
<pre>
  lm --input
</pre>
and search for <FONT size="+1"><tt>OPTIONS_SCR</tt></FONT>.  You should find
<pre>
 OPTIONS_SCR       opt    i4       1,  1          default = 0
   Use scr to accelerate convergence:
   ...
   4 Use model response to screen output q
</pre>
This token is used to accelerate convergence to self-consistency.
It is described in some detail on <A href="linear-response-asa.html">this web page</A>.

<h3><A name="mag"></A>The <FONT size="+1"><tt>--mag</tt></FONT> switch</h2>

This switch tells <b>blm</b> that you plan on doing a spin polarized calculation.
All it does is change the <A href="file-preprocessor.html#variables">preprocessor variable</A> <FONT size="+1"><tt>nsp</tt></FONT> to 2.
This turns on the spin polarization through
<A href="tokens.html#HAMcat"><FONT size="+1"><tt>NSPIN={nsp}</tt></FONT></A>.

<P> Without any other information the spin polarized calculation will
proceed with zero magnetic moment.  You have to supply some initial
information about the magnetic structure.  Since we know that the
magnetization is concentrated on the Co (Pt is paramagnetic,
though it has a high magnetic susceptibility), the <FONT
size="+1"><tt>init</tt></FONT> file supplies an initial magnetic
moment on the Co site of about 2 Bohr on the Co <i>d</i> orbital, in
the <FONT size="+1"><tt>SPEC</tt></FONT> category.  Of course the
actual magnetic moment is determined self-consistently.

<h3><A name="gfswitch"></A>The <FONT size="+1"><tt>--gf</tt></FONT> switch</h2>

When <FONT size="+1"><tt>--gf</tt></FONT> is used, <b>blm</b> prepares the input file for the
Green's function program <b>lmgf</b>.
This tutorial uses <b>lmgf</b> to <A href="#exchange">calculate magnetic exchange</A> interactions;
how <b>blm</b> modifies <FONT size="+1"><tt>actrl.copt</tt></FONT> is explained there.

<P> If you are not interested in this part of the tutorial, you can safely omit
<FONT size="+1"><tt>--gf</tt></FONT>.

<h3><A name="ctrl"></A>Make the <FONT size="+1"><tt>ctrl</tt></FONT> file</h3>

<b>blm</b> should generate file <FONT size="+1"><tt>actrl.copt</tt></FONT>, which should be essentially the same as <FONT size="+1"><tt>doc/demos/asa-copt/ctrl.copt</tt></FONT>.

<br> Invoking <b>blm</b> with the switches <A href="#ctrl">given
above</A> is sufficient to make a working input file.

Normally you can
<A href="#INVIT">copy <FONT size="+1"><tt>actrl.copt</tt></FONT> to <FONT size="+1"><tt>ctrl.copt</tt></FONT> as is<sup>1</sup></A>.

<P> For a fuller description of the <FONT size="+1"><tt>ctrl</tt></FONT> file, see the
<A href="ASAtutorial.html">the ASA tutorial</A>, the <A href="FPtutorial.html">FP tutorial</A>,
and also <A href="Building_FP_input_file.html">Building_FP_input_file.html</A>.

<P> Before proceeding to a self-consistent calculation you should
ensure that the sphere radii
<A href="#asa">satisfy the requisite criteria</A>,
 namely that the sphere volumes sum to the unit cell
volume and at the same time that the sphere overlaps are not too large (&lt;20%, better &lt;18%).
Run
<pre>
lmchk ctrl.copt
</pre>
You should see this line:
<pre>
  Cell volume= 371.16791   Sum of sphere volumes= 371.16791 (1)
                                                             <FONT color="#ff0000">&uarr;</FONT>
</pre>
The red arrow points to the ratio of these two volumes. It is exactly unity by construction, because
<A href="#asa"><FONT size="+1"><tt>SCLWSR=1</tt></FONT></A>
is present in
<A href="tokens.html#SPECcat"><FONT size="+1"><tt>SPEC</tt></FONT></A>.

<P> You should also inspect the table of sphere overlaps.  You should see a table beginning with:
<pre>
 ib jb  cl1     cl2        Pos(jb)-Pos(ib)      Dist  sumrs   Ovlp    %    summt   Ovlp   %
  1  2  Pt      Co        3.593  3.593  0.000  5.082  5.695   0.61  12.1*  3.557  -1.52 -30.0
  ...
 OVMIN, 76 pairs:  fovl = 1.78136e-6   <ovlp> = 11%   max ovlp = 12.1%
</pre>
The largest overlap is 12%, which is more than acceptable (L1<sub>2</sub> is a close-packed structure).

<h2><A name="ldaselfconsistency"></A>Self-consistent ASA calculation</h2>

<h3><A name="strx"></A>Structure constants</h3>

All the ASA electronic structure codes (<b>lm</b>, <b>lmgf</b>, and <b>lmpg</b>) use a
<A href="http://link.aps.org/doi/10.1103/PhysRevLett.53.2571">tight-binding form</A> of the LMTO basis,
where the envelope functions are screened to make them short ranged.
This information is carried through screened structure constants, which in this package are precomputed and stored using <b>lmstr</b>.
Run this setup to make the structure constants:
<pre>
  lmstr ctrl.copt                             &larr; Make and store structure constants
</pre>
It should store <FONT size="+1"><tt>str.copt</tt></FONT> and <FONT size="+1"><tt>sdot.copt</tt></FONT> on disk.
(If not, something is wrong and you should not proceed.)

<h3><A name="startingrho"></A>Starting density and potential</h3>

<P> As of yet we have no starting density or potential.  You can see this immediately by trying to run the band code straight off:
<pre>
  lm ctrl.copt
</pre>
The program will stop with this message:
<pre>
   LM:  Q=ATOM encountered or missing input
</pre>

In usual LDA calculations, a trial density is obtained by <A
href="Building_FP_input_file.html#lmfa">generating densities for free
atoms</A>, and superposing them (Mattheis construction). While the ASA
code could have been written to do just this, it does something different.
This code takes advantage of the simplification the ASA
offers, namely that the sphere density <A href="lmto.html#section2">is
completely determined</A> by a small number of parameters, namely the
log derivative parameters <i>P</i> and energy moments of the charge
density <i>Q</i><sub>0..2</sub> for each <i>l</i> channel.

We can supply reasonable guesses through the <FONT
size="+1"><tt>ctrl</tt></FONT> file, or let the program pick some
defaults as a first guess.  Defaults are typically assigned so that
<i>Q</i><sub>0</sub> is the charge in the <i>l</i> channel of the atom
and <i>Q</i><sub>1..2</sub> are taken to be zero.  While this is a
pretty crude guess (cruder than the Mattheis construction) usually it
is good enough that the program can find its way to the proper
self-consistent solution.

<P> The ASA code can <b>either</b> start from
<A href="lmto.html#sectionpp">"potential parameters"</A>,
which gives it enough information to generate energy bands and
calculate moments
(<FONT size="+1"><tt>P</tt></FONT><sub><i>l</i></sub>, <FONT size="+1"><tt>Q</tt></FONT><sub>0..2,<i>l</i></sub>)&thinsp;, <b>or</b> from the
<A href="lmto.html#sectionpq">moments (<FONT size="+1"><tt>P</tt></FONT><sub><i>l</i></sub>, <FONT size="+1"><tt>Q</tt></FONT><sub>0..2,<i>l</i></sub>)</A>&thinsp;
which is sufficient for the
sphere routine to fix the potential and calculated potential parameters.
The band and sphere blocks of the code are thus complementary: one
takes the input of the other and generates output required by the
other.  The cycle is described <A href="lmto.html#section2">here</A>.


<P> The <FONT size="+1"><tt>ctrl</tt></FONT> file is built with the following
<FONT size="+1"><tt>START</tt></FONT> category:
<pre>
  START CNTROL={nit==0} BEGMOM={nit==0}
</pre>
If <FONT size="+1"><tt>BEGMOM</tt></FONT> is nonzero, <b>lm</b> will start from potential parameters (which don't exist yet, in the present case).
<br> If <FONT size="+1"><tt>BEGMOM=0</tt></FONT> <b>lm</b> will start from the (<FONT size="+1"><tt>P</tt></FONT><sub><i>l</i></sub>&thinsp;, <FONT size="+1"><tt>Q</tt></FONT><sub>0..2,<i>l</i></sub>).
These haven't been given either, but <b>lm</b> can pick defaults for them.  We get an initial potential by doing:
<pre>
  lm ctrl.copt -vnit=0                             &larr; Because -vnit=0, BEGMOM={nit} is preprocessed into BEGMOM=0
</pre>
<b>lm</b> will start from (default) moments and generate a trial density for each sphere, together with potential parameters
corresponding to potential generated.
<br> The output should generate a table of potential parameters like this:
<pre>
PPAR:  Pt        nl=4  nsp=2  ves=  0.00000000
 l     e_nu          C        +/-del     1/sqrt(p)      gam         alp
...
 1 -0.33739987  0.66438324  0.17542338   6.2239779  0.13462479  0.13462479
 2 -0.21536757 -0.17914263  0.02841817   1.1299418  0.01358564  0.01358564
...
 1 -0.33739987  0.66438324  0.17542338   6.2239779  0.13462479  0.13462479
 2 -0.21536757 -0.17914263  0.02841817   1.1299418  0.01358564  0.01358564
...
</pre>
and a similar table for Co.  Particularly important are <FONT
size="+1"><tt>C</tt></FONT>, the band center of gravity <FONT
size="+1"><tt>C</tt></FONT> and the bandwidth <FONT
size="+1"><tt>del</tt></FONT>.  You can see that <i>C<sub>p</sub></i>
sits far above zero while <i>C<sub>d</sub></i> is a little below.  It tells you that the
Pt <i>d</i> orbital is important for bonding while the Pt <i>p</i>
orbital is pretty far above from the Fermi level and of much less
importance.  <FONT size="+1"><tt>del</tt></FONT> is the bandwidth parameter;
a little more detail is given in <A href="lmto.html#sectionpp">this web page</A>.

A disk file is created for each class.  It contains the (<FONT size="+1"><tt>P</tt></FONT><sub><i>l</i></sub>, <FONT size="+1"><tt>Q</tt></FONT><sub>0..2,<i>l</i></sub>), the potential parameters,
and possibly other things.  Take a look at files <FONT size="+1"><tt>co.copt</tt></FONT> and
<FONT size="+1"><tt>pt.copt</tt></FONT>.  You can see what defaults were chosen for (<FONT size="+1"><tt>P</tt></FONT><sub><i>l</i></sub>, <FONT size="+1"><tt>Q</tt></FONT><sub>0..2,<i>l</i></sub>).

<h3><A name="magneticstructure"></A>Magnetic density</h3>
<FONT size="+1"><tt>init.copt</tt></FONT> has this line:
<pre>
  SPEC ATOM=Co MMOM=0,0,2.2
</pre>
<FONT size="+1"><tt>MMOM</tt></FONT> is put in <FONT size="+1"><tt>ctrl.copt</tt></FONT> as a token in the Co species.

<P> When the sphere program selects default (<FONT size="+1"><tt>P</tt></FONT><sub><i>l</i></sub>, <FONT size="+1"><tt>Q</tt></FONT><sub><i>l</i></sub>) it
must select numbers for each spin channel.  <FONT size="+1"><tt>MMOM</tt></FONT> causes the starting <FONT size="+1"><tt>Q</tt></FONT><sub><i>l</i></sub>:
<FONT size="+1"><tt>MMOM=0,0,2.2</tt></FONT> splits the charge in <i>d</i> channel so that spin &uarr; has 2.2 more electrons than spin &darr;.

<P> Without supplying some initial magnetic structure, no magnetic
moment would appear in the spin-polarized calculation.  The system
needs a "push" in the initial direction to find the magnetic state.
The precise value 2.2 is not important: this quantity is determined
self-consistently.  Choosing it rather large (the bulk moment is
1.8&thinsp;<i>&mu;<sub>B</sub></i>) gives it a strong initial push so
to encourage it not revert to a (metastable) nonmagnetic state in the
course of a self-consistent calculation.

<P> Elemental Pt has no moment, so none was supplied in the <FONT size="+1"><tt>init</tt></FONT> file.

<h3><A name="selfconsistency"></A>Self-consistent band calculation</h3>
We are now ready for a self-consistent calculation.  Doing:
<pre>
  lm ctrl.copt -vnit=30 --pr31,20                &larr; NIT={nit} is preprocessed into NIT=30.
                                                    --pr31,20 sets verbosity fairly low
</pre>
will perform up to 30 self-consistent cycles, that is
<pre>
   PPAR &rarr; (P<sub><i>l</i></sub>, Q<sub>0..2,<i>l</i></sub>) &rarr; PPAR    &rarr; (P<sub><i>l</i></sub>, Q<sub>0..2,<i>l</i></sub>) &rarr;  PPAR ...
        <FONT color="#ff0000">&uarr;</FONT>              <FONT color="#0000ff">&uarr;</FONT>          <FONT color="#ff0000">&uarr;</FONT>              <FONT color="#0000ff">&uarr;</FONT>
      crystal        sphere    crystal        sphere
</pre>
<b>lm</b> will continue until the RMS change in (<FONT size="+1"><tt>P</tt></FONT><sub><i>l</i></sub>, <FONT size="+1"><tt>Q</tt></FONT><sub>0..2,<i>l</i></sub>) falls below tolerance
<A href="tokens.html#ITERcat">ITER_CONVC</A>, or until 30 iterations is reached.  In this demo convergence should be reached in
<A href="demos/asa-copt/out.lm#lastit">21 iterations</A>.

<h3><A name="interpretingoutout"></A>Interpreting the output</h3>

The output can provide some very useful information.  For example, the self-consistent Co moment is 1.8&thinsp;<i>&mu;<sub>B</sub></i>; Pt has a moment (induced by the
neighboring Co) of 0.3&thinsp;<i>&mu;<sub>B</sub></i>.  The density-of-states at the Fermi level <i>E</i><sub><i>F</i></sub> is
<FONT size="+1"><tt>D(Ef)=72</tt></FONT> (units of Ry<sup>&minus;1</sup> per unit cell), or about 1.3&thinsp;eV<sup>&minus;1</sup>/atom.
Had the calculation been done <i>without</i> spin polarization, <FONT size="+1"><tt>D(Ef)</tt></FONT> would be ~187, more than
twice larger.  This is a very large number and suggests there is a likely instability.  Indeed, the system can lower its energy by spontaneously magnetizing.
Consider the Stoner criterion for spontaneous magnetization, <i>I</i>&thinsp;<i>D</i>(<i>E</i><sub><i>F</i></sub>) &gt; 1.
In 3<i>d</i> transition metals <i>I</i> is about 1&thinsp;eV.  Thus the Stoner criterion is easily satisfied and the system should spontaneously magnetize.
In magnetizes so strongly that the Co moment (1.8&thinsp;<i>&mu;<sub>B</sub></i>) is larger than that for elemental Co (1.6&thinsp;<i>&mu;<sub>B</sub></i>).

<h3><A name="dos"></A>Making the partial DOS</h3>

<IMG border-color:green height=25% width=25% ALIGN="right" style="border:20px solid white" SRC="demos/asa-copt/dos-copt.gif"/>

The ASA saves on disk the moments needed to make the <i>l</i>-resolved DOS for each class.
You can make this DOS immediately on reaching self-consistency with:
<pre>
  echo 1001 -1 .5 | lmdos copt      &larr; Mesh of 1001 points on energy interval (-1,0.5)
</pre>
The command should make file <FONT size="+1"><tt>dos.copt</tt></FONT>.  The first line should read
<pre>
  -1.00000   0.50000 1001    8    2  -0.12927   0.00000    1
    <FONT color="#0000ff">&uarr;</FONT>         <FONT color="#0000ff">&uarr;</FONT>              <FONT color="#ff0000">&uarr;</FONT>    <FONT color="#ff0000">&uarr;</FONT>    <FONT color="#ff0000">&uarr;</FONT>
   energy window     8 channels, 2 spins, <i>E<sub>F</sub></i>
</pre>
There are 8 channels because the largest <i>l</i> cutoff is 3;
<i>spdf</i> channels for Pt and Co yield 8 channels.  (Note that the <i>l</i> cutoff for Co is 2,
so the <i>f</i> channel DOS is zero.)

<P><FONT color="#33bb00"><I>*Note</I>&nbsp;</FONT>
Even though there 4 atoms, there are only 2 classes.  <b>lm</b> saves moments by
class, and <b>lmdos</b> generates partial DOS for whatever channels are given to it.
You can resolve DOS in a variety of ways through the
<A href="generating-density-of-states.html#pdosswitches"><FONT size="+1"><tt>--pdos</tt></FONT></A> switch.
See <A href="generating-density-of-states.html">this web page</A> for a detailed discussion of the DOS and its decomposition.

<P> The DOS are dumped one after the other in <FONT size="+1"><tt>dos.copt</tt></FONT>, which is difficult to read directly.
But you should see this table at the close of <b>lmdos</b>' output:
<pre>
 Channels in dos file generated by LMDOS:
 site class label   spin-1                       spin-2
    1    1   Pt     1:7:2                        2:8:2
    2    2   Co     9:15:2                       10:16:2
</pre>
Each channel has two DOS (spins &uarr; and &darr;).  Thus the odd (even) numbered DOS correspond to spin &uarr; (spin &darr;).

<P> This table makes it easy for you to generate a picture of the partial DOS you are interested in.  For example,
suppose you want to draw a picture of the <i>spd</i> DOS on the Pt and the Co, and
you would like each channel to be displayed in a separate panel.
If you have the <FONT size="+1"><tt>pldos</tt></FONT> and <FONT size="+1"><tt>fplot</tt></FONT> packages installed you can
do this very conveniently.  Spin &uarr; and spin &darr; can be treated as one panel, with the &uarr; part drawn above the zero and
the &darr; part drawn below the zero.
You can tell <b>pldos</b> what channels go into each panel through the &thinsp;<FONT size="+1"><tt>-lst</tt></FONT>&thinsp; switch.
<pre>
  echo 15 7 -.8 0.5 | \
  pldos -ef=0 -fplot -lst="1;3;5;9;11;13" -lst2 dos.copt   &larr; -lst defines panels: `;' starts a new panel.  See below for -lst2
</pre>
This <b>pldos</b> command will make 6 panels of DOS (see Figure above), composed from channels 1, 3, 5, 9, 11, and 13 respectively.
(Any of these six numbers can actually be <A href="Integer-list-syntax.html">lists of channels</A> if you wish to combine channels into one panel.)

<h4><A name="pldosswitches">Switches and arguments to pldos</A></h4>

The four parameters given through the standard input have the following meanings:
<pre>
     15    &larr; An upper bound DMAX for the DOS in a given panel (DOS can be very spikey)
      7    &larr; The height, in cm, of a panel of height DMAX
 -.8 0.5   &larr; The energy window for the abscissa
</pre>

<P> <FONT size="+1"><tt>-lst=..</tt></FONT>&thinsp; specifies the channels for the DOS.
For the present case with both &uarr; DOS and &darr; DOS, it refers to the &uarr; DOS;
<br> <FONT size="+1"><tt>-lst2</tt></FONT>&thinsp; supplies the corresponding information for the &darr; DOS.
You can, but do not need to supply arguments for &thinsp;<FONT size="+1"><tt>-lst2</tt></FONT>&thinsp;.  Omitting them tells <b>pldos</b> to copy the &uarr; list to the
&darr; list, incrementing each element by 1.  This automatically generates the &darr; analogs of the &uarr; channels  (2, 4, 6, 10, 12, 14 in this instance).

<P> <FONT size="+1"><tt>-ef0</tt></FONT>&thinsp; tells <b>pldos</b> to assign <i>E<sub>F</sub></i> as the energy zero, and
<FONT size="+1"><tt>-fplot</tt></FONT> tells <b>pldos</b> to create a data file (<FONT size="+1"><tt>dosp.dat</tt></FONT> and because this
is a spin polarized calculation, <FONT size="+1"><tt>dosp2.dat</tt></FONT>) and script (<FONT size="+1"><tt>plot.dos</tt></FONT>) for the <b>fplot</b> graphics package.

<P> <FONT color="#33bb00"><I>*Note</I>&nbsp;</FONT>
to see all the switches <b>pldos</b> accepts, invoke it without any arguments.

<P> <b>fplot</b> makes the postscript file <FONT size="+1"><tt>ps.dat</tt></FONT>:
<pre>
  fplot -pr10 -f plot.dos
</pre>
Rename this file to <FONT size="+1"><tt><i>some-name</i>.ps</tt></FONT> and use your favorite postscript reader to view it.
You should see something close to the Figure shown.  As you might expect the DOS at <i>E<sub>F</sub></i> is dominated by the Co and Pt <i>d</i> channels.
The Co <i>d</i> DOS is spin-split by about &Delta;<i>E</i>=0.18 Ry or so, while the Pt is scarcely so.
&Delta;<i>E</i> gives you a rough estimate for the Stoner <i>I</i>, since approximately &Delta;<i>E</i> = <i>I</i>&times;<i>M</i>, where <i>M</i> is the local magnetic moment.
Here we get <i>I</i>=0.18/1.8 = 0.1&thinsp;Ry, slightly larger than 1&thinsp;eV.
A better calculation puts <i>I</i> closer to 1&thinsp;eV.

<P> The automatically generated figure is a bit untidy (too many tics on the <i>y</i> axis, for example).  You can "prettify" the picture by editing <FONT size="+1"><tt>plot.dos</tt></FONT>. Also consider adding <FONT size="+1"><tt>-esclxy=13.6</tt></FONT> to the <b>pldos</b> command-line arguments.  Then the abscissa will be in eV and the DOS will be in eV<sup>&minus;1</sup>.

<P> The DOS in the Figure appear a bit "ragged."  You can make them smoother by using a finer <b>k</b>-mesh.

<IMG border-color:green height=20% width=20% ALIGN="left" style="border:20px solid white" SRC="demos/asa-copt/bands-copt.gif"/>

<h3><A name="bands"></A>Energy bands</h3>

To draw energy bands, you need to choose symmetry lines.  Since the
lattice vectors of L1<sub>2</sub> are simple cubic the easiest is select
a stock symmetry lines file for the simple cubic lattice:
<pre>
  cp startup/syml.sc syml.copt
</pre>
Generate the bands with
<pre>
  lm ctrl.copt --band~fn=syml
</pre>

<P> The bands are dumped in a file <FONT size="+1"><tt>bnds.copt</tt></FONT>.
The following creates a postscript file for the spin-1 bands (requires that you have the <b>plbnds</b> and <b>fplot</b> packages installed):
<pre>
  echo -9 9 5 10 | plbnds -scl=13.6 -ef=0 -fplot -spin1 -lbl=X,G,M,R,G bnds.copt
  fplot -f plot.plbnds
</pre>
Rename this file to <FONT size="+1"><tt><i>some-name</i>.ps</tt></FONT> and use your favorite postscript reader to view it.  You should see something close to what is shown in the Figure.

<P> You may wish to draw energy bands <A href="generating-energy-bands.html">with color weights</A>.  The colors supply information about which orbitals contribute to a band (e.g. to select out the Pt <i>d</i> or Co <i>d</i> character), which can be very useful when interpreting them.

<br><br>

<h2><A name="lmgf"></A>The Green's function program <b>lmgf</b></h2>

<b>lmgf</b> is a Green's function program complementary to the ASA band code <b>lm</b>.
For some properties, e.g. calculating moments <i>Q</i><sub>0..2</sub></A>
<b>lmgf</b> can be straightforwardly substituted for <b>lm</b> because both calculate the DOS.
The DOS is 1/(2&pi;)&thinsp;Im&thinsp;<i>G</i>: it can be decomposed into site contributions and thus moments
<i>Q</i><sub>0..2</sub></A> can be generated for each site and <i>l</i> channel, as an alternative to
<A href="generating-density-of-states.html">decomposing the eigenfunctions</A> of the bands,
as <b>lm</b> does.  Thus it can achieve <A href="#selfconsistency">self-consistency</A>
in a manner similar to <b>lm</b>, but generating <i>Q</i><sub>0..2,&thinsp;<b>R</b><i>l</i></sub></A> by an alternate route.

If the ASA hamiltionian built by <b>lm</b> is suitably simplified, i.e. by
<OL>
<LI> omitting the "combined correction term" (<FONT size="+1"><tt>OPTIONS_ASA_CCOR</tt></FONT>)
<LI> generating <i>Q</i><sub>0..2,&thinsp;<b>R</b><i>l</i></sub></A> from true power moments as the Green's function does (<FONT size="+1"><tt>HAM_QASA</tt></FONT>=0),
</OL>
then <b>lmgf</b> and <b>lm</b> will produce nearly identical self-consistent solutions.  When
potential functions are parameterized to 2<sup>nd</sup> order in both <b>lm</b> and <b>lmgf</b>, and both methods are fully <i>k</i> converged, they should product nearly identical results.
By default <b>lm</b> parameterizes the potential function to 3<sup>rd</sup> order; <b>lmgf</b> can do the same.
The 3<sup>rd</sup> order parameterizations are similar in the two methods, but not identical.
To verify this, try the following test:
<pre>
  gf/test/test.gf co 1 2   &larr; Test 1 for 2nd order parameterization; test 2 for 3rd order
</pre>

<b>lmgf</b> is a bit messier to work with (Green's functions are harder to stabilize
than wave functions), and it a bit less accurate as the simplifications to <b>lm</b>
amount to approximations. So, typically <b>lm</b> makes a better self-consistent potential.

<P> But <b>lmgf</b> can do things <b>lm</b> doesn't do, e.g. calculate magnetic exchange interactions
through linear response <A href="#exchange">as this tutorial demonstrates</A>.  Sometimes
there is a need or advantage to carrying self-consistency
via <b>lmgf</b>, e.g.  when performing <A href="cpa.html">CPA
calculations</A>.  Unless there is good reason to do otherwise, it is better use the self-consistent
potential generated by <b>lm</b> to calculate other properties such as
the magnetic exchange parameters.  We follow that strategy here.

<h3><A name="inputgf"></A>Adapting the input file to <b>lmgf</b></h2>

<P> Adding <A href="#gfswitch"><FONT size="+1"><tt>--gf</tt></FONT></A> to
the <b>blm</b> command line argument modifies <FONT size="+1"><tt>actrl.copt</tt></FONT> in two ways:
<OL>
<LI> The <A href="#gfcat"><FONT size="+1"><tt>GF</tt></FONT> category</A> is created:
<pre>
% const gfmode=1 c3=t
GF      MODE={gfmode} GFOPTS={?~c3~p3;~p2;}
</pre>
<LI> <A href="#zcontour"><FONT size="+1"><tt>EMESH</tt></FONT> is added</A> to <FONT size="+1"><tt>BZ</tt></FONT>:

<FONT size="+1"><tt>EMESH</tt></FONT> is added to <FONT size="+1"><tt>BZ</tt></FONT>:
<pre>
% const nz=16 ef=0
        EMESH={nz},10,-1,{ef},.5,.3  # nz-pts;contour mode;emin;emax;ecc;bunching
</pre>
</OL>

<h3><A name="gfcat"></A>Green's function category</h3>

To see the purpose of <FONT size="+1"><tt>GF_MODE</tt></FONT>, do:
<pre>
  lmgf --input
</pre>
and look for <FONT size="+1"><tt>GF_MODE</tt></FONT>.  You should see:
<pre>
 GF_MODE           reqd   i4       1,  1          default = 0
    0: do nothing
    1: self-consistent cycle
   10: Transverse exchange interactions J(q), MST
   11: Read J(q) from disk and print derivative properties
   ...
</pre>

If <FONT size="+1"><tt>MODE=1</tt></FONT>, <b>lmgf</b> does a self-consistent calculation, generating the
<A href="#startingrho"><i>P</i> and <i>Q</i><sub>0..2</sub></A> for each <i>l</i> channel using Green's functions rather
than wave functions as <b>lm</b> does.

<h4><A name="gfopts">The <FONT size="+1"><tt>GF_GFOPTS</tt></FONT> token</A></h4>

<FONT size="+1"><tt>GFOPTS</tt></FONT> bundles a variety of
<A href="gf.html#section3.4.1"><b>lmgf</b>-specific options</A>,
which you supply through a sequence of strings separated by semicolons.
This tag:
<pre>
  GFOPTS={?~c3~p3;~p2;}
</pre>
becomes `<FONT size="+1"><tt>GFOPTS=p3;</tt></FONT>' after parsing by the <A href="file-preprocessor.html">preprocessor</A>,
because <FONT size="+1"><tt>c3</tt></FONT> is nonzero
<A href="file-preprocessor.html#expressions">(see expressions rule 1c)</A>.

<P> `<FONT size="+1"><tt>p3</tt></FONT>' tells <b>lmgf</b> to use 3<sup>rd</sup> order
potential functions (somewhat more accurate than 2<sup>nd</sup> order, but also prone to
generating false poles not too far from the real axis)


<h3><A name="zcontour"></A>Energy Contour</h3>

Green's functions are energy resolved; thus physical properties such
as the charge density or magnetic exchange interactions require an
integration over the energy as well as over the BZ.  For both density
and static exchange interactions, the integration must be taken on the
real axis from below the lowest eigenstate in the system to the Fermi
level <i>E<sub>F</sub></i>.  Im <i>G</i> is basically the
density-of-states.  It is very spikey on the real axis, and a very
fine energy mesh would be required to integrate Im <b>G</b> close to
the real axis.  The integration can be accomplished with vastly
greater eas by deformed the contour into an elliptical path in the
complex plane.  A gaussian quadrature is used; typically 15 or so energy
points is sufficient for a well converged result

<P> This contour is specified through <FONT size="+1"><tt>EMESH</tt></FONT>.
Breaking down the constituents of EMESH as autogenerated by <b>blm</b>:
<pre>
     EMESH={nz}          &larr;  number of energy points in the contour; {nz} evaluates 16 in this file
            10           &larr;  elliptical contour
            -1           &larr;  starting energy on the contour.  Must be deeper than the lowest state in the system (<A href="demos/asa-copt/out.lm#lastit">-0.776 Ry</A>)
           {ef}          &larr;  Fermi level determined by charge neutrality; see below
           0.5           &larr;  eccentricity of the ellipse ranging from 0 (circle) to 1 (line)
           0.3           &larr;  bunching parameter, bunching points near Ef. 0&rarr;no bunching
</pre>

We don't know what <i>E<sub>F</sub></i> is <i>a priori</i>.  In the ASA, a general reasonable guess is 0.
Since a band calculation was performed, we do know <i>E<sub>F</sub></i> generated by <b>lm</b>: it is <A href="demos/asa-copt/out.lm#lastit">&minus;0.12927&thinsp;Ry</A>.
<i>E<sub>F</sub></i> is fixed by charge neutrality.
If <b>lmgf</b> generates exactly the same spectrum as <b>lm</b>, and the <b>k</b>-integration were fully converged (or at least identical in the two cases)
<i>E<sub>F</sub></i> would be the same for <b>lm</b> as for <b>lmgf</b>.  Neither however, is the case and we can expect
the charge neutrality points will slightly different in the two methods.


<h3><A name="ef"></A>Finding <i>E<sub>F</sub></i></h3>

If <FONT size="+1"><tt>GF_MODE=1</tt></FONT>, <b>lmgf</b> will generate the
<i>Q</i><sub>0..2,&thinsp;<b>R</b><i>l</i></sub></A> for whatever <i>E<sub>F</sub></i> you give it.
However there is only one physcially meaningful <i>E<sub>F</sub></i> -- the one that satifies charge neutrality.

The input file is constructed so you can supply <i>E<sub>F</sub></i> through command-line argument <FONT size="+1"><tt>-vef=<i>expr</i></tt></FONT>: the preprocessor
evaluates &thinsp;<FONT size="+1"><tt>ef</tt></FONT>&thinsp; from  &thinsp;<FONT size="+1"><tt><i>expr</i></tt></FONT>,
substitutes it for &thinsp;<FONT size="+1"><tt>{ef}</tt></FONT>&thinsp; in the input file
<A href="file-preprocessor.html#expressions">(see expressions rule 3a)</A>.

<P> The simplest way to find the charge neutrality point is to run <b>lmgf</b> interactively in the self-consistent mode (<FONT size="+1"><tt>GF_MODE=1</tt></FONT>).
By running <b>lmgf</b> interactively you can monitor convergence.  Do:
<pre>
  lmgf ctrl.copt -vnit=30 --pr31,20 --iactiv -vef=-.1293
</pre>
You should see this table:
<pre>
 GFASA:  integrated quantities to efermi = -0.1293
     PL      D(Ef)      N(Ef)       E_band      2nd mom      Q-Z
 spin 1   11.461193   21.527368   -7.139484    2.654629    3.027368
 spin 2   79.615727   15.412515   -4.696215    1.699808   -3.087485
  total   91.076920   36.939883  -11.835699    4.354436   -0.060117
         deviation from charge neutrality: -0.060117
</pre>
Evidently <FONT size="+1"><tt>ef=-.1293</tt></FONT> results in a slight electron deficiency.
<b>lmgf</b> will estimate a constant shift to crystal potential to make the system neutral,
and interpolate <i>G</i> to contour adjusted by this shift using a Pade approximant.

<br> <FONT color="#33bb00"><I>*Note</I>&nbsp;</FONT>
<b>lmgf</b> shifts the average crystal potential:
<FONT size="+1"><tt>ef</tt></FONT>&thinsp; is kept fixed.

<P> <b>lmgf</b> prints out some results of the Pade correction in a subsequent table.
<pre>
 Corrections to integrated quantities estimated by Pade interpolation
     PL      D(Ef)      N(Ef)       E_band      2nd mom      Q-Z
 spin 1    8.860109   21.530130   -7.151567    2.654684    3.030130
 spin 2  110.802334   15.469870   -4.712054    1.700763   -3.030130
  total  119.662442   37.000000  -11.863621    4.355448    0.000000
         deviation from charge neutrality: 0
</pre>

<P> At the prompt you should see
<pre>
 QUERY: redo gf pass (def=F)?
</pre>
It is asking you whether you want to accept the Pade approximant, or
redo the GF calculation with the potential shift added.  Let's do the
latter, to see how good the estimate was.
<br> At the prompt type
<pre>
<FONT color="#555555"> QUERY: redo gf pass (def=F)? </FONT> <FONT color="#bb0000">st &lt;RET&gt; &lt;RET&gt;</FONT>
</pre>
After the cycle you should see
<pre>
  deviation from charge neutrality: 0.01565
</pre>
The Pade correction reduces the deviation from neutrality but overestimates the shift.  A new estimate is made for the potential shift
and the prompt reappears. You can repeat the GF cycle as many times as you like.
If you iterate enough you should see something like:
<pre>
 gfasa:  potential shift this iter = 0.000001.  Cumulative shift = -0.000429
</pre>
The shift of this last iteration is negligible.  &thinsp;`<FONT size="+1"><tt>Cumulative shift</tt></FONT>'&thinsp; is the
net shift accumulated over all the iterations.

<P> You can now
<A href="#vshft">proceed to self-consistency<sup>2</sup></A> but we will instead use
<A href="#lmgf">the potential generated by <b>lm</b></A> in order to make the
<A href="#exchange">exchange parameters</A>.

<P> At the prompt enter
<pre>
<FONT color="#555555"> QUERY: redo gf pass (def=F)? </FONT> <FONT color="#bb0000">a &lt;RET&gt; </FONT>
</pre>
to prevent <b>lmgf</b> from continuing its self-consistency cycle.

The constant potential shift is just the negative the the requisite Fermi level shift to achieve charge neutrality:
&thinsp;<FONT size="+1"><tt>ef</tt></FONT> needs to be adjsted to -0.1293&minus;(-0.000429) = &minus;0.1289&thinsp;Ry.

<P> To confirm that this is the correct &thinsp;<FONT size="+1"><tt>ef</tt></FONT>, repeat the interactive <b>lmgf</b> calculation with &thinsp;<FONT size="+1"><tt>-vef=-.1289</tt></FONT>.

<h2><A name="exchange"></A>Magnetic Exchange Interactions</h2>

The Heisenberg model is an empirical model that postulates a set of interacting rigid local spins.  The Hamiltonian is
<br> &emsp;&emsp;&emsp; <i>H</i> = &minus; &Sum;<sub><b>RR</b>'</sub> <i>J</i><sub><b>RR</b>'</sub> <b>S</b><sub><b>R</b></sub>&middot;<b>S</b><sub><b>R</b>'</sub>
<br>
The <i>J</i><sub><b>RR</b>'</sub> are called "Heisenberg exchange parameters." 
The Heisenberg applies to a system of rigid spins undergoing small excursions about equilibrium.  <b>R</b> and <b>R</b>' are any pair sites and
<i>J</i><sub><b>RR</b>'</sub> is a kind of magnetic analog to the dynamical matrix describing small oscillations of nuclei around their equilibrium point.
In a crystal with periodic boundary conditions
<i>J</i><sub><b>RR</b>'</sub> can be Bloch transformed to read: 
<br> &emsp;&emsp;&emsp; <i>J</i><sub><b>RR</b>'</sub>(<b>q</b>)  = &Sum;<sub><b>T</b></sub> exp(<i>i</i><b>q</b>&middot;<b>T</b>) <i>J</i><sub><b>R+T</b>,<b>R</b>'</sub>,
where <b>R</b> and <b>R</b>' are now confined to sites within a unit cell.
<br>

<P> <b>lmgf</b> calculates <i>J</i><sub><b>RR</b>'</sub>(<b>q</b>)
from the "Lichtenstein formula."  This <A href="#licht87">famous expression,</A><sup>3</sup> 
closely related the static transverse magnetic susceptibility &chi;<sup>+&minus;</sup>,
is derived from density functional perturbation theory.  It establishes a first-principles basis for the Heisenberg model.

One elegant (though approximate) feature of the ASA is that the magnetization is everywhere associated with an atomic sphere.
For local moment systems, the magnetization is well confined inside a sphere; thus associated with every site <b>R</b> there is a well defined local moment.
If sufficiently localized it rotates rigidly under the influence of an external perturbation.  The Lichtenstein formula is derived under these assumptions,
among others.<A href="#licht87"><sup>3</sup></A>

<P> When you set <FONT size="+1"><tt><A href="#gfcat">GF_MODE</A>=10</tt></FONT>,
<b>lmgf</b> will generate <i>J</i><sub><b>RR</b>'</sub>(<b>q</b>), and then perform an inverse Bloch transform (by Fast Fourier Transform)
to make <i>J</i><sub><b>R</b>+<b>T</b>,<b>R</b>'</sub> for as many lattice translation vectors <b>T</b> as there
are <b>k</b>-points.  In the present instance, calculate them with
<pre>
  lmgf -vgfmode=10 ctrl.copt -vef=-.1289
</pre>
Results are saved in file &thinsp;<FONT size="+1"><tt>jr.copt</tt></FONT> (see below).

<P> Most of the analysis is done in the next step, but already the output from &thinsp;<FONT size="+1"><tt>gfmode=10</tt></FONT>&thinsp; contains some useful information.
In the first of <A href="demos/asa-copt/out.lmgf.job10#j0">this pair of tables</A> you see
<i>J</i><sub>0</sub> and 2/3&thinsp;<i>J</i><sub>0</sub>.  <i>J</i><sub>0</sub> is the net Weiss magnetic field from the surrounding neighbors; 2/3&thinsp;<i>J</i><sub>0</sub> would be the (classical) mean-field estimate for the critical temperature <i>T</i><sub><i>c</i></sub> if there were one atom/cell.  
Since the Pt moment is very small it is weakly magnetic and has little effect on <i>T</i><sub><i>c</i></sub>.
In the second table <i>J</i><sub>0</sub> is decomposed into <i>lm</i> contributions.  As expected, the contributions to <i>J</i><sub>0</sub> originates almost entirely from the <i>d</i> states.

<P> If you run <b>lmgf</b> with  <FONT size="+1"><tt><A href="#gfcat">GF_MODE</A>=11</tt></FONT>, it reads &thinsp;<FONT size="+1"><tt>jr.copt</tt></FONT>&thinsp; and does some analysis with the parameters.  Invoke <b>lmgf</b> with
<pre>
  lmgf -vgfmode=11 ctrl.copt -vef=-.1289
</pre>

A unit cell of <i>N</i> sites has <i>N</i><sup>2</sup> pairs.
Thus &thinsp;<FONT size="+1"><tt>jr.copt</tt></FONT>&thinsp; holds a succession of <i>N</i><sup>2</sup> tables of <i>J</i>, one array
for each <b>RR</b>' pair in the unit cell.  Each array has <i>n</i><sub>1</sub><i>n</i><sub>2</sub><i>n</i><sub>3</sub> exchange parameters, corresponding to
the lattice translation vectors that follow from the Fast Fourier Transform of a <i>k</i> mesh of 
<i>n</i><sub>1</sub><i>n</i><sub>2</sub><i>n</i><sub>3</sub> points.  
You can find the headers for each array (headers follow a standard format this package uses) by doing:, e.g. : &thinsp;<FONT size="+1"><tt>grep rows jr.copt</tt></FONT> to see:

<pre>
  % rows 64 cols 8 real  rs  ib=1  jb=1
  % rows 64 cols 8 real  rs  ib=1  jb=2
  ...
</pre>
Each array has 64&times;8 entries, for <b>T</b> vectors derived from 8&times;8&times;8 <i>k</i>-points (the 3D array is stored in a 2D format).  <b>lmgf</b> 
unpacks these (<FONT size="+1"><tt>GF_MODE=11</tt></FONT>) and prints them out in a sequence of tables, e.g. 
<A href="demos/asa-copt/out.lmgf.job11#j23">this one</A> coupling all pairs of atoms belong to sites 2 and 3 in the unit cell.  Pairs are ordered by separation distance <i>d</i>.
Interactions fall off rapidly with <i>d</i>, and oscillate around 0, as might be expected from RKKY theory.
Then follow <A href="demos/asa-copt/out.lmgf.job11#meanfield">estimates for the critical temperature</A> <i>T<sub>c</sub></i>.  <i>T<sub>c</sub></i> is estimated
in Weiss mean-field theory, and also according to a spin-waves theory by Tyablikov (sometimes called the "RPA").  
Mean-field tends to overestimate <i>T<sub>c</sub></i>; RPA tends to be a little more accurate but
tends to underestimate it.  From these two estimates <i>T<sub>c</sub></i> should be around 1000K.

<IMG border-color:green height=20% width=20% ALIGN="right" style="border:20px solid white" SRC="demos/asa-copt/magnons-copt.gif"/>

<P> Next follows an estimate for the spin wave stiffness.  Finally because a symmetry lines file exists, copied previously from:
<pre>
  cp startup/syml.sc syml.copt
</pre>
<b>lmgf</b> reads this file and calculates the spin wave spectrum from the Heisenberg model, along the lines specified.  Results are saved in &thinsp;<FONT size="+1"><tt>bnds.copt</tt></FONT>&thinsp;
(the energy scale is now mRy).

<P> Plot magnon spectra using the same technology you use for
<A href="#bands">plotting energy bands</A>.  If you have the <b>plbnds</b> and <b>fplot</b> packages installed:
<pre>
  echo 0 350 5 10 | plbnds -scl=13.6 -fplot -lbl=X,G,M,R,G bnds.copt
  fplot -f plot.plbnds
</pre>
Rename this file to <FONT size="+1"><tt><i>some-name</i>.ps</tt></FONT> and use your favorite postscript reader to view it.  You should see something close to what is shown in the Figure.
Magnon energies are in meV. 

<P> <FONT color="#33bb00"><I>*Note</I>&nbsp;</FONT>
The 8&times;8&times;8 mesh is a bit coarse.  Use a finer <i>k</i> mesh for a smoother and more accurate magnon spectrum.

<P><br> <b>Notes</b>

<FN ID=INVIT><P>
<sup>1</sup>
One quirk <i>may</i> arise in this demo, depending on what compiler you use.  For some intermediate iteration to self-consistency
the inverse iteration algorithm used to diagonalize the hamiltonian may fail.
This does happen on rare occasions, but is of little consequence other than being a nuisance.
There are two workarounds:
<OL>
<LI> Insert this token in the &thinsp;<FONT size="+1"><tt>BZ</tt></FONT>&thinsp; category of &thinsp;<FONT size="+1"><tt>ctrl.copt</tt></FONT>:
<pre>
        INVIT=f # slows execution slightly, but algorithm is more stable.
</pre>
<LI> restart the <b>lm</b> calculation (which is what we do here)
</OL>
</FN>

<FN ID=vshft><P>
<sup>2</sup> If you do proceed to self-consistency using <b>lmgf</b>, note that it writes the potential shift and Fermi level to file
&thinsp;<FONT size="+1"><tt>vshft.copt</tt></FONT>.  This shift is automatically read when <b>lmgf</b> is restarted.
After self-consistency is reached you can
<i>either</i> keep &thinsp;<FONT size="+1"><tt>vshft.copt</tt></FONT>,
<i>or</i> remove the file and modify
&thinsp;<FONT size="+1"><tt>ef</tt></FONT>&thinsp;
so charge neutrality is satisfied without the shift.
</FN>

<FN ID=licht87><P>
<sup>3</sup> A. I. Liechtenstein, M. I. Katsnelson, V. P. Antropov, and V. A. Gubanov,
<i>Local spin density functional approach to the theory of exchange interactions in ferromagnetic metals and alloys</i>,
J. Magn. Magn. Mater. <b>67</b>, 65 (1987).  The authors were not aware of it at the time, but
this formula makes a "long wave approximation;" see
V. Antropov,
<i>The exchange coupling and spin waves in metallic magnets: removal of the long-wave approximation</i>,
J. Magn. Magn. Mater. <b>262</b>, l192 (2003).  The formula for <i>J</i>(<b>q</b>)
is exact (within the context of the ASA) only in the <b>q</b>&rarr;0 limit.
The ASA itself, and density-functional theory are other approximations implicit in the formula.
</FN>

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
</HTML>
