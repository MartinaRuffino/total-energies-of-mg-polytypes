This file is intended for anyone intending to understand or alter the code.

------------------- Programming style and documentation -----------------
The code is designed around several rules for uniform programming style:
(For historical reasons, some older routines don't follow these rules).

* Data is grouped into structures, whose elements are both declared and
  documented in file structures.h. (Caution: the Makefile is a bit wobbly
  when checking for dependencies on structures.h.  If you modify
  structures.h, it is safest to delete *.o */subs.a */*.mod and remake all
  binaries).

* Structures are not declared globally through modules, but are passed
  as arguments in subroutine calls.

* Subroutine arguments list inputs first followed by outputs : e.g. in
     subroutine evxcv(rho,rhosp,n,nsp,lxcf,exc,vxc)
  entries rho...lxcf are inputs; exc..vxc are outputs.

When you write a new routine, please adopt the convention described
below for comments that follow a subroutine declaration.

* At the start of the program:

- The first line after a subroutine or function declaration looks like
  C- a brief description of this subroutine

  This facilitates searching for something with the unix 'grep', e.g.
  grep -i '^C- .*symmetry' *.f

- Then follows a block with a brief description of inputs and outputs.
  There is a standard format, which labels inputs with 'Ci' outputs with
  'Co', and 'Cr' are for labeling additional Remarks; 'Cu' labels updates.

- Then follows variable declarations, with passed and local arguments
  separated.

  An emacs macro is available to do a big part of building this
  section automatically.  You can pick it up here:
    startup/fortran-list-subroutine-args.el

  For simple execution for a file foo.f in your top-level directory:
    1. emacs foo.f
    2. ESC-x load-file <ret> startup/fortran-list-subroutine-args.el
    3. ESC-x fortran-list-subroutine-args

  If your routine calls other routines, especially if it passes structures
  to them, it is better to allow this macro to pick up arguments in the
  routines called by your routine (and recursively in the routines they
  call).  To do this you need to create a tags table.  Procedure:
    1. zcat startup/tags.tar.gz | tar xvf -
    2. Edit the scripts; see esp v7input/dotags ...
       You will need to tailor the location of the slatsm directory.
    3. source doatags
    4. emacs foo.f
    4. ESC-x load-file <ret> startup/fortran-list-subroutine-args.el
    5. CTRL-U ESC-x fortran-list-subroutine-args

  This version will (recursively) find any reference to elements in
  structures passed to surbroutines it calls.

  Here is an example of the header style.

      subroutine mkgint(mode,s_ctrl,s_site,s_pot,s_ham,izp,wz,dz)
C- Conditionally-averaged GF for all DLM sites
C ----------------------------------------------------------------------
Cio Structures
Cio  s_ctrl :struct for program flow parameters; see structures.h
Ci     Elts read:  nbasp ldomg
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:*
Cio    Passed to:  *
Cio  s_site :struct for site-specific data; see structures.h
Ci     Elts read:  norb ncomp omgn omg
Co     Stored:     gc gcorr j0 sfvrtx
Co     Allocated:  sfvrtx
Cio    Elts passed:thet cpawt domg bxc gc gcorr j0 sfvrtx
Cio    Passed to:  *
Cio  s_pot  :struct for information about the potential; see structures.h
Ci     Elts read:  *
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:pf dpf ddpf
Cio    Passed to:  *
Cio  s_ham  :struct for parameters defining hamiltonian; see structures.h
Ci     Elts read:  ldham
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:*
Cio    Passed to:  *
Ci Inputs
Ci   mode  :1s digit
Ci         :0 use uncorrected omega
Ci         :1 calculate Lloyd correction (gcorr)
Ci         :10s digit
Ci         :0 make G only
Ci         :1 also make vertex for spin-flips.  See:
Ci            notes, K. Belashchenko dated 18 June 2012 and PRB 81, 064410
Ci   izp   :complex energy index for access to Omega
Ci   wz    :integration weight for this energy point
Ci   dz    :finite-difference delta z to calculate dOmega/dz
Ci         :(used only when calculating Lloyd correction to sev)
Co Outputs
Co   gc,gcorr,j0,sfvrtx are generated and stored in s_site
Cu Updates
Cu   06 Jan 13 Added capability to calculate spin flip vertex
Cu   18 Dec 12 Completed migration to F90 structures
Cu   25 Apr 12 (Belashchenko) CPA extended to treat chemical disorder
Cu   24 Dec 11 (Belashchenko) Complete rewrite
Cu   08 Dec 08 (P. Larson) First created
C ----------------------------------------------------------------------
      use structures
      implicit none
C Passed parameters:
      integer mode,izp
      double precision dz
      double complex wz
C ... For structures
!      include 'structures.h'
      type(str_ctrl)::  s_ctrl
      type(str_ham)::   s_ham
      type(str_pot)::   s_pot
      type(str_site)::  s_site(*)
C Local parameters:
       ...

- I prefer to delineate major blocks by comments containing '---' eg
C --- Vosko-Ceperley-Alder ---
C --- Hedin-Lundqvist ---
C --- Taken from ASW ---
C --- Vosko-Ceperley-Alder, spin polarized case ---
C --- Barth-Hedin ---

  and minor blocks by comments containing '...' eg
C ... Unpack arrays, now permuted and padded
C ... Shift doubly padded bas; repack

In this way major division can easily be found.  For example, there is
an emacs macro supplied in this directory (list-comment-lines.el) that
finds mode-specific comment lines (e.g. comments specific to C, TeX,
and fortran modes), and uses emacs 'Occur' mode to quickly enable one
to move to a block of interest.

- Any printouts should write to 'standard out' or 'standard log'
  and should have a verbosity check, e.g.  :

      call getpr(ipr)       <- Gets the "verbosity" set by the input file
                               (see slatsm iprint.f).
      stdo = nglob('stdo')  <- gets the logical unit for 'standard out'
      stdl = nglob('stdl')  <- gets the logical unit for the log file

      if (ipr >= 20 .and. ipr <= 30) then
        write (stdo,102)
      elseif (ipr >= 30) then
        write (stdo,103)
      endif

- Important information can be written in an abbreviated form
  to the log file (logical unit stdl).

- There is an 'info' subroutine that prints strings to standard
  output.  It is more versatile than the fortran 'write' statement.
  It is very useful if you want to make elegant, compact output.
  It is easiest just to copy from existing code; find them e.g. with
    grep 'call info2' */*.f

- When reading numerical input, consider using 'a2bin' or 'a2vec.'
  They allow algebraic expressions for input.  See, e.g. subs/suqlst.f.

------------------- Structures --------------------
Throughout this code, structures are always objects with labels s_xxx, e.g. s_ctrl or s_site.
This makes them easy to identify.

The structure elmements are all defined in a 'structures.h' in the top-level directory.
Note: if you change this file, you should recompile all object files.

I tried to follow C convention to the extent possible, avoiding shared state
in common blocks or modules. An exception is the input system, directory v7input,
which is independent of the rest of the code.  This required some
workarounds.  Structures are declared and elements documented in file
'structures.h'.

Two types of structures, s_site and s_spec, are actually allocated as
arrays of the basic structure: they contain data by site and species,
respectively.  Each of them is rather complex, as they are applied to
all branches of the code.

Regarding the site and species structures, sometimes
information is more convenient in vector form.  Use routine sitepack
(spec2class) tol pack or unpack an element from s_site (s_spec) into a
vector. (spec2class has some other options besides just packing and unpacking.)

Elements that are vectors or arrays must be allocated before use.
    if (.not. associated(s_bz%qp)) allocate(s_bz%qp(3*nq))
allocates s_bz%qp array as a vector of dimension 3*nq.

If you call the allocator for a pointer already allocated, it will
deallocate the current array before allocating a new one.  This makes
affairs simple, but be aware of what you are doing.

Multiple-dimensioned arrays are usually compressed into fewer dimensions, e.g. s_bz%qp
should be a two-dimensional array but is allocated as a single vector.

------------------- f77 Dynamic memory allocation --------------------
This code was originally written before fortran 90, and it originally
a form of adopted dynamic memory allocation in a fortran-77 compatible
way (described below).  The primary deficiency with the f77 style is
that arrays can only be allocated in a given routine, but used in the
allocating routine.  Most of the original f77-style dynamic allocation has been superseded,
but it still exists with a few packages (e.g. the molecules code)

This section documents the f77 style that still remains.

A large integer array (called 'w'), plays the role of the heap, is
defined at the beginning of the main program.  One declares an integer
array w of some (large) fixed size, and puts it in a common block /w/,
e.g.

      integer wksize
      parameter(wksize= 40 000 000)
      integer w(wksize)
      common /w/ w

To initialize the memory managment routines (see 'alloc.f' in the
slatsm library), invoke as one of the first executable statements:

      call wkinit(wksize)
      call wkfast(T)

NB: The second call isn't necessary, but the memory management
routines skip certain checks and they run faster.

Memory is allocated by taking pieces from this integer array in common
block 'w'.  To allocate memory of say size n, do one the following
(here oname and n are scalar integers):

      call defi (oname, n)    <- integer
      call defrr(oname, n)    <- double precision
      call defcc(oname, n)    <- double complex

Then w(oname) is the first element in the array.  Usually it isn't
useful directly (unless the array is an integer).  In practice you
allocate the memory in the routine that calls the one where you
actually need the array, and then you can use it as a 'normal' array
in the called routine.  Here is an example of allocation of a
two-dimensional array a2d(n,m):

      call defrr(oa2d, n*m)
      call mysub(w(oa2d),n,m)
      ...

      subroutine mysub(a2d,n,m)
      integer n,m
      double precision a2d(n,m)
      a2d(1,1) = 9
      ...

To free the memory, call 'rlse'.  subroutine rlse frees the array you
indicate, and all arrays allocated AFTER it.  Thus

      call defrr(ofirst,  m1)
      call defi (osecond, m2)
      call defcc(othird,  m3)

      call rlse(osecond)

allocates three arrays.  The 'rlse' command returns the memory allocated
for the second and third arrays to the heap.

Some other useful function calls:
  (a) 'wkchk' is for debugging: it runs through the links to ensure
      that none were overwritten.
  (b) 'defask' and 'wquery' return information about the amount of
      free memory and how much is used.
  (c) 'wkinfo' prints out all the arrays allocated and their memory
      used
  (d) Entries 'defsw', 'defps2', etc toggle the top two, three arrays
      or so on the stack
