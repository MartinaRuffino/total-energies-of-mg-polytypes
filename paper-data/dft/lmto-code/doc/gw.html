<!DOCTYPE html><html>

<head>
<title>GW driver</title>
<style>

/* For hyperlinks */
a:link {color:#FF0000;}      /* unvisited link */
a:link {color:#222288;}      /* unvisited link */
a:visited {color:#228822;}  /* visited link */
a:hover {color:#FF00FF;}  /* mouse over link */
a:active {color:#0000FF;}  /* selected link */
a:link {text-decoration:none;}
a:visited {text-decoration:none;}
a:hover {text-decoration:underline;}
a:active {text-decoration:underline;}

body {
       background-color:#ffffgg;
     }
 h1 {
      color:#880000;
      text-align:center;
      font-size:12px;
    }
 h2 {
      color:#bb3300;
      font-size:120%;
      font-weight:normal;
      font-style:italic;
    }

 h3 {
      color:#2255bb;
      font-size:110%;
      font-weight:normal;
      font-style:italic;
      text-indent: 0.5em;
    }

 h4 {
      color:#000000;
      font-size:100%;
      font-weight:bold;
      text-indent: 1.0em;
    }

 h5 {
      color:#444488;
      font-size:100%;
      font-weight:bold;
      font-style:normal;
      text-indent: 1.5em;
    }

  P {
<!--  font-family:"Times New Roman"; -->
<!--  font-size:12px; -->
<!--  color: red; -->
    }

  q {
      color: red;
    }

  a {
        color: blue;
    }

  tlarge {
       <font-size="+1">
    }

</style>

<!-- Enables the use of latex -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
<script type="text/javascript"
  src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

</head>

<h1><B><FONT size="+2">GW driver package (v7.10)</FONT></B></h1>

<h2>Purpose</h2>

This package coordinates with an all-electron <i>GW</i> package
written mainly by T. Kotani, including an implementation of
<A href=http://link.aps.org/doi/10.1103/PhysRevLett.96.226402> quasiparticle self-consistent <i>GW</i></A>
(QS<i>GW</i>) theory developed by the authors.

This package contains a driver <B>lmfgwd</B> that generates input the
<i>GW</i> code requires.  The <i>GW</i> code is a separate package,
and is not included here, though <i>GW</i> manual man033_ver1.pdf can
be found in this directory.  The driver is also designed to be used as
a driver to the Julich
<A href=http://www.flapw.de/pm/index.php?n=SPEX.Spex-Fleur>
spex <i>GW</i> code</A>, but this is still a work in progress.

Additionally <B><A href="fp.html">lmf</A></B> reads the
(energy-independent) self-energy as generated by the
QS<i>GW</i> implementation of the <i>GW</i> code.  This enables
<b>lmf</b> to do the same kinds of calculations as it performs with
the LDA potential, but substituting the QS<i>GW</i> self-energy for
the LDA exchange potential.  

<P>

QS<i>GW</i> theory is an elegant way to choose the optimum
noninteracting hamiltonian $H_0$ for <i>GW</i>
calculations, rather than using the LDA for $H_0$, as
is customary.  A particularly valuable property of this optimum
starting point is that the (real part) of the peaks of the interacting
Green's function <i>G</i> and the poles of $G_0$
coincide.  The eigenfunctions of $G_0$ are as close as
possible to those of <i>G</i>, by construction.  But what are poles in 
$G_0$ get broadened in <i>G</i> so quasiparticles lose
weight.  Thus the density-of-states, or spectral function, is composed
of a superposition of &delta;-functions for $G_0$, but
are broadened for <i>G</i>.  Also the eigenvalues acquire an imaginary
part, making the QP lifetime finite.

<P>

QS<i>GW</i> theory is described in some detail in
<A href=http://link.aps.org/abstract/PRB/v76/e165106>Phys. Rev. B<b>76</b>, 165106 (2007)</A>
including details of how
<b>lmf</b> is modified to use the QS<i>GW</i> self-energy, and how it
coordinates with the <i>GW</i> package.  Some <A href="#section3">modifications to the input file</A></B> are required
for <b>lmf</b> to read the QS<i>GW</i> self-energy.

<P> In QS<i>GW</i> theory $G_0$ and <i>G</i> are closely
linked.  Associated with the two kinds of <i>G</i> are two kinds of
density-of-states (DOS).  There is "noninteracting" or "coherent" DOS,
the spectral function of
$G_0$ which is what is usually associated with DOS, and what
is typically calculated by a band program such as <b>lmf</b>.  There is also the 
true DOS (spectral function of <i>G</i>) which is what is approximately measured by e.g. 
a photoemission experiment.  The <i>GW</i> package has a facility to
generate both kinds of DOS; through the 
<A href="#secmdos">normal <b>lmf</b> process</A> for the noninteracting DOS
or by analyzing the <A href="#sectiondos">spectral functions</A>.

<P> Once you have installed the executables, you can try out a 
<A href="Demo_QSGW_Si.html">demo LDA+QS<i>GW</i></A> calculation for Silcon.

<H2><A name="lmfgwd"></A>1. GW driver <b>lmfgwd</b></H2>

<P>

The GW driver package contains an executable <B>lmfgwd</B>, which acts
to set up input needed by the GW package.  Its structure is similar
to <b>lmf</b> but its function is to supply eigenfunctions and
eigenvalues, matrix elements of the LDA potential, etc., to
a <i>GW</i> package.  <B>lmfgwd</B> works either with standard
<A href="#section2"><B>one-shot <i>GW</i></B></A> where <i>G</i> and <i>W</i> are generated from LDA or LDA+U, and
<A href="#section2"><B>QS<i>GW</i></A></B>.

<P>

The <i>GW</i> codes that work with <b>lmfgwd</b> also have a feedback to
<B><Ahref="fp.html">lmf</A></B> and <b>lmfgwd</b>, to implement
QS<i>GW</i>.  In the QS<i>GW</i> mode, a (static, hermitian) file
&Sigma; is generated, which contains matrix elements of &Sigma; in the
basis used to generate it.  When placed into
file <FONT size="+1"><tt>sigm.<i>ext</i></tt></font> the
full-potential program <B>lmf</B> and the GW driver <B>lmfgwd</B> read
this potential and add it as an additional (static) potential to the
LDA potential.  In practice, $\Sigma{-}V^{\rm xcLDA}$ is stored
in <FONT size="+1"><tt>sigm.<i>ext</i></tt></font>.
See <A href="#readsig">Reading in the self-energy</A>.

<P>

Apart from these linkages, the <i>GW</i> package is completely
separate from the FP-LMTO program.  The <i>GW</i> package does not
depend on the input files <B>lmf</B> and <B>lmfgwd</B> use (e.g. <FONT
size="+1"><tt>ctrl.<i>ext</i></tt></font> and <FONT
size="+1"><tt>rst.<i>ext</i></tt></font>).

The <i>GW</i> code requires various kinds of input, most all of which 
is supplied automatically by <b>lmfgwd</b> through scripts that link the packages.
The <i>GW</i> package has has one additional input file,
<FONT size="+1"><tt>GWinput</tt></font>, which you must create.
<b>lmfgwd</b> can generate a template <FONT size="+1"><tt>GWinput</tt></font>, 
which is very useful since  <FONT size="+1"><tt>GWinput</tt></font> is a little complicated and rather unfriendly.
To make a template, invoke <B>lmfgwd</B> and enter &minus;1 when prompted for a job number.
You should then edit and modify this file.  To make this template <b>lmfgwd</b> will read input from an (optional) category
<FONT size="+1"><tt>GW</tt></font> in 
<FONT size="+1"><tt>ctrl.<i>ext</i></tt></font>.  Data from this
category modify the defaults that enter into generation
of <FONT size="+1"><tt>GWinput</tt></font>.

<P>

<b>lmfgwd</b> initially operates in the same manner as <b>lmf</b>.  After setting up the potoential
it prompts for a job, which tells <b>lmfgwd</b> what to do.

<UL>
<LI>
'Job &minus;1' generates <FONT size="+1"><tt>GWinput</tt></FONT>, as noted above.
<LI>
`Job 0'&nbsp; is an 'initializer' mode.  It creates input files the <i>GW</i> package requires:
<FONT size="+1"><tt>SYMOPS, LATTC, CLASS, NLAindx, ldima</tt></font>
<LI>
`Job 1'&nbsp; generates files required by the <i>GW</i> package (e.g. eigenfunctions, eigenvalues, and wave function information)
<LI>
'Job &minus;2' checks the <FONT size="+1"><tt>GWinput</tt></FONT> file for consistency.
</LI> </UL>

These steps must be peformed in a particular order to work with the
<i>GW</i> package.  For details, read the 
<B><A href="man033_ver1.pdf#"><i>GW</i> manual</A></B>.
Alternatively, scripts
<A href="#section2">lmgw</A> and 
<A href="#section2">lmgw1-shot</A> will carry out 1-shot <i>GW</i>
calculations and take care of linkages between the two packages.
Another script 
<A href="#section3">lmgwsc</A> carries out QS<i>GW</i>
calculations.  They are advanced versions of the simple scripts 
<FONT size="+1"><tt>gwsc1shot</tt></font> and 
<FONT size="+1"><tt>gwsc</tt></font> supplied in the <i>GW</i> package.

<P> <b>lmf2gw</b> is an additional program required to make the link to
the <i>GW</i> package.  It translates output of <b>lmfgwd</b> into a
format the <i>GW</i> package uses.  It should be compiled
automatically with the <FONT size="+1"><tt>--enable-gw</tt></font>
switch when you invoke <b>configure</b>.

<P> Finally, a pair of executables <b>spectral</b> and <b>lmfgws</b>
are included with this package that
generate <A href="#sectiondos">spectral functions</A>, either for
individual QP levels or integrated over the Brillouin zone to make the
density-of-states.

<h3><A name="gwtemplate"></A>1.1 Category <FONT size="+1"><tt>GW</tt></FONT> and its tokens</h3>

As noted, this category only affects <b>lmfgwd</b> when it creates a default <FONT
size="+1"><tt>GWinput</tt></font> for the user (job -1).  Invoke <b>lmfgwd</b> as usual, 
e.g. 
<pre>
  <b>lmfgwd</b> ext ...
</pre>
The standard input will prompt you for a job.  Enter -1.
<b>lmfgwd</b> will create a file <FONT size="+1"><tt>GWinput</tt></font>. 

<p>

The following tokens in the <A href="tokens.html#GWcat"><FONT size="+1"><tt>GW</tt></FONT> category</A> (if present
in your <FONT size="+1"><tt>ctrl</tt></FONT> file) will affect the contents of
<FONT size="+1"><tt>GWinput</tt></font>.
<pre>
 NKABC GCUTB GCUTX ECUTS NBAND NIME DELRE DELTA DELTAW GSMEAR PBTOL QOFFP MKSIG
</pre>
See the <A href="tokens.html#GWcat"><FONT size="+1"><tt>GW</tt></FONT> category in tokens.html</A>.

<H2><A name="section2"></A>2. One-shot <i>GW</i> calculations</H2>

The standard distribution has a script <FONT
size="+1"><tt>gw_lmfh</tt></font> to do one-shot calculations.  It is
described in the <i>GW</i> manual, e.g. man033_ver1.pdf.

This script is very simple, and its functionality is limited.  An
alternative, there are two scripts <b>lmgw</b> and <b>lmgw1-shot</b> that
facilitate calculations and the subsequent extraction of data.

<p>

<FONT size="+1"><tt>lmgw</tt></font>
is a multipurpose script that exercises the <i>GW</i> codes in
many kinds of modes; in particular it can be used in one-shot calculations.
Invoke lmgw without arguments to see what options are available.
The following is a typical invocation:
<pre>
   lmgw --insul=19 --ht srtio3
</pre>

It calculates the QP energies as a 1-shot perturbation given an LDA
pair of input files <FONT size="+1"><tt>ctrl.<i>ext</i></tt></font> and
<FONT size="+1"><tt>rst.<i>ext</i></tt></font>,
and file <FONT size="+1"><tt>GWinput</tt></font>.  There is an optional file 
<FONT size="+1"><tt>`switches-for-lm,'  </tt></font> that 
<b>lmgw</b> will use, if it is supplied.  File
<FONT size="+1"><tt>switches-for-lm</tt></font> should contain only one line.
Its contents are passed to <b>lmf</b> and <b>lmfgwd</b> as command-line arguments.

<P>

<b>lmgw</b> will carry out all the steps required for a one-shot
calculation.  The main results are kept in files <FONT
size="+1"><tt>TOTE2.UP</tt></font> (and <FONT
size="+1"><tt>TOTE2.DN</tt></font> in spin-polarized cases) and in a
more readable format in files <FONT size="+1"><tt>QPU</tt></font> (and
<FONT size="+1"><tt>QPD</tt></font> for spin-polarized calculations).

<P>

<b>lmgw1-shot</b> is a higher level script that calls <b>lmgw</b>.  It
greatly facilitates the exercising of <b>lmgw</b> by copying files in
and out of directories to enable batch runs.  <b>lmgw1-shot</b> calls extra
scripts:
<UL>
<LI>
<b>infgw</b> extracts timing and other data from output files, and
extracts QP levels into an easy-to-extract format.  Using this
script, <b>lmgw1-shot</b> extract QP data and stores it into file dat.
<LI>
<b>savegwfiles</b> copies selected files in and out of subdirectories.
<LI>
<b>gw-extract-prodbas-and-time-from-output</b> need not be installed.
If it is, it prints out out the size of the LMTO and product bases,
and execution times.
<LI>
<b>xqp</b> is not normally invoked by <b>lmgw1-shot</b>, so you need not
have it installed.  <b>xqp</b> is very useful post-processing script,
however: it formats the results in an easy-to-read manner.  It has
several modes, e.g. it can compare the differences in QP levels from
data in two directories.  For <b>xqp</b> to work, you must have
installed the matrix calculator program
<b>mcx</b>. 
</LI> </UL>

<FONT size="+1" color="#bb3300"><FONT size="+1"><i>Example</i></FONT></FONT>&nbsp;

Assess the effect of floating orbitals on the QP states in SRTiO<sub>3</sub>.

<P>
Prepare two directories, <FONT size="+1"><tt>NOFLOAT</tt></font> and
<FONT size="+1"><tt>FLOAT</tt></font>.  Each directory should contain
its respective <FONT size="+1"><tt>GWinput'</tt></font>, <FONT
size="+1"><tt>switches-for-lm'</tt></font>, (or distinct files <FONT
size="+1"><tt>ctrl.srtio3</tt></font>) and distinct <FONT
size="+1"><tt>rst.srtio3</tt></font>).  The two directories serve as
distinct input streams, in this case to two different LMTO basis sets:
one containing floating orbitals and the other not.  (Obviously you
can make other kinds of variations such as vary entries in <FONT
size="+1"><tt>GWinput'</tt></font>).

<P> Do the 1-shot calculations:

<pre>
   lmgw1-shot --autoht --infgwx --insul=19 -job= FLOAT srtio3
   lmgw1-shot --autoht --infgwx --insul=19 -job= NOFLOAT srtio3
</pre>

<FONT size="+1"><tt>--insul=19 </tt></font> tells <b>lmgw</b> to
define the zero at the 19th band.  (The <i>GW</i> code always uses a
particular level at the <font face="Symbol">G</font> point,
i.e. <b>q</b>=0, in this case the level 19, for the reference).

<p>
Invoke <b>lmgw1-shot</b> with no arguments to see what the rest of the switches mean.

<p>
<b>lmgw1-shot</b> puts new files into directories
<FONT size="+1"><tt>NOFLOAT</tt></font> and
<FONT size="+1"><tt>FLOAT</tt></font>, e.g files:
<pre>
   ctrl.preprocessed.srtio3 GWinput switches-for-lm TOTE.UP dat job QPU TOTE2.UP version rst.srtio3
</pre>

Use <b>xqp</b> to retrieve data in a pretty format.  This command
generates QP data for levels 1,2,6,9,12,15,18,20 in 3 groups of 3:
<pre>
   xqp -lda -lst=1,2,6,9,12,15,18,20 -eshft=-.36,-.36,-.35 -qp=0.00,0.00,0.00 -qp=0.50,0.50,0.50 -qp=0.50,0.00,0.00 FLOAT
</pre>
Output:
<pre>
    qp=0.00,0.00,0.00      qp=0.50,0.50,0.50   qp=0.50,0.00,0.00 
    eQP  eQP(noZ) eLDA    eQP  eQP(noZ) eLDA    eQP eQP(noZ)  eLDA
  -32.70 -32.87 -32.49  -33.43 -34.46 -32.43  -33.14 -33.64 -32.57
  -33.43 -34.49 -32.36  -33.43 -34.46 -32.43  -33.42 -34.48 -32.36
  -16.99 -17.66 -16.13  -17.04 -17.66 -15.74  -16.97 -17.63 -16.09
  -15.65 -15.91 -14.53  -15.99 -16.24 -14.82  -15.59 -15.85 -14.48
   -3.00  -3.09  -2.85   -3.97  -3.87  -4.21   -3.01  -3.08  -2.89
   -1.25  -1.27  -1.21   -3.65  -3.59  -3.79   -2.30  -2.25  -2.41
   -0.36  -0.36  -0.35    0.00   0.00   0.00   -0.77  -0.79  -0.73
    3.81   4.53   1.77    6.41   7.39   4.48    4.02   4.77   1.95
</pre>

The <FONT size="+1"><tt>-eshft</tt></font> switch was necessary here
because the QPU generator shifts the energy zero around by assuming
the VBM is at Gamma; for SrTiO<sub>3</sub> the VBM falls at
(1/2,1/2,1/2).

To see the difference in the two QP calculations, invoke <b>xqp</b> with two
directories as:

<pre>
   xqp -lda -lst=1,2,6,9,12,15,18,20 -qp=0.00,0.00,0.00 -qp=0.50,0.50,0.50 -qp=0.50,0.00,0.00 FLOAT NOFLOAT
</pre>

Output:
<pre>
    qp=0.00,0.00,0.00      qp=0.50,0.50,0.50   qp=0.50,0.00,0.00 
    eQP  eQP(noZ) eLDA    eQP  eQP(noZ) eLDA    eQP eQP(noZ)  eLDA
    0.09   0.13   0.01    0.06   0.09   0.01    0.08   0.11   0.01
    0.06   0.08   0.01    0.06   0.09   0.01    0.06   0.08   0.00
    0.06   0.06   0.00    0.06   0.07   0.00    0.05   0.07   0.00
    0.05   0.07   0.01    0.05   0.07   0.01    0.05   0.07   0.01
    0.01   0.01   0.00    0.01   0.00   0.01    0.01   0.00   0.00
   -0.02  -0.02  -0.01    0.01   0.00   0.01    0.00  -0.01   0.01
    0.00   0.00   0.00   -0.01  -0.02   0.00    0.00  -0.01   0.00
   -0.03  -0.03  -0.01   -0.02  -0.03   0.00   -0.02  -0.04   0.00
</pre>

In the SrTiO<sub>3</sub> case, floating orbitals don't matter much.

<p>

Run <b>xqp</b> with no arguments to see other options.  


<H2><A name="section3"></A>3. Quasiparticle self-consistent <i>GW</i> (QS<i>GW</i>) calculations</H2>

<P> To perform QS<i>GW</i> calculations, simple shell scripts
<b>gwsc1shot</b> and <b>gwsc</b> supplied in the <i>GW</i> package,
and how to use them is documented in the <B><A
href="man033_ver1.pdf#"><i>GW</i> manual</A></B>.

Alternatively, a high-level script <b>lmgwsc</b> can be used.  It
calls <A href="#section2">lmgw</A> for a single
iteration, then performs some checks, and calls <b>lmgw</b> again,
cycling through iterations until convergence or the maximum number of iterations is reached.  
Convergence is checked by monitoring the RMS change in &Sigma;
and will stop iterating when a certain tolerance is met. 
<b>lmgwsc</b> `iteration 0' is approximately like
<b>gwsc1shot</b>, except that the full &Sigma; is made (including the
off-diagonal parts).
<b>lmgwsc</b> corresponds to <b>gwsc</b> in subsequent iterations.
Invoke <b>lmgwsc</b> without arguments to see the various options.

<H3><A name="siginput"></A>3.1 Additional input for reading the QS<i>GW</i> self-energy &Sigma;</H3>

To read the the self-energy from file <FONT
size="+1"><tt>sigm.<i>ext</i></tt></font>, you must add a token to category
<FONT size="+1"><tt>HAM</tt></FONT>.

<pre>
  RDSIG=   token specifying whether to read the self-energy generated
           by the GW package and add to to the LDA hamiltonian.
           The argument of RDSIG= consists of three digits:
           1s digit specifies whether to read &Sigma; from file sigm.<i>ext</i>.
               0  : do not read &Sigma; 
               1  : read sigma but not symmetrize it
               2  : read sigma and symmetrize using given <A href=tokens.html#SYMGRPcat>symops.</A>

           10s digit interpolation mode; see <A href="#sigintrp">Notes on interpolation of &Sigma;</A>
               0  : Simple bloch sum of sigma
               1  : (strongly recommended) approx high-energy states
                    with diagonal part of sigma.
               2  : perturbation approach (not documented)
               3  : Linear interpolation of sigma from neighboring points
                    (not documented)

          100s digit is specific to 10s digit = 2.  It specifies how many
               neighboring points should be included in the interpolation.
               Choosing 0 causes the program to choose the default value of 4.

        10000s digit has to do with symmetry operations and how
               lattice vectors are assembled.

               1 Tells <b>lmf</b> that <FONT size="+0"><tt>sigm.<i>ext</i></tt></FONT> contains no
                 symmetry operations.  Equivalent to --rsig:fbz.

               2 tells <B>lmf</B> not to augment the standard nk1&times;nk2&times;nk3
                 lattice translation vectors that would follow from
                 standard inverse fast fourier transform.  By default
                 some extra vectors are added to make the system
                 compatible with symmetry operations.  If you use this
                 option, you cannot symmetrize sigma.

               4 warning on file <I>k</I>-point mismatch.  Normally
                 a check is made that the <I>k</I>-points read from <FONT size="+0"><tt>sigm.<i>ext</i></tt></FONT>,
                 match <I>k</I>-points in the list of irreducible <I>k</I>-points constructs itself.
                 By default the program will abort if a mismatch is found.
                 Use this switch when, e.g. you deform a lattice slightly and want to
                 use estimate sigma from the sigma for the original lattice.
                 
                 Linear combinations of these switches are allowed.

  RSRNGE=  token specifying the maximum range of the r.s. sigma (units of alat)
           computed by Bloch transform of &Sigma;(k) generated by the GW package (see <A href="#readsig">below</A>).

</pre>

<H3><A name="readsig"></A>3.2 Reading in the self-energy &Sigma;</H3>

The self-energy &Sigma;(<B>k</B>) (actually &Sigma;&minus;</font><i>V</i><sup>xc</sup><sup>LDA</sup>) is
generated by the <i>GW</i> package on a mesh of points in the
irreducible Brillouin zone (BZ).  When this information is stored in
file <FONT size="+1"><tt>sigm.<i>ext</i></tt></font>, it can be read by
<b>lmf</b> and
<b>lmfgwd</b>, and added to the LDA one-particle potential, cancelling </font><i>V</i><sup>xc</sup><sup>LDA</sup>.
When reading this file &Sigma; is rotated to the
entire BZ and then inverse Fourier (Bloch) transformed into a
real-space form &Sigma;(<B>T</B>).  Thus, &Sigma;(<B>T</B>) can be computed at any <b>k</b>-point, so 
<b>lmf</b> can work in the just the same way in using a QS<i>GW</i>
potential as it does an LDA potential.  This is a crucial advantage of
the present implementation.   The output from <b>lmf</b> indicating that
the Bloch transformed has been effected looks like the following:
<pre>
   q-points in full BZ where sigma calculable ...
   BZMESH:  18 irreducible QP from 18 ( 3 3 2 )  shift= F F F
   Irr. qp for which sigma is calculated ...
   BZMESH:  6 irreducible QP from 18 ( 3 3 2 )  shift= F F F
   hft2rs created hrs:  ndhrs=29  max Re(hrs) = 1.21  max Im(hrs) = 6e-4
</pre>


The correctness of this inverse FT is checked by computing the Forward
FT of &Sigma;(<B>T</B>) at the known
<B>k</B>-points; and the difference in the two is printed in the lines
<pre>
   comparing s(iq) to interpolated sq for iq=   1  errmx= 5.6E-17 at i,j=  30  30
   comparing s(iq) to interpolated sq for iq=   2  errmx= 6.2E-17 at i,j=  34  34
   ...
</pre>

The error should be approximately that of machine precision.  Next, if
you so specify (see token <FONT size="+1"><tt>RDSIG</tt></font>),
<B>lmf</B> will symmetrize &Sigma;(<B>T</B>)
according to the given group operations; the difference in the file
&Sigma;(<B>k</B>) and FT of the symmetrized &Sigma;(<B>T</B>) is checked once again.  Because of
small numerical errors in the generation of &Sigma;, the symmetrized &Sigma;
will differ a little from the unsymmetrized one.  <FONT
size="+1"><tt>"maximum error"</tt></font> in the following output
indicates the effect of symmetrization:
<pre>
   rsmsym: symmetrizing complex s(1..1704) using 8 group operations
   symstr: max asymmetry = 7.93e-7
   check FT s(R) against s(q) ... maximum error = 6.2e-5
   check FT s(R) against s(q) ... maximum error = 6.2e-5 spin 2
</pre>

<H3><A name="lcsigma"></A>3.3  Taking a linear combination of two &Sigma; files</H3>

You can read self-energies from two distinct files and
add them in a linear combination.  Usually &Sigma; is read from file
<FONT size="+1"><tt>sigm.<i>ext</i></tt></FONT>.  You can read &Sigma; as some linear combination of 
<FONT size="+1"><tt>sigm.<i>ext</i></tt></FONT> and <FONT size="+1"><tt>sigm1.<i>ext</i></tt></FONT> as
<pre>
    sigma = alpha*(sigm.<i>ext</i>) + beta*(sigm1.<i>ext</i>)
</pre>
by invoking <b>lmf</b> with
<pre>
   --mixsig=alpha,beta
</pre>
If second parameter is missing, the effect is to read
<FONT size="+1"><tt>sigm.<i>ext</i></tt></FONT> scaled by factor alpha.

<H3><A name="secmdos"></A>3.4 Generating <i>m</i>-resolved $G_0$ DOS</H3>

The <i>GW</i> package provides a facility to calculate DOS either
<A href="#sectiondos">from <i>G</i></A>, or from $G_0$.  Using <i>GW</i> for latter is possible but
unecessarily complicated, as <b>lmf</b> accomplishes the same thing.
Furthermore <b>lmf</b> enables you to
<A href=generating-density-of-states.html>decompose the DOS</A> in
various ways.  When <b>lmf</b> is run with &Sigma; matrix elements
included you recover the $G_0$ DOS from QS<i>GW</i>.

<P>

<b>lmf</b>'s current implementation does not allow you to generate <i>m</i>-resolved 
$G_0$ DOS with symmetry operations turned on.  To work
properly eigenfunctions must be rotated to the full BZ from the
irreducible set to integrate an individual <i>m</i> component of the DOS over the BZ.
Since this has not been implemented, you must turn of symmetry operations.
To do this when including &Sigma;, you must do the following:

<pre>
1.  Create a self-energy file (<FONT size="+0"><tt>sigm.<i>ext</i></tt></FONT>) without symmetry.
    Do this by invoking <A href="#sigmavariants">lmf --wsig:fbz ...</A> .
    This will cause <b>lmf</b> to write a new file sigm2.<i>ext</i> with the
    same structure as <FONT size="+0"><tt>sigm.<i>ext</i></tt></FONT>, but generated for points
    in the entire BZ.

2.  copy sigm2.<i>ext</i> to sigm.<i>ext</i>.  
    (Note: you will probably want to preserve the original file!)

3.  Turn off symmetry operations in your ctrl file, to make the irreducible <i>k</i>-points
    correspond to the the entire BZ, e.g. add a line
      SYMGRP E
</pre>
This should enable you to generate partial DOS in the same manner as is done for the LDA, described
<A href=generating-density-of-states.html>here</A>.

<H3><A name="sigmavariants"></A>3.5 Forms of the &Sigma; file</H3>

File <FONT size="+1"><tt>sigm.<i>ext</i></tt></FONT> may have special formats or conditions,
which you can specify with the <FONT size="+1"><tt>--rsig</tt></FONT> switch.

<P>

The full syntax is:
<pre>
  --<B>rsig[~ascii][~rs][~fbz][~shftq[=#,#,#]</B>
</pre>
Note: delimiter <FONT size="+1"><tt>`:'</tt></FONT> separating options can actually be any ascii character,
e.g. <FONT size="+1"><tt>`^'</tt></FONT>.  (Sometimes you can't use <FONT size="+1"><tt>`:'</tt></FONT> as the delimiter because it
may used in one of the arguments, and you will confuse the parser.)

<pre>
 ~ascii Data is read in ascii format from file sigma.<i>ext</i> (default is binary)

 ~rs    Sigma is stored on disk in real space.  The inverse Bloch sum has already been performed.

        If either of the preceding two switches is used, the file name changes to:
                      k-space  real-space
            binary     sigm      sigmrs
            ascii      sigma     sigmars

 ~fbz   flags lmf that the sigma file contains no symmetry operations.  
        Equivalent to setting 10000s digit=1 in token RDSIG= .
        (Not meaningful if the ~rs switch is used)

 ~shftq=#,#,# tells the program that &Sigma;(<B>k</B>) stored in file 'sigm'
        was generated on a kmesh offset by #,#,#
 ~shftq without arguments performs the same function; the offset is taken from a default.

</pre>

<H3><A name="wsig"></A>3.6 Modifications to the static &Sigma; file: the <FONT size="+1"><tt>--wsig</tt></FONT> switch</H3>

<FONT color="#33bb00"><I>*Note</I>&nbsp;</FONT> This section needs updating.<P>

You can manipulate the static &Sigma; file in various ways.  To do this,
include <FONT size="+1"><tt>--wsig</tt></FONT> on the command line:
<b>lmf</b> will write an output &Sigma; file, usually named  <FONT size="+1"><tt>sigm2.<i>ext</i></tt></font> 
so as not to overwrite existing files.  Whenever it writes a file
<B>lmf</B> exits without further processing.

<P>
There are two self-energy editors corresponding to the two forms of self energy in QS<i>GW</i>:
see the 
<A href="siged-tutorial.html">tutorial for analysis and manipulation of these forms</A>.

You can use this <FONT size="+1"><tt>--wsig</tt></FONT> to generate, for example, a properly symmetrized
self-energy (see <A href="#siginput"><FONT size="+1"><tt>RDSIG</tt></font></A>).

<P>

Additionally you can make several modifications that change what is written to
<FONT size="+1"><tt>sigm2.<i>ext</i></tt></font>, though switches passed with <FONT size="+1"><tt>--wsig</tt></FONT>.

The full syntax is, with available options:
<pre>
  --<B>wsig[:fbz][:newkp][:onesp][shftq[=#,#,#]][:rot=rotation-string][:edit][:phase][:trans=#]</B>
</pre>
Note: delimiter <FONT size="+1"><tt>`:'</tt></FONT> separating options can actually be any ascii character,
e.g. <FONT size="+1"><tt>`^'</tt></FONT>.  (Sometimes you can't use <FONT size="+1"><tt>`:'</tt></FONT> as the delimiter because it
may used in one of the arguments, and you will confuse the parser.)

<P>
The options do the following

<pre>
 :fbz   causes <B>lmf</B> to ignore symmetry operations and generate a sigma
        file for k-points in the entire BZ.  It is useful when generating a
        sigma file that allows fewer symmetry operations, e.g. when making the
        <A href="#sigintrp"><I>m</I>-resolved density-of-states</A>, or creating a <A href="#sigmavariants">trial <FONT size="+1"><tt>sigm.<i>ext</i></tt></FONT> for a sheared crystal</A>.
        Note: to <I>read</I> a sigm file generated by <FONT size="+1"><tt>--wsig:fbz</tt></FONT>, set 
        the 10000's digit in token <A href="#sigmavariants">RDSIG</A>, or use <FONT size="+1"><tt>--rsig:fbz</tt></FONT>

 :ascii <FONT size="+1"><tt>sigm2.<i>ext</i></tt></FONT> will be written in ascii format

 :newkp causes <B>lmf</B> to use the mesh used by the lmf program.  By default
        <B>lmf</B> generates sigm on the mesh as defined in the sigm file.
        This switch enables the user to interpolate the sigma to a new <B>k</B> mesh.

 :onesp (for spin-polarized case) causes <B>lmf</B> to average the up- and down-
        self-energies, and write a nonmagnetic self-energy to disk.

 :shftq=#,#,# is used in conjunction with trans=#, where #=1,2,3; see below.
        It flags that an offset of #,#,# should be added to the standard <i>k</i> mesh
        when generating transformed &Sigma;.
        to avoid inadvertant swap of (nearly) degenerate LDA eigenvalues as the LDA basis
        set is changed.  (The scheme requires that eigenvalues in the two basis sets
        synchronize in the energy range of interest).

 :rot=rotation-string causes <B>lmf</B> to rotate sigm to a coordinate
        system, whose rotation is specified by 'rotation-string'.
        Here is an example :
             lmf si --wsig^rot=z:.1,y:2,z:.3
             cp sigm2.si sigm.si
             ... Edit the STRUC category to include ROT=z:.1,y:2,z:.3 and then do:
             lmf si --rs=101

        Points to note:

        1. Switch --rs=101 tells lmf to rotate the local charge density read from
        the restart file.

        2. Note the use of caret (^) as delimiter, since (:) is needed in the string

        3. <B><A href="rotations.html">rotations.html</A></B> describes how to specify a rotation.

        4. Be advised that the interpolation may not proceed in exactly
        the same way in the rotated and unrotated systems, owing to different
        sets of lattice vectors taken for large r.  To minimize these differences,
        work with a symmetrized self-energy as much as possible, and
        read the density (and lattice positions) from the same restart file.

        The example below follows the recommended procedure. The STRUC
        category of input file <B>ctrl</B>.si has this segment:
          %ifdef rot
                  ROT=z:.1,y:2,z:.3
          %endif
        which applies a rotation when variable <I>rot</I> is nonzero.
        Also the HAM category has token <B>RDSIG</B>=<I>sig</I>. 

          ... first step symmetrizes sigma
          lmf si -vsig=12 -vrot=0 --wsig
          cp sigm2.si sigm.si

          ... this pass in the unrotated coordinated system
          lmf si -vsig=12 -vrot=0 

          ... should match this pass in the rotated coordinated system
          lmf si -vsig=12 --rs=101,0 -vrot=0 --wsig^rot=z:.1,y:2,z:.3
          cp sigm2.si sigm.si
          lmf si -vsig=12 --rs=101,0 -vrot=1 

 :trans=# is designed to enable transformations of &Sigma;(<B>k</B>) 
        to new basis sets.

        trans=1 causes <B>lmf</B> to read &Sigma;(<B>k</B>) (file sigm) in its usual form (orbital basis)
        and transform it to the LDA basis. &Sigma;<sup>LDA</sup>(<B>k</B>) is written to file sigm2.

        trans=2 is similar, but the high-energy part of &Sigma;<sup>LDA</sup>(<B>k</B>) is replaced before
        it is written, as described <A href="#sigintrp">here</A>.

        trans=5  also substitutes the high-energy part of &Sigma;<sup>LDA</sup>(<B>k</B>), but stores
        &Sigma;(<B>k</B>) in the orbital basis.

        trans=3 causes <B>lmf</B> to generate and LDA eigenfunctions <i>Z</i><sup>LDA</sup>(<B>k</B>) and store them
        in file 'evec.'  &Sigma;(<B>k</B>) is not used in this mode; file sigm is not touched. 
        Note: you must run trans=1 first because it generates a list of k-points.
        
        trans=-1 reads &Sigma;<sup>LDA</sup>(<B>k</B>) from file 'sigm2' and <i>Z</i><sup>LDA</sup>(<B>k</B>) from file 'evec'
        and generates &Sigma;<sup>orb</sup>(<B>k</B>), i.e. &Sigma; in the usual orbital basis.
        The transformed file is written into file '<FONT size="+1"><tt>sigm3</tt></FONT>'.

        The following sequence should: make sigma(LDA) and evec, and then transform sigma(LDA)->sigm(orb)
        It should recover the original sigm file (apart from numerical imprecision).

        doing nothing (except for roundoff errors)
          <b>lmf</b> ext --wsig:shftq:fbz:trans=1
          <b>lmf</b> ext --wsig:shftq:fbz:trans=3
          <b>lmf</b> ext --wsig:trans=-1
          cp sigm3.<i>ext</i> sigm.<i>ext</i>
        ... run with:
          <b>lmf</b> ext --rsig:fbz:shftq 

        However, you can change the orbital basis between lmf invocations, thus
        transforming sigm to a new orbital basis.
        The following is the recommended way to remake sigm in a new basis
          lmf ext -vsig=12 --rs=1,0 -vnit=1 -vemaxs=2 --pr45 --wsig:trans=5
          cp sigm2.<i>ext</i> sigm.<i>ext</i>
          cp sigm.<i>ext</i> sigm.<i>ext</i>~
          <b>lmf</b> ext --wsig:shftq:fbz:trans=1
        ... change basis set in input file         
          <b>lmf</b> ext --wsig:shftq:fbz:trans=3
          <b>lmf</b> ext --wsig:trans=-1
          cp sigm3.<i>ext</i> sigm.<i>ext</i>
        ... run with:
          <b>lmf</b> ext --rsig:fbz:shftq         

         For an example, after running test 
           gw/test/test.gw si
         Do:
           cp gw/test/si/sigm.si .
           rdcmd '-f:#rdcmd:%2f' -cat:TSIGT --noerr ctrl.si > out.trans.si

 :edit  invokes an interactive editor that allows you to modify
        elements in the sigma file

 :phase causes <B>lmf</B> to scale rows and columns associated with particular
        sites in the sigm matrix by a <B>q</B>-dependent phase.  This is
        because in the standard FP program <B>lmf</B>, the structure matrix
        is computed by Ewald sums which contain extra site-dependent <B>R_j</B>
        and <B>q</B>-dependent phases 
             exp(i <B>q.R_j</B>)
        in when summing over sites <B>R_j</B> in the lattice.  The
        coordinates R_j are internally shifted automatically by some
        combination of lattice vectors, to shorten their length and
        avoid convergence problems in the Ewald sum.

        For that reason, when using the sigm file generated by
        rot=... , the user is strongly advised to construct the
        input file and its basis vectors in the unrotated coordinate
        system, and rotate the lattice and basis vectors through the
        <B>ROT=</B> token in the <A href="lmto.html#STRUC"><B>STRUC</B></A> category.
        (The syntax for this string is identical to :rot= above.)
        Additionally, the site positions should be read through the
        rst file, as they will not be further shortened by <B>lmf</B>.

        Use option :phase if for some reason you do change the
        shortening of lattice vectors.  For this option to work, the
        translation vectors must be supplied in a file
        <B>shorps</B>.<i>ext</i>.   <B>lmf</B> reads this file and scales
        sigm accordingly.

        You can create file <B>shorps</B>.<i>ext</i> by hand, or do it automatically.
        Either way, you must coordinate the positions <B>lmf</B>
        actually uses with the sigm file.

        To generate file <B>shorps</B>.<i>ext</i> automatically, you can invoke <B>lmf</B>
        with the switch --<B>shorps</B>, which, after reading site positions from
        file <B>rst</B>.<i>ext</i>, further shortens the site positions and saves
        the lattice translations used for shortening in <B>shorps</B>.<i>ext</i>.
        Take care to rewrite file <B>rst</B>.<i>ext</i>, e.g. by invoking
        <B>lmf --shorps ...</B> with no iterations.

        Once <B>shorps</B>.<i>ext</i> is created, you can generate a new sigma:
          <B>lmf --wsig:phase ...</B>
          <b>cp sigm2.<i>ext</i> sigm.<i>ext</i></b>

        With both files <FONT size="+1"><tt>rst.<i>ext</i></tt></FONT> and <FONT size="+1"><tt>sigm.<i>ext</i></tt></FONT> altered,
        <B>lmf</B> should generate identically the same eigenvalues
        and output density.

</pre>

<H4><A name="wsig.1"></A>Example:&nbsp; adapting a &Sigma; file to a symmetry-lowering shear distortion</H3>

Two changes have to be made to <FONT size="+1"><tt>sigm.<i>ext</i></tt></font>.
<P>
1. Because the starting <FONT size="+1"><tt>sigm.<i>ext</i></tt></font> has higher symmetry than the case
of interest, the new <FONT size="+1"><tt>sigm.<i>ext</i></tt></font> may require more irreducible <I>k</I>-points.
<P>
2. The
sigma file reader will by default require the <I>k</I> points in the
file correspond to the <I>k</I> points generated by <B>lmf</B>.  This will no
longer be the case if you want to adapt <FONT size="+1"><tt>sigm.<i>ext</i></tt></font> to a distorted mesh.

<P>

Supposing for definiteness that your input file has token <FONT
size="+1"><tt>RDSIG</tt></font> set by variable sig and that you want
to make a shear distortion along the [001], which you control by
variable tet:
<pre>
  HAM  RDSIG=sig
  STRUC SHEAR=0 0 1 tet
</pre>

<P>

To solve problem 1 above, generate a new <FONT size="+1"><tt>sigm.<i>ext</i></tt></font> on a mesh without any symmetry operations:
<pre>
  lmf ... original arguments ... --wsig:fbz
  cp sigm2.<i>ext</i> sigm.<i>ext</i>
</pre>

<P>

Now you are in a position create a useable <FONT size="+1"><tt>sigm.<i>ext</i></tt></font>.
Change your input file or alter command-line switches for the symmetry-changing distortion.  
You also must tell the sigma reader to (1) that the input <FONT size="+1"><tt>sigm.<i>ext</i></tt></font> has no symmetry operations and 
to overlook the mismatch in <I>k</I>-points.  To this end, use token RDSIG=50011.
In the above example, you would not change the input file but invoke:
<pre>
  lmf ... original arguments ... -vsig=50011 -vtet=1.01 --wsig:newkp
  cp sigm2.<i>ext</i> sigm.<i>ext</i>
</pre>

<P>

This will create a <FONT size="+1"><tt>sigm.<i>ext</i></tt></font> with the <I>k</I>-points appropriate to the distorted lattice.

<H3><A name="sigintrp"></A>3.7 Notes on interpolation of &Sigma;</H3>

&Sigma; is generated on a set of irreducible <b>k</b>-points.  In
general we need &Sigma; other points, e.g.  the offset-&Gamma; method
used in the QS<i>GW</i> cycle needs &Sigma; at other points.  We need
QP levels at other <b>k</b> to calculate energy bands, or if
the <b>lmf</b> code requires a finer mesh (for kinetic energy) than is
required for &Sigma;.  This last point is important: &Sigma; is
expensive to calculate and the cost to calculate it increases as the
square of the number of <b>k</b>-points.  It can happen -- especially in
metals --- it is not feasible to calculate &Sigma; on a sufficiently
fine <b>k</b> mesh to get the kinetic energy right.

<P>
To accomplish this we use and algorithm to interpolate &Sigma;
betweeen points where it has been calculated.  It turns out that it is
difficult to do.  The difficulty apparently arises in 
interpolating &Sigma; at high energies, typically above 2 Ry.  

One essential thing is that the envelope functions <i>cannot be too
long-ranged</i>.  Thus, when doing QS<i>GW</i> calculations you should
set the LMTO envelope parameters <FONT size="+1"><tt>EH</tt></FONT> to
-0.3 Ry, or in some cases (2<sup>nd</sup> row elements especially) a
bit deeper.

<P> A couple of procedures have been developed to circumvent this problem,
which you can specify by the 10s digit of
the <FONT size="+1"><tt>HAM_RDSIG</tt></FONT> token.

Our experience to date suggests
that <FONT size="+1"><tt>RDSIG=1<i>x</i></tt></FONT> is the only reliable
mode, but other modes are documented here for completeness.  
(The 1's digit, <FONT size="+1"><tt><i>x</i></tt></FONT>, is normally 1 or 2;
refer to <FONT size="+1"><tt>HAM_RDSIG</tt></FONT> in <A href="tokens.html#HAMcat">tokens.html</A>).

<P>
&nbsp;
 <FONT size="+1"><tt>RDSIG=0<i>x</i></tt></FONT>: Interpolate &Sigma; by forward Bloch transform of &Sigma;(<B>T</B>).
        This is the simplest, but it doesn't work.
<P>
&nbsp;
 <FONT size="+1"><tt>RDSIG=1<i>x</i></tt></FONT>:
        Above a certain cutoff specified by the user, the off-diagonal
        part of &Sigma; in the representation of LDA eigenstates is eliminated.
        Moreover, the diagonal part of &Sigma; (sigii) is constrained 
        for these high-lying states.  That is, &Sigma; is transformed
        to the basis of eigenfunctions defined by LDA hamiltonian, with the
        states ordered in ascending order of the LDA eigenvalues.  In
        this representation, the self-energy for states above a cutoff
        (you choose the cutoff either through <FONT size="+1"><tt>SIGP_NMAX</tt></FONT> or <FONT size="+1"><tt>SIGP_EMAX</tt></FONT>, below) is
        taken to be diagonal, and the diagonal part constrained. 
<br><br>

We assume for the rest of this section that <FONT size="+1"><tt>RDSIG=1<i>x</i></tt></FONT>.

<P>
The interpolation requires additional input, which you specify 
with tokens in the <FONT size="+1"><tt>HAM_SIGP</tt></FONT> tag.
Recommended is something like:
<pre>
HAM  SIGP[MODE=4 EMAX=2]
</pre>
The full syntax is:
<pre>
  SIGP[MODE=modsgp NMIN=nmin EMIN=emin NMAX=nmax EMAX=emax A=asig B=bsig EFIT=#]
</pre>

<FONT size="+1"><tt>MODSGP</tt></FONT> controls how the digaonal part is to
        be evaluated.  <tt>MODSGP=4</tt> is recommended (the
        diagonal part is constant, with the value supplied by the
        program).  In any case the result should not depend much on
        the choice.  
        
The following describes the tokens in <FONT size="+1"><tt>SIGP:</tt></FONT>

<pre>
You can also constrain to be either larger than,
        or equal to, a specified linear function of the LDA energy
        (asig+bsig*Elda) It turns out that sigma is reasonably
        linear in Elda.  In any case, these high-lying states should be far
        enough away from the Fermi level that their effect should be
        small, and the result should depend very little on the choice
        of constraint. Another point to keep in mind is that by
        approximating &Sigma; for these states, you ensure that the LDA
        and quasiparticle eigenvectors for those states are the same.

        Further, you can elect to eliminate the off-diagonal parts of
        sigma for the lowest-lying states.  In this case, there is no
        option to constrain sigii.


        MODE selects how the constraint for the diagonal elements of &Sigma; is applied:
              0 constrain sigii to be > asig+bsig*Elda
              1 constrain sigii to be = asig+bsig*Elda
              2 constrain sigii to be  asig < sigii < bsig
              3 constrain sigii as in modsgp 1.  The difference between
                modes 1 and 3 are merely informational.
              4 constrain sigii to be a constant.  Its value is
                calculated by the GW package and read from
                sigm.<i>ext</i>. This mode requires no information from the user. 
                It is the recommended mode, available in version 7.7 or later.
                Default: 4

        NMIN  is an integer specifying how many of the lowest-lying
              states are approximate sigma by discarding the
              off-diagonal parts in the basis of LDA functions.
              If nmin is zero, no low-lying states are approximated.
                Default: 0

        EMIN  is an alternative way to specify approximation of low-
              lying sigma.  It is only used if nmin<0, which which case
              emin is an energy cutoff: states below emin are approximated.
                Default: not used

        NMAX  is an integer specifying which of the highest (LDA)
              states are to be approximated.  States higher than nmax
              have the off-diagonal part of sigma stripped; moreover
              (unlike the low-lying states) the diagonal part of sigma
              is constrained (see modsgp above).
              If nmax is <= 0, it is not used; see emax below.
                Default: 0

        EMAX  is an alternative way to specify approximation of high-
              lying sigma.  It is only used if nmax<=0, which which case
              emax is an energy cutoff: states above emax are approximated.
                Default: 2

        A     is the coefficient asig in the linear fit (modsgp 0..3)
              If modsgp=4, asig is not used.
              In the linear constraints (modes 0,1) it is the constant
              coefficient; for modsgp=2, it is the lower bound.
                Default: 0.02 (good estimate for Si)

        B     is the bsig coefficient in the linear fit (modsgp 0..3)
              If modsgp=4, bsig is not used.
              In the linear constraints (modes 0,1) it is the linear
              coefficient; for modsgp=2, it is the upper bound.
                Default: 0.06 (good estimate for Si)

        EFIT  lower bound for least squares fit; see next section.
              If modsgp=4, efit is not needed.

        Notes on estimation of asig and bsig (modsgp=0..3):

        lmf will supply you information to find reasonable estimates for
        asig and bsig.  For modsgp<3, it will make a least-squares fit
        to sigii for states higher than efit. For modsgp=3, it will make
        a least-squares fit for states between efit and emax.  You must
        use the latter if you are going to only going to calculate sigma
        for states above some emax (set as in the last lines in the
        GWIN0 file).  For the former, you must invoke lmf ON THE MESH of
        k-points for which sigma is known (there appear to be fewer
        problems with interpolation on that mesh).  lmf accumulates the
        minimum, maximum, and least-squares fit for the as-given sigma
        for all the states above the cutoff.  (Look in the output for a
        line beginning with "hambls:".  Also, if you set the verbosity
        above 45, lmf will print out the calculated sigii for each of
        these states, together with the constrained value.)  For either
        style, lmf will write to file sigii.<i>ext</i> the data used to make
        the fit, and summarize the fit and the end of the file.

mode 2: is an experimental perturbation approach that is not documented.
        mode 1 works well enough that it is probably not needed.

mode 3: linearly interpolates sigma in the basis of the LDA wave
        functions, by finding k-points in the vicinity of the desired
        k-point and performing a linear interpolation. Our
        experience to date suggests that mode 1 is the
        most reliable.  The default number of k-points used in the
        interpolation is 4.  You can specify a different number
        with the 100s digit of token <A href="#siginput"> <FONT size="+1"><tt>RDSIG</tt></FONT></A>).
</pre>

<!--- Section 4 -->
<H2><A name="section4"></A>4. Dynamic spin susceptibility, rigid spin approximation</H2>

When the GW code is run in the exchange mode, rigid spin approximation, spin waves
and Heisenberg exchange parameters can be extracted.  A typical command is:
<pre>
  lmgw --chixNLF --big --ht ext
</pre>

<FONT size="+1" color="#bb3300"><FONT size="+1">
<i>Extracting exchange parameters from output of </i><FONT size="+1"><tt>--chixNLF</tt></FONT> <i>mode</i>
</FONT></FONT>

<BR><BR>

Invoking the <FONT size="+1"><tt>--chixNLF</tt></FONT> mode generates
files <FONT size="+1"><tt>ChiPMxxxx.nlfc.mat</tt></FONT>, which can be
used to generate Heisenberg exchange parameters.

For concreteness, supposing your job 
generated susceptibility at 43 irreducible <i>k</i>-points
<pre>
  lmf --pr30 '--chimedit~new 43~read tkrs~export qx0q~exchange~a' ctrl.<i>ext</i> [switches]
  ln -sf Jmat_X0inv_w0eb.allq results
</pre>
This generates file 'results' which must be in turn massaged to generate exchange J.

The following commands put it in a form the ASA program <b>lmgf</b> can read.

If these 43 points were generated from an 8x8x8 mesh, which is set by 
switch <FONT size="+1"><tt>nk1</tt></FONT> in the ctrl file), do the following:
<pre>
  lmf --pr80 --rs=1,0 -vnit=0 -vnk1=8 --noinv --wpos=pos ctrl.<i>ext</i> [switches] | tee out.tmp
</pre>
It generates files <FONT size="+1"><tt>pos.<i>ext</i></tt></FONT> and <FONT size="+1"><tt>out.tmp</tt></FONT> .
(<FONT size="+1"><tt>pos.<i>ext</i></tt></FONT> may be needed if you have more than one atom/cell.)

Run this script, located in the startup directory of the lmto package:
<pre>
  lm/startup/preAllpoints.sh 
</pre>
It generates files <FONT size="+1"><tt>allpoints_m</tt></FONT>,
<FONT size="+1"><tt>allpoints</tt></FONT>,  and <FONT size="+1"><tt>points</tt></FONT>.
The last two are need for the next step.

<BR><BR>

At this point we have files <FONT size="+1"><tt>points,</tt></FONT> <FONT size="+1"><tt>allpoints,</tt></FONT> <FONT size="+1"><tt>results</tt></FONT>.
Next you need to compile program 
  <FONT size="+1"><tt>map-results-irr-to-fbz.f</tt></FONT>
(source in the startup directory).  
Look at the comments in the beginning for how to use this program.

Call the executable <FONT size="+1"><tt>map-results-irr-to-fbz</tt></FONT>.
For example, if we have one magnetic atom and its magnetic moment is 3.5, invoke this 
<pre>
  map-results-irr-to-fbz -takao3:1:3.5 -ft --check
</pre>
If you have more than one atom, you should specify positions to
possibly adjust phases.  This program should create a file <FONT
size="+1"><tt>jr.dat</tt></FONT>, which you can rename as <FONT
size="+1"><tt>jr.<i>ext</i></tt></FONT> and use as input for <b>lmgf</b>, mode 11.

<BR><BR>

<H2><A name="sectiondos"></A>Spectral functions and Spectrum DOS</H2>

The <i>GW</i> code can generate spectral functions for a specified
list of k-points and QP levels.  To generate the data, carry out a
QS<i>GW</i> or 1-shot calculation.  Then modify the beginning <FONT size="+1"><tt>QPNT</tt></FONT> block
of the <FONT size="+1"><tt>GWinput</tt></FONT> file.  By default it will look something like:

<pre>
 --- Specify qp and band indices at which to evaluate Sigma
</pre>

Change it to read as follows (you can modify the two numbers):
<pre>
***** ---Specify the q and band indices for which we evaluate the omega dependence of self-energy ---
   0.01 2   (Ry) ! dwplot omegamaxin(optional)  : dwplot is mesh for plotting.
                   : this omegamaxin is range of plotting -omegamaxin to omegamaxin.
                   : If omegamaxin is too large or not exist, the omegarange of W by hx0fp0 is used.
</pre>

Then invoke <b>hsfp0</b> like this:
<pre>
  echo 4 |  hsfp0 > out.hsfp0
</pre>
Note: this calculation may be time consuming.  <b>hsfp0</b> will generate files <FONT size="+1"><tt>SEComg.UP</tt></FONT> (<FONT size="+1"><tt>SEComg.DN</tt></FONT>).

<P> 

Program <b>spectral</b> will read this file and generate spectral functions for
each <i>k</i>-point and band read from <FONT size="+1"><tt>SEComg.UP</tt></FONT>.
A number of switches are available that enable you to tailor the results.
For example:
<pre>
  spectral --eps=.005 --domg=0.003 --cnst:iq==1&eqp>-10&eqp<30
</pre>
generates spectral functions :
<LI> for the 1st <i>k</i>-point (<b>k</b>=0);
<LI> for bands whose QP levels range between -10 and 30;
<LI> on a uniform frequency mesh of 3 meV;
<LI> using <FONT size="+1"><tt>eps</tt></FONT>=5 meV. &nbsp; <FONT size="+1"><tt>eps</tt></FONT> is added to Im&Sigma; which artificially broadens the
     QP level.  This is negligible except for states very
     close to the Fermi level, where Im&Sigma; tends to 0.
     <BR> &nbsp;&nbsp;&nbsp; <FONT size="+1"><tt>eps</tt></FONT> is the
     entire part of Im&Sigma; for the spectral function corresponding
     to the noninteracting Green's function $G_0$.
</LI>

<b>spectral</b> writes a separate file for each spectral function.  Its functionality is a bit limited;
it is best suited for generating a particular spectral function at a <b>q</b> on the the given mesh.

<BR> 
Program <b>lmfgws</b> is a much more powerful and versatile way to generate spectral functions and related quantities.  To use this program, first run <b>spectral</b> to create an input file for <b>lmfgws</b>, as follows:
<pre>
  spectral --ws --nw=1
  mv se se.<i>ext</i>
</pre>
File <FONT size="+1"><tt>se</tt></FONT> generated by <b>spectral</b> 
must be renamed with the extension used by the standard package, as shown.

<P>

<b>lmfgws</b> takes as input the same files 
<b>lmf</b> and <b>lmfgwd</b> use.  Invoke <b>lmfgws</b> with <FONT size="+1"><tt>--sfuned</tt></FONT>.
This starts the spectral function editor, which can do various things.  Type '?' to see options, or try out
out the example below.

<P> 

Particularly useful is the ability to generate the spectral functions for
an arbitrary <i>k</i>-point by interpolating the
<i>GW</i> &nbsp;&Sigma; to that <i>k</i>.  It can also generate the
spectral DOS (spectral functions summed over QP levels and integrated over
the entire BZ) on a fine <i>k</i>-mesh, to make a smooth spectrum DOS (1/&pi; Im
<i>G</i>) and noninteracting DOS (1/&pi; Im $G_0$).

<P> 

For an example, in the top-level directory do the following:
<pre>
  gwd/test/test.gwd fe 4
  gwd/test/test.gwd fe 5
</pre>
(Note: Each of these steps is time consuming.)

<P>

After file <FONT size="+1"><tt>se.<i>ext</i></tt></FONT> is created, this test invokes <b>lmfgws</b> as follows:
<pre>
  lmfgws fe `cat switches-for-lm` '--sfuned~units eV~readsek~eps .030~dos isp=1 range=-10,10 nq=32 nw=30~savesea~q'
</pre>

<b>lmfgws</b> takes commands interactively; alternatively you can supply the commands as arguments to <FONT size="+1"><tt>--sfunded</tt></FONT> as shown above.

In this example the arguments do the following:
<pre> 
  units eV   tells the editor you want to work in eV units
  readsek    reads file se.fe
  eps .030   Constant added to Im &Sigma; thus <i>G</i> is further (artificially) broadened by eps.
             For $G_0$ eps is the only broadening.
  dos isp=1 range=-10,10 nq=32 nw=30
             generates the spectral DOS, over an energy window of (-10,10) eV.
             The <i>k</i>-mesh is interpolated to 32 divisions to converge the DOS well.
             The energy mesh given by se.fe is subdivided 30-fold.
  savesea    saves the DOS in a file sdos.fe
  q          exits the editor
</pre>



<P> 

The noninteracting DOS (Im $G_0$) should tally with the DOS <b>lmf</b>
generates.  You can confirm that such is the case for the Fe test case.
Relative to the top-level directory, file <FONT size="+1"><tt>gwd/test/fe/dosp.fe.gz</tt></FONT>
contains DOS generated by <b>lmf</b>.  Running checks 4 and 5 as above,
you should obtain a file <FONT size="+1"><tt>sdos.fe</tt></FONT>, which should match
to <FONT size="+1"><tt>gwd/test/fe/sdos.fe.gz</tt></FONT>.

To see how how the spectrum DOS, the $G_0$ DOS, and
DOS generated by <b>lmf</b> compare, do :
<pre>
  gunzip -c gwd/test/fe/sdos.fe.gz > sdos.fe
  gunzip -c gwd/test/fe/dosp.fe.gz > dosp.fe
  fplot -f gwd/test/fe/plot.dos 
</pre>

You should see that the DOS from <FONT size="+1"><tt>dosp.fe</tt></FONT>
(black) is very similar to the $G_0$ DOS (gray) generated by
<b>lmfgws</b> (3<sup>rd</sup> column in file <FONT
size="+1"><tt>sdos.fe</tt></FONT>) They are not quite identical because
<b>lmf</b> generates the DOS with the linear tetrahdron method; the
$G_0$ DOS is generated by sampling with Lorenz broading.
Peaks in spectrum DOS (red) are broadened or even damped out.

<P>
<FONT size="+1" color="#bb3300"><FONT size="+1">
<i>Spectral Function</i> <i>A<sub>i</sub></i>(&omega;,<b>q</b>)</I>
</FONT></FONT>

<BR>

You can generate the spectral functions <i>A<sub>i</sub></i>(&omega;) for a particular QP level <i>E<sub>i</sub></i>
at an arbitrary <b>q</b> vector. For the Fe example,
<pre>
  lmfgws fe `cat switches-for-lm` '--sfuned~units eV~eps .01~readsek~se q=1.05,2.91,1.01 ib=2 nw=10 isp=1~savesea~q'
</pre>
generates a file <FONT size="+1"><tt>seia.fe</tt></FONT> for the spectral function of the 2<sup>nd</sup> band, at <FONT size="+1"><tt><b>q</b>=1.05,2.91,1.01</tt></FONT> (<b>q</b> is in units of 2&pi;/<i>a</i>).

<BR>

<FONT size="+1"><tt>nw=10</tt></FONT>, <FONT size="+1"><tt>eps .01</tt></FONT>, and <FONT size="+1"><tt>isp=1</tt></FONT> 
have the same meanings as in the DOS calculation.

<P>

<FONT size="+1"><tt>seia.fe</tt></FONT> contains these columns:
<BR>
<FONT size="+1"><tt>#     omega  &nbsp&nbsp; Re sigm-vxc &nbsp&nbsp; Im sigm-vxc &nbsp&nbsp; int A(w) &nbsp&nbsp; int A0(w) &nbsp&nbsp; A(w) &nbsp&nbsp; A0(w)</tt></FONT>
<BR>

One thing to check is that $\int A_0(\omega)\,d\omega$ over the entire energy
window is close to unity.  That information is printed out in a line
like this:
<BR>
&nbsp; <FONT size="+1"><tt> int A(w)dw = 0.826994  int A0(w)dw = 1.006518</tt></FONT>
</BR>

If the integral differs substantially from 1, probably your
<FONT size="+1"><tt>eps</tt></FONT> is too small compared to the frequency mesh spacing 
(<FONT size="+1"><tt>nw=</tt></FONT> subdivides the mesh generated by <FONT size="+1"><tt>hsfp0</tt></FONT>).
Look for a line in the output like the following one:
<BR>
&nbsp; <FONT size="+1"><tt> window (-27.233,27.191) dw=0.01361 eps=0.01000</tt></FONT>
</BR>
<FONT size="+1"><tt>dw</tt></FONT> is the spacing between energy points, and it should be smaller than <FONT size="+1"><tt>eps</tt></FONT>, or at most of the same order.

<BR>
The interacting $\int A(\omega)\,d\omega$ should be close to unity too, if the &omega;-integration limits are sufficiently large.
The incoherent part of <i>A</i> is spread out over a very large energy,
which can only be captured by running <FONT size="+1"><tt>hsfp0</tt></FONT> over a large energy window.

<P>

To generate the spectral function <i>A</i>(&omega;) at an arbitrary
<b>q</b>, &Sigma;(&omega;,<b>q</b>) has to be interpolated to the
desired <b>q</b>.  It is accomplished by linear interpolation from the four
nearest k-points.  The interpolation is somewhat crude, mainly because
the linear interpolation does not reliably describe the shift in the
QP peak.  To improve on this you can tell the spectral function generator
to generate QP levels independently, and substitute them for those
read from the <FONT size="+1"><tt>se</tt></FONT> file.  It also generates the QP level at the desired 
<b>q</b> and imposes the QS<i>GW</i> condition Re&Sigma;(&omega;,<b>q</b>)&minus;<i>V</i><sup>xc</sup>(<b>q</b>)=0 at the calculated QP energy for that <b>q</b>.
You make <b>lmfgws</b> do this by adding the <FONT size="+1"><tt>getev</tt></FONT> option, as follows:
<pre>
  lmfgws fe `cat switches-for-lm` '--sfuned~units eV~eps .01~readsek~evsync~se q=1.05,2.91,1.01 ib=2 nw=10 getev isp=1~savesea~q'
</pre>

Note the <FONT size="+1"><tt>evsync</tt></FONT> tag as well as the addition of <FONT size="+1"><tt>getev</tt></FONT>.
&nbsp; <FONT size="+1"><tt>evsync</tt></FONT> is not required, but it does improve the accuracy slightly.
&nbsp; <FONT size="+1"><tt>evsync</tt></FONT> calculates the Fermi level for the
given QS<i>GW</i> potential, and shifts the &omega;-spectrum so that
the zero frequency aligns with <i>E<sub>F</sub></i> calculated by <b>lmf</b>.
It should be close to the one calculated by the <i>GW</i> code but <b>lmf</b>'s
integration scheme is better.  To see the shift, and
verify it is essentially constant, look at the output after the band pass.
The Fermi level is printed out, the average shift relative to QP
levels supplied by the input <FONT size="+1"><tt>se.fe</tt></FONT>,
and the RMS deviation about the average. For the shift to be truly constant, the RMS deviation should be negligible.
<pre>
 evalqp:  Ef=0.115652.  Shift bands to Ef=0 and scale to eV ...
          Average shift = 0.021058  RMS deviation about avg = 0.000053
</pre>
The &omega;-interval is shifted and the shift will indicated in the next line of the output file.
<pre>
  sugws: shifting omega interval by 0.021058 to (-27.232658,27.190542)
</pre>
After generating the shift, <b>lmfgws</b> enforces the QS<i>GW</i> condition
$\Sigma_i(\omega{=}E_i)=V_i^{\rm xc}$ by adjusting <i>V<sub>i</sub></i><sup>xc</sup>.
The adjustment it makes is summarized in the next output line:
<pre>
&lt;eQP-w(sig-vxc=0)>=0.025214  RMS=0.248736  <&minus;(sig-vxc)_w=eQP>=0.000006  RMS=0.000041 (adjusted)
</pre>
The third number shows the mean adjustment to <i>V</i><sup>xc</sup>: it should be small, as should the RMS difference.
(The first average and RMS show how much the &omega;-axis would have to shift to meet the QS<i>GW</i> condition; this number can be large for states far from <i>E<sub>F</sub></i> and is not so meaningful.)

<IMG style="max-width:60%"  SRC="fe-eqpinterp.jpg" WIDTH="400" ALIGN="RIGHT">


<BR>
Invoking the editor with various kinds of options and some output using them are summarized in the following table:
<pre>
job    sigfun command segment                   Output
 1     se q=0.75,0.5,0.50 ib=2                 	eQP=-2.60341   om_Amax=-2.539082  shift=0.064328
 2     evsync~se q=0.75,0.5,0.50 ib=2          	eQP=-2.624466  om_Amax=-2.560139  shift=0.064327
 3     evsync~se q=0.75,0.5,0.50 ib=2 getev    	eQP=-2.624466  om_Amax=-2.560139  shift=0.064327
 4     evsync~se q=0.75,0.5,0.55 ib=2          	eQP=-2.595838  om_Amax=-2.536366  shift=0.059472
 5     evsync~se q=0.75,0.5,0.55 ib=2 getev    	eQP=-2.616804  om_Amax=-2.554370  shift=0.062434
 6     evsync~se q=0.75,0.5,0.55 ib=2 getev=16  eQP=-2.608861  om_Amax=-2.547603  shift=0.061258
</pre>
Job 1 is a straight evaluation of <i>A</i>(&omega;) at
<b>q</b>=0.75,0.5,0.50. This <b>q</b> is equivalent to one of the irreducible
k-points, so the k-interpolation is perfect.  Note that the maximimum in <i>A</i>(&omega;) does not
quite coincide with the QP peak.  This occurs because of the &omega;-dependence of Im &Sigma;.

<BR>
Jobs 1 and 2 differ because of <b>lmf</b> determines <i>E<sub>F</sub></i> differently from the <i>GW</i> code (shift is 0.021 eV).

<BR>
Jobs 2 and 3 are identical because there is no <b>q</b>-interpolation.  Since the QP levels were initially adjusted by <FONT size="+1"><tt>evsync</tt></FONT>, further adjustments in job 3 have no effect.
<BR>
Jobs 4 and 5 are not identical because <b>q</b> must now be interpolated.
<FONT size="+1"><tt>eQP</tt></FONT> of job 4 is obtained by linear
interpolation from neighboring <b>k</b>; in
job 5 the <i>E<sub>i</sub></i> are calculated at
<b>q</b>=0.75,0.5,0.55, so the energy interpolation is perfect.  The
improved <i>E<sub>i</sub></i> is also used to improve on the interpolation of
Re &Sigma;<i><sub>i</sub></i>(&omega;)&minus;<i>V<sub>i</sub></i><sup>xc</sup>, by ensuring that the QS<i>GW</i> condition is met.
<BR>
Jobs 5 and 6 differ in that the <i>E<sub>i</sub></i> are calculated on
a finer grid (16&times;16&times;16 k-divisions).  Even while the
<b>q</b>-interpolation is perfect in both cases, the finer grid produces a
better Fermi energy (a change of 8 meV).

The need for good QP interpolation is shown in the Figure.  This is
the Fe calculation, this time along q=(<i>x</i>,0,0).  Black shows the
QP levels using switches like job 2; red shows them using switches
like job 3.  It is apparent that the second and third band cross
around q=0.4, the red line picks up only the lowest band.  Blue show
frequencies corresponding to the maximum value of
<i>A</i>(<i>&omega;</i>) as a function of <b>q</b>.  It is shifted by
an amount roughly constant relative to the QP level.


<P>
<FONT size="+1" color="#bb3300"><FONT size="+1">
<i>Simulating</i> ARPES</I>
</FONT></FONT>

<BR><BR>

Work in progress.

<H2><A name="sectionFAQ">Frequently asked questions</H2>

(This section needs building up) 

<P>

<BR><I>Q</I>: When I do Ni with 10&times;10&times;10 divisions, I get

<pre>
 hft2rs created hrs:  ndhrs=39  max Re(hrs) = 0.771  max Im(hrs) = 2.33e-9

   i   j      diff              bloch sum                file value
  21   1    0.000174     -0.036707    0.000000     -0.036533    0.000000

 Exit -1 rdsigm: Bloch sum deviates more than allowed tolerance (tol=5e-6)
</pre>

What does this mean?  or how to avoid the problem?

<BR>
<BR><I>A:</I>

It almost always means that the range set up for the r.s. Bloch sigma
is not long enough to encompass all possible connecting vectors.  The
easiest way to fix it is to increase the range.  You need to add to
the HAM category something like

<pre>
HAM   RSRNGE=8
</pre>

In the output, look for where the sigma is read in.  You will see
something like this output

<pre>
 RDSIGM: read file sigm and create COMPLEX sigma(R) by FT ...
         Sigm will be approximated by:  diagonal Sigma for high and low states 
         Approximate sigma for energies E(lda)>2.5
         For high states Sigii = 0.000 + 0.080 * E(lda) 
         Linear fit to diagonal sigma for E(lda)>0 and E(lda)<2.5 
         sigm file has 20 irreducible QP: nk = ( 4 4 4 )  shift= F F F
 hft2rs: make neighbor table for r.s. hamiltonian using range = 5 * alat
 pairc:   8278 pairs total 4139 is max cluster size
 hft2rs: found 256 connecting vectors out of 256 possible for FFT
</pre>

<tt>range = 5 * alat</tt> means that RSRNGE=5 (default value).  If RSRNGE is
large enough, this line
<pre>
 hft2rs: found 256 connecting vectors out of 256 possible for FFT
</pre>
indicates that all possible connecting vectors were found (as they are
in this example); then there should be no problem.
