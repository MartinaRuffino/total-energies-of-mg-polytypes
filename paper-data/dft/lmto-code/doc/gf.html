<!DOCTYPE html><html>

<head>
<title>ASA Green's function package</title>
<style>

/* For hyperlinks */
a:link {color:#FF0000;}      /* unvisited link */
a:link {color:#222288;}      /* unvisited link */
a:visited {color:#228822;}  /* visited link */
a:hover {color:#FF00FF;}  /* mouse over link */
a:active {color:#0000FF;}  /* selected link */
a:link {text-decoration:none;}
a:visited {text-decoration:none;}
a:hover {text-decoration:underline;}
a:active {text-decoration:underline;}

body {
       background-color:#ffffgg;
     }
 h1 {
      color:#880000;
      text-align:center;
      font-size:12px;
    }
 h2 {
      color:#bb3300;
      font-size:120%;
      font-weight:normal;
      font-style:italic;
    }

 h3 {
      color:#2255bb;
      font-size:110%;
      font-weight:normal;
      font-style:italic;
      text-indent: 0.5em;
    }

 h4 {
      color:#000000;
      font-size:100%;
      font-weight:bold;
      text-indent: 1.0em;
    }

 h5 {
      color:#444488;
      font-size:100%;
      font-weight:bold;
      font-style:normal;
      text-indent: 1.5em;
    }

  P {
<!--  font-family:"Times New Roman"; -->
<!--  font-size:12px; -->
<!--  color: red; -->
    }

  q {
      color: red;
    }

  a {
        color: blue;
    }

  tlarge {
       <font-size="+1">
    }

</style>

<!-- Enables the use of latex -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
<script type="text/javascript"
  src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

</head>

<h1><B><FONT size="+2">ASA Green's function package (v7.11)</FONT></B></h1>

<h2>Purpose</h2>

This package implements the ASA local spin-density approximation using
Green's functions.  The Green's functions are contructed by
approximating KKR multiple-scattering theory with an analytic
potential function.  The approximation to KKR is essentially similar
to the linear approximation employed in band methods such as LMTO and
LAPW. It can be shown that this approximation is nearly equivalent to
the LMTO hamiltonian without the
"<A href="lmto.html#section8">combined correction</A>" term.  With
this package a new program, <b>lmgf</b> is added to the suite of
executables.  <b>lmgf</b> plays approximately the same role as the
LMTO-ASA band program <B>lm</B>: a potential is generated
from <A href="lmto.html#sectionpq">energy moments</A>
 <i>Q</i><sub>0</sub>, <i>Q</i><sub>1</sub>, and <i>Q</i><sub>2</sub> of the density of states.
in the same way as the <b>lm</b> code.

You can use <b>lmgf</b> to make a self-consistent density as you can do with <b>lm</b>.
<i>lmgf</i> is a Green's function method: Green's functions have less information
than wave functions, so in one sense the things you can do with <b>lmgf</b> 
are more limited: you cannot make the bands directly, for example.
However <b>lmgf</b> enables you do do things you cannot do with <b>lm</b>.
The two most imprortant are:

<UL>
<LI> Calculate magnetic exchange interactions (essentially the static magnetic susceptibility)

<LI> Calculate properties of disordered materials, either chemically
disordered or spin disorder from finite temperature, within the
<A href="cpa.html">Coherent Potential Approximation</A>, or CPA.

<LI> Calculate the ASA static susceptibility at <b>q</b>=0 to help converge
calculations to self-consistency.

</UL>

<h2><A name="section1"></A>Structure of Green's function program</h2>

<B>lmgf</B> runs in much the same way as program <B>lm</B>.

The band pass routine of <B>lm</B>, <FONT size="+1"><tt>bndasa.f</tt></FONT>, generates eigenvalues
and eigenvectors, which can in turn generate quantities of interest.
<FONT size="+1"><tt>bndasa</tt></FONT> is replaced by a Green's function routine, <FONT size="+1"><tt>gfasa</tt></FONT>.
<FONT size="+1"><tt>gfasa</tt></FONT> can generate output moments DOS, density-matrix, etc., in
the same way as <FONT size="+1"><tt>bndasa</tt></FONT>.

<P>

In contrast to band methods (such as implemented in <b>lm</b>) where
the Hamiltonian <i>H</i> is energy independent and all the bands are
generated by diagonalizing <i>H</i>, Green's functions are calculated
for a specific energy; information is extracted from <i>G</i> for a
particular energy.

<P>

This fact highlights the strengths and weaknesses of a Green's
function approach.  Energy-integrated properties such as the moments,
must be obtained by integrating over energy.  Calculating <i>G</i>
explicitly at a family of energies is more cumbersome than
diaonalizing a hamiltonian.  On the other hand, Green's function
methods are naturally suited to contexts where the energy-dependence
is needed anyway.  CPA theory yields an energy-dependent potential;
Green's functions are natural way to implement it.  Similarly,
noninteracting susceptibilities can be expressed
as <i>G</i>&times;<i>G</i> (`&times;' implies either
convolution or product depending on the space you are working in).

<P> 

<b>lmgf</b> always loops over some energy contour; what contour you use
depends on the context as described see <A href="gf.html#section3">below</A>.
<FONT size="+1"><tt>gfasa</tt></FONT> accumulates various kinds of
data for each mesh point, such as the point's contribution the
from <A href="lmto.html#sectionpq">energy moments</A> used in an ASA
self-consistent cycle.

Finally an estimate for the Fermi level <i>E<sub>F</sub></i> is determined 
using a from <A href="gf.html#section2">Pade approximation</A>.
If the original guess for <i>E<sub>F</sub></i> is sufficiently close, the
cycle is finished as in program <B>lm</B>.  If the estimate is too far
off, a new energy mesh is taken and the process repeated.

<h2><A name="section2"></A>Energy Contours, Potential Shifts and the Determination of the Fermi Level</h2>

For energy-integrated properties, a very fine energy mesh would be required if the
energy integration were carried out close to the real axis.  It is much more efficient
to deform the integration contour is deformed into an elliptical path in the
complex plane, approaching the real axis only at the lower and upper integration limits.

<P> To integrate quantities over occupied states, integration to the Fermi level
<i>E<sub>F</sub></i> is required.  <i>E<sub>F</sub></i> is not known but
must be fixed by charge neutrality.  Thus <i>E<sub>F</sub></i> must be guessed
at and iteratively refined until the charge neutrality condition is satisfied.
<b>lmgf</b> does not vary <i>E<sub>F</sub></i>; the user specifies it
at the outset.  Instead <b>lmgf</b> looks for a constant potential
shift that satisfies charge neutrality; this must be searched for
iteratively.  Both the potential shift and <i>E<sub>F</sub></i> are
maintained in a file <FONT size="+1"><tt>vshft.<i>ext</i></tt></FONT>.
Inspection of <FONT size="+1"><tt>vshft.<i>ext</i></tt></FONT> may
look unecessarily complicated; this is because you can use the file to
add site-dependent shifts.  <FONT size="+1"><tt>vshft.<i>ext</i></tt></FONT> is also used
by the <A href="pgf.pdf">layer Green's function code</A> <b>lmpg</b>, which requires
extra information about shifts on the left and right leads.

<P></P>

Metals and nonmetals are distinguished in that in the latter case,
there is no DOS in the gap and therefore the Fermi level (or potential
shift) cannot be specified precisely.

<ul>
 <B>Metal case</B> (set by 
<A href="tokens.html#BZcat"><FONT size="+1"><tt>BZ_METAL=1</tt></FONT></A>):
 once the <I>k</I>- and energy-points are
 summed over and the deviation from charge neutrality is determined,
 the code will attempt to find the potential shift that fixes charge
 neutrality.  It does this in one of two ways:

<P></P><ul>

<LI> Using a Pade approximant, <b>lmgf</b> interpolates the diagonal elements of <i>G</i>.
 The interpolation is used to evaluate the GF
 on the starting elliptical contour shifted rigidly by a constant, and
 the shift is iterated until the charge-neutrality condition is
 satisfied.  At this stage, there are two possibilities:
 <OL> 
<LI>  repeat the integration of <i>G</i> over <b>k</b> and the energy contour with
 the constant shift added to the potential.
   
<LI> Assume that the Pade-approximant to the diagonal <i>G</i> is a sufficiently
good estimate for the actual <i>G</i>.
</OL>

If the potential shift is larger than a user-specifed tolerance (see
<FONT size="+1"><tt>padtol</tt></FONT> in <FONT size="+1"><tt>GF_GFOPTS</tt></FONT> below), option 1 is taken
and the Pade shift re-evaluated.  A new Pade estimate is made for the potential shift
requiring charge neutrality, and it is tested once against the user-specified tolerance.

<P> 
When the shift falls below the tolerance, option 2 is taken
and <b>lmgf</b> proceeds to the next step.

The user is advised to monitor these shifts and the deviation from
charge neutrality.

<P><LI> The charge is integrated in a contour near the real axis
 subsequent to the elliptical contour.  In this mode, the
 determination of the potential shift is accomplished by continuing
 the integration contour on the real axis starting from the originally
 estimated Fermi level. A trapezoidal rule is used (or Simpson's rule
 using a Pade approximate for the midpoint), and new energy points are
 computed and integrals accumulated until charge neutrality is found.
 There is no iterative scheme as with the Pade approximation.  This
 option tends to be a little less accurate than the Pade, but somewhat
 more stable as it is less susceptible to interpolation errors.

</P></ul>

 One last comment about the <FONT size="+1"><tt>METAL</tt></FONT> case: by default the program will
 save the potential shift to use in the next iteration.  You can
 suppress this save (see frzvc below), which again can be less
 accurate, but more stable.  In particular if you are working with an
 insulator where stability can be an issue (determination of the Fermi
 level is somewhat ill conditioned), a stable procedure is to use this
 option together with second energy integration scheme described above
 (the integration contour on the real axis).

<P>
 <B>Nonmetal case</B> (set by BZ METAL=0): <B>lmgf</B> will not attempt to
 shift the potential, or ensure charge neutrality.  The user is
 cautioned to to pay rather closer attention to deviations from charge
 neutrality.  It can happen because of numerical integration errors,
 or because your assumed Fermi level does not fall within the gap.
 You can use METAL=1 even if the material is a nonmetal.

</ul>

<h3>Some Details concerning how <b>lmgf</b> works internally</h3>

For each energy point, the BZ integration is accomplished by routine
in <FONT size="+1"><tt>gf/gfibz.f</tt></FONT>, which loops over all
irreducible points, generating the "scattering path operator" <I>g</I>
and the corresponding <I>g</I> for all the points in the star of <I>k</I> to
generate a properly symmetrized <I>g</I>.  Within the ASA,
second-generation LMTO, <I>g</I> is converted to proper Green's
function <I>G</I>, corresponding to the orthogonal gamma
representation by an energy scaling.  The scaling is carried out in
routine <FONT size="+1"><tt>gf/gfg2g.f</tt></FONT>. 

Next the various integrated quantities sought are assembled (done
by <FONT size="+1"><tt>gf/gfidos.f</tt></FONT>).  The potential
shift to satisfy charge neutrality is found, and stored in
<FONT size="+1"><tt>vshft.<i>ext</i></tt></FONT>.  The I/O
is handled by routine <FONT size="+1"><tt>subs/iovshf.f</tt></FONT>.

<h2><A name="section3"></A>GF-specific input</h2>

<h3><A name="section3.0"></A>Energy integration contour</h3>

Green's functions are always performed on some energy contour, which
is discretized into a mesh of points in the complex energy plane.
(A description of the various kinds of contours this code uses is documented
in the comments to <FONT size="+1"><tt>gf/emesh.f</tt></FONT>.)

<i>G</i> is "spikey" for energies on the real axis (it has poles where there
are eigenstates).  To compute energy-integrated properties such as magnetic
moments or the static susceptibility, the calculation is most efficiently done
by deforming the contour in an ellipse in the complex plane.

<P> At other times you want properties on the real axis, e.g. density-of-states or
<A href="SpectralFunction.htm">spectral functions</A>.

You specify the contour in <A href="tokens.html#BZcat">category <FONT size="+1"><tt>BZ</tt></FONT></A> as:
<pre>
  EMESH= nz mode emin emax [other args, depending mode]
</pre>
where
<pre>
         nz         number of energy points
         mode       specifies the kind of contour; see below
         emin,emax  are the energy window (emax is usually the Fermi level)
</pre>

<br>
  Right now there are the following contours:

<P>
<ul>
  <B>mode=0</B>: a uniform mesh of points 
          between emin and emax, with a constant imaginary component.
<pre>
  EMESH= nz 0 emin emax Im-z [<A href="#section3.3">... + possible args for layer geometry</A>.]

         Im-z is the (constant) imaginary component.
</pre>
  This mode is generally not recommended for self-consistent cycles
  because the GF has a lot of structure close to the real axis (small
  Im-z), while shifting off the real axis introduces errors.  It is
  used, however, in other contexts, e.g. <A href="#section3.3">transport</A>.

</ul>

<H3><A name="section3.1"></A></H3>

<ul>
  <B>mode=10</B>: a Gaussian quadrature on an ellipse. 

<pre>
  EMESH= nz 10 emin emax ecc eps

         ecc is the eccentricity of the ellipse, 
             ranging from 0 (circle) to 1 (line)
         eps is a 'bunching' parameter that, as made larger,
             tends to bunch points near emax.  
             As a rule, e2=0 is good, or maybe e2=.5 
             to emphasize points near Ef.
</pre>
<BR>
After the integration is completed, there will be some deviation from
charge neutrality, because emax will not exactly correspond to the
Fermi level.  This deviation is ignored if METAL=0; otherwise, the
mesh is rigidly shifted by a constant amount, and the diagonal GF
interpolated using a Pade approximant to the shifted mesh.  The
shifting+interpolation is iterated until charge neutrality is found,
as described in <A href="gf.html#section2">section 2</A>.  If the
rigid shift exceeds a specified tolerance, the Pade interpolation may
be suspect.  Thus, the entire cycle is repeated from scratch, on the
shifted mesh where the shift is estimated by Pade.
</ul>

<ul>
  <B>mode=310</B>: a Gaussian quadrature on an ellipse to a trial emax, as in
  mode 2.  However, the search for the Fermi level is not done by Pade
  approximant, as in mode 10.  Instead, a second integration proceeds
  along a uniform mesh from emax to some (Fermi) energy which
  satisfies charge neutrality.   This procedure is not iterative.

<pre>
  EMESH= nz 310 emin emax e1 e2 delz

         e1 and e2 are just as in mode 10
         delz      is the spacing between energy points for the 
                   second integration on the uniform mesh.
</pre>

<BR><BR>
  <B>mode=2</B>: is the same contour as <A href="#section3.0">mode=0</A>.  However, it is designed for
  cases when you want to resolve the energy dependence of some
  quantity, such as the DOS or magnetic exchange coupling.  These are
  discussed in the GF category below.

</ul>

<A name="section3.2"></A>

<ul>
  <B>mode=110</B>: is a contour input specific to nonequilibrium Green's function.

The nonequilibrium Green's function requires additional information
for the energy window between the left and right leads.  (The
nonequilibrium Green's function is implemented for the layer geometry
in <B>lmpg</B>.)

Thus the integration proceeds in two parts: first an integration on an
elliptical path is taken to the left Fermi level (as in <A href="#section3.1">mode=10</A>).
Then an integration over is performed on the nonequilibrium contour,
i.e. the energy window from the left to the right Fermi level.  This
integration is performed on a uniform mesh close to the real axis, as
in <A href="#section3.0">mode=0</A>.  For the nonequilibrium contour, three additional pieces of
information must be supplied:
<pre>
  nzne  number of (uniformly spaced energy points on the nonequilibrium contour
  vne   difference in fermi energies of right and left leads, ef(R)-ef(L)
  delne Im-z on the nonequilibrium contour
</pre>
<br>
The mesh is specified as 
<pre>
  EMESH= nz 110 emin ef(L) ecc eps nzne vne delne [del00]
</pre>

The last argument plays the role of delne specifically for computing
the self-energy that determines the end boundary conditions.  There is
an incompatibility in the requirements for Im-z in the central and end
regions. the same incompatibility applies to transport and is
discussed [<A href="#section3.3">below]</A>.

<h3><A name="section3.3"></A>Modifications of energy contour for layer geometry</h3>

<ul>
When computing transmission coefficients via the Landauer-Buttiker
formalism, one chooses a contour as in <A
href="#section3.1">mode=0</A>.  However, a there is a problem in how
to choose <tty>Im-z</tty>.  A small Im-z is needed for a
reliable calculation of the transmission coefficient, but using a
small Im-z to determine the surface Green's function may not succeed
because the GF can become long range and the iterative cycle used to
generate it may not be stable.

To accomodate these conflicting requirements, a surface-specific
<tty>Im-z</tty> should be used, called <tty>del00</tty>.
The <tty>mode=0</tty> mesh is specified as 
<pre>
  EMESH= nz 0 emin emax delta xx xx xx xx del00
</pre>
<tty>delta</tty> is <tty>Im-z</tty> for the central region;
<tty>del00</tty> is <tty>Im-z</tty> for the surfaces.<br>
Entries <tty>xx</tty> have no meaning but are put there for
compatibility with the contour used in nonequilibrium
calculations.  (A similar situation applies to the <A
href="#section3.1">nonequilibrium part of the contour</A>).


<br><br>
The mesh for <A href="#section3.1">self-consistent nonequilibrium calculations</A> is
<pre>
  EMESH= nz 110 emin ef(L) ecc eps nzne vne delne del00
</pre>

</ul>
</ul>

<h3><A name="section3.4"></A>Green's function category</h3>

<B>lmgf</B> requires a GF-specific category.

<pre>
GF  MODE=1 GFOPTS=options
</pre>

<P>
Token <B><tt>MODE=</tt></B> controls what <B>lmgf</B> calculates.  Options are 
<tt>MODE=1</tt>, <tt>MODE=10</tt>, <tt>MODE=11</tt>, described below.


<ul>
  <B><tt>MODE=1</tt></B> goes through the usual cycle calling gfasa.  It performs a
  function analogous to bndasa in the band program, generating output
  density, moments, and optionally other quantities such as
  density-of-states.
<BR>
  Taken with the special integration contour mode=2 (see <tt>EMESH</tt> above), N(E)
  and its integral are computed and tabulated over the window
  specified.  With the following sample input segment:

<BR>
<pre>
  % const ef=-0.025725
  BZ      EMESH=5 2 {ef} {ef+.002*4} .001 0

  the integration would be tabulated for five points
  ef, ef+.002, ef+.004, ef+.006, ef+.008 like so (spin-polarized case)

       Re z       Im z   spin       dos           idos
    -0.025725   0.001000   1      13.55272       0.00000
    -0.025725   0.001000   2      10.38435       0.00000
    -0.025725   0.001000   t      23.93706       0.00000
    -0.023725   0.001000   1       9.17407       0.02273
    -0.023725   0.001000   2       4.13694       0.01452
    -0.023725   0.001000   t      13.31101       0.03725
    -0.021725   0.001000   1      15.33776       0.04724
    -0.021725   0.001000   2       7.42200       0.02608
    -0.021725   0.001000   t      22.75976       0.07332
    -0.019725   0.001000   1      19.58433       0.08216
    -0.019725   0.001000   2       7.52708       0.04103
    -0.019725   0.001000   t      27.11141       0.12319
    -0.017725   0.001000   1      20.83078       0.12258
    -0.017725   0.001000   2       9.31350       0.05787
    -0.017725   0.001000   t      30.14428       0.18045
</pre>


  If the partial DOS is generated, the usual tokens in the BZ
  category specifying the window (DOS=) and number of points (NPTS=)
  are overridden by the parameters in EMESH.
<P>
  <B><tt>MODE=10</tt></B> invokes a special branch that computes magnetic exchange
  interactions using a linear response technique.  In particular, J_ij is
  computed for pairs of sites (i,j), where the J's are the parameters in
  the Heisenberg hamiltonian
<pre>
    E(s_i, s_j) = sum_ij J_ij s_i . s_j
</pre>

  Thus, the J's are coefficients to energy changes for small rotations
  of the spins. It can be computed from a change in the band energy,
  and for small rotations can be done analytically.
<P>
  Taken with the usual elliptical integration contour, the J's are
  computed by energy integration to the Fermi level.  Taken with the
  special integration contour mode=2 (see EMESH above), dJ/dE is
  computed instead.  There is a shell script gf/test/getJq0z (invoke
  with no arguments to see usage) that will collect some of the ouput
  for you into tables.  The data are collected into file dj0dz.  For
  an example illustrating this mode, invoke
    gf/test/test.gf co 5
  This test computes the exchange coupling both for the usual elliptical 
  contour and resolves the energy-dependence of J in a small window near
  the Fermi level.
<P>
  Often only some atoms are magnetic, and all that is desired are the
  exchange parameters J connecting a partial list of sites to its
  neighbors.  This can be useful, even essential for large systems,
  because it is can be very expensive both in time and memory to
  compute exchange interactions for all pairs.  To compute exchanges
  only for a list of sites, use switch
<pre>
   --sites:pair:site-list
</pre>
  See <A href="#section4">command-line arguments</A></B> for more details.

<P> <FONT color="#bb3300"><I>Caution</I>.</FONT>
<b>lmgf</b> reads and writes a potential shift file vshft<FONT size="+1"><tt>.ext</tt></FONT> 
which shifts site potential by a constant to cause the Fermi level to
match what is specified by the input.  This shift also gets added into
the atom file; potential VES in line PPAR is adjusted.

When calculating exchange interactions, vshft<FONT size="+1"><tt>.ext</tt></FONT> is not read.
However, the shift is preserved because they are held in the potential
parameters section of the atom file.  But if you run the atom part <b>lm</b> or
<b>lmgf</b> and <i>remake</i> the PP's from the moments (<FONT
size="+1"><tt>START BEGMOM=1</tt></FONT>), this causes estat potential
to be remade, but the sphere program does <i>not</i> add the contents
<FONT size="+1"><tt>vshft</tt></FONT> (it is done at the start of the
Green's function calculation).  The exchange parameters should be evaluated with
the potential parameters generated by <b>lmgf</b>.  If they are alternatively evaluated
from the atom files generated by <b>lm</b>, the Fermi level needs to be aligned to
the Fermi level of <b>lm</b> (or close to it; there are slight differences between Fermi levels
generated by <b>lm</b> and by <b>lmgf</b>).

<P>
  <B><tt>MODE=11</tt></B> is an exchange branch that is run after <tt>MODE=10</tt>.  It prints out
  the J_ij and does several other analyses.  Switch
<pre>
   --sites:pair:site-list
</pre>
  also applies to this mode; see see <A href="#section4">command-line arguments</A>.

</ul>

<A name="section3.4.1"></A>

Token <B><tt>GFOPTS= option-list</tt></B> causes gfasa to do a variety of different things.

<pre>
  Options are entered as a series of strings string1;string2;...  
  Option strings are:

    emom   generate the output ASA moments, needed for self-consistency
    idos   make integrated properties, such as the sum of one-electron energies
    dmat   make the density-matrix G_RL,R'L'
    sdmat  make the site-diagonal density-matrix G_RL,RL'
           The density matrix is written to a file 'dmat'
    pdos   Make the partial density of states (this has never been checked)
    p3     Use third order potential functions
    padtol Set the tolerance for maximum potential shift permissible by
           Pade interpolation, as described above
    frzvc  Suppress saving the constant potential shift used 
           to determine charge neutrality
</pre>

<H2><A name="section4"></A>lmgf-specific command-line arguments</H2>

<pre>

  -ef=# overrides upper limit of energy integration (Fermi level) 
        and assigns to #

</pre>
  The following are specific to the exchange calculation modes 10 and 11:
<pre>
  --sites[:pair]:site-list  Make the exchange parameters J_ij only for 
        sites i in the site list.  In mode 11, option :pair means
        that only parameters J_ij where both i and j are printed.
        See <A href="Integer-list-syntax.html">here</A> for the syntax of `site-list'.
</pre>

  Example:  running lmgf using <tt>MODE=10</tt> and this command line argument
<pre>
          --sites:pair:1,3,5,7
</pre>
  generates J connecting sites 1, 3, 5 and 7 to all neighbors.
<BR><BR>
  Running lmgf using <tt>MODE=11</tt> with the same <tt>--sites</tt> switch
  argument will print out the exchanges just between pairs of these sites.
<BR><BR>
  Running lmgf using <tt>MODE=11</tt> without any <tt>--sites</tt>
  argument will print out the exchanges between these sites and all neighbors.
<BR><BR>

<pre>
  --wrsj[:fn=name][:scl=#][:tol=#]  (mode 11 only)
    Writes the Heisenberg exchange parameters in a standard format,
    suitable for use in spin dynamics simulations.
      fn=name writes to file 'name'  (default name is rsj)
      scl=#   scales the parameters by #
      tol=#   writes only parameters with energy > tol

  --rcut=# 
    Truncates the range of the R.S exchange paremeters ... 
    useful to assist in the determination of the effect distant neighbors.

  --2xmsh
    When integrating over the BZ to estimate T<sub>c</sub> from Tablikov formula, this option 
    doubles the k-mesh.  Can be helpful in testing k-convergence
    of the singular q->0 limit entering into the formula.

  --amoms=mom1,mom2,...
  --amom=mom1,mom2,...
    This switch overrides ASA moments (which are automatically generated).
    The first switch reads a vector of nbas moments, one for each site
    The first switch reads a vector of nclass moments, one for each class

    Sphere magnetic moments are tabulated in the printout at the end of mode 10, 
    and the start of mode 11.
    If you are importing exchange parameters (file <FONT size="+1"><tt>jr.ext</tt></FONT>, e.g. from the full-potential code,
    you will want to supply the moments calculated from that program.

</pre>

<H2><A name="section5"></A>Test cases and examples</H2>

This script:
<pre>
gf/test/test.gf
</pre>
carries out a number of tests, which also demonstrate various branches of the code.
To see the materials and corresponding tests try

<pre>
gf/test/test.gf --list
</pre>
