      subroutine pgfasa(s_ctrl,s_lat,s_spec,s_site,s_bz,s_str,s_ham,
     .  s_pot,s_strn,lldau,vorb,dmatu,vconst,vshft,zp,wz,pgfsl,pgplp,
     .  efermi,moddos,sumev,qnu,rhos,amag,aamom)
C- Planar Green's function, ASA
C ----------------------------------------------------------------------
Cio Structures
Cio  s_ctrl :struct for program flow parameters; see structures.h
Ci     Elts read:  nbas nbasp nl nspin lncol lpgf lham nclasp nofgl
Ci                 nofgr nclass ipc nspec lgen3 npl lasa ldlm nccomp
Co     Stored:     lpgf lham lasa
Co     Allocated:  *
Cio    Elts passed: ldos lpgf ics ips lasa ipc nrc lham lrel dclabl
Cio                initc
Cio    Passed to:  setne pgsoscl supgh supgbc supghz suhamz mkpotf
Cio                makpfz pgsif pgflu shoctl
Cio  s_lat  :struct containing lattice information; see structures.h
Ci     Elts read:  alat plat
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:pos
Cio    Passed to:  supgbc pgsif pgflu
Cio  s_spec :struct for species-specific data; see structures.h
Ci     Elts read:  z idxdn lmxb lmxa ncomp idu a nr rmt hcr
Co     Stored:     idxdn lmxa
Co     Allocated:  *
Cio    Elts passed:*
Cio    Passed to:  pgflu7 makidx nscpa supgh getidu supgbc supghz
Cio                suhamz mkpotf makpfz pgsif shoctl
Cio  s_site :struct for site-specific data; see structures.h
Ci     Elts read:  ncomp dlmcl spec norb pfr pfra class pnu clabel v0
Co     Stored:     pfra
Co     Allocated:  pfr dpfr ddpfr pfra
Cio    Elts passed:pfra pfr dpfr ddpfr
Cio    Passed to:  getidu supgbc supghz suhamz mkpotf makpfz mkptfp
Cio                mkfrpf mksopf gvbma pgsif plhamnc plham plhamso
Cio                pgbevl pgkmap pgflu pgemb pvemb pgdysn pgles pgcurr
Cio  s_bz   :struct for the Brillouin Zone; see structures.h
Ci     Elts read:  lmet nkp semsh dosw ndos
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:qp wtkp
Cio    Passed to:  setne
Cio  s_str  :struct for parameters for screened strux; see structures.h
Ci     Elts read:  rmax npr
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:npr iax alph s nds
Cio    Passed to:  supgh supgbc pgsif plhamnc plham pgbevl pgkmap pgflu
Cio                sblham pgemb pvemb pgdysn pgles pgcurr
Cio  s_ham  :struct for parameters defining hamiltonian; see structures.h
Ci     Elts read:  nlibu lmaxu udiag eterms iprmb offH ldham lncol hord
Ci                 neula lgen3 lham bandw
Co     Stored:     offH iprmb eterms bandw lncol
Co     Allocated:  offH iprmb
Cio    Elts passed:iprmb offH lncol eula
Cio    Passed to:  supgh pglusu supgbc supghz suhamz mkpotf makpfz
Cio                pgsif plhamnc plham plhamso pgbevl pgkmap pgflu
Cio                sblham pgemb pvemb pgdysn pgles pgcurr gfg2g
C
Cio  s_pot  :struct for information about the potential; see structures.h
Ci     Elts read:  vmtz ves palp
Co     Stored:     socscl
Co     Allocated:  cp pf dpf ddpf dddpf pfr dpfr ddpfr papg gmar palp
Co                 gma pfnc
Cio    Elts passed: pp pf qc gma palp dpf ddpf dddpf pfr dpfr ddpfr
Cio                papg gmar sop socscl pprel dlmwt pfnc pnu qnu ves
Cio    Passed to:  pgsoscl supgh supgbc supghz suhamz mkpotf makpfz
Cio                mkptfp mksopf gvbma pgsif plhamnc plham pgbevl
Cio                pgkmap pgflu sblham pgemb pvemb pgdysn pgles pgcurr
Cio                gfg2g shoctl
Cio  s_strn :struct for global strings; see structures.h
Ci     Elts read:  *
Co     Stored:     strn
Co     Allocated:  *
Cio    Elts passed:*
Cio    Passed to:  str_pack
Ci Inputs
Ci   lldau :lldau(ib)=0 => no U on this site otherwise
Ci          U on site ib with dmat beginning at dmats(*,lldau(ib))
Ci   vorb  :orbital dependent potential matrices
Ci   dmatu :density matrix for LDA+U
Ci   vshft :array of site potential shifts
Ci   zp    :points for complex energy contour
Ci   wz    :weights for complex energy integration
Ci   pgfsl :PL index: site ib belongs to layer pgfsl(ib) (pgfset.f)
Ci   efermi:Fermi energy
Ci         :In non-equilibrium mode, Fermi energy of left lead
Cio Inputs/Outputs
Cio  pgplp :index and dimensioning information for each PL (pgfset.f)
Cio         1: number of basis atoms in all PL prior to this one
Cio         2: index labelling kind of potential of this PL
Cio         The following are created internally by routine supgh:
Cio         3: source (column) dimension of GF for this PL
Cio         4: row (field) matrix dimension for this PL
Cio         5: matrix dimension for this PL including i-waves
Cio         6: offset to diagonal part of g
Cio         pgplp(1) and pgplp(2) are generated by pgfset;
Cio         the remainder are generated by pgfasa.
Cio
Co Outputs: see Remarks
Co  vconst :array of global potential shifts to estat potential
Co         :to ensure charge neutrality.
Co         :vconst(1) = potential shift
Co         :vconst(2) = potential shift of L end region (PGF)
Co         :vconst(3) = potential shift of R end region (PGF)
Co         :Shifts are chosen so that the system is neutral for the
Co         :given Fermi level (input, and fixed quantity).  Shifts
Co         :are accumulated by pgfasa as it iteratively finds its way to
Co         :charge neutrality. Which vconst are altered depends on lpgf:
Co         :  lpgf=1: Adjust vconst(1)
Co         :  lpgf=2: Adjust vconst(2), vconst(3)
Co         :Local variable vbar accumulates the correction to vconst
Co         :until pgfasa is finished.
Co   moddos: flags marking what quantities were made
Co   sumev :sum of eigenvalues
Co   qnu   :energy-weighted moments of the sphere charges
Co   rhos  :spin density-matrix
Ci   amag  :system magnetization
Co   aamom :local magnetic moments
Co   ogii  :table of offsets arrays containing GF by layer.
Co         :gii(i) holds diagonal block of GF for PL i and
Co         :possibly some off-diagonal blocks adjacent to i, if
Co         :specified by nofgL and nofgR described in Local variables.
Co         :See also *Notes about memory allocation below
Cs Command-line switches
Cs  --onesp : Generate bands for one spin (not implemented)
Cl Local variables
Cl  bigemb :(for lpgf=1,5,7,8)
Cl         :1 compute gLL and gRR for layers (-1, npl), and corresponding output charges
Cl         :0 do not compute these charges
Cl   lgii  :attributes of the gii generated.  Not needed except
Cl         :for informational purposes. See lgupac for conventions.
Cl         :... the following are made under special conditions
Cl   gend  :gend(1) = g(npl,-1)  (lpgf=5)
Cl         :gend(2) = g(-1,npl)  (lpgf=5)
Cl         :gend(3) = gll (Left surface GF at -1)        (lpgf=7)
Cl         :gend(4) = grr (right surface GF at npl)      (lpgf=7)
Cl  strRL(1..2) used when g_LR=g(L,R) and g_RL=g(R,L) are made.
Cl          1   maximum dimension of all diagonal GF in layers -1..npl
Cl          2   maximum dimension diagonal GF, layers -1 and npl only
Cl              strRL(1) and strRL(2) dimension g_RL and g_LR as:
Cl              g_LR = g_LR(strRL(2),strRL(1))
Cl              g_RL = g_RL(strRL(1),strRL(2))
Cl              In the noncollinear case strRL(1..2) are doubled
Cl   gflst :a table of PL for which diagonal G.F. are made, with
Cl         :the structure defined in pgglst.
Cl         :gflst(0) is the total number of layers to be considered
Cl   glstp :a similar table, for which to accumulate DOS & other props
Cl   vshfn :potential shifts added to vshft, by layer, generated
Cl         :by pgfasa to achieve charge neutrality.
Cl         :Initially vshfp is zero
Cl   vhldp :a work array used by gfzerq to bracket potential shifts
Cl         :for charge-neutrality point
Cl   vsint :a work array to bracket potential shifts over internal loops
Cl         :where g is explicitly calculated.  It plays a role similar
Cl         :to the Pade, except that points kept are real, not estimates.
Cl   vbar  :cumulative change in vconst to ensure charge neutrality
Cl   nipl  :number of PL for which to accumulate integrated quantities
Cl   hord  :order of polynomial approximation to hamiltonian
Cl   nofgL :specifies range of GF connecting a PL to neighboring PL
Cl         :nofgL>0 specifies that GF connecting layer i to layers
Cl         :i-1, i-2, ... i-nofgL are computed together when the
Cl         :diagonal GF for layer i is computed.
Cr         :See *Notes about memory allocation below
Cl   nofgR :similar to nofgL.
Cl         :nofgR>0 specifies that GF connecting layer i to layers
Cl         :i+1, i+2, ... i+nofgR are computed.
Cl   lpgf  :a local copy of structure element 'ctrl lpgf'; see Remarks
Cl   lspc  :0 if spins for surface GF are to be treated as uncoupled
Cl         :1 if spins for surface GF are to be treated as coupled
Cl  lagain :0 => quantities from diagaonal G calculated from true GF
Cl         :1 => quantities from diagaonal G estimated by Pade
Cl         :2 => quantities from diagaonal G estimated by Pade, last iteration
Cl         :<0 => same as 0, but internal iteration
Cl    jk   :transmission probability for one k-point
Cl  totjk  :transmission probability integrated over k||
Cl  totjE  :transmission probability integrated over k|| and energy
Cl  vne    :ef(R)-efermi, where ef(R) is fermi energy of right lead
Cr Remarks
Cr *Branches of execution.  Branches are mutually exclusive.
Cr 'ctrl lpgf' governs which branch is taken.
Cr     1: Generate diagonal GF and output density
Cr     2: Find Fermi left- and right-bulk Ef relative to input ves
Cr     3: Trace out band structure for spec'd energy mesh, left bulk
Cr        In this case make Im(z)=0.
Cr     4: Ditto for right bulk.
Cr     5: Calculate current through structure
Cr        See *Notes about memory allocation, below
Cr     6: Experimental mode : current with weakly varying potential
Cr     7: Calculate reflection at L and R interfaces
Cr     8: For spin torques
Cr
Cr *Options, which may apply to some or all of the major branches.
Cr Those options inapplicable to a particular branch are ignored
Cr Options are passed in a string form, in gfopts.
Cr Options are separated delimiter ';'
Cr   'bigemb'      Include layers -1 and npl in active region
Cr   'emom'        accumulate output moments
Cr   'noemom'      suppresss accumulation of output moments
Cr   'idos'        integrated DOS by plane
Cr   'noidos'      suppress integrated DOS by plane
Cr   'dmsv'        ?
Cr   'intrinsic'   ?
Cr   'skip'        ?
Cr   'pdos'        accumulate partial DOS
Cr   'nclead'      Allow leads to be noncollinear
Cr   'declead'     Calculate lead GF with decimation (this may be the default)
Cr   'p1' or 'p3'  order of potential function
Cr   'padtol=#'    tolerance in the Pade estimate for Fermi level shift
Cr   'qtolp=#'
Cr   'refinegs=#'  Use iterative procedure to refine surface g after it has been made
Cr                 0 => no refinement
Cr   'ibloch'      inverse Bloch transform
Cr
Cm Memory
Cm *Notes about storage of GF and memory allocation
Cm   The entire GF is not needed in general; what is kept depends
Cm   on the mode (lpgf) and variables nofgL and nofgR described in
Cm   Local variables above.  The GF are created and stored for
Cm   a single energy and k-point; relevant information is extracted
Cm   from them and the gf are discarded.  GF for each layer are
Cm   stored in separate arrays; the diagonal GF g(i,i) for layer i
Cm   is stored in gii(i)%gll.
Cm
Cm   Off-diagonal GF g(i,j) connecting layer i to adjacent layers j
Cm   (computed for nofgL>0 or nofgR>0) are also stored in gii(i)%gll.
Cm   Integer array pgplp holds information about the dimensioning
Cm   of gii(i).  In particular pgplp(4..6,i) hold the row and column
Cm   dimensions, and the offset within the array gii(i) to the start of
Cm   the diagonal block, g(i,i).
Cm
Cm  In transport mode (lpgf=5), the only GF needed are the four 'corner'
Cm  blocks, g(-1,-1), g(-1,npl), g(npl,npl), g(npl,-1) .
Cm  In this mode, these blocks are made and stored in gend.
Cm  Special memory is allocated for them; information about the array
Cm  dimensions are kept in strRL(1..2); see Local variables above.
Cm
Cm  Because there no need to retain even the diagonal GF g(i,i) except
Cm  at the corners, the same memory is reused for each layer and then
Cm  gii for layers -1<i<npl are DESTROYED.  Code for memory allocation
Cm  follows the comment
Cm  '... Allocate memory for the diagonal gii, transport mode (lpgf=5)'
Cm  found below.
Cb Bugs
Cb   potential-related variables do not belong here ...
Cu Updates
Cu   05 Dec 17 Iterative refinement of surface gf
Cu   15 Jun 17 Noncollinear branch now works in global axis.
Cu             Rotation to local axis moved to pgfasa, after g's have been made
Cu             This renders LU and embedding modes consistent.
Cu   28 Aug 16 pgf mode 1 redesigned to handle nonequilibrium, noncollinear case
Cu   05 Jun 16 First cut at noncollinear nonequilibrium GF
Cu   02 May 16 Started on spin torques (lpgf=8)
Cu   01 May 16 Leads can be noncollinear
Cu   03 Oct 15 First cut at making embedding branch noncollinear
Cu   02 Sep 15 complete migration to f90 pointers
Cu   08 May 13 Eliminate s_array
Cu   12 Nov 12 Begin migration to f90 pointers
Cu   10 Nov 11 Begin migration to f90 structures
Cu   01 Dec 07 LDA+U implementation (diagonal only), first cut
Cu   25 Apr 05 Self-energy can have different Im Z than active region
Cu             for contours close to real axis.
Cu   15 Jan 04 (S.Faleev) implemented nonequilibrium mode
Cu    6 Dec 03 lpgf=5 works for noncollinear branch
Cu   21 Mar 03 redesigned potential shifts; new argument list.
Cu   10 Mar 03 Poke double-counting from appl. field into eterms
Cu   01 Nov 02 (D. Stewart) bug fix in k-point weights for current
Cu   26 Feb 02 Several revisions.  LU decomposition and
Cu             layer-by-layer approach put on equal footing:
Cu              * both can make g(-1),g(npl) for lpgf=1; this is
Cu                done if bigemb>0, which can be set through the
Cu                gfopts switch
Cu              * both generate surface GF in advance using
Cu                supgbc, for lpgf=1
Cu              * either approach should produce essentially
Cu                identical densities and output
Cu             vshft is now distributed over sites internally.
Cu             Some bug fixes.
Cu   21 Dec 01 Altered argument list
Cu   18 Dec 01 (D. Stewart) implemented transmission formula (lpgf=5)
Cu   12 Dec 01 pgflu can compute off-diagonal GF for transmission.
Cu             and several small changes to accomodate transmission
Cu             formula
Cu   28 Apr 00 made noncollinear, sparse mode
C ----------------------------------------------------------------------
      use mpi
      use structures
      implicit none
C ... Passed parameters
      integer nsp,pgfsl(*),pgplp(6,-1:*)
      double precision vconst(3)
      double precision amag(3),aamom(*),vshft(*),qnu(*),rhos(*),
     .  efermi,zp(2,*),wz(2,*),sumev,eterms(22)
C ... For LDA+U
      integer lldau(*)
      double complex vorb(*),dmatu(*)
C ... For MPI
      integer, allocatable :: kpproc(:)
      double precision, allocatable :: qploc(:,:)
C ... For structures
!      include 'structures.h'
      type(str_ctrl)::  s_ctrl
      type(str_lat)::   s_lat
      type(str_spec)::  s_spec(*)
      type(str_site)::  s_site(*)
      type(str_bz)::    s_bz
      type(str_str)::   s_str
      type(str_ham)::   s_ham
      type(str_pot)::   s_pot
      type(str_strn) :: s_strn(*)
C ... Dynamically allocated arrays
      integer, pointer :: gflst(:),glstp(:),offHb(:,:),iprmbb(:)
      integer, allocatable :: ipa(:)
      integer, allocatable :: idu(:)
      integer, allocatable :: lgii(:)
      integer, allocatable :: dlmcl(:)
      real(8), allocatable :: z(:)
      real(8), allocatable :: orbtm(:)
      real(8), allocatable :: vshfn(:)
      real(8), allocatable :: vhldp(:)
      real(8), allocatable :: dvldu(:)
      real(8), allocatable :: dosi(:,:,:)
      real(8), allocatable :: pdos(:)
      real(8), allocatable :: wki(:)
      real(8), allocatable :: vpl(:)
      real(8), allocatable :: qne(:),dosne(:)
      real(8), allocatable :: ovlpa(:)
      complex(8), allocatable :: gd(:),sdmat(:)
      complex(8), allocatable :: r(:),rvec(:)
      complex(8), allocatable :: dmatloc(:)
C     Parameters for non-equlibrium mode (S.F.)
      complex(8), allocatable :: snn(:),bnn(:),gin(:)
      complex(8), pointer :: gsL(:,:),gsR(:,:),gLL(:,:),gRR(:,:),gRL(:,:),gLR(:,:)
C     Pointer array to different layer GF's
      type (s_lgf), allocatable :: gii(:),gij(:,:)
      type (s_lgf), target :: gii2(2),gend(4)
C ... Local parameters
      integer,parameter :: NULLI=-99999
      integer nkap0,n0H
      parameter (nkap0=4,n0H=5)
      logical F,T,lemom,lnos,lpade,lrhos,ltmp,lso,onesp,lpdos,llast,declead,lgcorr,ldmsv,
     .  lskip,lintr,lreslead,linveula
      integer PRTG,hord,i,i1,i2,ib,ib1,ib2,ierr,lagain, ikp,ipl,ipr,iprx,isp,
     .  izp,j,jpl,kpl,ldlm,lbulk,ldham(16), hdim,ldim,lidim,lhdim,ldim0,ldim1,
     .  ldim2,lgunit,lham,lmem,lmet,lncol,lpgf, lpgfl,lsprse,lspc,moddos,mode,
     .  modemb,moddos2,nbas,nbasp,nclass,nclasp,nclspd, ndg,ndos,nipl,nkp,nl,
     .  nlo,nlspcp,nofgL,nofgR,npados,npdos,npl,nrpt,nrhos,nspc,nspcl,nzp,nzptot,pgdim,stdo,
     .  strRL(4),ldim0x,ndgx,ldos,bigemb, mxorb,npadl,npadr,ifi,lrel,str_pack,
     .  offpd,offd
      double precision xx,rmsdv,rmsdq,wk(12),wksum(5,2),semsh(10),ghh(1)
      double precision alat,plat(3,3),rmaxs,qp(3),wtkp,padtol,dqsum,
     .  dosw(2),zval,qtolp,qtot,qtotl,qtotr,vbar(3),xv(1),vsint(14),growdv
      double precision dum(4*2*2*9),mag(3)
      integer ndmat
C     Parameters for transport
      double precision totjk(2,2,2,2),totjE(2,2,2,2,2),jk(2,2,2,2,2,2)
C     Parameters for rotating the noncollinear G to local spin quantization axis
      integer offL,offi,offR,kcplx,optrot
C     character*8 fnam(2)
      integer ISH,IPLMOD,MZP
      parameter(PRTG=70,T=.true.,F=.false.,ISH=1,IPLMOD=64,MZP=64)
      character*80 outs,fmt*20,gfopts*120
      equivalence (ldim,ldham(1)),(lidim,ldham(2)),(lhdim,ldham(3))
      procedure(logical) :: bittst,cmdopt
      procedure(integer) :: fxst,isw,fopn,fopna,iprint,partok,nglob,bitand,parg2
C ... For DLM (not implemented)
!     integer odlmcl
      integer,allocatable:: ncomp(:)
      character *14 dosfil
      character *6 aib
      integer icomp
C ... Parameters for non-equlibrium mode (S.F.)
      double precision vne,qnesum(2),qne2(2),dosne2(4)
C     double precision delne,del00
      integer nzne,ld0n,ldmx,lds,ld0nx,ldmxx
      logical lnoneq
      double precision zpbak(2)
C ... For LDA+U
      integer nlibu,lmaxu,ludiag
C ... for MPI
      integer mpipid,procid,master,nproc,nkploc,nlen,err
C .. Parameters to write DOS on non-equil. contour
C#ifdefC DEBUG
C      double precision,allocatable:: dos_ne(:,:)
C      double precision qq,qqt,qqtt,dost
C#endif
      procedure(integer) :: rotspd
      integer ipass

C --- Unpack parameters, set defaults ---
      call tcn('pgfasa')
      procid = mpipid(1)
      nproc = mpipid(0)
      master = 0
      lmet = s_bz%lmet
      nkp = s_bz%nkp
      semsh = s_bz%semsh
      dosw = s_bz%dosw
      ndos = s_bz%ndos
      alat = s_lat%alat
      plat = s_lat%plat
      growdv = 1                ! May be set larger if vshft is systematically underestimated
      nbas = s_ctrl%nbas
      nbasp = s_ctrl%nbasp
      nl = s_ctrl%nl
      nsp = s_ctrl%nspin
      lncol = s_ctrl%lncol
      lso = bittst(lncol,4)
      lrel = mod(nglob('lrel'),10)
      if (lso .and. lrel == 2) call rx('lso and lrel=2 in pgfasa: should never happen')
      nlibu = s_ham%nlibu
      lmaxu = s_ham%lmaxu
      ludiag = s_ham%udiag
      ldos   = IAND(s_ctrl%ldos,7)
      lpgf   = s_ctrl%lpgf(1)
      lsprse = mod(s_ctrl%lpgf(2),10)
      ipass = 1
      nspc = 1
      if (bitand(lncol,1+2+4+8) /= 0) nspc = 2
C     Sparse mode only applicable to certain modes
      if (lpgf /= 1 .and. lpgf /= 5 .and. lpgf /= 7 .and. lpgf /= 8) lsprse = 0
C     if (lpgf == 7) lsprse = 1 ! Reflection implemented only in LU decomp mode
      lham = s_ctrl%lham
      nlo = nl
      if (ldos >= 4) nlo = nl*nl
      mxorb = nglob('mxorb')
      nclasp = s_ctrl%nclasp
      nclspd = nclasp  !  + nangl
      nofgL = s_ctrl%nofgl
      nofgR = s_ctrl%nofgr
      nclass = s_ctrl%nclass
C     gfopts = ' '
C     if (i2 >= i1) gfopts = sstrn(i1:i2)
      j = str_pack('gfopt',-2,s_strn,gfopts(2:))
      gfopts(1:1) = ';'
C     No special off-diagonal GF needed in these cases
      if (lpgf >= 2 .and. lpgf <= 8) then
        nofgL = 0
        nofgR = 0
      endif
      rmaxs = s_str%rmax
      padtol = .03d0; qtolp = 0; s_ctrl%refinegstol = 0
      efermi = semsh(4)
C     delne = semsh(9)
C     del00 = semsh(10)
      stdo = lgunit(1)
      npl = pgfsl(nbas)
      npadl = pgplp(1,0)
      npadr = pgplp(1,npl-1) - pgplp(1,npl-2)

C ... Class-based arrays
      allocate(z(nclasp))
      call spec2class(s_spec,nclasp,s_ctrl%ics,'z',1,[0],z)

C     vbar = change in vconst to ensure charge neutrality
C     At the close of pgfasa, vconst is incremented by vbar
      call dpzero(vbar,3)

C --- Global setup: array dimensions ---
      ldlm = s_ctrl%ldlm
      nzp = nint(semsh(1))
      lrhos  = bittst(lncol,16)
      if (lso .or. nspc == 2) lrhos = T                ! Kirill
      nrhos  = nl
      onesp = cmdopt('--onesp',7,0,outs)
      nlspcp = nl * nsp * nclasp
      allocate(lgii(-2:npl+1)); call iinit(lgii,npl+4)
      allocate(gii(-2:npl+1))
      do  i = -2, npl+1; nullify(gii(i)%gll); enddo
      nullify(gend(1)%gll,gend(2)%gll,gend(3)%gll,gend(4)%gll)
C ... Allocate space for orbital moment in nspc=2 case
      if (nspc == 2) then
        allocate(orbtm(nlo*2*nclasp)); call dpzero(orbtm,nlo*2*nclasp)
      else
        allocate(orbtm(1))
      endif

C     For double-counting terms
      eterms = s_ham%eterms
      call dvset(eterms,17,18,0d0)

C --- Setup for non-equilibrium mode (S.F.)
      call setne(s_bz,s_ctrl,nzne,vne,lnoneq)
      if (lnoneq) then
C       Exclude branches where non-equilibrium mode does not work yet
C        if (lsprse /= 0 .and. lpgf /= 5)
C     .    call rx('pgfasa: not ready for LU decomp in non-equlibr. mode')
C       if (lrhos)        ! Kirill commented out and next line
C    .    call rx('pgfasa: not ready for den. matrix in non-equlibr. mode')
        if (nofgL /= 0 .or. nofgR /= 0)
     .    call rx('pgfasa: not ready for nofgL(R)!=0 in non-equlibr. mode')

C       Shift fermi energy of right lead by vne ( ef(R) = efermi + vne )
C#ifdefC SPLITVNE
C        call gtibpl(-1,npl,pgplp,ib1,ib2)
C        forall (ib=ib1:ib2) vshft(ib) = vshft(ib) - vne/2
C        call gtibpl(npl,npl,pgplp,ib1,ib2)
C        forall (ib=ib1:ib2) vshft(ib) = vshft(ib) + vne/2
C#else
       call gtibpl(npl,npl,pgplp,ib1,ib2)
       forall (ib=ib1:ib2) vshft(ib) = vshft(ib) + vne
C#endif
      endif

      if (nlibu > 0 .and. ludiag == 0) call rx('LDA+U requires HAM UDIAG=T')

C --- Unpack GF options ---
C     Default nos,emom ON for contour integral
      lnos = mod(nint(semsh(2)),100) == 10
      lemom = lnos
      lpade = T
      bigemb = 0
      lgcorr = F                ! Not implemented yet
      call partk0(0,len(gfopts),1,-1,0,len(gfopts),-1,31,F)
C     if (lpgf == 2) savshf = T
      i = partok(gfopts,'bigemb',' ;',ltmp,' ',0,0,0,0)
      if (ltmp) bigemb = 1
      i = partok(gfopts,'emom',' ;',ltmp,' ',0,0,0,0)
      if (ltmp) lemom = T
      i = partok(gfopts,'noemom',' ;',ltmp,' ',0,0,0,0)
      if (ltmp) lemom = F
      i = partok(gfopts,'idos',' ;',ltmp,' ',0,0,0,0)
      if (ltmp) lnos = T
      i = partok(gfopts,'noidos',' ;',ltmp,' ',0,0,0,0)
      if (ltmp) lnos = F
      if (ltmp) lemom = F
      i = partok(gfopts,'pdos',' ;',lpdos,' ',0,0,0,0)
      i = partok(gfopts,'dmsv',' ;',ldmsv,' ',0,0,0,0)
      i = partok(gfopts,'skip',' ;',lskip,' ',0,0,0,0)
      i = partok(gfopts,'intrinsic',' ;',lintr,' ',0,0,0,0)
      i = partok(gfopts,'nclead',' ;',ltmp,' ',0,0,0,0)
      if (ltmp) s_ctrl%lpgf(2) = 10 + s_ctrl%lpgf(2) - IAND(s_ctrl%lpgf(2),10)
      i = partok(gfopts,'inveula',' ;',linveula,' ',0,0,0,0)
      if (linveula) call srotspd(0)
      i = partok(gfopts,'declead',' ;',declead,' ',0,0,0,0)
      i = partok(gfopts,'padtol=','= ;',padtol,' ',-1,4,0,0)
      i = partok(gfopts,'qtolp=','= ;',qtolp,' ',-1,4,0,0)
      lreslead = parg2(gfopts,';','sreslead',',',' ;',4,0,0,i1,0,0) > 0
      s_ctrl%refinegstol = 0
      i = parg2(gfopts,';','refinegs=',',',' ;',4,1,1,i1,s_ctrl%refinegstol,s_ctrl%refinegstol)

      hord = 2
      i = partok(gfopts,'p3',' ;',ltmp,' ',0,0,0,0)
      if (ltmp) hord = 3
      i = partok(gfopts,'p1',' ;',ltmp,' ',0,0,0,0)
      if (ltmp) hord = 1

      if (lpdos .and. mod(nint(semsh(2)),100) == 10) lpade = T
      if (lpgf == 2) then
C       lnos = T
        lpade = T
      elseif (lpgf == 5 .or. lpgf == 6 .or. lpgf == 7 .or. lpgf == 8) then
        nofGL = 0; nofGR = 0
        lnos = .false.; lpdos = .false.; lpade = .false.; lemom = .false.
      endif
      lspc = isw(s_ctrl%lpgf(2) >= 10 .and. nspc == 2)
      if (padtol <= 0) then
        lpade = .false.
        padtol = -padtol
      endif

C ... Zero out SO coupling in end layers
      if ((lrel == 2 .or. lso) .and. fxst('socscl') /= 1 .and. lspc /= 1)
     .  call pgsoscl(s_ctrl,s_pot)

C ... Exclude p1,p3 cases which do not work in non-equilibrium mode (S.F.)
C      if (lnoneq .and. hord /= 2)
C     . call rx('pgfasa non-equil. mode: remove p1 or p3 from ctrl file')
C ... Exclude pDOS cases  which do not work in non-equilibrium mode
      if (lpdos .and. nzne /= 0) then
         if (nint(semsh(2)) /= 100)
     .    call rx('pgfasa: need semsh(2)=100 to make pDOS by G^<')
         if (lnos) call rx('pgfasa: need  noidos in ctrl file to make pDOS by G^<')
         if (nzp /= 0) call rx('pgfasa: need nzp = 0 in ctrl file to make pDOS by G^<')
      endif

C ... What of output rho or dos to get (see gfidos)
      moddos = 0
      if (lnos) moddos = 1
C ... No Pade approximant for this mesh
      if (lpdos .and. mod(nint(semsh(2)),100) == 0)
     .           moddos = moddos + 10
      if (lpade) moddos = moddos + 20
      if (lemom) moddos = moddos + 100
      if (lrhos) then
        moddos = moddos + 1000
        if (allocated(sdmat)) deallocate(sdmat)
        allocate(sdmat(nl**4*nbasp*nsp*nspc*4))
        sdmat = 0
        do  ib = 1, nbasp
          i = 4*s_site(ib)%norb**2 ! the factor 4 is for the LMTO moments phi/phidot
          if (nspc == 2) i = i * 4
          call ptr_site(s_site,8+1,'dmat',ib,i,s_site(ib)%ncomp,xx)
        enddo
      else
        allocate(sdmat(1))
      endif
      if (nproc > 1 .and. lpgf /= 5 .and. lpgf /= 7 .and. lpgf /= 1)
     .  call rx('pgfasa: parallel mode only works for modes 1, 5 and 7')

C ... Hamiltonian setup
      if (lpgf == 2 .or. lpgf == 5  .or. lpgf == 6 .or. lpgf == 7 .or. lpgf == 8) bigemb = 1
      allocate(ipa(nbasp+1)); call iinit(ipa,nbasp+1)
C     Case large embedded region: remake hamiltonian offsets
      if (bigemb > 0) then
        iprmbb => s_ham%iprmb; nullify(s_ham%iprmb)
        offHb => s_ham%offH; nullify(s_ham%offH)
        call ptr_ham(s_ham,8+1,'offH',n0H*nkap0,(nbasp+1),xv)
        call ptr_ham(s_ham,8+1,'iprmb',(nbasp*mxorb)+3,0,xv)
        call pgflu7(nbas,npadl,npadr,nl,s_spec,s_ctrl%ips,ipa,
     .    s_ham%offH,s_ham%iprmb,ldham)
      endif
      deallocate(ipa)

      ldham = s_ham%ldham
      call supgh(s_ctrl,s_spec,s_ham,s_pot,s_str,pgplp)

      hdim = lhdim-lidim
      if (hdim /= 0) call rx('pgfasa not ready for downfolding')

C ... Setup for off-diagonal GF, transmission current modes
      call iinit(strRL,4)
      allocate(gij(1,-1:1))     ! dummy to avoid tripping up compiler
      if (lpgf == 5 .or. lpgf == 6 .or. lpgf == 8) then
C       Leading dim of G(L,R) = largest dimension of any diagonal GF
        strRL(1) = nspc*pgdim(3,-1,npl,-1,npl,pgplp)
C       strRL(2) = largest dimension of any diagonal GF
C   ... Second dimension of g(L,R)
        strRL(2) = nspc*max(pgplp(3,-1),pgplp(3,npl))
C   ... Allocate space for G(L,R) and (lpgf=8) for all g's connected to endpoints
        j = strRL(1)*strRL(2)
        allocate(gend(1)%gll(strRL(1),strRL(2)))
        allocate(gend(2)%gll(strRL(2),strRL(1)))
        if (lpgf == 8) then
          deallocate(gij); allocate(gij(4,-1:npl))
          do  i = -1, npl
            allocate(gij(1,i)%gll(nspc*pgplp(4,-1),nspc*pgplp(3,i)))   ! gij(-1,i)
            allocate(gij(2,i)%gll(nspc*pgplp(4,i),nspc*pgplp(3,-1)))   ! gij(i,-1)
            allocate(gij(3,i)%gll(nspc*pgplp(4,npl),nspc*pgplp(3,i)))  ! gij(npl,i)
            allocate(gij(4,i)%gll(nspc*pgplp(4,i),nspc*pgplp(3,npl)))  ! gij(i,npl)
          enddo
        endif
      endif

C --- Printout at entry ---
      if (iprint() >= 30) then
        call info8(30,1,0,
     .    ' --- PGFASA ('//
     .    '%?#n# gamma,##'//
     .    '%?#n#%b-bar,##'//
     .    '%?#n# bigemb,##'//
     .    '%?#n# nc leads,##'//
     .    '%?#n# leads by decimation,##'//
     .    '%?#(n>0)# refine gs,##%-1j'//
     .    '%?#(n<0)# refine gs from file,##'//
     .    '%?#n# LU-decmpsn,##'//
     .    '%?#(n%10)# Fermi-sea only,##%-1j'//
     .    '%?#(n>=10)# inverse-euler,##'//
     .    '%?#%c==,#%b## ) ---',
     .    bitand(lham,128),bitand(s_ctrl%lasa,512),bigemb,lspc,
     .    isw(declead.and.lpgf == 2),
     .    nint(dsign(1d0,s_ctrl%refinegstol(1))*isw(s_ctrl%refinegstol(1) /= 0)),
     .    lsprse,isw(lintr)+10*isw(linveula))

        call awrit7('%x '//
     .    '%?;n==1;layer GF;;%-1j'//
     .    '%?;n==2;bulk L,R GF;;'//
     .    '%?;n;: find neutral Ef;;'//
     .    '%?;n==3;make kmap(l);;'//
     .    '%?;n==4;make kmap(r);;'//
     .    '%?;n;make transmission;;'//
     .    '%?;n==7;make reflection;;'//
     .    '%?;n==8;make spin torques;;',
     .    outs,80,0,
     .    lpgf,isw(lpgf == 2.and.lnos),lpgf,lpgf,
     .    isw(lpgf == 5.or.lpgf == 6),lpgf,lpgf)
        call awrit7('%a'//
     .    '%?;(n<3); and;;'//
     .    '%?;n; qnu,;;'//
     .    '%?;n; idos,;;'//
     .    '%?;n; pdos,;;'//
     .    '  using P%i,'//
     .    '%?;n; none,;;'//
     .    '%?;n; none;;%a%b %a',outs,80,-stdo,lpgf,isw(lemom),
     .    isw(lnos),isw(lpdos),hord,0,0)
        i = 18
        fmt = '(1x,a,20I4)'
        do  8  ipl = 0, npl-1, i
          if (ipl > 0) print *, ' ....'
          print fmt,'  PL',(ib, ib = ipl, min(i+ipl-1,npl-1))
          print fmt,' 1st',
     .      (pgplp(1,ib-1)+1, ib = ipl, min(i+ipl-1,npl-1))
          print fmt,'nbas',
     .       (pgplp(1,ib)-pgplp(1,ib-1), ib = ipl, min(i+ipl-1,npl-1))
          print fmt,'ndim',(pgplp(3,ib), ib = ipl, min(i+ipl-1,npl-1))
          print fmt,'ldim',(pgplp(4,ib), ib = ipl, min(i+ipl-1,npl-1))
          print fmt,' L+I',(pgplp(5,ib), ib = ipl, min(i+ipl-1,npl-1))
          print fmt,' PLV',(pgplp(2,ib), ib = ipl, min(i+ipl-1,npl-1))
C         print fmt,'offs',(pgplp(6,ib), ib = ipl, min(i+ipl-1,npl-1))
    8   continue
      endif

      if (iprint() >= 30 .and. procid == master) then
        call info0(25,0,0,' ')
        call iovshf(nbas,6,' using',xx,efermi,vconst,vshft,-stdo)
        call info0(25,0,0,' ')
      endif

      if (nlibu > 0 .and. bitand(lham,128) == 0) call rx('LDA+U requires gamma repsn')

C ... Quit if --quit=ham given
      if (s_ctrl%quit == 8) call rx0('quit = ham')

C --- PL(i) for which to make g_ii (gflst) and props of g (glstp) ---
      if (lpgf == 3 .or. lpgf == 4) then
        allocate(gflst(0:1))
        gflst(0)   = 1
        gflst(1) = -1
        if (lpgf == 4) gflst(1) = npl
        glstp => gflst
      elseif (lpgf == 5 .or. lpgf == 6) then
        allocate(gflst(0:npl+2))
        call pgglst(011,npl,pgplp,gflst(0))
        glstp => gflst
      elseif (lpgf == 1 .or. lpgf == 7 .or. lpgf == 8) then
        allocate(gflst(0:npl+2))
        allocate(glstp(0:npl+2))
        call pgglst(001,npl,pgplp,gflst(0))
        if (bigemb == 0) call pgglst(000,npl,pgplp,glstp(0))
        if (bigemb /= 0) call pgglst(111,npl,pgplp,glstp(0))

C        if (lsprse == 0 .or. bigemb /= 0) then
C          call pgglst(001,npl,pgplp,gflst(0))
C          call pgglst(111,npl,pgplp,glstp(0))
C        else
C          call pgglst(000,npl,pgplp,gflst(0))
C          glstp => gflst
C        endif
      elseif (lpgf == 2) then
        allocate(gflst(0:2))
        gflst(0) = 2
        gflst(1) = -1
        gflst(2) = npl
        glstp => gflst

      else
        call rxi('pgfasa: not implemented lpgf=',lpgf)
      endif
      nipl = glstp(0)

C     call awrit2(' gflst %n:1i',' ',100,stdo,gflst(0)+1,gflst(0))
C     call awrit2(' glstp %n:1i',' ',100,stdo,glstp(0)+1,glstp(0))

C ... Allocate memory for the diagonal gii, transport mode (lpgf=5)
C     Except when skipping through repeating-potential layers,
C     we need retain only diagonal GF at and a given layer and that
C     of the right ajacent layer.  This applies until layer npl is
C     reached, when when 3 diagonal GF needed.
C     Repeating layers require an additional allocation.
C     Memory for two layers are allocated in oi(1..2), and these
C     pointers are copied to gii(-1...npl)
C     Note : sparse mode allocates its arrays internally
      if ((lpgf == 5 .or. lpgf == 6) .and. lsprse == 0) then
        j = strRL(1)**2
        allocate(gii2(1)%gll(strRL(1),strRL(1)))
        allocate(gii2(2)%gll(strRL(1),strRL(1)))

C       Allocate gii(-1) separately; we need to save it
        allocate (gii(-1)%gll(strRL(1),strRL(1)))
C       Variable i will toggle between 1 and 2
        i = 2
        do  kpl = 1, gflst(0)

C         -1 layer already computed
          if (gflst(kpl) == -1) cycle

C         ipl = layer adjacent to last calculated layer
C         jpl = ipl+nrpt-1 (next sif GF)
          nrpt = gflst(kpl) - gflst(kpl-1)
          jpl = gflst(kpl)
          ipl = jpl-nrpt+1

          if (nrpt /= 1) call rx('pgfasa: fix mem alloc for lpgf=5, nrpt>1')
          i = 3-i
          gii(ipl)%gll => gii2(i)%gll
        enddo
      endif

C ... Starting verbosity for looping over k-points
      ipr=0
      if (iprint() >= 30) ipr=1
      if (iprint() >= 35) ipr=2
      if (iprint() > 40) ipr=3

C ... Adjust potential shifts, if target Fermi level has changed
      allocate(vshfn(glstp(0)))
      allocate(vhldp(12*gflst(0)))
C      if (getdig(int(vshft(0)),1,10) == 1) then
C        stop 'vshf'
C        xx = efermi-vshft(-7)
C        if (abs(xx) > 1d-6 .and. iprint() >= 20)
C     .    call awrit2('%N shifting average potential from reference'//
C     .    ' ef=%;6d to target ef=%;6d',' ',scrwid,stdo,vshft(-7),
C     .    efermi)
C        call advshp(npl,0,pgplp,glstp(0),xx,vshft)
C      endif

C ... Allocate room for nos for each PL listed in glstp
      if (lnos) then
        allocate(dosi(5,nsp,nipl))
      else
        allocate(dosi(1,1,1)) ! So pointer is defined
      endif
      if (lnos .and. nzne > 0) then
C       qne   :addition to charge by integration along
C             :nonequilibrium contour; for each PL,spin
C       dosne :dos at endpoints of nonequilibrium contour
C             :using G^< for ipl<npl and G^r for ipl=npl
        allocate(qne(nipl*nsp))
        allocate(dosne(2*nipl*nsp))
      else
        allocate(qne(1),dosne(1))
      endif
      allocate(pdos(1),gd(1))
      if (lpdos .or. lpade) then
        npdos  = 0
        npados = 0
        do  kpl = 1, glstp(0)
          ipl = glstp(kpl)
          call gtibpl(ipl,npl,pgplp,ib1,ib2)
          npados = npados + nl*nl*(ib2-ib1+1)
          npdos  = npdos  + nlo*(ib2-ib1+1)
        enddo
C   ... Direct calculation of partial DOS
        if (lpdos .and. mod(mod(moddos/10,10),2) == 1) then
          deallocate(pdos)
          allocate(pdos((nzp+nzne)*npdos*nsp)); call dpzero(pdos,(nzp+nzne)*npdos*nsp)
        endif
        if (lpade) then
          deallocate(gd)
          allocate(gd((nzp+nzne)*nsp*nspc*npados))
        endif
      endif

      allocate(dvldu(lhdim*nsp)); call dpzero(dvldu,lhdim*nsp)
      if (nlibu /= 0) then
        allocate(idu(4*nbasp))
        call getidu(nbasp,s_spec,s_site,idu)
        call u2pph(1,nbasp,lmaxu,nsp,nlibu,idu,vorb,s_ham%iprmb,ldim,lhdim,1d0,dvldu)
      else
        allocate(idu(1))
      endif

C ... Allocate and fill angle and weight arrays for DLM
      allocate(ncomp(nbasp))
      allocate(dlmcl(nbasp)); call iinit(dlmcl,nbasp)
      call sitepack(s_site,1,nbasp,'ncomp',1,ncomp,xv)
      call sitepack(s_site,1,nbasp,'dlmcl',1,dlmcl,xv)

C --- Re-entry for internal self-consistency ---
      lagain = 0; call dpzero(vsint,14)
  101 continue

C      So far, diagonal-only approximation
C      if (nlibu > 0) then
C        call vorbydl(-2,ssite,
C     .    s_site,s_spec,nbasp,nl,nsp,lmaxu,lldau,s_pot%pp,
C     .    vorb)
C      endif

C ... Initialize arrays in preparation for energy, k loop
      if (lnos) call dpzero(dosi,5*nipl*nsp)
      if (lnos .and. nzne > 0) then
        call dpzero(qne,nipl*nsp)
        call dpzero(dosne,2*nipl*nsp)
      endif
      if (lemom .and. bigemb /= 0) then
        call dpzero(qnu,3*nlspcp)
      elseif (lemom) then
        call dpzero(qnu,3*nl*nsp*nclass)
      endif
      if (lpade) call dpzero(gd,2*(nzp+nzne)*nsp*nspc*npados)
      call dpzero(vshfn,glstp(0))
      call dpzero(vhldp,12*gflst(0))
      call dpzero(totjE,4*4*2)

C#ifdefC DEBUG
C      if (cmdopt('-debug',6,0,outs)) then
C        zp(1,1) = .1d0
C        zp(2,1) = .2d0
C        call dcopy(2,zp,1,s_bz%qp,1)
C        zp(1,1) = -.1d0
C        zp(2,1) = -.2d0
CC       zp(2,1) = -.001d0
C        print *, 'set debugging: z,q=',zp(1,1),zp(2,1)
C      endif
C#endif

C --- Divvy up the k-points between the threads
C     if (nproc == 0) nproc = 1
      allocate (kpproc(0:nproc))
      if (nproc > 1) then
        call pshpr(1)
        call dstrbp(nkp,nproc,1,kpproc(0))
        call poppr
      else
        kpproc(0) = 1 ; kpproc(1) = nkp+1
      endif
      nkploc = kpproc(procid+1)-kpproc(procid)
      allocate (qploc(3,nkploc))
      call dpscop(s_bz%qp,qploc,3*nkploc,3*kpproc(procid)-2,1,1d0)

C --- Set up appropriate boundary conditions for L,R ---
      if (lpgf < 2 .or. lpgf > 4) then
        i = 1
        j = 0
        if (lsprse == 1 .or. .true.) then
          i = 1
          j = 1
          if (lsprse == 0) j = 0
C         call info0(30,1,0,' ... make L- and R- surface g')
C         call snot('pgfasa 917 call supgbc')
          zpbak(2) = zp(2,1)
          call shftzi(2,semsh,0,zp,wz) ! modify tiny Im zp when making surface g
          call supgbc(s_ctrl,s_lat,s_ham,s_pot,s_str,s_spec,s_site,
     .      dvldu,vshft,zp,nzp+nzne,nzp,qploc,nkploc,i,j,pgplp)
          call shftzi(1,semsh,0,zp,wz) ! Restore Im zp
          if (nzne > 0) zp(2,nzp+1) = zpbak(2)   !? why do this?
        endif
      endif
      deallocate(qploc)
C ... Quit if --quit=bc given
      if (s_ctrl%quit == 128) call rx0('quit = bc')

C --- Loop over energies, spin and k|| ---
      allocate(vpl(npl+2))
      call pgvpl(npl,pgplp,vshft,vpl)
C ... setup to write DOS on non-equilibrium contour
C#ifdefC DEBUG
C      if (nzne > 0 .and. ipass == 1 ) then
C        allocate(dos_ne(nzne,-1:npl))
C        open(unit=299,file='dos_ne')
C        dos_ne= 0d0
C        qqtt = 0d0
C      endif
C#endif
      if (lrhos) then
        do  ib = 1, nbasp
          call zinit(s_site(ib)%dmat,size(s_site(ib)%dmat))
        enddo
      endif

C --- Loop over energy mesh ---
      nzptot = nzp + nzne
      if (lintr) nzptot = nzp
      do  izp = 1, nzptot
C     do  izp = 1, nzp + nzne
C     if (izp <= nzp) cycle  ! Debugging : just noneq parts
C     if (izp >= nzp) call snit(lgii,izp,zp)

        do  isp = 1, nsp
          if (nspc == 2 .and. isp == 2) exit
          if (onesp .and. isp == 2) call rx('pgfasa not ready for noncol')

C     ... Hamiltonian setup for this energy and spin
          call supghz(s_ctrl,s_site,s_ham,s_pot,s_spec,dvldu,vshft,isp,zp(1,izp),3*isw(izp > nzp))
          call dpzero(totjk,2*4*2)

C     ... Loop over k
          if (nproc > 1) call info0(50,1,0, ' ... Start MPI k-loop')
          do  ikp = kpproc(procid), kpproc(procid+1)-1

C           print *, '!! skip ikp=1'; if (ikp == 1) cycle

            call dpscop(s_bz%qp,qp,3,3*ikp-2,1,1d0)
            wtkp = abs(s_bz%wtkp(ikp))

C       ... For printout
            if (izp == 2 .or. ikp == 2) ipr = max(ipr-1,0)
            iprx = ipr
            if (iprint() >= 30 .and. mod(ikp,100) == 0) iprx=max(ipr,1)
            if (mod(izp,100) == 1 .and. ikp == 1 .or. iprint() >= 70) then
              call info8(2,0,0,' iz = %i of %i%?;n;+%-1j%i;;'//
     .          '  z =%2:1;6,6G  wz =%2:1;6,6g%?#(n==2)#  isp=%i#%j#  q=%3:1;6d',
     .          izp,nzp,nzne,zp(1,izp),wz(1,izp),nsp,isp,qp)
          endif

C     --- Generate bulk GF in list of planes ---
          if (lpgf == 2) then
            do  kpl = 1, gflst(0)
              ipl = gflst(kpl)
              allocate(gii(ipl)%gll(nspc*pgplp(4,ipl),nspc*pgplp(3,ipl)))
              lgii(ipl) = 1
              j = 12; if (declead) j = 2
              call pgsif(j,s_ctrl,s_lat,s_ham,s_pot,s_str,s_spec,s_site,
     .          ipl,pgplp,qp,isp,pgplp(4,ipl),pgplp(3,ipl),lgii(ipl),gii(ipl)%gll)
            enddo
            goto 48
          endif

C     --- Find k corresponding to specified z (kmap) ---
          if (lpgf == 3 .or. lpgf == 4) then
            ipl = gflst(1)
            ldim0 = pgplp(4,ipl)
            mode = 0
            if (ipl == npl) mode = 1
            allocate(rvec(4*ldim0**2))
            allocate(r(2*ldim0))
            call pgkmap(s_ham,s_pot,s_str,s_site,plat,ipl,pgplp,qp,isp,mode,zp(1,izp),rvec,r)
            deallocate(r,rvec)
            cycle
          endif

C         Not needed
C         call dpzero(gend(1)%gll, 2*strRL(1)*strRL(2))
C         call dpzero(gend(2)%gll, 2*strRL(1)*strRL(2))

C         Modes 1 & 7 require same GF: use lpgfl to subst mode1 for mode 7 where appropriate
C         lpgfl = -1 => sign flags pgflu to return surface g for nonequilibrium branch
          lpgfl = lpgf; if (lpgf == 7) lpgfl = 1
          if (lpgfl==1 .and. izp>nzp) lpgfl = -1

C     --- Layer GF by LU decomposition ---
C         pgflu returns :
C         lpgf   bigemb   gii(-1)    gii(npl)  gend(1)  gend(2)  gend(3)  gend(4)  gij
C           1       0      gsLL        gsRR      -                         gsRR(*)  -  (*) if noneq
C           1       1      gLL         gRR                                          -
C           5       1      gsLL        gsRR      gRL      gLR                       -
C           7       1      gLL         gRR                        gsLL     gsRR     -
C           8       1      gsLL        gsRR      gRL      gLR                      all
          if ((iabs(lpgfl) == 1.or.lpgf == 5.or.lpgf == 8) .and. lsprse /= 0) then

C           Reflectance : return gend(3)%gll = gsLL and gend(4)%gll = gsRR
            if (lpgf == 7 .and. .not.associated(gend(3)%gll)) then
              allocate(gend(3)%gll(pgplp(4,-1)*nspc,pgplp(3,-1)*nspc))
              gsL => gend(3)%gll
            endif

C           Reflectance or Nonequilibrium point: return gend(4)%gll = gsR
            if (iabs(lpgfl)==1 .and. izp>nzp .and. .not.associated(gend(4)%gll) .or.
     .          lpgf==7 .and. .not.associated(gend(4)%gll)) then
              allocate(gend(4)%gll(pgplp(4,npl)*nspc,pgplp(3,npl)*nspc))
              gsR => gend(4)%gll
            endif

C           print *, '!!', ikp; if (ikp == 2 .or. .true.) call pshpr(80)
            call pgflu(s_ctrl,s_lat,s_ham,s_pot,s_str,s_site,isp,izp,zp,qp,semsh,
     .        lsprse,bigemb,pgplp,lpgfl,lgii,gii,strRL,gend,gij)
C           print *, '!!', ikp; if (ikp == 2) call poppr
            i = 0; if (iprint() >= 80 .or. lpgf == 5 .and. iprint() >= 70) i=3
C           if (izp > nzp .and. ikp == 1) i = 3-2; ! print *, '!!',izp,bigemb,npl
            call awrit1(' Layer GF after LU dcmpsn, izp=%i:',outs,len(outs),0,izp)
            call shopgf(i,outs,nspc,-1,npl,pgplp,gii,strRL,gend,lgii)

C           Special handling for nonequilibrium part of GF contour
            if (izp > nzp .and. iabs(lpgfl) == 1) then
              gsR => gend(4)%gll
C             allocate(gsR(pgplp(4,npl),pgplp(3,npl)))
C             call rdsurfg(npl,1,isp,0,1,izp,npl,0,semsh,pgplp,zp,qp,plat,lgii,gii(npl)%gll)
C              ld0nx = nspc*pgplp(4,npl)
C              call yprm('gs(npl)',2,gsR,ld0nx*ld0nx,ld0nx,ld0nx,ld0nx)
              goto 50
            endif
            goto 48
          endif

          call rxx(lpgf == 8,'mode 8 not implemented with Dyson, sorry')

C     ... Get left surface GF
          if (lpgf /= 5 .and. lpgf /= 6) allocate(gii(-1)%gll(pgplp(4,-1)*nspc,pgplp(3,-1)*nspc))
          call rdsurfg(-1,1,isp,lspc,nspc,izp,npl,0,semsh,pgplp,zp,qp,plat,lgii,gii(-1)%gll)
C          Build it explicitly
C          ldim0 = pgplp(4,-1)
C            call pgsif(0,
C     .      s_ctrl,s_lat,s_ham,s_pot,s_str,s_spec,s_site,-1,pgplp,
C     .      qp,isp,ldim0,pgplp(3,-1),lgii(-1),gii(-1)%gll)
C          ndg   = pgplp(3,-1)
C          call yprm('gs(-1)',2,gii(-1)%gll,ldim0*ndg,ldim0,ldim0,ndg)

C         if (ikp == 1) then
C         ldim0 = pgplp(4,-1)*nspc; ndg = pgplp(3,-1)*nspc
C         call yprm('gs(-1)',2,gii(-1)%gll,ldim0*ndg,ldim0,ldim0,ndg)
C         endif

C         Save gsL = gii(-1) : preserve in gend(1)%gll and also gend(2)%gll
          if (lpgf == 5 .or. lpgf == 6) then
C           if (nspc == 2) call rx('pgfasa: this mode not ready for nspc == 2')
            ldim0 = pgplp(4,-1)*nspc
            call ymcpy(gii(-1)%gll,ldim0,1,ldim0**2,
     .        gend(1)%gll,strRL(1),1,strRL(1)*strRL(2),ldim0,ldim0)
            call ymcpy(gii(-1)%gll,ldim0,1,ldim0**2,
     .        gend(2)%gll,strRL(2),1,strRL(1)*strRL(2),ldim0,ldim0)
C           call yprm('gs(-1)',2,gend(1)%gll,strRL(1)*strRL(2),strRL(1),ldim0,ldim0)
C           call yprm('gs(-1)',2,gend(2)%gll,strRL(1)*strRL(2),strRL(2),ldim0,ldim0)

C         Reflectance : return gend(3)%gll = gsL
          elseif (lpgf == 7) then
            if (.not. associated(gend(3)%gll)) allocate(gend(3)%gll(pgplp(4,-1)*nspc,pgplp(3,-1)*nspc))
            if (size(gend(3)%gll) /= size(gii(-1)%gll)) call rx('pgfasa: size mismatch')
            call zcopy(size(gend(3)%gll),gii(-1)%gll,1,gend(3)%gll,1)
C            ldim0 = pgplp(4,-1)*nspc; ndg = pgplp(3,-1)*nspc
C            call yprm('gs(-1)',2,gii(-1)%gll,ldim0*ndg,ldim0,ldim0,ndg)

          endif

C     --- Build up semi-infinite GF starting from the left ---
C         L-R loop over PL making left diagonal surface g(i,i) to i=npl-2  and
C         diagonal interface g(i,i) at i=npl-1.
C         These are stored in gii(i)%gll, i=-1..npl-2, and gii(npl-1)%gll
C         Also the right surface g(npl,npl) is read and stored in gii(npl)%gll
          do  kpl = 1, gflst(0)

C           -1 layer already computed
            if (gflst(kpl) == -1) cycle

C       ... Add nrpt PL to surface GF, or connect to RHS
C           ipl = layer adjacent to last calculated layer
C           jpl = ipl+nrpt-1 (next sif GF)
            nrpt = gflst(kpl) - gflst(kpl-1)
            if (lnoneq .and. nrpt > 1) call rx('pgfasa: not ready for nrpt>1 in non-equil. mode')
            jpl = gflst(kpl)
            ipl = jpl-nrpt+1

            ldim0 = pgplp(4,max(ipl,0))
C           ldiml = pgplp(4,max(ipl-1,0))
C           ldimr = pgplp(4,min(ipl+1,npl-1))
C           ldim = ldiml+ldim0+ldimr
C           ldimx = ldim

            lgii(ipl) = 1
            modemb = 1
            if (lpgf == 5) then
              modemb = 6
            elseif (lpgf == 6) then
              modemb = 16
            else
              allocate(gii(ipl)%gll(pgplp(4,ipl)*nspc,pgplp(3,ipl)*nspc))
              call dpzero(gii(ipl)%gll,2*size(gii(ipl)%gll))
            endif

C       ... Case nrpt>1: make new sif GF
            if (jpl > ipl) then
              if (nofgL+nofgR /= 0) call rx('not ready for this branch')
              if (lpgf /= 5 .and. lpgf /= 6) allocate(gii(jpl)%gll(pgplp(4,jpl),pgplp(4,jpl)*5))
              lgii(jpl) = 1
              call rxx(jpl == npl,'pgfasa: bad jpl')

C       ... Case jpl=npl: make iface GF
            elseif ((jpl+1 == npl .and. lpgf /= 5 .and. lpgf /= 6) .or.
     .              (jpl == npl .and. (lpgf == 5 .or. lpgf == 6))) then
              if (lpgf /= 5 .and. lpgf /= 6) allocate(gii(npl)%gll(pgplp(4,npl)*nspc,pgplp(3,npl)*nspc))
C             call dvset(gii(npl)%gll,1,2*pgplp(4,npl)*pgplp(3,npl),-1d0)
              jpl = npl
C             Read surface GF from disk
C              fnam(1) = 'rbc'
C              fnam(2) = 'rbc2'
C              ifi = fopn(fnam(isp))
C              read(ifi,err=99,end=99) lrd,lrd,lrd,lrd,igfl
C              backspace ifi
C              call shftzi(2,semsh,izp,zp,wz)
C              lgii(npl) = 1
C              lrd = iogfrs(10000*(ISH+IPLMOD)+10*MZP+6,igfl,0,fnam,ifi,1,1,nbas,j,zp(1,izp),
C     .          qp,plat,xv,pgplp,xv,xv,ldim0*pgplp(6,npl),0,0,gii(npl)%gll)
C              call shftzi(1,semsh,izp,zp,wz)
C              if (lrd == 0) call lgupac(lgii(npl),'p',1,2,0,3,0,0)

              call rdsurfg(npl,1,isp,lspc,nspc,izp,npl,0,semsh,pgplp,zp,qp,plat,lgii,gii(npl)%gll)
C             Build it explicitly
C             Bug : an offset should be passed through to pgsif
C              call pgsif(1,
C     .          s_ctrl,s_lat,s_ham,s_pot,s_str,s_spec,s_site,npl,
C     .          pgplp,qp,isp,ldim0,pgplp(3,npl),lgii(npl),
C     .          w(ogii(npl)+ldim0*pgplp(6,npl)*i1mach(18)))
C              call pgsif3(plat,nl,nbas,nbasp,npl,npl,nofgL,
C     .          nofgR,pgplp,qp,w(ogii(npl)),lgii(npl),w(ogii(npl)),
C     .          lgii(npl))
C              ld0nx = nspc*pgplp(4,npl)
C              call yprm('gs(n)',2,gii(npl)%gll,ld0nx*ld0nx,ld0nx,ld0nx,ld0nx)

              modemb = 3    ! Flag this layer as the R layer => Make gRR, not gRR~
              if (lpgf == 5 .or. lpgf == 6) modemb = 7  ! Make gend, gRL, not gend~, gRL~

C             Reflectance : return gend(4)%gll = gsR
              if (lpgf == 7 .or. nofgR > 0) then
                if (.not.associated(gend(4)%gll)) allocate(gend(4)%gll(pgplp(4,npl)*nspc,pgplp(3,npl)*nspc))
                if (size(gend(4)%gll) /= size(gii(npl)%gll)) call rx('pgfasa: size mismatch')
                call zcopy(size(gend(4)%gll),gii(npl)%gll,1,gend(4)%gll,1)
              endif

C              if (izp == nzp+1) then
C                ldim0 = pgplp(4,-1)*nspc; ndg = pgplp(3,-1)*nspc
C                call yprm('gs(n)',2,gii(npl)%gll,ldim0*ndg,ldim0,ldim0,ndg)
C              endif

            endif

C       ... Make new surface GF or, for the last layer, iface GF
C           NB: for last layer, iface GF is not needed for transmission (lpgf=5,6),
C           and is not made
            call pgemb(s_ham,s_pot,s_str,s_site,plat,isp,ipl-1,ipl,jpl,nrpt,
     .        vpl,modemb,pgplp,qp,iprx,lgii,gii,strRL,gend)
C         call shopgf(3,outs,nspc,-1,npl,pgplp,gii,strRL,gend,lgii)

C#ifdefC TMODE1
CC         Calculate transmission using Lake's formula
C          if (jpl == npl) goto 48
C#endif

C           In modes 5 and 6, GF of earlier layers overwritten
            if ((lpgf == 5 .or. lpgf == 6) .and. kpl > 1) then
C             print *, kpl, jpl, nrpt, jpl-nrpt, gflst(kpl-1)
              if (gflst(kpl-1) /= -1) lgii(gflst(kpl-1)) = 0
            endif

          enddo                 ! L-R loop over PL

          i = 0
          if (iprint() >= 80 .or. lpgf == 5 .and. iprint() >= 70) i=3
C         if (izp >= nzp .and. ikp == 1) i = 3-2; ! print *, '!!',izp,bigemb,npl
           call shopgf(i,' Layer GF after L-R pass',nspc,-1,npl,pgplp,gii,strRL,gend,lgii)

C   ---   Build up proper diagonal GF starting from the right ---
C   ...   Case skip backward updates
          if (lpgf == 2 .or. lpgf == 5 .or. lpgf == 6) goto 48

          gsR => gii(npl)%gll
C   ...   Entry point to treat nonequilibrium part of GF generated by LU decomposition
   50     continue

C   ...   Non-equilibrium mode: make self-energy bnn for right contact (S.F.)
C         This block begins with gii(npl-1) = interface g and gii(npl) = right surface g
C         It does the following:
C         1. Creates bnn
C         2. Allocates gin = g(ipl,npl-1) and populates it with interface g(npl-1,npl-1)
C            gin will be overwritten for ipl=npl-2,npl-3,...; see pgles below
          if (izp > nzp) then

            if (lsprse==1 .and. bigemb>0) then
              call rx('(sparse mode, nonequil, bigemb) branches do not work in combination, sorry')
            endif

            ld0n = pgplp(4,npl)
            ldmx = pgdim(3,-1,npl,-1,npl,pgplp)
            ld0nx = nspc*ld0n
            ldmxx = nspc*ldmx

C           call shopgf(3,' look at gs(n)',nspc,-1,npl,pgplp,gii,strRL,gend,lgii)
C           call yprm('gs(n)',2,gsR,ld0nx*ld0nx,ld0nx,ld0nx,ld0nx)
            allocate(snn(3*ld0nx*ld0nx),bnn(3*ld0nx*ld0nx))
            call plhamnc(s_ham,s_pot,s_str,s_site,0,plat,isp,nspc,0,npl,npl,ld0n,3*ld0n,pgplp,qp,bnn,snn)
            deallocate(bnn)
            allocate(bnn(ld0nx*ld0nx))
            call pgbfac(gsR,ld0n,pgplp(3,npl),pgplp(6,npl),nspc,snn,ld0n,2,bnn)
C           call pgbfac(gii(npl)%gll,ld0n,pgplp(3,npl),pgplp(6,npl),nspc,snn,ld0n,2,bnn)
C           call plham(0,s_ham,s_pot,s_str,s_site,plat,isp,0,npl,pgplp,qp,3*ld0n,ld0n,snn)
C           call pgbfac0(gsR,ld0n,pgplp(3,npl),pgplp(6,npl),nspc,snn,ld0n,2,bnn)
C            call shopgf(3,outs,nspc,-1,npl,pgplp,gii,strRL,gend,lgii)
C            call yprm('bnn',2,bnn,(ld0n*nspc)**2,ld0n*nspc,ld0n*nspc,ld0n*nspc)
            deallocate(snn)
C           Allocate and set up crystal GF gin(i,npl-1); initial i = npl-1
            allocate(gin(ldmx*nspc*pgplp(4,npl-1)*nspc))
C           Set up initial gin: copy interface gii(npl-1) to gin = g(npl-1,npl-1)
C           In subsequent steps gin will become off-diagonal g(ipl,npl-1)
            call pgsetg(0,ldmx,pgplp(4,npl-1),pgplp(3,npl-1),pgplp(4,npl-1),pgplp(6,npl-1),
     .        nspc,gii(npl-1)%gll,gin)
C            call pgsetg(npl,ldmxx,nspc*pgplp(4,npl-1),nspc*pgplp(3,npl-1),
C     .                  pgplp(6,npl-1),lgii(npl-1),gii(npl-1)%gll,gin)
          endif
C     ... End making self-energy, non-equilibrium mode

C     ... Make gii(npl) if needed for integrated properties
          if (glstp(glstp(0)) == npl .and. lsprse == 0) then
            modemb = 50

C       ... Make g(npl-1)(npl), g(npl)(npl), g(npl)(npl-1)
            call pgdysn(s_ham,s_pot,s_str,s_site,plat,isp,npl,npl,nofgL,
     .        min(nofgR,1),1,vpl,modemb,pgplp,qp,lgii,gii)
C           call shopgf(3,outs,nspc,-1,npl,pgplp,gii,strRL,gend,lgii)

C       ... Make g(npl,npl+1) from g(npl,npl),g~(npl+1,npl+1)
C       ... Should be call like Make g(i,-2) from g(i,-1) and g~(-2,-2)
C            if (nofgR > 0) then
C              call pgsif3(plat,nl,nbas,nbasp,npl,npl,nofgL,nofgR,pgplp,qp,
C     .          gii(npl)%gll,lgii(npl),gend(4)%gll,lgii(npl+1))
C            endif
          endif

C         First pass through loop (ipl=npl-1) is used only for nonequil g^<
          do  kpl = gflst(0), 1, -1

C       ... ipl = sif layer to update; jpl = ipl+nrpt-1 (not used)
            ipl = gflst(kpl)
            if (lsprse /= 0) goto 51  ! Skip to nonequilibrium part
            nrpt = gflst(kpl) - gflst(kpl-1)
            if (ipl == -1) nrpt = 1
C           jpl = ipl-nrpt+1
            modemb = 40
C           outs = ' Pgfasa, PL %i:'
            ldim0 = pgplp(4,ipl)
C           ldiml = pgplp(4,max(ipl-1,0))
C           ldimr = pgplp(4,max(ipl+1,npl-1))
C           ldim = ldiml+ldim0+ldimr
C           ldimx = ldim
            call lgupac(lgii(ipl),'uab',lmem,0,0,lbulk,0,0)
            call rxx(lmem == 0,'no GF defined for layer')

C       ... Save surface GF if needed again to make off-diagonal g
            if (nofgL > 0 .and. ipl == -1) then
              i = pgplp(4,-1)*pgplp(3,-1)
              allocate(gii(-2)%gll(pgplp(4,-1),pgplp(3,-1)))
              call dpcopy(gii(-1)%gll,gii(-2)%gll,1,i*2,1d0)
              lgii(-2) = lgii(-1)
            endif

C       ... Non-equilibrium branch
   51       continue
            if (izp > nzp) then
              lds = pgplp(4,max(ipl-1,-1)) + pgplp(4,max(ipl,-1))
     .            + pgplp(4,min(ipl+1,npl))

C             For izp>nzp gii(ipl) holds diagonal G^<(ipl,ipl)*(-1/2)
C             that is used the same way as Im[G^r] for density calculations

C             if (izp >= nzp) print *, 'enter pgles', izp,ikp
C             call pshpr(90)
              call pgles(s_ham,s_pot,s_str,s_site,plat,isp,nspc,ipl,npl,pgplp,
     .          ldmx,ld0n,pgplp(3,ipl),pgplp(4,ipl),qp,
     .          bnn,gin,lgii(ipl),gii(ipl)%gll)
C             call poppr
C             if (izp >= nzp) print *, 'exit pgles'
            elseif (ipl < npl-1) then
              call pgdysn(s_ham,s_pot,s_str,s_site,plat,isp,ipl,npl,
     .          nofgL,nofgR,nrpt,vpl,modemb,pgplp,qp,lgii,gii)
            endif
          enddo                   ! R-L loop over principal layers

          if (izp > nzp) deallocate(gin,bnn)

          i = 0; if (iprint() >= 80) i = 3
C         if (izp >= nzp+1 .and. ikp == 1) i = 3 ! ; print *, '!!',izp
          call shopgf(i,' Attributes of layer GF after R-L pass',nspc,-1,npl,pgplp,gii,strRL,gend,lgii)
c         pause

C         Re-entry point for sparse LU decomposition
C         and modes not requiring all diagonal GF
   48     continue

C   --- Rotate diagonal noncollinear (P-S)^-1 to local spin quantization axis ---
        if (nspc == 2 .and. lpgf<5) then  ! Note g-1 may be g~-1 in LU decomposition case
C         call shopgf(3,' Attributes of layer GF after R-L pass',nspc,-1,npl,pgplp,gii,strRL,gend,lgii)
          kcplx = 0
          do  kpl = gflst(0), 1, -1
C       ... ipl = layer to rotate
            ipl = gflst(kpl)
            call lgupac(lgii(ipl),'ut',0,i,0,0,0,0)
            if (i == 0) cycle
            call pghoff(ipl,npl,pgplp,s_ham%iprmb,mxorb,offL,offi,offR)
C           Shift indxsh to starting at 1 for ipl
            call pblch3(0,1,[offi],1,nbasp,mxorb,ldham,s_ham%iprmb)
C           call pblch2([-offi],1,nbasp,mxorb,s_ham%iprmb)
            optrot = 100*kcplx + rotspd(1) ! global z -> local z
            if (bittst(s_ham%lham,256)) optrot = optrot + 10 ! Spherical harmonics
            if (mod(s_lat%lsym/8,2) /= 0) optrot = optrot + 1000 ! Suppress orbital rotation
            call gtibpl(ipl,npl,pgplp,ib1,ib2)
            ld0n = pgplp(4,ipl); ndg = pgplp(3,ipl)
C           call yprmi('g_%i,%-1j%i before rot to local spin axis',ipl,ipl,2+0,gii(ipl)%gll,ld0n*2*ndg*2,ld0n*2,ld0n*2,ndg*2)
            call rotheu(optrot,s_ham,nl,ib1,ib2,nbasp,0,ld0n,ld0n,ndg,gii(ipl)%gll)
C           Restore indxsh
            call pblch3(11,1,[offi],1,nbasp,mxorb,ldham,s_ham%iprmb)
C           call yprmi('g_%i,%-1j%i local spin axis',ipl,ipl,2+0,gii(ipl)%gll,ld0n*2*ndg*2,ld0n*2,ld0n*2,ndg*2)
          enddo
        endif
C        if (izp > nzp) then
C          if (ikp == 1) print *, 'izp is',izp
CC         call shopgf(3,' Attributes of layer GF after R-L pass',nspc,-1,npl,pgplp,gii,strRL,gend,lgii)
C        endif

C   --- Calculate transmission probability ---

C       Transmission probability using Lake's formula
C#ifdefC TMODE1
C        lims = pgplp(4,npl-2)+pgplp(4,npl-1)+pgplp(4,npl)
CC       Transport using GNN
C        if ((lpgf == 1) .and. (lsprse == 0)) then
C
C        call pgjdensk(zp(1,izp),wz(1,izp),qp,wtkp/2.0,ikp,
C     .    npl-1,plat,isp,gii(npl-1)%gll,
C     .    pgplp(4,npl-1),pgplp(3,npl-1),pgplp(6,npl-1),
C     .    gii(npl)%gll,pgplp(4,npl),pgplp(3,npl),
C     .    pgplp(6,npl),lims,pgplp,jk)
C
C        endif
C
C        if ((lpgf == 1) .and. (lsprse /= 0)) then
C
CC       Transport using G00
C        call pgjdensk(zp(1,izp),wz(1,izp),qp,wtkp/2.0,ikp,
C     .    0,plat,isp,w(ogii(0)),
C     .    pgplp(4,0),pgplp(3,0),pgplp(6,0),
C     .    gii(-1)%gll,pgplp(4,-1),pgplp(3,-1),
C     .    pgplp(6,-1),lims,pgplp,jk)
C
C        endif
C
C        if (lncol /= 0) call rx('Lakes formula not implemented lncol')
C        totjk(1,1) = totjk(1,1)+jk(1,1,1)*wz(1,izp)
C        totjk(2,1) = totjk(2,1)+jk(2,1,1)*wz(1,izp)
C        cycle
C#endif

C         Transmission:
C         gend(1) = gRL     gend(2) = gLR   gii(-1) = gsL   gii(npl) = gsR
C         Reflectance:
C         gend(1) = gLL     gend(2) = gRR   gii(-1) = gsL   gii(npl) = gsR

          if (lpgf >= 5 .and. lpgf <= 7) then
C           call shopgf(3,outs,nspc,-1,npl,pgplp,gii,strRL,gend,lgii)
            if (lpgf == 5 .or. lpgf == 6) then
              gsL => gii(-1)%gll; gsR => gii(npl)%gll
              gLL => gii(-1)%gll; gRR => gii(npl)%gll  !Not used lpgf=5
              gLR => gend(2)%gll;  gRL => gend(1)%gll
            else
              gsL => gend(3)%gll;  gsR => gend(4)%gll
              gLL => gii(-1)%gll; gRR => gii(npl)%gll
              gLR => gii(-1)%gll; gRL => gii(npl)%gll  !Not used lpgf=5
            endif
            nspcl = 1
            if (lspc == 1 .and. lpgf == 5 .and. lreslead) nspcl = 2
            call dpzero(jk,size(jk))
            call pgcurr(zp(1,izp),qp,s_ctrl,s_ham,s_pot,s_str,s_site,plat,lpgf,
     .        isp,nspc,nspcl,pgplp,ikp,npl,strRL(2)/nspc,strRL(1)/nspc,
     .        gLR,gRL,gsL,gLL,pgplp(4,-1),pgplp(3,-1),pgplp(6,-1),
     .        gsR,gRR,pgplp(4,npl),pgplp(3,npl),pgplp(6,npl),jk)

            do  i2 = 1, nspc
            do  i1 = 1, nspc
              do  i = 1, nspcl
              do  j = 1, nspcl
                totjk(1:2,i1,i2,1) = totjk(1:2,i1,i2,1) + jk(1:2,i1,i,i2,j,1)*wtkp/2
                totjk(1:2,i1,i2,2) = totjk(1:2,i1,i2,2) + jk(1:2,i1,i,i2,j,2)*wtkp/2
              enddo
              enddo
            enddo
            enddo
            cycle    ! end of this kp
          elseif (lpgf >= 8) then
            if (ikp == 1) call info0(30,0,0,'spin torque here')
            cycle    ! end of this kp
          endif

C     --- Generate various quantities from the PGF ---
          offpd = 0
          offd  = 0
          do  kpl = 1, glstp(0)

            ipl = glstp(kpl)
            call gtibpl(ipl,npl,pgplp,ib1,ib2)
            ldim0 = pgplp(4,ipl)
            ndg   = pgplp(3,ipl)
            ldim0x= nspc*ldim0
            ndgx  = nspc*ndg

C      ... Debugging printout
           if (iprint() >= PRTG/1 .and. ndg /= ldim0) then
             call yprmi(' g(%i,%i):',ipl,ipl,2,gii(ipl)%gll,ldim0x*ndgx,ldim0x,ldim0x,ndgx)
           endif

C       --- Convert g_ii into G_ii by energy scaling ---
C           For now, pull out vector of potential functions for asa
            if (ldim0 /= ndg) call rx('fix energy scaling to handle off-diagonal g')

            i = 100
            if (bittst(lham,128)) i = 300
C           Non-equilibrium mode: gii(ipl)%gll contains g^< for izp > nzp
            if (izp > nzp .and.  ipl < npl ) i = 400
C           if izp>nzp then only alp. repn., even for g^r at ipl=npl
            if (izp > nzp .and.  ipl == npl ) i = 100
            call gfg2g(s_ham,s_pot,i,lrel,isp,ib1,ib2,ib1,ib2,
     .        ldim0,ndg,gii(ipl)%gll,xv,ierr)
C            offp = s_ham%offH(1+nkap0*n0H*(ib1-1))
C            call pgfg2g(ldim0,ldim0,T,offp,offp,s_pot%dpf,s_pot%ddpf,
C     .        gii(ipl)%gll,ierr)
            if (lrel /= 2 .and. ierr > 0)
     .        call awrit4(' pgfasa (warning) layer %i,'//
     .        ' izp=%i, ikp=%i, %i positive Im gii encountered',' ',80,
     .        stdo,ipl,izp,ikp,ierr)
C            if (ierr > 0) call fexit2(-1,111,' Exit -1 PGFASA: '
C     .        //'izp=%i, ikp=%i, negative Im gii encountered',izp,ikp)

C       --- Park diagonal blocks of g into s_site ---
C           This call assumes gii(ipl)%gll has complex, real separated (kcplx=0)
            call pgfgii(3,s_site,s_ham,ipl,npl,pgplp,isp,ldim0,ndg,gii(ipl)%gll)

C       ... Debugging printout
            if (iprint() >= PRTG/1) then
              call awrit2(' G_%i,%i:',outs,len(outs),0,ipl,ipl)
              call yprm(outs,2,gii(ipl)%gll,ldim0x**2,ldim0x,ldim0x,ldim0x)
            endif

C       --- Accumulate DOS or output rho ---
            if (moddos /= 0) then
              call pghoff(ipl,npl,pgplp,s_ham%iprmb,mxorb,i1,ldim1,i2)
              ldim2 = ldim1+ldim0
              call gtibpl(ipl,npl,pgplp,ib1,ib2)
              j = moddos
              if (ikp == kpproc(procid) .and. mod(moddos,10) == 1) j = j+1
              if (.not. lgcorr .and. .not. lso) then
              call gfidos(nl,nbasp,j,0,ib1,ib2,s_ham%iprmb,ldim1,ldim2,0,
     .          0,ldim0,gii(ipl)%gll,0,0,wtkp/2,zp(1,izp),wz(1,izp),isp,
     .          nsp,nspc,s_pot%pp,dvldu,vshft,s_ctrl%ipc,s_ctrl%nrc,
     .          ncomp,nrhos,izp,nzp+nzne,nzp,ipl,npl,kpl,offd,offpd,dosi,
     .          pdos,gd,qnu,qne,dosne,orbtm,sdmat,rhos)
              endif
C         ... CPA sites (site-diagonal Green's function taken from s_site(ib)%gc)
              if (ldlm /= 0) then
                moddos2 = j
!               if (.not. lso) moddos2 = moddos2 + 20000 ! gfidos2 processes CPA sites only
                if (lso .and. lemom) moddos2 = moddos2 + 400 ! gfidos2 calculates orbital moments
                if (lrel == 2 .and. lemom) moddos2 = moddos2 + 100000
                do  ib = ib1, ib2
                  if (lskip .and. izp <= nzp) cycle
                  ndmat = s_site(ib)%norb*s_site(ib)%norb*nsp*nspc*4*ncomp(ib)
                  allocate(dmatloc(ndmat))
                  call dpzero(dmatloc,2*ndmat)
                  call gfidos2(nl,nbasp,moddos2,0,ib,ib,s_ham%iprmb,ldim1,ldim2,0,hdim,lidim,
     .              hdim,ghh,wtkp/2,zp(1,izp),wz(1,izp),isp,nsp,nspc,s_pot%pp,dvldu,vshft,
     .              s_ctrl%ipc,s_ctrl%nrc,izp,nzp+nzne,nzp,ipl,npl,kpl,offd,offpd,dosi,
     .              pdos,s_site(ib)%pdos,gd,qnu,qne,dosne,orbtm,dmatloc,rhos,ncomp(ib),
     .              s_site(ib)%thet,s_site(ib)%dlmcl,s_site(ib)%cpawt,s_site(ib)%gc,
     .              s_site(ib)%gcorr,s_pot%mxy,s_pot%qcorr,s_site(ib)%norb,s_pot%sop)
                  call dpadd(s_site(ib)%dmat,dmatloc,1,2*ndmat,1d0)
                  if (mod(moddos2,10) == 2) moddos2 = moddos2 - 1 ! Add to DOS after first site
                  call dmatav(.false.,nl,s_site(ib)%norb,ncomp(ib),dmatloc,dum,mag,dum,dum)
C                 call info5(0,0,0,'ib %,5i ikp %,5i mag%3:1;10F',ib,ikp,mag,0,0)
                  deallocate(dmatloc)
                enddo
              endif

C#ifdefC DEBUG
C              if (izp > nzp .and. ipass == 1) then
C                 dos_ne(izp-nzp,ipl)=dos_ne(izp-nzp,ipl)+qq
C                 qqtt = qqtt + qqt
C              endif
C#endif
            endif
          enddo                   ! loop over PL kpl

          do  kpl = -1, npl+1
            if (associated(gii(kpl)%gll)) then
              deallocate(gii(kpl)%gll); nullify(gii(kpl)%gll)
            endif
          enddo

        enddo                   ! loop over k

        if (lpgf == 5 .or. lpgf == 7)
     .    call mpibc2(totjk,2*4*2,4,3,.false.,'pgfasa','totjk')

        dosfil = ' '
        if ((lpgf==5 .or. lpgf==6) .and. isp == 1) dosfil = 'jzk'
        if ((lpgf==5 .or. lpgf==6) .and. isp == 2) dosfil = 'jzk2'
        if (dosfil /= ' ') call mpi_append_files(1,trim(dosfil),nproc)

        if (procid == master) then
          if (lpgf == 5) then
            if (iprint() >= 10 .and. nspc /= 2) write(stdo,27)
     .        'zp:',zp(1,izp),' isp=',isp,'  intjk=',totjk(1,1,1,1),'  Im j=',totjk(2,1,1,1)
   27       format (1X,A,F8.4,A,I2,A,1PE12.4,A,1PE12.4:A,1P2E12.4)
            if (iprint() >= 10 .and. nspc == 2) write(stdo,127)
     .        'zp:',zp(1,izp),'  intjk=',
     .        ((totjk(1,i1,i2,1), i1=1,2),i2=1,2),'Im j=',((totjk(2,i1,i2,1), i1=1,2),i2=1,2)
  127       format (1X,A,F8.4,A,1P,4E12.4/15X,A,4E12.4)
            ifi = fopna('jz',-1,0)
            if (nspc == 1) then
              write(ifi,29) zp(1,izp),isp,totjk(1,1,1,1),totjk(2,1,1,1)
   29         format (1X,F13.8,I4,1PE14.6,1PE14.6)
            else
              write(ifi,129) zp(1,izp),
     .          ((totjk(1,i1,i2,1), i1=1,2),i2=1,2), ((totjk(2,i1,i2,1), i1=1,2),i2=1,2)
  129         format (1X,F13.8,1P,4E14.6,2x,4E14.6)
            endif

          elseif (lpgf == 7) then
            if (iprint() >= 10 .and. nspc /= 2) write(stdo,27)
     .        'zp:',zp(1,izp),' isp=',isp,'  intrL=',totjk(1,1,1,1),
     .        '  intrR=',totjk(1,1,1,2),'  Im r=',totjk(2,1,1,1:2)
            if (iprint() >= 10 .and. nspc == 2) then
              write(stdo,127) 'zp:',zp(1,izp),'  intrL=',
     .          ((totjk(1,i1,i2,1), i1=1,2),i2=1,2),'Im r=',((totjk(2,i1,i2,1), i1=1,2),i2=1,2)
              write(stdo,127) 'zp:',zp(1,izp),'  intrR=',
     .          ((totjk(1,i1,i2,2), i1=1,2),i2=1,2),'Im r=',((totjk(2,i1,i2,2), i1=1,2),i2=1,2)
            endif
            if (nspc == 1) then
              write(fopna('rzl',-1,0),29) zp(1,izp),isp,totjk(1,1,1,1),totjk(2,1,1,1)
              write(fopna('rzr',-1,0),29) zp(1,izp),isp,totjk(1,1,1,2),totjk(2,1,1,2)
            else
              write(fopna('rzl',-1,0),129) zp(1,izp),totjk(1,:,:,1),totjk(2,:,:,1)
              write(fopna('rzr',-1,0),129) zp(1,izp),totjk(1,:,:,2),totjk(2,:,:,2)
            endif

          elseif (lpgf == 8) then
            call info0(10,0,0,' output from torque mode here')

          endif
        endif

        if (lpgf == 5 .or. lpgf == 6 .or. lpgf == 7) then
          if (abs(wz(2,izp)) > 1d-10) call rx('PGFASA: lpgf=[5,6,7], wz not real')
          do  i1 = 1, nspc
          do  i2 = 1, nspc
            totjE(isp,1,i1,i2,1:2) = totjE(isp,1,i1,i2,1:2) + totjk(1,i1,i2,1:2)*wz(1,izp)
            totjE(isp,2,i1,i2,1:2) = totjE(isp,2,i1,i2,1:2) + totjk(2,i1,i2,1:2)*wz(1,izp)
          enddo
          enddo
        endif

      enddo                     ! Loop over spins
      call clhamz(s_pot%pf)
C     call clhamz(int(s_pot%opf))
C     call clpgv(s_pot)

      if (lpgf >= 3 .and. lpgf <= 8) cycle
C ... End loop over iz
C#ifdefC DEBUG
C      if (izp > nzp .and. ipass == 1) then
C        dost= 0d0
C        do ipl=0,npl-1
C          dost = dost + dos_ne(izp-nzp,ipl)
C        enddo
C        write(299,'(13f14.7)')zp(1,izp),dost,
C     .    (dos_ne(izp-nzp,i),i=0,npl-1)
C      endif
C#endif
      enddo ! Loop over frequencies

C     call yprm('dosi',1,dosi,0,5*nsp,5*nsp,npl)

C ... Sharing data among processes
      deallocate(kpproc)

      if (nproc > 1) then
        if (lpgf == 1) then
          if (lnos) call mpibc2(dosi,5*nipl*nsp,4,3,.false.,'pgfasa','dosi')
          if (lnos .and. nzne > 0) then
            call mpibc2(qne,nipl*nsp,4,3,.false.,'pgfasa','qne')
            call mpibc2(dosne,2*nipl*nsp,4,3,.false.,'pgfasa','dosne')
          endif
          if (lpade) call mpibc2(gd,(nzp+nzne)*nsp*nspc*npados,6,3,.false.,'pgfasa','gd')
          if (bigemb /= 0) then
            nlen = 3*nlspcp
          else
            nlen = 3*nl*nsp*nclass
          endif
          if (lemom) then
            call mpibc2(qnu,nlen,4,3,.false.,'pgfasa','qnu')
            if (nspc == 2) call mpibc2(orbtm,nlo*2*nclasp,4,3,.false.,'pgfasa','orbtm')
          endif
          if (lpdos .and. mod(mod(moddos/10,10),2) == 1) call mpibc2(pdos,(nzp+nzne)*npdos*nsp,4,3,.false.,'pgfasa','pdos')
          if (lrhos) then
            call mpibc2(sdmat,nl**4*nbasp*nsp*nspc*4,6,3,.false.,'pgfasa','sdmat')
            do ib = 1, nbasp
              call mpi_allreduce(mpi_in_place, s_site(ib)%dmat, size(s_site(ib)%dmat),
     .                           mpi_complex16,mpi_sum,mpi_comm_world,err)
! Avoid using mpibc* because 1) it is very confusing 2) will a major pain to detangle automatically once there is time to structure MPI communicators properly!
! The common mpi calls are covered by nullmpi for serial mpi emulation.
!             call mpibc2(s_site(ib)%dmat,4*s_site(ib)%norb**2*4*s_site(ib)%ncomp,6,3,.false.,'pgfasa','dmat')
            enddo
          endif
        endif
      endif

C --- Print out the density matrices          ! Kirill
      if (lrhos) then
!       call packdmat(F,nbasp,nl,sdmat,s_site)
        if (ldmsv .and. procid == master) then
          i = fopna('dmat',-1,0)
          call dmatio(1,1,nl*nl,nbasp,nsp,nspc,sdmat,sdmat,-i)
          call fclr('dmat',i)
          call pshpr(1)
          do  ib = 1, nbasp
            do icomp = 1, s_site(ib)%ncomp
              i = 0
              call bin2a('',0,0,1000*ib+icomp,2,0,6,aib,i)
              dosfil = 'dmat'//aib(1:i)
              i = fopna(dosfil,-1,0)
              call dmatio(1,1,s_site(ib)%norb,1,nsp,nspc,s_site(ib)%dmat(:,icomp),xx,-i)
              call fclr(dosfil,i)
            enddo
          enddo
          call poppr
        endif
      endif

C ... Printout
      if (lrhos .and. lrel /= 2 .and. lpgf<5) call magcpa(s_ctrl,s_site,nl,s_pot%sop,amag)
C     if (lrel == 2 .or. lso) call iorbtm(s_spec,0,0,s_ctrl%ics,nl,nlo,nclassd,nsp,orbtm,s_bz%sopertp,xx)

      if ((lpgf == 5 .or. lpgf == 6 .or. lpgf == 7) .and. iprint() >= 10) then
        write(stdo,'(/'' Total Current Density for Each Spin Channel'')')
        if (nspc == 1) then
        do  isp = 1, nsp
          print 26,'spin',isp,' curr dens ',totJE(isp,1,1,1,1),' Im part ',totjE(isp,2,1,1,1)
   26     format (1X,A,I2,A,1p,E12.5,A,E12.5)
        enddo
        endif
      endif

C ... Cleanup: deallocate
      deallocate(vpl)
      if (associated(gend(1)%gll)) deallocate(gend(1)%gll,gend(2)%gll)
      if ((lpgf == 5 .or. lpgf == 6) .and. lsprse == 0) then
        deallocate(gii2(1)%gll,gii2(2)%gll)
      else
        do  i = -1, npl
          if (associated(gii(i)%gll)) then
            deallocate(gii(i)%gll)
          endif
          if (lpgf /= 8) cycle
          if (associated(gij(1,i)%gll)) then
            deallocate(gij(1,i)%gll,gij(2,i)%gll,gij(3,i)%gll,gij(4,i)%gll)
          endif
        enddo
      endif

C     call zprm('gd',2,gd,nz*nsp*nspc,nz*nsp*nspc,npados)

C      So far, diagonal-only approximation
C      if (nlibu > 0) then
C        call vorbydl(-1,ssite,s_site,s_spec,
C     .    nbasp,nl,nsp,lmaxu,lldau,s_pot%pp,vorb)
C      endif

C ... L- or R- bulk GF has changed; remove boundary conditions file
      if (lpgf == 2) then
        i = fopna('lbc',-1,4)
        call dfclos(i)
        i = fopna('rbc',-1,4)
        call dfclos(i)
      endif

      if (lpgf == 3 .or. lpgf == 4) then
        call rx0('PGFASA: finished band mapping')
      elseif (lpgf == 5 .or. lpgf == 6) then
        call rx0('PGFASA: finished calculating transmittance')
      elseif (lpgf == 7) then
        call rx0('PGFASA: finished calculating reflectance')
      endif

C --- Integrated properties: NOS and band-structure energy ---
C ... dqsum = deviation in charge neutrality from calculated GF (not Pade approximants to it)
      dqsum = 0
      llast = .false.
      lagain = 0
      if (iprint() >= 25 .and. lnos .and. procid == master)
     .  print '(/'' PGFASA: integrated quantities from G'')'

C ... Re-entry point for Pade approximation
   16 continue
      if (lnos) then
C     call pshpr(60)
      if (lagain == 1) call pshpr(iprint()-10)
      ipr = iprint()
      if (ipr >= 25 .and. nzne <= 0) write(stdo,370)
      if (ipr >= 25 .and. nzne > 0) write(stdo,470)
  370 format('     PL      D(Ef)      N(Ef)',
     .       '       E_band      2nd mom      Q-Z')
  470 format('    PL    D(Ef)   Dne(L)   Dne(R)    Q_ne    N(Ef)',
     .       '    E_band  2nd mom    Q-Z ')

C ... Printout of DOS, integrated DOS, eval sum
      qtot = 0; qtotl = 0; qtotr = 0
      call dpzero(wksum,10)
      if (nzne > 0) call dpzero(qnesum,2)

      do  kpl = 1, glstp(0)
        ipl = glstp(kpl)
        call gtibpl(ipl,npl,pgplp,ib1,ib2)
        call gtqval(ib1,ib2,z,s_pot%qc,s_ctrl%ipc,zval)
        j = 5*nsp*(kpl-1)
        call dpscop(dosi,wk,5,1+j,1,1d0)
        if (nzne > 0)  then
          call dpscop(qne,qne2,1,1+nsp*(kpl-1),1,1d0)
          call dpscop(dosne,dosne2,2,1+2*nsp*(kpl-1),1,1d0)
        endif
        if (wk(5) /= 0) wk(1) = wk(5)  ! If Projection to Ef is available
        call daxpy(3,1d0,wk,1,wksum,1)
        if (nzne > 0) qnesum(1) = qnesum(1) + qne2(1)
        if (ipr >= 25 .and. nzne <= 0)
     .        write(stdo,371) ipl,(wk(i),i=1,4),wk(2)-zval/nsp
        if (ipr >= 25 .and. nzne > 0)
     .        write(stdo,471) ipl,wk(1),dosne2(1),dosne2(2),qne2(1),
     .            (wk(i),i=2,4),wk(2)-zval/nsp
        qtot = qtot + wk(2) - zval
        if (ipl == -1) qtotl = qtotl + wk(2) - zval
        if (ipl == npl) qtotr = qtotr + wk(2) - zval
        wksum(5,1) = wksum(5,1) + wk(2)-zval/nsp
        if (nsp == 2) then
          call dpscop(dosi,wk,5,6+j,6,1d0)
           if (nzne > 0)  then
             call dpscop(qne,qne2,1,2+nsp*(kpl-1),2,1d0)
             call dpscop(dosne,dosne2,2,3+2*nsp*(kpl-1),3,1d0)
           endif
          if (wk(10) /= 0) wk(6) = wk(10)
          qtot = qtot + wk(7)
          if (ipl == -1) qtotl = qtotl + wk(7)
          if (ipl == npl) qtotr = qtotr + wk(7)
          call daxpy(3,1d0,wk(1+5),1,wksum(1,2),1)
          if (nzne > 0) qnesum(2) = qnesum(2) + qne2(2)
          wksum(5,2) = wksum(5,2) + wk(7)-zval/nsp
          if (ipr >= 25 .and. nzne <= 0) then
            write(stdo,372) 'spin 2', (wk(i+5),i=1,4),wk(7)-zval/nsp
            write(stdo,372) ' total', (wk(i)+wk(i+5), i=1,4),
     .        wk(2)+wk(7)-zval
          endif
           if (ipr >= 25 .and. nzne > 0) then
            write(stdo,472)'spin 2',wk(6),dosne2(3),dosne2(4),
     .         qne2(2),(wk(i+5),i=2,4),wk(7)-zval/nsp
            write(stdo,472)' total',wk(1)+wk(6),dosne2(1)+dosne2(3),
     .         dosne2(2)+dosne2(4),qne2(1)+qne2(2),
     .         (wk(i)+wk(i+5),i=2,4),wk(2)+wk(7)-zval
          endif
        endif
C   ... Update since corrected DOS might be available
        call dpscop(wk,dosi,5*nsp,1,1+j,1d0)
  371   format(i7,5f12.6)
  372   format(1x,a,5f12.6)
  373   format(1x,a,3f12.6,12x,f12.6)
  471   format(i6,8f9.4)
  472   format(a,8f9.4)
  473   format(a,f9.4,18x,3f9.4,9x,f9.4)
      enddo
      if (ipr >= 25) then
        if (nzne <= 0) then
        write(stdo,373) 'All PL', (wksum(i,1),i=1,3),wksum(5,1)
        if (nsp == 2)
     .  write(stdo,373) 'spin 2', (wksum(i,2),i=1,3),wksum(5,2)
        write(stdo,373) 'PL tot', (wksum(i,1)+wksum(i,2), i=1,3),
     .    wksum(5,1)+wksum(5,2)
        else
          write(stdo,473) 'All PL',wksum(1,1),qnesum(1),
     .                (wksum(i,1),i=2,3),wksum(5,1)
          if (nsp == 2)
     .    write(stdo,473) 'spin 2',wksum(1,2),qnesum(2),
     .                (wksum(i,2),i=2,3),wksum(5,2)
          write(stdo,473) 'PL tot',wksum(1,1)+ wksum(1,2),
     .      qnesum(1)+qnesum(2),(wksum(i,1)+wksum(i,2), i=2,3),
     .      wksum(5,1)+wksum(5,2)
        endif
        if (bigemb == 0) then
          write(stdo,377) qtot-qtotl-qtotr
  377     format(' Deviation from charge neutrality in embedded layers:  ',f12.6)
        else
          write(stdo,374) qtotl,qtotr,qtot-qtotl-qtotr,qtot
  374     format(' Deviations from charge neutrality:'
     .          /'   Left end layer   ',f12.6
     .          /'   Right end layer  ',f12.6
     .          /'   Embedded layers  ',f12.6
     .          /'   Sum of all layers',f12.6)
        endif
      endif

C#ifdefC DEBUG
C      if (nzne > 0 .and. ipass == 1 ) then
C      deallocate(dos_ne)
C        write(*,'(a7,2f14.7)') 'Q_NE=',qqtt,qnesum(1)
C      close(299)
C      ipass=0
C      !stop 'STOP HERE TEMP'
C      endif
C#endif

C     if (dqsum == 0) dqsum = abs(qtot)
      if (dqsum == 0) dqsum = abs(qtot-qtotl-qtotr)

C --- Accumulate N(vbar) from passes involving actual G ---
      if (lpgf == 1 .and. lnos .and. lagain == 0) then
        izp = vsint(13)
        xx = vbar(1)
        call pshpr(iprint()-10)
        call rfalsi(xx,qtot-qtotl-qtotr,5d-8,1d-7,5d-8,.05d0,30,vsint(1),izp)
        call poppr
        vsint(13) = izp
        vsint(14) = xx
      endif

C --- Float potentials to ensure charge neutrality ---
C ... Case lpgf=1: estimate constant potential shift for layers 0..npl-1
C     that makes system charge neutral
      call info0(25,0,0,' ')
      if (abs(qtot-qtotl-qtotr)<qtolp) then ! charge tolerance reached; no further interpolation
        call info2(21,1,0,
     .    ' gfasa : deviation from c.n. < qtolp (%;3g) ... end %?;n;Pade interpolation;search for neutrality point;',
     .    qtolp,lagain)
      elseif (lpgf == 1) then
C     if (lpgf == 1 .and. mod(lmet,2) == 1) then   ! To bypass gfzerq
C       Subtract starting const vshfp(1) from vshft, excluding -1, npl
C        vbar(1) = vbar(1) - vshfn(1)
C        print *, '!!'
C       call advshp(npl,101,pgplp,glstp(0),vshfn,vshft)
C       Update vshfp(1); vhold(1) keeps input vshfp(1)
        call gfzerq(1,npl,nsp,pgplp,s_ctrl%ipc,z,s_pot%qc,
     .    glstp(0),efermi,dosi,dosne,nzne,-999d0,vshfn,vhldp,
     .    rmsdv,rmsdq)
C       dqsum = max(dqsum,rmsdq)
C       Add updated const vshfp(1) to vshft, excluding -1, npl
        vbar(1) = vbar(1) - vhldp(1) + vshfn(1)
C       call advshp(npl,100,pgplp,glstp(0),vshfn,vshft)

C   ... Estimate correction to integrated dos by Pade approximant
C       = int dz [dos(z-vshfp) - dos(z-vhold)]
        if (lpade) call gippad(100,moddos,pgplp,glstp(0),npl,nzp+nzne,
     .    nzp,zp,wz,nl,nsp,nspc,s_ham%iprmb,lidim,s_pot%pp,vshft,
     .    s_ctrl%ipc,s_ctrl%nrc,nrhos,ncomp,dlmcl,nzp+nzne,nzp,zp,
     .    gd,efermi,vne,qne,vhldp,vshfn,dosi,qnu,rhos)
        call pgevdc(0,glstp(0),nsp,dosi,vhldp(1),vshfn(1))

C ... Case lpgf=2: potential shift for each layer -1, npl separately
C     that makes L and R padding layers charge neutral independently
      elseif (lpgf == 2) then
C       call advshp(npl,11,pgplp,glstp(0),vshfn,vshft)
        call gfzerq(0,npl,nsp,pgplp,s_ctrl%ipc,z,s_pot%qc,
     .    glstp(0),efermi,dosi,xv,0,-999d0,vshfn,vhldp,
     .    rmsdv,rmsdq)
C       call advshp(npl,10,pgplp,glstp(0),vshfn,vshft)
        vbar(2) = vbar(2) - vhldp(1)
        vbar(2) = vbar(2) + vshfn(1)
        vbar(3) = vbar(3) - vhldp(1+12)
        vbar(3) = vbar(3) + vshfn(1+1)

C   ... Estimate correction to integrated dos by Pade approximant
        allocate(wki(glstp(0)))
C   ... Contract pot. shift in layers -1, npl into 2-element array
        call dcopy(glstp(0),vhldp,12,wki,1)
C       call daxpy(glstp(0),-1d0,vshfn,1,wki,1)
        call gippad(10,moddos,pgplp,glstp(0),npl,nzp,nzp,zp,wz,
     .    nl,nsp,nspc,s_ham%iprmb,lidim,s_pot%pp,vshft,s_ctrl%ipc,
     .    s_ctrl%nrc,nrhos,ncomp,dlmcl,nzp,nzp,zp,gd,efermi,
     .    0,xv,wki,vshfn,dosi,qnu,rhos)
        call pgevdc(1,glstp(0),nsp,dosi,wki,vshfn)
        deallocate(wki)
      endif

C ... Restore reduced verbosity
      if (lagain == 1) call poppr

C ... If estimate correction to integrated quantities with Pade
      if (abs(qtot-qtotl-qtotr)<qtolp) then ! charge tolerance reached; no further interpolation
        lagain = 0
      elseif (lagain /= 2 .and. lpade) then
        lagain = isw(rmsdv > 1d-7 .and. lpade)
        if (lagain == 1) goto 16

        call info0(25,1,0,' Corrections to integrated quantities estimated by Pade interpolation')
        lagain = 2
        goto 16
      endif

      xx = vshfn(1)
      dosfil = ' ' ; if (abs(vshfn(1))>abs(padtol)) dosfil = ' > padtol.'
      if (iprint() >= 25) then
      if (lpgf == 1 .and. iprint() >= 25) then
        write(stdo,376) 'embedded layers',vshfn(1),trim(dosfil),vbar(1)
      elseif (lpgf == 2) then
        write(stdo,376) 'L PL',vshfn(1),trim(dosfil),vbar(2)
        write(stdo,376) 'R PL',vshfn(2),trim(dosfil),vbar(3)
        xx = max(abs(vshfn(2)),abs(vshfn(2)))
      endif
  376 format(' potential shift ',a,' =',f10.6,a,'  Cumulative shift =',f10.6)
      endif

C ... Update vshift, decide whether dq is large enough to recalculate G
      if (lpgf == 1) then
        call advshp(npl,100,pgplp,glstp(0),vshfn,vshft)
      elseif (lpgf == 2) then
        call advshp(npl,10,pgplp,glstp(0),vshfn,vshft)
C       call dpzero(wk,10)
C       call dpscop(dosi,wk,5*nsp,1,1,1d0)
        xx = max(abs(vshfn(1)),abs(vshfn(2)))
      endif
C     lagain = dqsum > padtol*nbas
C      if (lagain .and. ipr >= 20) call awrit2('%N pgfasa: '//
C     .  'dq/atom (%;2g) exceeded Pade tolerance (%;2g) '//
C     .  '... redo GF pass',' ',scrwid,stdo,dqsum/nbas,padtol)

C --- Repeat internal self-consistency loop ---
      if (dqsum<qtolp) then
        lagain = 0
      else
        lagain = -isw(abs(xx) > padtol)
        if (vsint(13) >= -4 .and. vsint(13) <= -2 .and. lpgf == 1) then
        call info8(30,0,0,
     .    ' Interpolate shift for true G: v1=%1;4e N1=%1;4e  v2=%1;4e N2=%1;4e'//
     .    '%?;n<-3;  bracket=F;;%-1j'//
     .    '%?;n==-2;  lin=T;;%-1j'//
     .    '%?;n==-3;  qua=T;;'//
     .    '  est=%1;6g',
     .    vsint(2),vsint(5),vsint(1),vsint(4),nint(vsint(13)),vsint(14),0,0)
        if (vsint(13) == -4) growdv = growdv * 1.1d0
        if (vsint(13) /= -4) growdv = 1
        endif
        if (lagain == -1) then
          call info2(20,0,1,' shift (%;2g) exceeded'//
     .      ' Pade tolerance (%;2g) ... redo GF pass',xx,padtol)
        elseif (lpade) then
          call info5(20,1,1,' shift (%;2g) within Pade'//
     .      ' tolerance (%;2g, tolq=%;2g) ... accept Pade correction to G',xx,padtol,qtolp,4,5)
        endif
      endif

      if (lagain /= 0 .and. lpgf == 1) then
        xx = vbar(1)*growdv
        if (vsint(13) >= -4 .and. vsint(13) <= -2) then
          if (vsint(13) == -3 .or. vsint(13) == -2) xx = vsint(14)
          call awrit2(' vbar %;6g (dos) %;6g (rfalsi).  Modify vbar',outs,len(outs),0,vbar,xx)
          call query(trim(outs),4,xx)
        endif
        if (xx /= vbar(1)) then
          call advshp(npl,100,pgplp,glstp,xx-vbar(1),vshft)
          vbar(1) = xx
        endif
      endif

      ltmp = lagain /= 0
      call query('redo pgf pass',0,ltmp)
      if (ltmp) goto 101

C ... End of integrated-properties branch
      endif

C --- Magnetic moments corresponding to output density matrix ---
C      if (bittst(lncol,1)) then
C        neul = s_ham%neula
C        call pshpr(iprint()-0)
C        call amagnc(nbas,nl,s_ctrl%ipc,rhos,qnu,s_ham%eula,neul,0,amag,aamom,w)
C        if (bittst(lncol,8)) then
C          call bdotsr(nbas,nl,s_ctrl%ipc,rhos,qnu,s_ham%eula,neul,s_ham%bdots,
C     .      lhdim,s_ham%iprmb,0,ehterm(6))
C        endif
C       call poppr
C      endif

C --- Partial DOS by Pade approximant ---
      if (lpdos .and. mod(mod(moddos/10,10),2) == 0) then
        deallocate(pdos)
        allocate(pdos(ndos*npdos*nsp)); call dpzero(pdos,ndos*npdos*nsp)
        call pgpdos(ndos,dosw,pgplp,glstp(0),npl,nl,nlo,nsp,nspc,nzp,
     .    zp,gd,pdos)
      elseif (lpdos) then
        ndos  = nzp + nzne
        call dpcopy(semsh(3),dosw,1,2,1d0)
      endif

C --- Dump partial dos, if generated ---
      if (lpdos) then
        call dosio(pdos,ndos,npdos*nsp,ndos,npdos,dosw(1),dosw(2),
     .    nsp,efermi,1d0,1,-fopn('DOS'))
        call fclose(fopn('DOS'))
      endif

C --- Restore potential parameters to orthogonal rep'n ---
      allocate(ovlpa(nlspcp))
      call pptrns(1,nl,s_ctrl%ipc,nclasp,nsp,xx,size(s_ctrl%ipc),s_pot%pp,ovlpa)
      deallocate(ovlpa)

C ... Add double-counting correction to eterms,ehterm
      if (lpgf == 1 .and. procid == master) then
        print *, 'pgfasa needs d.c. terms'
      elseif (lpgf == 2) then
        call dpzero(wk,10)
        j = 0
        call dpscop(dosi,wk,5*nsp,1+j,1,1d0)
        qtot = wk(2) + wk(7)
        xx = vbar(2) * qtot
        j = 5*nsp
        call dpscop(dosi,wk,5*nsp,1+j,1,1d0)
        qtot = wk(2) + wk(7)
        xx = xx + vbar(3) * qtot
        eterms(17) = eterms(17) + xx
        eterms(18) = eterms(18) + xx
        call info5(21,0,0,' pgfasa: vbar = %,6d, %,6d adds d.c. term '
     .    //'vbar * zval = %,6d',vbar(2),vbar(3),xx,0,0)
      endif

      if (lemom .and. procid == master) then
        call shoctl(s_ctrl,s_spec,s_pot,0,lgunit(2))
        if (iprint() > 40/1)
     .    call shoctl(s_ctrl,s_spec,s_pot,0,lgunit(1))
      endif

C ... Update constant potential shift and undo vshft
      if (lpgf == 1) then
        vconst(1) = vconst(1) + vbar(1)
        call advshp(npl,101,pgplp,glstp(0),vbar,vshft)
        call info2(31,1,0,' pgfasa (exit): vconst updated from'//
     .    ' %,6d to %,6d',vconst(1)-vbar(1),vconst)
      elseif (lpgf == 2) then
        call daxpy(2,1d0,vbar(2),1,vconst(2),1)
        call advshp(npl,11,pgplp,glstp(0),vbar(2),vshft)
        call info5(31,1,0,' pgfasa (exit): vconst updated from'//
     .    ' %,6d(L), %,6d(R) to %,6d(L), %,6d(R)',
     .    vconst(2)-vbar(2),vconst(3)-vbar(3),vconst(2),vconst(3),0)
      endif

C     Undo shift fermi energy of right lead by vne
      if (lnoneq) then

C#ifdefC SPLITVNE
C         call gtibpl(-1,npl,pgplp,ib1,ib2)
C         forall (ib=ib1:ib2) vshft(ib) = vshft(ib) + vne/2
C         call gtibpl(npl,npl,pgplp,ib1,ib2)
C         forall (ib=ib1:ib2) vshft(ib) = vshft(ib) - vne/2
C#else
        call gtibpl(npl,npl,pgplp,ib1,ib2)
        forall (ib=ib1:ib2) vshft(ib) = vshft(ib) - vne
C#endif
      endif
C     Restore hamiltonian offsets
      if (bigemb > 0) then
        deallocate(s_ham%offH); s_ham%offH => offHb
        deallocate(s_ham%iprmb); s_ham%iprmb => iprmbb
      endif

C ... Repack d.c. terms from potential shifts or applied field
      s_ham%eterms = eterms

      deallocate(ncomp,dlmcl,qne,dosne)
      deallocate(z,orbtm,vshfn,vhldp,dvldu,idu)
      if (procid == master) print *, 'setting sumev=0 for now'
      sumev = 0

      call tcx('pgfasa')
      return

   99 call rx('pgfasa: failed to read bc file')
      end
C      subroutine pgsoscl(s_ctrl,s_pot)
C      implicit none
CC ... Passed parameters
CC ... For structures
C      include 'structures.h'
C      type(str_ctrl)::  s_ctrl
C      type(str_pot)::   s_pot
CC ... Local parameters
C      integer ib,ic
C
C      call info2(20,1,0,' PGFASA: set SO perturbation to 0 for padded classes',0,0)
CC     Set SO scale to zero for any padded classes
C      do  ib  = s_ctrl%nbas+1, s_ctrl%nbasp
C        ic = s_ctrl%ipc(ib)
C        s_pot%socscl(ic) = 0
C      enddo
C
C      end
C      subroutine snot(strn,npl,gii)
C
C      character strn*(*)
C      integer npl
C      type lgf
C      complex(8), pointer :: gll(:,:)
C      end type lgf
C      type (s_lgf) :: gii(-2:npl)
C
C      print *, strn
C      do  i = -1, npl
C        print *, i, associated(gii(i)%gll)
C      enddo
C      end
C      subroutine snit(lgii,izp,zp)
C      integer lgii(*),izp
C      double precision zp(2,izp)
C      print *, 'this is snit'
C      return
C      end
