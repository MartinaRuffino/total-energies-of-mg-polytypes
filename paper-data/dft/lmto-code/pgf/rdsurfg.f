      subroutine rdsurfg(iolr,igf,isp,lspc,nspc,izp,npl,kcplx,semsh,pgplp,zp,qp,plat,
     .  lgii,gs)
C- Read surface GF from disk, converting to spinors in noncollinear case
C ----------------------------------------------------------------------
Ci   iolr  :<0 read gll from file lbc or lbc2
Ci         :>0 read grr from file rbc or rbc2
Ci   isp   :current spin channel (1 or 2)
Ci   lspc  :0 if surface GF to be treated as collinear, even in nc ase
Ci         :1 if spins are to be treated as coupled
Ci   nspc  :2 if spin-up and spin-down channels are coupled; else 1.
Ci   izp   :current point on energy contour
Ci   npl   :number of principal layers (pgfset.f)
Ci   kcplx:mode of complex storage for g
Ci         0: g stored with imaginary following real
Ci         1: g in complex*16 format
Ci         2: g have real, imaginary separated by columns
Ci   semsh :parameters defining energy contour
Ci   pgplp :index and dimensioning information for each PL (pgfset.f)
Ci          1: number of basis atoms in all PL prior to this one
Ci          2: index labelling kind of potential of this PL
Ci          The following are created internally by routine supgh:
Ci          3: source (column) dimension of GF for this PL
Ci          4: row (field) matrix dimension for this PL
Ci          5: matrix dimension for this PL including i-waves
Ci          6: offset to diagonal part of g
Ci          pgplp(1) and pgplp(2) are generated by pgfset;
Ci          the remainder are generated by pgfasa.
Ci   zp    :mesh for complex energy contour
Ci   qp    :k-point
Ci   plat  :primitive lattice vectors, in units of alat
Cio Inputs/Outputs
Cio  igf   :0 if file contents not specified.  In this case igf is returned as 1 or 3
Cio        :1 if require file contents to be surface gf
Cio        :3 if require file contents to be self-energy
Co Outputs
Co   lgii  :attributes of the gii generated; see lgupac for conventions
Co   gs    :surface Green's function
Cb Bugs
Cb   noncollinear case: reads in kcplx=1 and converts.
Cb   More efficient to read in kcplx mode directly.
Cu Updates
Cu   30 Apr 16  Surface GF can be noncollinear.  New switch lspc
Cu   24 Sep 15  First created, adapted from pgfasa
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer iolr,igf,isp,lspc,nspc,izp,npl,kcplx,pgplp(6,-1:npl),lgii(-2:npl)
      double precision zp(2,izp),qp(3),gs(*),plat(3,3),semsh(10)
C ... Dynamically allocated arrays
      complex(8), pointer :: zwk(:)
C ... Local parameters
      character*8 fnam(2)
      integer ifi,igfl,iogfrs,ipl,j,ld0,ld0x,lrd,ltype,offg
      integer, parameter :: ISH=1,MZP=64,IPLMOD=64,MSC=128
      double precision xv(3)
      procedure(integer) :: fopn
C ... External calls
      external lgupac,rx,shftzi,iogfrs

      if (iolr < 0) then
        fnam(1) = 'lbc'
        fnam(2) = 'lbc2'
        ipl = -1
        ltype = 1
      else
        fnam(1) = 'rbc'
        fnam(2) = 'rbc2'
        ipl = npl
        ltype = 2
      endif

      ifi = fopn(fnam(isp))
      read(ifi,err=99,end=99) lrd,lrd,lrd,lrd,igfl
      backspace ifi
      if (igfl /= igf .and. igf /= 0) then
        call rx('rdsurfg: unexpected file contents, file '//fnam(isp))
      else if (igf == 0) then
        igf = igfl
      endif

      j = 0                     ! j a dummy here ... assignment only to keep compilers from complaining
      ld0 = pgplp(4,ipl)
      offg = ld0*pgplp(6,ipl)
      call shftzi(2,semsh,izp,zp,zp) ! wz is not modified; use zp as dummy for wz

      if (isp == 1 .and. nspc == 2 .and. lspc == 0) then ! Read g+, g- in cmplx*16 mode
        ld0x = ld0*2
        call dvset(gs,1,2*(ld0x)**2-1,0d0)
        allocate(zwk(ld0**2))
        lrd = iogfrs(10000*(ISH+IPLMOD)+10*MZP+6,igfl,0,fnam,ifi,1,1,j,j,
     .    zp(1,izp),qp,plat,xv,pgplp(1,ipl),xv,xv,offg,0,1,zwk)
        call zmscop(0,ld0,ld0,ld0,ld0x,0,0,0,0,zwk,gs)
        ifi = fopn(fnam(2))
        lrd = iogfrs(10000*(ISH+IPLMOD)+10*MZP+6,igfl,0,fnam,ifi,1,1,j,j,
     .    zp(1,izp),qp,plat,xv,pgplp(1,ipl),xv,xv,offg,0,1,zwk)
        call zmscop(0,ld0,ld0,ld0,ld0x,0,0,ld0,ld0,zwk,gs)
        if (lrd /= 0) goto 99
C       call zprm('gs',2,gs,ld0x,ld0x,ld0x)
        call ztoyy(gs,ld0x,ld0x,ld0x,ld0x,1,kcplx)
C       kcplx=0 printout
C       call yprm('gs',2,gs,ld0x*ld0x,ld0x,ld0x,ld0x)
      else
        lrd = iogfrs(10000*(ISH+IPLMOD)+10*(MZP+MSC*lspc)+6,igfl,0,fnam,ifi,1,1,j,j,
     .    zp(1,izp),qp,plat,xv,pgplp(1,ipl),xv,xv,offg,0,kcplx,gs)
C       call yprm('gs',2,gs,ld0*ld0,ld0,ld0,ld0)
        if (lrd /= 0) goto 99
      endif


      call shftzi(1,semsh,izp,zp,zp) ! wz is not modified; use zp as dummy for wz

      if (lrd == 0) call lgupac(lgii(ipl),'p',1,ltype,0,3,0,0)

      return

   99 call rx('rdsurfg: failed to read bc file')
      end
