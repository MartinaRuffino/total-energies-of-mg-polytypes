#!/bin/tcsh -f
# Shell script to read and structure symmetry line points
#
#  Updates
#    27 Mar 15  New --qlat=qlatfile
#---------------------------------------------

set nk = 0
set instr = nkq1q2
set qlat
set qlatl=-1

if ($#argv == 0) goto usage

while (`echo $1 | sed -e 's/\(.\).*/\1/' `  ==  "-")
  set arg1 = $1; shift

  switch ($arg1)
    case "--help":
    case "--h":
      goto usage

    case "--r":
    case "--replace":
      set replace
      breaksw

    case "-nk=*":
      set nk = `echo $arg1 | sed s/-nk=//`
      breaksw

    case "-qlat=*":
      set qlatl=0
      set qlatf = `echo $arg1 | sed s/-qlat=//`
      set qlat = (`cat $qlatf`)
      if (`echo $qlat | awk '{print NF}'` != 9) then
        echo "symlinepoints (abort) : require qlat be a 3x3 matrix"
      endif
      breaksw

    case "-qlatl=*":
      set qlatl=1
      set qlatf = `echo $arg1 | sed s/-qlatl=//`
      set qlat = (`cat $qlatf`)
      if (`echo $qlat | awk '{print NF}'` != 9) then
        echo "symlinepoints (abort) : require qlat be a 3x3 matrix"
      endif
      breaksw

    case "--in=all":
      set instr = nkq1q2
      breaksw

    case "--in=q":
      set instr = q1q2
      breaksw

    case "--in=q1":
      set instr = q1
      breaksw

    default:
      echo unrecognized switch $arg1
      goto usage
  endsw
end

# set verbose
if ($#argv == 0) then
  set infile
else if (-r $1) then
  set infile = $1
else
  echo missing file $1
  goto usage    
endif

 awk -vqlatl=$qlatl -vqlat="$qlat" -vnk=$nk -vinstr="$instr" '\
 {if (instr == "q1") \
 {nql=split(qlat,ql); split($0,now); split($0,out);\
 {strn=" ";{for (i = 4; i<=length(now); i++) {strn = strn " " now[i]}}};\
 now[4]=last[1]; now[5]=last[2]; now[6]=last[3];\
 out[4]=last[1]; out[5]=last[2]; out[6]=last[3];\
 {if (nql == 9) {split(qlat,ql); \
 q1=now[1]*ql[1]+now[2]*ql[4]+now[3]*ql[7];\
 q2=now[1]*ql[2]+now[2]*ql[5]+now[3]*ql[8];\
 q3=now[1]*ql[3]+now[2]*ql[6]+now[3]*ql[9];\
 out[1]=now[1]; out[2]=now[2]; out[3]=now[3];\
 now[1]=q1; now[2]=q2; now[3]=q3;\
 q1=now[4]*ql[1]+now[5]*ql[4]+now[6]*ql[7];\
 q2=now[4]*ql[2]+now[5]*ql[5]+now[6]*ql[8];\
 q3=now[4]*ql[3]+now[5]*ql[6]+now[6]*ql[9];\
 out[4]=now[4]; out[5]=now[5]; out[6]=now[6];\
 now[4]=q1; now[5]=q2; now[6]=q3;\
 }};\
 {if (NR > 1) {d=((now[1]-now[4])^2+(now[2]-now[5])^2+(now[3]-now[6])^2)^.5;\
 nki=41 ; if (nk > 0) {nki = 2*int(int(nk*d)/2)+1};\
 {if (qlatl != 0) printf "%3i  %10s %10s %10s  %10s %10s %10s %s\n", nki, out[4], out[5], out[6], out[1], out[2], out[3], strn};\
 {if (qlatl == 0) printf "%3i%12.6f%11.6f%11.6f%12.6f%11.6f%11.6f %s\n", nki, now[4], now[5], now[6], now[1], now[2], now[3], strn}}};\
 split($0,last)}}\
\
 {if (instr == "q1q2") \
 {nql=split(qlat,ql); split($0,now); split($0,out);\
 {strn=" ";{for (i = 7; i<=length(now); i++) {strn = strn " " now[i]}}};\
 {if (qlat) {split(qlat,ql); \
 q1=now[1]*ql[1]+now[2]*ql[4]+now[3]*ql[7];\
 q2=now[1]*ql[2]+now[2]*ql[5]+now[3]*ql[8];\
 q3=now[1]*ql[3]+now[2]*ql[6]+now[3]*ql[9];\
 now[1]=q1; now[2]=q2; now[3]=q3;\
 q1=now[4]*ql[1]+now[5]*ql[4]+now[6]*ql[7];\
 q2=now[4]*ql[2]+now[5]*ql[5]+now[6]*ql[8];\
 q3=now[4]*ql[3]+now[5]*ql[6]+now[6]*ql[9];\
 now[4]=q1; now[5]=q2; now[6]=q3;\
 }};\
 {d=((now[1]-now[4])^2+(now[2]-now[5])^2+(now[3]-now[6])^2)^.5;\
 nki=41 ; if (nk > 0) {nki = 2*int(int(nk*d)/2)+1};\
 {if (qlatl != 0) printf "%3i  %10s %10s %10s  %10s %10s %10s %s\n",      nki, out[1], out[2], out[3], out[4], out[5], out[6], strn};\
 {if (qlatl == 0) printf "%3i%12.6f%11.6f%11.6f%12.6f%11.6f%11.6f  %s\n", nki, now[1], now[2], now[3], now[4], now[5], now[6], strn}};\
 split($0,last)}}\
\
 {if (instr == "nkq1q2") \
 {nql=split(qlat,ql); split($0,now); split($0,out);\
 {strn=" ";{for (i = 8; i<=length(now); i++) {strn = strn " " now[i]}}};\
 {if (qlat) {split(qlat,ql); \
 q1=now[2]*ql[1]+now[3]*ql[4]+now[4]*ql[7];\
 q2=now[2]*ql[2]+now[3]*ql[5]+now[4]*ql[8];\
 q3=now[2]*ql[3]+now[3]*ql[6]+now[4]*ql[9];\
 now[2]=q1; now[3]=q2; now[4]=q3;\
 q1=now[5]*ql[1]+now[6]*ql[4]+now[7]*ql[7];\
 q2=now[5]*ql[2]+now[6]*ql[5]+now[7]*ql[8];\
 q3=now[5]*ql[3]+now[6]*ql[6]+now[7]*ql[9];\
 now[5]=q1; now[6]=q2; now[7]=q3;\
 }};\
 {d=((now[2]-now[5])^2+(now[3]-now[6])^2+(now[4]-now[7])^2)^.5;\
 nki=$1 ; if (nk > 0) {nki = 2*int(int(nk*d)/2)+1};\
 {if (nki > 1 && qlatl != 0) printf "%3i  %10s %10s %10s  %10s %10s %10s %s\n",      nki, out[2], out[3], out[4], out[5], out[6], out[7], strn};\
 {if (nki > 1 && qlatl == 0) printf "%3i%12.6f%11.6f%11.6f%12.6f%11.6f%11.6f  %s\n", nki, now[2], now[3], now[4], now[5], now[6], now[7], strn}};\
 split($0,last)}}\
' $infile

exit
usage:
echo 'usage : symlinepoints [--switches] [sym-line-filename]'
cat <<EOF
        Symmetry line info from stdin, in one of the formats shown below.
        If sym-line-filename is not specified, symmetry lines are read from stdin.

        Switches:
        -nk=#
            Specify number of k-points as (length of line)*#

        -qlat=qfile | -qlatl=qfile
            Specify that each k-point read in is a multiple of reciprolcal lattice vectors qlat.
            qfile is a 3x3 matrix of the RLV (9 elements) ordered as follows:
               Qx1 Qy1 Qz1 Qx2 Qy2 Qz2 Qx3 Qy3 Qz3
            The Questaal codes print out reciprocal lattice vectors in this order.
            Extract qlat with e.g.
              lmchk ext [switches] | grep -A 3 Qlat | tail -3 | awk '{print $4, $5, $6}' > qfile

            -qlat writes k-points in Cartesian coordinates, while -qlatl writes them in multiples of qlat
            In the latter case qp are printed in the same coordinates as they are input.
            The RLV are used only to determine the line length.

        --in=all (default)
            Each row has format:   nk q1x q1y q1z  q2x q2y q2z  [string]
        --in=q
            Each row has format:      q1x q1y q1z  q2x q2y q2z  [string]
        --in=q1
            Each row has format:      q1x q1y q1z               [string]

        --help
        --h
          show this message

EOF

