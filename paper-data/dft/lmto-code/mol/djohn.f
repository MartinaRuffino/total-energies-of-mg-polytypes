      SUBROUTINE C2FFT(C,ID,NM,NN,WM,WN,ISIG,IORD,IWORK,IERR)
****PURPOSE:
*       THIS ROUTINE PERFORMS A 2-DIMENSIONAL COMPLEX FOURIER TRANSFORM,
*       OF ORDER NM*NN.
****USAGE:
*       THE USER IS EXPECTED TO PROVIDE THE DATA IN A 2-DIMENSIONAL
*       COMPLEX ARRAY C, DIMENSIONED IN THE CALLING PROGRAM C(ID,NN);
*       ID CAN BE DIFFERENT FROM NM, AND IT IS RECOMMENDED THAT IT IS
*       CHOSEN EQUAL TO NM+1 IF NM IS EVEN OR TO NM IF NM IS ODD.
*       THE ELEMENTS C(K,*),NM<K<=ID MUST BE ZEROED. THE ROUTINE IS
*       INTENDED FOR REPEATED USAGE, THUS SEPARATE SET-UP AND
*       OPERATING CALLS ARE AVAILABLE : THE USER SHOULD ALWAYS PERFORM
*       A SET-UP CALL ( ISIG=0 ) PASSING THE CHOSEN PARAMETERS, BEFORE
*       PERFORMING THE ACTUAL TRANSFORM ( ISIG= +1 OR -1 ); THE USER CAN
*       CHOOSE WHETHER TO OBTAIN THE RESULTS OF THE DIRECT TRANSFORM
*       IN NATURAL ORDER (ISIG=-1,IORD=1) OR LEAVE THEM IN THE
*      'BIT-REVERSED' ORDER( ISIG=-1,IORD=0); THIS CHOICE SAVES
*       SOME COMPUTER TIME, AND IT IS RECOMMENDED IN CASES DISCUSSED
*       IN THE LONG WRITE-UP. ANALOGOUSLY,THE INVERSE TRANSFORM ACCEPTS
*       INPUT ( PLEASE NOTE! ) DATA IN NATURAL ORDER ( ISIG=1,IORD=1),
*       OR DATA ALREADY SUBJECTED TO A BIT-REVERSAL PERMUTATION( ISIG=1
*       IORD=0 ).
****PARAMETERS :
*       INPUT :
*       C : ARRAY TO BE TRANSFORMED; DECLARED COMPLEX C(ID,NN) IN THE
*           CALLING PROGRAM;
*       ID : FIRST DIMENSION OF C IN THE CALLING PROGRAM
*       ISIG : OPTION FLAG : ISIG=0 : SET-UP RUN, C NOT USED
*                            ISIG=-1: DIRECT TRANSFORM
*                            ISIG=+1: INVERSE TRANSFORM
*       WM,WN : INTEGER ARRAYS , USED TO HOST TABLES FOR THE TRANSFORM;
*               DIMENSIONED IN THE CALLING PROGRAM AT LEAST (4*NM+14)
*               AND (4*NN+14) RESPECTIVELY; IF ISIG.NE.0 ,THEY ARE
*               ASSUMED TO HAVE BEEN SET BY A PREVIOUS CALL WITH ISIG=0
*               (ALL OTHER ARGUMENTS UNCHANGED), AND NEVER HAVE BEEN
*               MODIFIED SINCE THEN;
*               IF NM=NN, WM AND WN DO NOT NEED TO BE DISTINCT;
*       NM : ORDER OF THE TRANSFORM ALONG THE COLUMNS OF C
*       NN : ORDER OF THE TRANSFORM ALONG THE ROWS OF C
*       IORD : OPTION FLAG : =1 : OUTPUT IN NATURAL ORDER (ISIG=-1)
*                                 INPUT IN NATURAL ORDER  (ISIG=+1)
*                            =0 : OUTPUT IN BIT-REVERSED ORDER(ISIG=-1)
*                                 INPUT IN BIT-REVERSED ORDER(ISIG=+1)
*       IWORK : INTEGER ARRAY, USED AS WORK AREA FOR REORDERING IF IORD=
*                1, IT MUST BE AT LEAST MAX(NM,NN) WORDS LONG.
*                IT IS UNUSED IF IORD=0.
*
****OUTPUT :
*       C : TRANSFORMED ARRAY
*       WM, WN : ONLY IF ISIG=0, WM AND WN ARE FILLED WITH THE
*               APPROPRIATE  TABLES (TWIDDLE FACTORS).
*       IWORK : UNDEFINED
*       IERR  : ERROR CODE : =0 : SUCCESSFUL
*                            =1 : DATA DIMENSIONS ARE NOT CORRECT
*                            =2 : PRIME FACTORS DIFFERENT FROM 2,3,5
*                                 ARE PRESENT IN DATA DIMENSIONS
*                            =3 : TABLES NOT CORRECTLY INITIALIZED
*
      implicit double precision (a-h,o-z)
      complex*16 C(*)
      double precision WM(-14:*),WN(-14:*)
      INTEGER IWORK(*)
      INTEGER IDERR,FACERR,TBERR
      PARAMETER (IDERR=1,FACERR=2,TBERR=3)
      IF(ID.LT.NM)THEN
         IERR=IDERR
         RETURN
      ENDIF
      IERR=0
      IF(ISIG.EQ.0)THEN
         CALL MFFTP(NM,WM(0),WM,0,IERR)
         IF(IERR.NE.0)RETURN
         IF(NN.NE.NM)THEN
         CALL MFFTP(NN,WN(0),WN,0,IERR)
         IF(IERR.NE.0)RETURN
         ELSE
         CALL MFFTZ0(WM,1,2*NM+7,WN,1)
         ENDIF
         RETURN

      ELSE IF(ISIG.GT.0)THEN

         IF(IORD.NE.0)THEN
         CALL MFFTOV(C,1,ID,NM,NN,WM(3*NM),IWORK)
         CALL MFFTOV(C,ID,1,NN,NM,WN(3*NN),IWORK)
         ENDIF

         CALL MFFTIV(C,1,ID,NM,NN,WM,WM(0),IERR)
         IF(IERR.NE.0)RETURN
         CALL MFFTIV(C,ID,1,NN,NM,WN,WN(0),IERR)
         IF(IERR.NE.0)RETURN

      ELSE
         CALL MFFTDV(C,1,ID,NM,NN,WM,WM(0),IERR)
         IF(IERR.NE.0)RETURN
         CALL MFFTDV(C,ID,1,NN,NM,WN,WN(0),IERR)
         IF(IERR.NE.0)RETURN

         IF(IORD.NE.0)THEN
         CALL MFFTOV(C,1,ID,NM,NN,WM(2*NM),IWORK)
         CALL MFFTOV(C,ID,1,NN,NM,WN(2*NN),IWORK)
         ENDIF
      ENDIF

      END
      SUBROUTINE C3FFT(C,ID,NL,NM,NN,WL,WM,WN,IOPT,ISIG,IORD,IWORK,IERR)

****PURPOSE:
*       THIS ROUTINE PERFORMS A 3-DIMENSIONAL COMPLEX FOURIER TRANSFORM,
*       OF ORDER NL*NM*NN  .
*       IT IS A USER INTERFACE FOR A PACKAGE (MFFT), SPECIALLY DESIGNED
*       FOR HIGH PERFORMANCE ON CRAY X-MP MACHINES.
****USAGE:
*       THE USER IS EXPECTED TO PROVIDE THE DATA IN A 3-DIMENSIONAL
*       COMPLEX ARRAY C, DIMENSIONED IN THE CALLING PROGRAM C(ID,NM,NN);
*       ID CAN BE DIFFERENT FROM NL, AND IT IS RECOMMENDED THAT IT IS
*       CHOSEN ODD FOR MAXIMUM PERFORMANCE. THE ROUTINE IS
*       INTENDED FOR REPEATED USAGE, THUS SEPARATE SET-UP AND
*       OPERATING CALLS ARE AVAILABLE : THE USER SHOULD ALWAYS PERFORM
*       A SET-UP CALL ( ISIG=0 ) PASSING THE CHOSEN PARAMETERS, BEFORE
*       PERFORMING THE ACTUAL TRANSFORM ( ISIG= +1 OR -1 ); THE USER CAN
*       CHOOSE WHETHER TO OBTAIN THE RESULTS OF THE DIRECT TRANSFORM
*       IN NATURAL ORDER (ISIG=-1,IORD=1) OR LEAVE THEM IN THE
*       BIT-REVERSED  ORDER( ISIG=-1,IORD=0); THIS CHOICE SAVES
*       SOME COMPUTER TIME, AND IT IS RECOMMENDED IN CASES DISCUSSED
*       IN THE LONG WRITE-UP. ANALOGOUSLY, THE INVERSE TRANSFORM ACCEPTS
*       INPUT ( PLEASE NOTE! ) DATA IN NATURAL ORDER ( ISIG=1,IORD=1),
*       OR DATA ALREADY SUBJECTED TO A BIT-REVERSAL PERMUTATION( ISIG=1
*       IORD=0).
*       A SPECIAL TREATMENT IS AVAILABLE TO SPEED UP THE TRANSFORM OF
*       SMALL MATRICES. THIS TREATMENT IS ACTIVATED BY THE FLAG IOPT. IN
*       THIS CASE THE TABLES FOR THE SECOND DIMENSION ( WM ) ARE LARGER,
*       BUT THE INCREASE IN PERFORMANCE IS SUBSTANTIAL WHEN NM<32.
****ARGUMENTS :
*       INPUT :
*       C : ARRAY TO BE TRANSFORMED; DECLARED COMPLEX C(ID,NM,NN) IN THE
*           CALLING PROGRAM;
*       ID : FIRST DIMENSION OF C IN THE CALLING PROGRAM
*       ISIG : OPTION FLAG : ISIG=0 : SET-UP RUN, C NOT USED
*                            ISIG=-1: DIRECT TRANSFORM
*                            ISIG=+1: INVERSE TRANSFORM
*       WL,WM,WN : INTEGER ARRAYS,USED TO HOST TABLES FOR THE TRANSFORMS
*               DIMENSIONED IN THE CALLING PROGRAM AT LEAST (4*NL+14)
*               (4*NM+14) AND (4*NN+14) RESPECTIVELY; IF IOPT=1
*               WM MUST BE DIMENSIONED AT LEAST (4*NM*(ID+1)+14)
*               IF ISIG.NE.0, THEY ARE ASSUMED TO HAVE BEEN SET BY A
*               PREVIOUS CALL WITH ISIG=0 AND OTHER ARGUMENTS EQUAL, AND
*               NEVER HAVE BEEN MODIFIED ;
*               WHEN THE CORRESPONDING ORDERS ARE EQUAL, THEY DO NOT
*               NEED TO BE DISTINCT.
*       NL : ORDER OF THE TRANSFORM ALONG THE COLUMNS OF C
*       NM : ORDER OF THE TRANSFORM ALONG THE ROWS OF C
*       NN : ORDER OF THE TRANSFORM ALONG THE THIRD DIMENSION OF C
*       IOPT : OPTION FLAG : =0 : NORMAL TREATMENT
*                            =1 : SPECIAL TREATMENT FOR IMPROVING
*                                 VECTORIZATION ON MATRICES WITH
*                                 SMALL NL; REQUIRES LONG WM(SEE);IF
*                                 REQUESTED, MUST BE PRESENT IN BOTH
*                                 THE SET-UP AND TRANSFORM CALLS;
*       IORD : OPTION FLAG : =1 : OUTPUT IN NATURAL ORDER (ISIG=-1)
*                                 INPUT IN NATURAL ORDER  (ISIG=+1)
*                            =0 : OUTPUT IN BIT-REVERSED ORDER(ISIG=-1)
*                                 INPUT IN BIT-REVERSED ORDER(ISIG=+1)
*       IWORK : INTEGER ARRAY, USED AS WORK AREA FOR REORDERING IF
*               IORD=1; IT MUST BE AT LEAST MAX(NL,NM,NN) WORDS LONG.
*
*        OUTPUT :
*       C : TRANSFORMED ARRAY
*       WL, WM, WN : ONLY IF ISIG=0, WL,WM AND WN ARE FILLED WITH THE
*                     APPROPRIATE TABLES
*       IWORK : UNDEFINED
*       IERR  : ERROR CODE : =0 : SUCCESSFUL
*                          : =1 : DATA DIMENSIONS ARE NOT CORRECT
*                            =2 : PRIME FACTORS DIFFERENT FROM 2,3,5
*                                 ARE PRESENT IN DATA DIMENSIONS
*                            =3 : TABLES NOT CORRECTLY INITIALIZED

      implicit double precision (a-h,o-z)
        complex*16 C(0:*)
        double precision WM(-14:*),WN(-14:*),WL(-14:*)
        INTEGER IWORK(*)
        INTEGER IDERR,FACERR,TBERR
        PARAMETER (IDERR=1,FACERR=2,TBERR=3)

        IF(ID.LT.NL)THEN
        IERR=IDERR
        RETURN
        ENDIF
        IERR=0
        IF(ISIG.EQ.0)THEN
        CALL MFFTP(NM,WM(0),WM,ID*IOPT,IERR)
        IF(IERR.NE.0)RETURN
        IF(NM.NE.NN)THEN
        CALL MFFTP(NN,WN(0),WN,0,IERR)
        IF(IERR.NE.0)RETURN
        ELSE
        CALL MFFTZ0(WM,1,2*NM+7,WN,1)
        ENDIF
        IF(NL.EQ.NM)THEN
        CALL MFFTZ0(WM,1,2*NM+7,WL,1)
        ELSE IF(NL.EQ.NN)THEN
        CALL MFFTZ0(WN,1,2*NN+7,WL,1)
        ELSE
        CALL MFFTP(NL,WL(0),WL,0,IERR)
        IF(IERR.NE.0)RETURN
        ENDIF
        RETURN

        ELSE   IF(ISIG.GT.0)THEN

        IF(IORD.NE.0)THEN
        CALL MFFTOV(C,1,ID,NL,NM*NN,WL(3*NL),IWORK)
        CALL MFFTOV(C,ID*NM,1,NN,ID*NM,WN(3*NN),IWORK)
        CALL MFFTOM(C,ID,ID*NM,1,NM,NN,NL,WM(3*NM),
     $                IWORK)
        ENDIF
        CALL MFFTIV(C,1,ID,NL,NM*NN,WL,WL(0),IERR)
        IF(IERR.NE.0)RETURN
        IF(IOPT.EQ.0)THEN
        CALL MFFTIM(C,ID,ID*NM,1,NM,NN,NL,WM,WM(0),IERR)
        IF(IERR.NE.0)RETURN
        ELSE
        CALL MFFTIS(C,ID,ID*NM,1,NM,NN,NL,WM,WM(0),IERR)
        IF(IERR.NE.0)RETURN
        ENDIF
        CALL MFFTIV(C,ID*NM,1,NN,ID*NM,WN,WN(0),IERR)
        IF(IERR.NE.0)RETURN

      ELSE

        CALL MFFTDV(C,1,ID,NL,NM*NN,WL,WL(0),IERR)
        IF(IERR.NE.0)RETURN
        IF(IOPT.EQ.0)THEN
        CALL MFFTDM(C,ID,ID*NM,1,NM,NN,NL,WM,WM(0),IERR)
        IF(IERR.NE.0)RETURN
        ELSE
        CALL MFFTDS(C,ID,ID*NM,1,NM,NN,NL,WM,WM(0),IERR)
        IF(IERR.NE.0)RETURN
        ENDIF
        CALL MFFTDV(C,ID*NM,1,NN,ID*NM,WN,WN(0),IERR)
        IF(IERR.NE.0)RETURN
        IF(IORD.NE.0)THEN
        CALL MFFTOV(C,1,ID,NL,NM*NN,WL(2*NL),IWORK)
        CALL MFFTOV(C,ID*NM,1,NN,ID*NM,WN(2*NN),IWORK)
        CALL MFFTOM(C,ID,ID*NM,1,NM,NN,NL,WM(2*NM),
     $                IWORK)
        ENDIF

      ENDIF

      END
      SUBROUTINE R2FFT(C,ID,NM,NN,WM,WN,ISIG,IORD,IWORK,IERR)
*
****PURPOSE:
*       THIS ROUTINE PERFORMS A 2-DIMENSIONAL REAL FOURIER TRANSFORM,
*       OF ORDER NM*NN.
****USAGE:
*       THE USER IS EXPECTED TO PROVIDE THE DATA IN A 2-DIMENSIONAL
*       REAL ARRAY C, DIMENSIONED IN THE CALLING PROGRAM C(ID,NN)
*       AND EQUIVALENCED TO A COMPLEX ARRAY CCOM(ID/2,NN).
*       WHEN A DIRECT TRASNFORM IS PERFORMED, HALF OF THE OUTPUT
*       COEFFICIENTS ARE CONTAINED IN CCOM(I,J) AS FOLLOWS
*        X(I,J)= CCOM(I,J) WITH I=1,(NM/2+1) AND J=1,NN
*       THE REMAINING ONES ARE OBTAINED EXPLOITING THE CONJUGATED
*       SYMMETRY RELATION
*        X(I,J) = CONJG(CCOM(NM-I+2,1+mod(NN-J+1,nn)))
*       WITH I=NM/2+2,NM  AND  J=1,NN
*       NM (ACTUAL FIRST DIMENSION OF DATA) MUST BE AN EVEN NUMBER;
*       ID (DECLARED FIRST DIMENSION) MUST BE GR. OR EQ. TO NM+2.
*       THE ELEMENTS C(K,*), NM<K<=ID MUST BE ZEROED. THE ROUTINE IS
*       INTENDED FOR REPEATED USAGE, THUS SEPARATE SET-UP AND
*       OPERATING CALLS ARE AVAILABLE : THE USER SHOULD ALWAYS PERFORM
*       A SET-UP CALL ( ISIG=0 ) PASSING THE CHOSEN PARAMETERS, BEFORE
*       PERFORMING THE ACTUAL TRANSFORM ( ISIG= +1 OR -1 ); THE USER CAN
*       CHOOSE WHETHER TO OBTAIN THE RESULTS OF THE DIRECT TRANSFORM
*       IN NATURAL ORDER (ISIG=-1,IORD=1) OR LEAVE THEM IN THE
*       BIT-REVERSED  ORDER( ISIG=-1,IORD=0); THIS CHOICE SAVES
*       SOME COMPUTER TIME, AND IT IS RECOMMENDED IN CASES DISCUSSED
*       IN THE LONG WRITE-UP. ANALOGOUSLY, THE INVERSE TRANSFORM ACCEPTS
*       INPUT ( PLEASE NOTE! ) DATA IN NATURAL ORDER ( ISIG=1,IORD=1),
*       OR DATA ALREADY SUBJECTED TO A BIT-REVERSAL PERMUTATION( ISIG=1
*       IORD=0 ).
****PARAMETERS :
*       INPUT :
*       C : ARRAY TO BE TRANSFORMED; DECLARED REAL C(ID,NN) IN THE
*           CALLING PROGRAM;
*       ID : FIRST DIMENSION OF C IN THE CALLING PROGRAM
*            IT MUST BE AN EVEN NUMBER EQUAL TO NM+2.
*       ISIG : OPTION FLAG : ISIG=0 : SET-UP RUN, C NOT USED
*                            ISIG=-1: DIRECT TRANSFORM
*                            ISIG=+1: INVERSE TRANSFORM
*       WM,WN : INTEGER ARRAYS , USED TO HOST TABLES FOR THE TRANSFORM;
*               DIMENSIONED IN THE CALLING PROGRAM IN THIS WAY :
*               WM : AT LEAST (6*NM+14)
*               WN : AT LEAST (4*NN+14)
*               IF ISIG.NE.0 ,THEY ARE ASSUMED TO HAVE BEEN SET
*                BY A PREVIOUS CALL WITH ISIG=0 AND
*               ALL THE OTHER ARGUMENTS UNCHANGED, AND NEVER HAVE BEEN
*               MODIFIED SINCE THEN;
*               IF NM=NN, WM AND WN DO NOT NEED TO BE DISTINCT;
*       NM : ORDER OF THE TRANSFORM ALONG THE COLUMNS OF C
*       NN : ORDER OF THE TRANSFORM ALONG THE ROWS OF C
*       IORD : OPTION FLAG : =1 : OUTPUT IN NATURAL ORDER (ISIG=-1)
*                                 INPUT IN NATURAL ORDER  (ISIG=+1)
*                            =0 : OUTPUT IN BIT-REVERSED ORDER(ISIG=-1)
*                                 INPUT IN BIT-REVERSED ORDER(ISIG=+1)
*                                 WARNING:THE FIRST DIMENSION IS ORDERED
*                                 IN ANY CASE BECAUSE OF POST-PROCESSING
*                                 (FOR DIRECT) AND PRE-PROCESSING FOR
*                                 INVERSE REAL TRANSFORMS
*       IWORK : INTEGER ARRAY, USED AS WORK AREA FOR REORDERING IF IORD=
*               1, MUST BE AT LEAST MAX(NM,NN) WORDS LONG.
*
****OUTPUT :
*       C : TRANSFORMED ARRAY
*       WM, WN : ONLY IF ISIG=0, WM AND WN ARE FILLED WITH THE
*               APPROPRIATE  TABLES
*       IWORK : UNDEFINED
*       IERR  : ERROR CODE : =0 : SUCCESSFUL
*                            =1 : WRONG ID PARAMETER
*                            =2 : PRIME FACTORS DIFFERENT FROM 2,3,5
*                                 ARE PRESENT IN DATA DIMENSIONS
*                            =3 : TABLES NOT CORRECTLY INITIALIZED
*                            =4 : FIRST DIMENSION IS AN ODD NUMBER
      implicit double precision (a-h,o-z)
      complex*16 C(*)
      double precision WM(-14:*),WN(-14:*)
      INTEGER IWORK(*)
*
      INTEGER IDERR,FACERR,TBERR,ODDERR
      PARAMETER (IDERR=1,FACERR=2,TBERR=3,ODDERR=4)
*
      IF(ID.LT.NM+2)THEN
        IERR=IDERR
        RETURN
      ENDIF
      NM1=NM/2
      IF(NM1*2.NE.NM)THEN
        IERR=ODDERR
        RETURN
      ENDIF
      IERR=0
*
      IF(ISIG.EQ.0) THEN
        CALL MFFTRP(NM,WM(4*NM))
        CALL MFFTP(NM1,WM(0),WM,0,IERR)
        IF(IERR.NE.0)RETURN
        IF(NN.NE.NM1) THEN
          CALL MFFTP(NN,WN(0),WN,0,IERR)
          IF(IERR.NE.0)RETURN
        ELSE
          CALL MFFTZ0(WM,1,2*NM1+7,WN,1)
        ENDIF
        RETURN
      ELSE  IF(ISIG.GT.0) THEN

        IF(IORD.NE.0) THEN
          CALL MFFTOV(C,ID/2,1,NN,NM1+1,WN(3*NN),IWORK)
        ENDIF
        CALL MFFTIV(C,ID/2,1,NN,NM1+1,WN,WN(0),IERR)
        IF(IERR.NE.0)RETURN
        CALL MFFTRI(C,1,ID/2,NM1,NN,WM(4*NM))
        CALL MFFTOV(C,1,ID/2,NM1,NN,WM(3*NM1),IWORK)
        CALL MFFTIV(C,1,ID/2,NM1,NN,WM,WM(0),IERR)
        IF(IERR.NE.0)RETURN

      ELSE
        CALL MFFTDV(C,1,ID/2,NM1,NN,WM,WM(0),IERR)
        IF(IERR.NE.0)RETURN
        CALL MFFTOV(C,1,ID/2,NM1,NN,WM(NM1*2),IWORK)
        CALL MFFTRD(C,1,ID/2,NM1,NN,WM(4*NM))
        CALL MFFTDV(C,ID/2,1,NN,NM1+1,WN,WN(0),IERR)
        IF(IERR.NE.0)RETURN

        IF(IORD.NE.0) THEN
          CALL MFFTOV(C,ID/2,1,NN,NM1+1,WN(NN*2),IWORK)
        ENDIF
*
      ENDIF
*
      END
C     ###########    FFT1 ENDS HERE     ###################
C --- Start of fft2 ---
      SUBROUTINE R3FFT(C,ID,NL,NM,NN,WL,WM,WN,IOPT,ISIG,IORD,IWORK,IERR)
*
****PURPOSE:
*       THIS ROUTINE PERFORMS A 3-DIMENSIONAL REAL FOURIER TRANSFORM,
*       OF ORDER NL*NM*NN  .
****USAGE:
*       THE USER IS EXPECTED TO PROVIDE THE DATA IN A 3-DIMENSIONAL
*       REAL ARRAY C, DIMENSIONED IN THE CALLING PROGRAM C(ID,NM,NN);
*       ID HAS TO BE AN EVEN INTEGER, EQUAL TO NL+2.
*       FOR OUTPUT DATA ARRENGEMENT SEE NOTES TO R2FFT HERE ABOVE.
*       THIS ROUTINE IS
*       INTENDED FOR REPEATED USAGE, THUS SEPARATE SET-UP AND
*       AND OPERATING CALLS ARE AVAILABLE: THE USER SHOULD IN ANY CASE
*       PERFORM A SET-UP CALL (ISIG=0) PASSING THE PARAMETERS BEFORE
*       PERFORMING AN ACTUAL TRANSFORM ( ISIG= +1 OR -1 ); THE USER CAN
*       CHOOSE WHETHER TO OBTAIN THE RESULTS OF THE DIRECT TRANSFORM
*       IN NATURAL ORDER (ISIG=-1,IORD=1) OR LEAVE THEM IN THE
*       BIT-REVERSED  ORDER( ISIG=-1,IORD=0); THIS CHOICE SAVES
*       SOME COMPUTER TIME, AND IT IS RECOMMENDED IN CASES DISCUSSED
*       IN THE LONG WRITE-UP. ANALOGOUSLY, THE INVERSE TRANSFORM ACCEPTS
*       INPUT ( PLEASE NOTE! ) DATA IN NATURAL ORDER ( ISIG=1,IORD=1),
*       OR DATA ALREADY SUBJECTED TO A BIT-REVERSAL PERMUTATION( ISIG=1
*       IORD=0).
*       A SPECIAL TREATMENT IS AVAILABLE TO SPEED UP THE TRANSFORM OF
*       SMALL MATRICES. THIS TREATMENT IS ACTIVATED BY THE FLAG IOPT. IN
*       THIS CASE THE TABLES FOR THE SECOND DIMENSION ( WM ) ARE LARGER,
*       BUT THE INCREASE IN PERFORMANCE IS SUBSTANTIAL WHEN NM<32.
****ARGUMENTS :
*       INPUT :
*       C : ARRAY TO BE TRANSFORMED; DECLARED COMPLEX C(ID,NM,NN) IN THE
*           CALLING PROGRAM;
*       ID : FIRST DIMENSION OF C IN THE CALLING PROGRAM
*            IT HAS TO BE AN EVEN INTEGER .GE. NL+2.
*       ISIG : OPTION FLAG : ISIG=0 : SET-UP RUN, C NOT USED
*                            ISIG=-1: DIRECT TRANSFORM
*                            ISIG=+1: INVERSE TRANSFORM
*       WL,WM,WN : INTEGER ARRAYS,USED TO HOST TABLES FOR THE TRANSFORMS
*               DIMENSIONED IN THE CALLING PROGRAM AT LEAST (6*NL+14)
*               (4*NM+14) AND (4*NN+14) RESPECTIVELY; IF
*               IOPT=1, WM MUST BE DIMENSIONED AT LEAST 4*NM*(ID/2+1)+14
*               IF ISIG.NE.0, THEY ARE ASSUMED TO HAVE BEEN SET BY A
*               PREVIOUS CALL WITH ISIG=0 AND OTHER ARGUMENTS EQUAL, AND
*               NEVER HAVE BEEN MODIFIED ;
*               WHEN THE CORRESPONDING ORDERS ARE EQUAL, THEY DO NOT
*               NEED TO BE DISTINCT
*       NL : ORDER OF THE TRANSFORM ALONG THE COLUMNS OF C
*            IT HAS TO BE AN EVEN INTEGER.
*       NM : ORDER OF THE TRANSFORM ALONG THE ROWS OF C
*       NN : ORDER OF THE TRANSFORM ALONG THE THIRD DIMENSION OF C
*       IOPT : OPTION FLAG : =0 : NORMAL TREATMENT
*                            =1 : SPECIAL TREATMENT FOR IMPROVING
*                                 VECTORIZATION ON MATRICES WITH
*                                 SMALL NL; REQUIRES LONG WM(SEE);IF
*                                 REQUESTED, MUST BE PRESENT IN BOTH
*                                 THE SET-UP AND TRANSFORM CALLS;
*       IORD : OPTION FLAG : =1 : OUTPUT IN NATURAL ORDER (ISIG=-1)
*                                 INPUT IN NATURAL ORDER  (ISIG=+1)
*                            =0 : OUTPUT IN BIT-REVERSED ORDER(ISIG=-1)
*                                 INPUT IN BIT-REVERSED ORDER(ISIG=+1)
*       IWORK : INTEGER ARRAY, USED AS WORK AREA FOR REORDERING IF
*               IORD=1; IT MUST BE AT LEAST MAX(NL,NM,NN) WORDS LONG.
*
*        OUTPUT :
*       C : TRANSFORMED ARRAY
*       WL, WM, WN : ONLY IF ISIG=0, WL,WM AND WN ARE FILLED WITH THE
*                     APPROPRIATE TABLES
*       IWORK : UNDEFINED
*       IERR  : ERROR CODE : =0 : SUCCESSFUL
*                            =1 : WRONG ID PARAMETER
*                            =2 : PRIME FACTORS DIFFERENT FROM 2,3,5
*                                 ARE PRESENT IN DATA DIMENSIONS
*                            =3 : TABLES NOT CORRECTLY INITIALIZED
*                            =4 : FIRST DIMENSION IS AN ODD NUMBER
*
      implicit double precision (a-h,o-z)
      complex*16 C(*)
      double precision WL(-14:*),WM(-14:*),WN(-14:*)
      INTEGER  IWORK(*)
*
*
      INTEGER IDERR,FACERR,TBERR,ODDERR
      PARAMETER (IDERR=1,FACERR=2,TBERR=3,ODDERR=4)
*
      IF(ID.LT.NL+2)THEN
        IERR=IDERR
        RETURN
      ENDIF
      NL1=NL/2
      IF(NL1*2.NE.NL)THEN
        IERR=ODDERR
        RETURN
      ENDIF
      IERR=0

      NMPN=NM*NN
*
*
      IF(ISIG.EQ.0) THEN
        CALL MFFTP(NM,WM(0),WM,ID/2*IOPT,IERR)
        IF(IERR.NE.0)RETURN

        CALL MFFTRP(NL,WL(4*NL))
        IF(NL1.NE.NM) THEN
          CALL MFFTP(NL1,WL(0),WL,0,IERR)
          IF(IERR.NE.0)RETURN
        ELSE
          CALL MFFTZ0(WM,1,2*NM+7,WL,1)
        ENDIF
*
        IF(NM.EQ.NN) THEN
          CALL MFFTZ0(WM,1,2*NM+7,WN,1)
        ELSE IF(NN.EQ.NL1) THEN
          CALL MFFTZ0(WL,1,2*NL1+7,WN,1)
        ELSE
          CALL MFFTP(NN,WN(0),WN,0,IERR)
          IF(IERR.NE.0)RETURN
        ENDIF
        RETURN
*
      ELSE   IF(ISIG.GT.0) THEN
*
        IF(IORD.NE.0) THEN
          CALL MFFTOM(C,ID/2,ID/2*NM,1,NM,NN,NL1+1,WM(NM*3),IWORK)
          CALL MFFTOV(C,ID/2*NM,1,NN,ID/2*NM,WN(NN*3),IWORK)
        ENDIF
*
        CALL MFFTIV(C,ID/2*NM,1,NN,ID/2*NM,WN,WN(0),IERR)
        IF(IERR.NE.0)RETURN
*
        IF(IOPT.EQ.0) THEN
          CALL MFFTIM(C,ID/2,ID/2*NM,1,NM,NN,NL1+1,WM,WM(0),IERR)
          IF(IERR.NE.0)RETURN
        ELSE
          CALL MFFTIS(C,ID/2,ID/2*NM,1,NM,NN,NL1+1,WM,WM(0),IERR)
          IF(IERR.NE.0)RETURN
        ENDIF
*
        CALL MFFTRI(C,1,ID/2,NL1,NMPN,WL(4*NL))
        CALL MFFTOV(C,1,ID/2,NL1,NMPN,WL(NL1*3),IWORK)
        CALL MFFTIV(C,1,ID/2,NL1,NMPN,WL,WL(0),IERR)
        IF(IERR.NE.0)RETURN
*
*
      ELSE
*
*
        CALL MFFTDV(C,1,ID/2,NL1,NMPN,WL,WL(0),IERR)
        IF(IERR.NE.0)RETURN
        CALL MFFTOV(C,1,ID/2,NL1,NMPN,WL(NL1*2),IWORK)
        CALL MFFTRD(C,1,ID/2,NL1,NMPN,WL(4*NL))
*
*
        IF(IOPT.EQ.0) THEN
          CALL MFFTDM(C,ID/2,ID/2*NM,1,NM,NN,NL1+1,WM,WM(0),IERR)
          IF(IERR.NE.0)RETURN
        ELSE
          CALL MFFTDS(C,ID/2,ID/2*NM,1,NM,NN,NL1+1,WM,WM(0),IERR)
          IF(IERR.NE.0)RETURN
        ENDIF
*
        CALL MFFTDV(C,ID/2*NM,1,NN,ID/2*NM,WN,WN(0),IERR)
        IF(IERR.NE.0)RETURN
*
        IF(IORD.NE.0) THEN
          CALL MFFTOV(C,ID/2*NM,1,NN,ID/2*NM,WN(NN*2),IWORK)
          CALL MFFTOM(C,ID/2,ID/2*NM,1,NM,NN,NL1+1,WM(NM*2),IWORK)
        ENDIF
*
      ENDIF
*
      END
      SUBROUTINE MFFTDM(C,IMSX,IVSX,IESX,NMX,NVX,NEX,TABLES,W,IERR)
*   PURPOSE:
*       THIS SUBROUTINE PERFORMS A DIRECT FOURIER TRANSFORM ALONG
*       THE SECOND DIMENSION OF A 3-DIMENSIONAL MATRIX, USING THE
*       GENTLEMAN-SANDE ALGORITHM.
*       THE SEQUENCE TO BE TRANSFORMED IS C[IMSX,NMX], WHOSE COMPONENTS
*       ARE THE 2-VECTORS C(M)[IVSX,NVX [IESX,NEX]].
*       SEE REF.[1] FOR NOTATIONS.
*  EXAMPLE:
*       LET C BE A 3-D MATRIX C(N1,N2,N3), DECLARED VIA
*              DIMENSION C(NN1,N2,N3)
*       WITH NN1.GE.N1
*       THEN ITS DFT ALONG THE SECOND DIMENSION IS OBTAINED BY
*              CALL MFFTDM(C,NN1,NN1*N2,1,N2,N3,N1,TABLES,IERR)
*  IMPLEMENTATION:
*       THE TRANSFORMATION IS IMPLEMENTED THROUGH REPEATED CALLS TO THE
*       "BUTTERFLY" TRANSFORMATION MFFT?6; PARAMETERS OF THE "BUTTERFLY"
*       ARE COMMUNICATED THROUGH THE COMMON BLOCK MFFTPA.
*  ARGUMENTS:
*    INPUT  :
*       C : ARRAY TO BE TRANSFORMED.
*       IMSX,IVSX,IESX,NMX,NVX,NEX: THESE ARGUMENTS DEFINE THE STRUCTURE
*           OF C ACCORDING TO THE DEFINITIONS ABOVE. THEY ARE UNCHANGED
*           ON OUTPUT
*       TABLES : ARRAY PREPARED BY MFFTP. IT  IS NOT CHANGED ON OUTPUT.
*                IT SHOULD BE DECLARED INTEGER TABLES(4*NM+14);
*                IT MUST BE INITIALIZED BY MFFTP BEFORE USAGE.
*    OUTPUT:
*       C : TRANSFORM OF THE ORIGINAL ARRAY; "BIT REVERSED" ORDER
*       IERR : ERROR CODE : =0 : SUCCESSFUL
*                         : =3 :  'TABLES' NOT CORRECTLY INITIALIZED
      implicit double precision (a-h,o-z)
      complex*16 C(*)
      double precision w(0:*)
      INTEGER TABLES(-14:*)
      INTEGER IDERR,FACERR,TBERR
      PARAMETER (IDERR=1,FACERR=2,TBERR=3)
      COMMON /MFFTPA/  IMS,IVS,IES,NM,NV,NE,MX,LX,MLIM,MSTEP,LLIM,LSTEP,
     $ NUSTEP,IVLIM,ILIM,MD2LIM,LD2LIM
*  LOADING THE COMMON BLOCK : CONSTANTS
      IMS=IMSX
      IVS=IVSX
      IES=IESX
      NM=NMX
      NV=NVX
      NE=NEX

      IVLIM=(NV-1)*IVS
      ILIM=(NE-1)*IES
      MSTEP=IMS
*  LOADING THE COMMON BLOCK : ITERATION-DEPENDENT QUANTITIES: INITIALIZA
      LX=1
      MX=NM
*  SELECT THE HIGHEST FACTOR OF NM
      IFAC=TABLES(-1)
      GOTO(200,300,500)IFAC
      IERR=TBERR
      RETURN
*...  RADIX 5 LOOP
500   CONTINUE
      DO 510 IM=1,TABLES(-12)
        MX=MX/5
        NUSTEP=MX*MSTEP
        MLIM=NUSTEP-MSTEP
        LSTEP=NUSTEP*5
        LLIM=NM*MSTEP-LSTEP
        CALL MFFTC6(C,W)
        LX=LX*5
510   CONTINUE
*..  RADIX 3 LOOP
300   CONTINUE
      DO 310 IM=1,TABLES(-13)
        MX=MX/3
        NUSTEP=MX*MSTEP
        MLIM=NUSTEP-MSTEP
        LSTEP=NUSTEP*3
        LLIM=NM*MSTEP-LSTEP
        CALL MFFTB6(C,W)
        LX=LX*3
310   CONTINUE
*..  RADIX 2 LOOP
200   CONTINUE
      DO 210 IM=1,TABLES(-14)
        MX=MX/2
        NUSTEP=MX*MSTEP
        MLIM=NUSTEP-MSTEP
        MD2LIM=NUSTEP/2-MSTEP
        LSTEP=NUSTEP*2
        LLIM=NM*MSTEP-LSTEP
        CALL MFFTA6(C,W)
        LX=LX+LX
210   CONTINUE
      END
      SUBROUTINE MFFTDS(C,IMSX,IVSX,IESX,NMX,NVX,NEX,TABLES,W,IERR)

*   PURPOSE:
*       THE SAME AS MFFTDM.    IT IS A VARIANT OF MFFTDM
*       AIMED AT OPTIMAL PERFORMANCE ON MATRICES HAVING THE
*       FIRST DIMENSION SMALLER THAN 64. IT REQUIRES THAT MFFTP HAS
*       BEEN CALLED WITH ID .NE. 0
*  IMPLEMENTATION:
*       THE TRANSFORMATION IS IMPLEMENTED THROUGH REPEATED CALLS TO THE
*       "BUTTERFLY" TRANSFORMATION MFFT?8; PARAMETERS OF THE "BUTTERFLY"
*       ARE COMMUNICATED THROUGH THE COMMON BLOCK MFFTPA.
*  ARGUMENTS:
*    INPUT  :
*       C : ARRAY TO BE TRANSFORMED.
*       IMSX,IVSX,IESX,NMX,NVX,NEX: THESE ARGUMENTS DEFINE THE STRUCTURE
*           OF C ACCORDING TO THE DEFINITIONS ABOVE. THEY ARE UNCHANGED
*           ON OUTPUT
*       TABLES : ARRAY PREPARED BY MFFTP. IT  IS NOT CHANGED ON OUTPUT.
*                IT SHOULD BE DECLARED INTEGER TABLES(4*NM+14);
*                IT MUST BE INITIALIZED BY MFFTP BEFORE USAGE.
*    OUTPUT:
*       C : TRANSFORM OF THE ORIGINAL ARRAY; "BIT REVERSED" ORDER
*       IERR : ERROR CODE : =0 : SUCCESSFUL
*                         : =3 :  'TABLES' NOT CORRECTLY INITIALIZED
      implicit double precision (a-h,o-z)
      complex*16 C(*)
      double precision w(0:*)
      INTEGER TABLES(-14:*)
      INTEGER IDERR,FACERR,TBERR
      PARAMETER (IDERR=1,FACERR=2,TBERR=3)
      COMMON /MFFTPA/  IMS,IVS,IES,NM,NV,NE,MX,LX,MLIM,MSTEP,LLIM,LSTEP,
     $ NUSTEP,IVLIM,ILIM,MD2LIM,LD2LIM
      SAVE IBASE
*  LOADING THE COMMON BLOCK : CONSTANTS
      IMS=IMSX
      IVS=IVSX
      NM=NMX
      NV=NVX
      NE=NEX
      IVLIM=(NV-1)*IVS
      MSTEP=IMS
*  LOADING THE COMMON BLOCK : ITERATION-DEPENDENT QUANTITIES: INITIALIZA
      LX=1
      MX=NM

      IBASE=2*NM
*  SELECT THE HIGHEST FACTOR OF NM
      IFAC=TABLES(-1)
      GOTO(200,300,500)IFAC
      IERR=TBERR
      RETURN
*...  RADIX 5 LOOP
500   CONTINUE
      DO 510 IM=1,TABLES(-12)
        MX=MX/5
        NUSTEP=MX*MSTEP
        ILIM=NUSTEP-1
        LSTEP=NUSTEP*5
        LLIM=NM*MSTEP-LSTEP
        CALL MFFTC8(C,W(2*IBASE))
        LX=LX*5
        IBASE=IBASE+NUSTEP*4
510   CONTINUE
*..  RADIX 3 LOOP
300   CONTINUE
      DO 310 IM=1,TABLES(-13)
        MX=MX/3
        NUSTEP=MX*MSTEP
        ILIM=NUSTEP-1
        LSTEP=NUSTEP*3
        LLIM=NM*MSTEP-LSTEP
        CALL MFFTB8(C,W(2*IBASE))
        LX=LX*3
        IBASE=IBASE+NUSTEP*2
310   CONTINUE
*..  RADIX 2 LOOP
200   CONTINUE
      DO 210 IM=1,TABLES(-14)
        MX=MX/2
        NUSTEP=MX*MSTEP
        ILIM=NUSTEP-1
        MD2LIM=NUSTEP/2-MSTEP
        LSTEP=NUSTEP*2
        LLIM=NM*MSTEP-LSTEP
        CALL MFFTA8(C,W(2*IBASE))
        LX=LX+LX
        IBASE=IBASE+NUSTEP
210   CONTINUE

      END
      SUBROUTINE MFFTDV(C,IVSX,IESX,NVX,NEX,TABLES,W,IERR)
*   PURPOSE:
*       THIS SUBROUTINE PERFORMS A DIRECT FOURIER TRANSFORM ALONG
*       ONE DIMENSION OF A 2-DIMENSIONAL MATRIX, USING THE
*       GENTLEMAN-SANDE ALGORITHM; NO REORDERING IS PERFORMED.
*       THE SEQUENCE TO BE TRANSFORMED IS C[IVSX,NVX], WHOSE COMPONENTS
*       ARE THE VECTORS C(M)[IESX,NEX].
*       SEE REF.[1] FOR NOTATIONS.
*  EXAMPLE:
*       LET C BE A 2-D MATRIX C(N1,N2) DECLARED VIA
*                 DIMENSION C(ID,N2)
*       WITH ID.GE.N1.
*       THEN THE DFT ALONG THE FIRST DIMENSION IS OBTAINED BY
*                 CALL MFFTDV(C,1,ID,N1,N2,TABLES,IERR)
*       THE DFT ALONG THE SECOND DIMENSION IS OBTAINED BY
*                 CALL MFFTDV(C,ID,1,N2,N1,TABLES,IERR)
*  IMPLEMENTATION:
*       THE TRANSFORMATION IS IMPLEMENTED THROUGH REPEATED CALLS TO THE
*       "BUTTERFLY" TRANSFORMATION MFFT?4; PARAMETERS OF THE "BUTTERFLY"
*       ARE COMMUNICATED THROUGH THE COMMON BLOCK MFFTPA.
*  ARGUMENTS:
*       C : ARRAY TO BE TRANSFORMED.
*       IVSX,IESX,NVX,NEX: THESE ARGUMENTS DEFINE THE STRUCTURE OF
*           C ACCORDING TO THE DEFINITIONS ABOVE. THEY ARE UNCHANGED ON
*           OUTPUT;
*       TABLES : ARRAY PREPARED BY MFFTP. IT  IS NOT CHANGED ON OUTPUT.
*                IT SHOULD BE DECLARED INTEGER TABLES(4*NM+14);
*                IT MUST BE INITIALIZED BY MFFTP BEFORE USAGE.
*    OUTPUT:
*       C : TRANSFORM OF THE ORIGINAL ARRAY; "BIT REVERSED" ORDER
*       IERR : ERROR CODE : =0 : SUCCESSFUL
*                         : =3 :  'TABLES' NOT CORRECTLY INITIALIZED
      implicit double precision (a-h,o-z)
      complex*16 C(*)
      double precision w(0:*)
      INTEGER TABLES(-14:*)
      INTEGER IDERR,FACERR,TBERR
      PARAMETER (IDERR=1,FACERR=2,TBERR=3)
      COMMON /MFFTPA/  IMS,IVS,IES,NM,NV,NE,MX,LX,MLIM,MSTEP,LLIM,LSTEP,
     $ NUSTEP,IVLIM,ILIM,MD2LIM,LD2LIM
*  LOADING THE COMMON BLOCK : CONSTANTS
      IVS=IVSX
      IES=IESX
      NV=NVX
      NE=NEX
      ILIM=(NE-1)*IES
      MSTEP=IVS
*  LOADING THE COMMON BLOCK : ITERATION-DEPENDENT QUANTITIES: INITIALIZA
      LX=1
      MX=NV
*  SELECT THE HIGHEST FACTOR OF NV
      IFAC=TABLES(-1)
      GOTO(200,300,500)IFAC
      IERR=TBERR
      RETURN
*...  RADIX 5 LOOP
500   CONTINUE
      DO 510 IM=1,TABLES(-12)
        MX=MX/5
        NUSTEP=MX*MSTEP
        MLIM=NUSTEP-MSTEP
        LSTEP=NUSTEP*5
        LLIM=NV*MSTEP-LSTEP
        CALL MFFTC4(C,W)
        LX=LX*5
510   CONTINUE
*..  RADIX 3 LOOP
300   CONTINUE
      DO 310 IM=1,TABLES(-13)
        MX=MX/3
        NUSTEP=MX*MSTEP
        MLIM=NUSTEP-MSTEP
        LSTEP=NUSTEP*3
        LLIM=NV*MSTEP-LSTEP
        CALL MFFTB4(C,W)
        LX=LX*3
310   CONTINUE
*..  RADIX 2 LOOP
200   CONTINUE
      DO 210 IM=1,TABLES(-14)
        MX=MX/2
        NUSTEP=MX*MSTEP
        MLIM=NUSTEP-MSTEP
        MD2LIM=NUSTEP/2-MSTEP
        LSTEP=NUSTEP*2
        LLIM=NV*MSTEP-LSTEP
        CALL MFFTA4(C,W)
        LX=LX+LX
210   CONTINUE
      END
C --- Start of fft3 ---
      SUBROUTINE MFFTIM(C,IMSX,IVSX,IESX,NMX,NVX,NEX,TABLES,W,IERR)

*   PURPOSE:
*       THIS SUBROUTINE PERFORMS AN INVERSE FOURIER TRANSFORM ALONG
*       THE SECOND DIMENSION OF A 3-DIMENSIONAL MATRIX, USING THE
*       COOLEY-TUKEY ALGORITHM.
*       THE INPUT SEQUENCE IS ASSUMED TO HAVE BEEN SUBJECTED TO A
*       "BIT REVERSAL" PERMUTATION, THROUGH A CALL TO MFFTOM, OR
*       BECAUSE IT IS THE OUTPUT OF MFFTDM.
*       THE SEQUENCE TO BE TRANSFORMED IS C[IMSX,NMX], WHOSE COMPONENTS
*       ARE THE 2-VECTORS C(M)[IVSX,NVX [IESX,NEX]].
*       SEE REF.[1] FOR NOTATIONS.
*  EXAMPLE:
*       LET C BE A 3-D MATRIX C(N1,N2,N3), DECLARED VIA
*              DIMENSION C(NN1,N2,N3)
*       WITH NN1.GE.N1
*       THEN ITS IDFT ALONG THE SECOND DIMENSION IS OBTAINED BY
*              CALL MFFTIM(C,NN1,NN1*N2,1,N2,N3,N1,TABLES,IERR)
*  IMPLEMENTATION:
*       THE TRANSFORMATION IS IMPLEMENTED THROUGH REPEATED CALLS TO THE
*       "BUTTERFLY" TRANSFORMATION MFFT?7; PARAMETERS OF THE "BUTTERFLY"
*       ARE COMMUNICATED THROUGH THE COMMON BLOCK MFFTPA.
*  ARGUMENTS:
*    INPUT  :
*       C : ARRAY TO BE TRANSFORMED.
*       IMSX,IVSX,IESX,NMX,NVX,NEX: THESE ARGUMENTS DEFINE THE STRUCTURE
*           OF C ACCORDING TO THE DEFINITIONS ABOVE. THEY ARE UNCHANGED
*           ON OUTPUT
*       TABLES : ARRAY PREPARED BY MFFTP. IT  IS NOT CHANGED ON OUTPUT.
*                IT SHOULD BE DECLARED INTEGER TABLES(4*NM+14);
*                IT MUST BE INITIALIZED BY MFFTP BEFORE USAGE.
*    OUTPUT:
*       C : TRANSFORM OF THE ORIGINAL ARRAY;
*       IERR : ERROR CODE : =0 : SUCCESSFUL
*                         : =3 :  'TABLES' NOT CORRECTLY INITIALIZED
      implicit double precision (a-h,o-z)
      complex*16 C(*)
      double precision w(0:*)
      INTEGER TABLES(-14:*)
      INTEGER IDERR,FACERR,TBERR
      PARAMETER (IDERR=1,FACERR=2,TBERR=3)
      COMMON /MFFTPA/  IMS,IVS,IES,NM,NV,NE,MX,LX,MLIM,MSTEP,LLIM,LSTEP,
     $ NUSTEP,IVLIM,ILIM,MD2LIM,LD2LIM
*  LOADING THE COMMON BLOCK : CONSTANTS
      IMS=IMSX
      IVS=IVSX
      IES=IESX
      NM=NMX
      NV=NVX
      NE=NEX
      IVLIM=(NV-1)*IVS
      ILIM=(NE-1)*IES
      LSTEP=IMS
*  LOADING THE COMMON BLOCK : ITERATION-DEPENDENT QUANTITIES: INITIALIZA
      LX=1
      MX=NM
      IFAC=TABLES(-1)
      IF(IFAC.GT.3)THEN
        IERR=TBERR
        RETURN
      ENDIF
*..   RADIX 2 LOOP
200   CONTINUE
      DO 210 IM=1,TABLES(-14)
        MX=MX/2
        NUSTEP=LX*LSTEP
        LLIM=NUSTEP-LSTEP
        LD2LIM=NUSTEP/2-LSTEP
        MSTEP=NUSTEP*2
        MLIM=NM*LSTEP-MSTEP
        CALL MFFTA7(C,W)
        LX=LX+LX
210   CONTINUE
      IF(IFAC.EQ.1)RETURN
*..   RADIX 3 LOOP
300   CONTINUE
      DO 310 IM=1,TABLES(-13)
        MX=MX/3
        NUSTEP=LX*LSTEP
        LLIM=NUSTEP-LSTEP
        MSTEP=NUSTEP*3
        MLIM=NM*LSTEP-MSTEP
        CALL MFFTB7(C,W)
        LX=LX*3
310   CONTINUE
      IF(IFAC.EQ.2)RETURN
*..   RADIX 5 LOOP
500   CONTINUE
      DO 510 IM=1,TABLES(-12)
        MX=MX/5
        NUSTEP=LX*LSTEP
        LLIM=NUSTEP-LSTEP
        MSTEP=NUSTEP*5
        MLIM=NM*LSTEP-MSTEP
        CALL MFFTC7(C,W)
        LX=LX*5
510   CONTINUE
      END
      SUBROUTINE MFFTIS(C,IMSX,IVSX,IESX,NMX,NVX,NEX,TABLES,W,IERR)
*   PURPOSE:
*       THE SAME AS MFFTIM.  IT IS A VARIANT OF MFFTIM, OPTIMIZED FOR
*       MAXIMUM PERFORMANCE ON MATRICES WHOSE FIRST DIMENSION IS
*       LESS THAN 64.
*       IT REQUIRES THAT TABLES HAS BEEN PREPARED BY A CALL TO MFFTP
*       WITH ID .NE. 0 .
*  IMPLEMENTATION:
*       THE TRANSFORMATION IS IMPLEMENTED THROUGH REPEATED CALLS TO THE
*       "BUTTERFLY" TRANSFORMATION MFFT?9; PARAMETERS OF THE "BUTTERFLY"
*       ARE COMMUNICATED THROUGH THE COMMON BLOCK MFFTPA.
*  ARGUMENTS:
*    INPUT:
*       C : ARRAY TO BE TRANSFORMED.
*       IMSX,IVSX,IESX,NMX,NVX,NEX: THESE ARGUMENTS DEFINE THE STRUCTURE
*           OF C ACCORDING TO THE DEFINITIONS ABOVE. THEY ARE UNCHANGED
*           ON OUTPUT
*       TABLES : ARRAY PREPARED BY MFFTP. IT  IS NOT CHANGED ON OUTPUT.
*                IT SHOULD BE DECLARED INTEGER TABLES(4*NM+14);
*                IT MUST BE INITIALIZED BY MFFTP BEFORE USAGE.
*    OUTPUT:
*       C : TRANSFORM OF THE ORIGINAL ARRAY; "BIT REVERSED" ORDER
*       IERR : ERROR CODE : =0 : SUCCESSFUL
*                         : =3 :  'TABLES' NOT CORRECTLY INITIALIZED
      implicit double precision (a-h,o-z)
      complex*16 C(*)
      double precision w(0:*)
      INTEGER TABLES(-14:*)
      INTEGER IDERR,FACERR,TBERR
      PARAMETER (IDERR=1,FACERR=2,TBERR=3)
      COMMON /MFFTPA/  IMS,IVS,IES,NM,NV,NE,MX,LX,MLIM,MSTEP,LLIM,LSTEP,
     $ NUSTEP,IVLIM,ILIM,MD2LIM,LD2LIM
      SAVE IBASE
*  LOADING THE COMMON BLOCK : CONSTANTS
      IMS=IMSX
      IVS=IVSX
      IES=1
      NM=NMX
      NV=NVX
      NE=NEX

      IVLIM=(NV-1)*IVS
      LSTEP=IMS
*  LOADING THE COMMON BLOCK : ITERATION-DEPENDENT QUANTITIES: INITIALIZA
      LX=1
      MX=NM

      IBASE=(2+IMS)*NM
      IFAC=TABLES(-1)
      IF(IFAC.GT.3)THEN
        IERR=TBERR
        RETURN
      ENDIF
*..   RADIX 2 LOOP
200   CONTINUE
      DO 210 IM=1,TABLES(-14)
        MX=MX/2
        NUSTEP=LX*LSTEP
        ILIM=NUSTEP-1
        MSTEP=NUSTEP*2
        MLIM=NM*LSTEP-MSTEP
        CALL MFFTA9(C,W(2*IBASE))
        LX=LX+LX
        IBASE=IBASE+NUSTEP
210   CONTINUE
      IF(IFAC.EQ.1)RETURN
*..   RADIX 3 LOOP
300   CONTINUE
      DO 310 IM=1,TABLES(-13)
        MX=MX/3
        NUSTEP=LX*LSTEP
        ILIM=NUSTEP-1
        MSTEP=NUSTEP*3
        MLIM=NM*LSTEP-MSTEP
        CALL MFFTB9(C,W(2*IBASE))
        LX=LX*3
        IBASE=IBASE+NUSTEP*2
310   CONTINUE
      IF(IFAC.EQ.2)RETURN
*..   RADIX 5 LOOP
500   CONTINUE
      DO 510 IM=1,TABLES(-12)
        MX=MX/5
        NUSTEP=LX*LSTEP
        ILIM=NUSTEP-1
        MSTEP=NUSTEP*5
        MLIM=NM*LSTEP-MSTEP
        CALL MFFTC9(C,W(2*IBASE))
        LX=LX*5
        IBASE=IBASE+NUSTEP*4
510   CONTINUE
      END
      SUBROUTINE MFFTIV(C,IVSX,IESX,NVX,NEX,TABLES,W,IERR)
*
*   PURPOSE:
*       THIS SUBROUTINE PERFORMS AN INVERSE FOURIER TRANSFORM ALONG
*       ONE DIMENSION OF A 2-DIMENSIONAL MATRIX, USING THE
*       COOLEY-TUKEY ALGORITHM.
*       THE INPUT MATRIX IS ASSUMED TO HAVE BEEN SUBJECTED
*        TO A "BIT-REVERSAL" REORDERING ( THROUGH MFFTOV OR
*       BECAUSE IT IS THE OUTPUT OF MFFDV AND HAS NOT BEEN REORDERED)
*       THE SEQUENCE TO BE TRANSFORMED IS C[IVSX,NVX], WHOSE COMPONENTS
*       ARE THE VECTORS C(M)[IESX,NEX].
*       SEE REF.[1] FOR NOTATIONS.
*  EXAMPLE:
*       LET C BE A 2-D MATRIX C(N1,N2) DECLARED VIA
*                 DIMENSION C(ID,N2)
*       WITH ID.GE.N1.
*       THEN THE IDFT ALONG THE FIRST DIMENSION IS OBTAINED BY
*                 CALL MFFTIV(C,1,ID,N1,N2,TABLES,IERR)
*       THE IDFT ALONG THE SECOND DIMENSION IS OBTAINED BY
*                 CALL MFFTIV(C,ID,1,N2,N1,TABLES,IERR)
*  IMPLEMENTATION:
*       THE TRANSFORMATION IS IMPLEMENTED THROUGH REPEATED CALLS TO THE
*       "BUTTERFLY" TRANSFORMATION MFFT?5; PARAMETERS OF THE "BUTTERFLY"
*       ARE COMMUNICATED THROUGH THE COMMON BLOCK MFFTPA.
*  ARGUMENTS:
*       C : ARRAY TO BE TRANSFORMED.
*       IVSX,IESX,NVX,NEX: THESE ARGUMENTS DEFINE THE STRUCTURE OF
*           C ACCORDING TO THE DEFINITIONS ABOVE. THEY ARE UNCHANGED ON
*           OUTPUT;
*       TABLES : ARRAY PREPARED BY MFFTP. IT  IS NOT CHANGED ON OUTPUT.
*                IT SHOULD BE DECLARED INTEGER TABLES(4*NM+14);
*                IT MUST BE INITIALIZED BY MFFTP BEFORE USAGE.
*  OUTPUT:
*       C : TRANSFORM OF THE ORIGINAL ARRAY; "BIT REVERSED" ORDER
*       IERR : ERROR CODE : =0 : SUCCESSFUL
*                         : =3 :  'TABLES' NOT CORRECTLY INITIALIZED
      implicit double precision (a-h,o-z)
      complex*16 C(*)
      double precision w(0:*)
      INTEGER TABLES(-14:*)
      INTEGER IDERR,FACERR,TBERR
      PARAMETER (IDERR=1,FACERR=2,TBERR=3)
      COMMON /MFFTPA/  IMS,IVS,IES,NM,NV,NE,MX,LX,MLIM,MSTEP,LLIM,LSTEP,
     $ NUSTEP,IVLIM,ILIM,MD2LIM,LD2LIM
*  LOADING THE COMMON BLOCK : CONSTANTS
      IVS=IVSX
      IES=IESX
      NV=NVX
      NE=NEX
      ILIM=(NE-1)*IES
      LSTEP=IVS
*  LOADING THE COMMON BLOCK : ITERATION-DEPENDENT QUANTITIES: INITIALIZA
      LX=1
      MX=NV
*  SELECT THE HIGHEST FACTOR OF NV
      IFAC=TABLES(-1)
      IF(IFAC.GT.3)THEN
        IERR=TBERR
        RETURN
      ENDIF
*..  RADIX 2 LOOP
200   CONTINUE
      DO 210 IM=1,TABLES(-14)
        MX=MX/2
        NUSTEP=LX*LSTEP
        LLIM=NUSTEP-LSTEP
        LD2LIM=NUSTEP/2-LSTEP
        MSTEP=NUSTEP*2
        MLIM=NV*LSTEP-MSTEP
        CALL MFFTA5(C,W)
        LX=LX+LX
210   CONTINUE
      IF(IFAC.EQ.1)RETURN
*..  RADIX 3 LOOP
300   CONTINUE
      DO 310 IM=1,TABLES(-13)
        MX=MX/3
        NUSTEP=LX*LSTEP
        LLIM=NUSTEP-LSTEP
        MSTEP=NUSTEP*3
        MLIM=NV*LSTEP-MSTEP
        CALL MFFTB5(C,W)
        LX=LX*3
310   CONTINUE
      IF(IFAC.EQ.2)RETURN
*..   RADIX 5 LOOP
500   CONTINUE
      DO 510 IM=1,TABLES(-12)
        MX=MX/5
        NUSTEP=LX*LSTEP
        LLIM=NUSTEP-LSTEP
        MSTEP=NUSTEP*5
        MLIM=NV*LSTEP-MSTEP
        CALL MFFTC5(C,W)
        LX=LX*5
510   CONTINUE
      END
      SUBROUTINE MFFTOM(C,IMS,IVS,IES,NM,NV,NE,INDEX,ITEMP)
*
*   PURPOSE :
*     THIS ROUTINE PERFORMS A REORDERING OF A VECTOR-OF-2 VECTORS
*     OF COMPLEX C[IMS,NM [IVS,NV [IES,NE]]], ACCORDING TO A
*     PERMUTATION INDEX "INDEX".
*     SEE REF.[1] FOR NOTATIONS, AND COMMENTS TO MFFTDM ABOVE.
*  ARGUMENTS
*     C : VECTOR-OF-2 VECTORS TO BE REORDERED
*     IMS,IVS,IES,NM,NV,NE: THESE ARGUMENTS DESCRIBE THE STRUCTURE OF
*     C, ACCORDING TO THE ABOVE DEFINITION;
*     INDEX: INTEGER ARRAY , CONTAINING THE PERMUTATION INDEX  ;
*            IT IS NM ELEMENTS LONG ; PREPARED BY MFFTP.
*     IWORK: INTEGER ARRAY, OF LENGTH AT LEAST NM, USED AS WORKSPACE;
*
      implicit double precision (a-h,o-z)
      INTEGER INDEX(0:*),ITEMP(0:*)
      complex*16 C(0:IMS-1,0:*),T

      I3LIM=(NV-1)*IVS
      JLIM=(NE-1)*IES
      DO 1 I=0,NM-1
1     ITEMP(I)=INDEX(I)

      DO 4 I=1,NM-3
2       IF(ITEMP(I).NE.I)THEN
          IDEST=ITEMP(I)
          DO 3 I3=0,I3LIM,IVS
          DO 3 J=I3,I3+JLIM,IES
            T=C(J,I)
            C(J,I)=C(J,IDEST)
            C(J,IDEST)=T
3         CONTINUE
          ITEMP(I)=ITEMP(IDEST)
          ITEMP(IDEST)=IDEST
        GOTO 2
        ENDIF
4     CONTINUE
      END
      SUBROUTINE MFFTOV(C,IVS,IES,NV,NE,INDEX,ITEMP)
*
*   PURPOSE :
*     THIS ROUTINE PERFORMS A REORDERING OF A VECTOR-OF-VECTORS
*     OF COMPLEX C[IVS,NV [IES,NE]], ACCORDING TO A
*     PERMUTATION INDEX "INDEX".
*     SEE REF.[1] FOR NOTATIONS, AND COMMENTS TO MFFTDV.
*  ARGUMENTS
*     C : VECTOR-OF-VECTORS TO BE REORDERED
*     IVS,IES,NV,NE: THESE ARGUMENTS DESCRIBE THE STRUCTURE OF
*     C, ACCORDING TO THE ABOVE DEFINITION;
*     INDEX: INTEGER ARRAY , CONTAINING THE PERMUTATION INDEX ;
*            IT IS NV ELEMENTS LONG; PREPARED BY MFFTP.
*     IWORK: INTEGER ARRAY, OF LENGTH AT LEAST NV, USED AS WORKSPACE;
*
      implicit double precision (a-h,o-z)
      INTEGER INDEX(0:NV-1),ITEMP(0:NV-1)
      complex*16 C(IVS,0:*),T

      NEIES=NE*IES
      DO 1 I=0,NV-1
1     ITEMP(I)=INDEX(I)

      DO 4 I=1,NV-3
2       IF(ITEMP(I).NE.I)THEN
          IDEST=ITEMP(I)
          DO 3 J=1,NEIES,IES
            T=C(J,I)
            C(J,I)=C(J,IDEST)
            C(J,IDEST)=T
3         CONTINUE
          ITEMP(I)=ITEMP(IDEST)
          ITEMP(IDEST)=IDEST
        GOTO 2
        ENDIF
4     CONTINUE
      END
      SUBROUTINE MFFTP(N,W,IW,ID,IERR)
*
*     THIS SUBROUTINE PREPARES TABLES FOR USE BY THE MFFT
*     ROUTINES. THE PARAMETERS ARE
*
*     N : IS THE ORDER OF THE TRANSFORM;
*
*     W : ARRAY OF LENGTH AT LEAST 4*N+14  WORDS IF ID=0,
*      AND 4*N*(ID+1)+14 IF ID > 0 ; THIS ARRAY IS FILLED
*      BY THE PRESENT ROUTINE, AND SHOULD NOT BE MODIFIED BY THE
*      USER; IT IS REQUIRED BY ALL THE OPERATING ROUTINES;
*      THE ROUTINES MFFTIS AND MFFTDS
*      REQUIRE THAT W HAS BEEN FILLED BY A CALL TO MFFTP WITH
*      ID .GT. 0 ; ALL THE ROUTINES DO NOT MODIFY THE CONTENTS
*      OF W ;
*      WARNING: DIFFERENT PORTIONS OF W ARE HANDLED AS COMPLEX OR
*               INTEGER VARIABLES BY DIFFERENT ROUTINES.
*
*     ID : IF ID .EQ. 0 THE TABLES ARE SET FOR A NORMAL
*      TRANSFORM; IF ID .GT. 0 THE TABLES ARE SET FOR BOTH
*      A NORMAL AND A "SPECIAL" TRANSFORM (I.E. OPTIMIZED FOR SMALL
*      FIRST DIMENSION DATA ARRAYS, SEE REF.[2]); IN THIS CASE IT
*      SHOULD BE EQUAL TO THE FIRST DIMENSION OF THE ARRAY TO BE
*      TRANSFORMED, AS DECLARED IN THE CALLING PROGRAM.
*
*     IERR : ERROR CODE : =0 : SUCCESSFUL
*                       : =2 : FACTORIZATION ERROR
*
*
*************************************************************
*
*      REFERENCE INFORMATION : LAYOUT OF W
*
*  IN ALL CASES
*
* WORD ADDRESS      TYPE    N. OF EL. WORD LENGTH   PURPOSE
*
*  0                INTEGER      14      14     FACTORIZATION OF N
*
*  14               COMPLEX     N       2*N     EXP(I*P/(2*N)*K),K=
*                                               0,N-1
*  3*N+14           INTEGER     N        N      PERMUTATION INDEX:KOFI
*  2*N+14           INTEGER     N        N      PERMUTATION INDEX:IOFK
*
*  ONLY IF ID .GT. 0
*
*  4*N+14           COMPLEX    N*ID     2*N*ID  TABLES FOR MFFTDS
*  4*N+2*N*ID+14    COMPLEX    N*ID     2*N*ID  TABLES FOR MFFTIS
*
*
*
*******************************************************************
      implicit double precision (a-h,o-z)
      INTEGER IW(-14:*)
      double precision w(0:1,0:*)

*...  FACTORIZATION OF N IN IW(-14)..W(-1)
      CALL MFFTP1(IW(-14),N,IERR)
      IF(IERR.NE.0)RETURN
*
*     PREPARATION OF PERMUTATION INDEXES IN W(N)..W(2*N-1)
*     WARNING : IW(0)..IW(N-1) USED AS A WORK SPACE
      CALL MFFTP2(W(2*N,0),W(3*N,0),W(0,0),IW(-14),N)
*
*     PREPARATION OF PHASE FACTOR TABLE IN W(0)..W(2N-1)
      W(0,0)=1.0d0
      W(1,0)=0.0D0
      PI2DN=dATAN(1.d0)*8.d0/N
      DO 1  I=1,N-1
        W(0,I) = DCOS(PI2DN*I)
        W(1,I) = DSIN(PI2DN*I)
1     CONTINUE
*
*     IF TABLES FOR SPECIAL TRANSFORM ARE REQUESTED
      IF(ID.GT.0)THEN
        CALL MFFTP4(W(0,0),W(4*N,0),IW(-14),N,ID)
      ENDIF
*
      END
      SUBROUTINE MFFTRD(C,ISV,ISE,NV,NE,RW)
*
*   PURPOSE:
*       THIS ROUTINE PERFORMS THE POST-PROCESSING PHASE FOR
*       REAL 2-DIMENSIONAL DFT'S, ACCORDING TO FORMULA (2.7)
*       IN REF.[1].
*       POST-PROCESSING ACTS AFTER COMPUTING THE COMPLEX DFT
*       AND EVENTUAL REORDERING (CALLS TO MFFTDV AND MFFTOV).
*       IT APPLIES TO A VECTOR-OF-VECTORS-OF-COMPLEX
*               C[IVS,NV [IES,NE]].
*       SEE REF.[1] FOR NOTATIONS.
*
*   ARGUMENTS:
*      INPUT:
*       C : DATA ARRAY, OUTPUT FROM MFFTDV, MFFTOV; TO BE DECLARED
*                      REAL C(ISE*2,NE)
*           IN THE CALLING PROGRAM.
*     ISV : SEPARATION OF ELEMENTS IN A COLUMN OF C (USUALLY 1)
*     ISE : SEPARATION OF ELEMENTS IN A ROW OF C, DIVIDED BY 2
*      NV : NO. OF ELEMENTS TO BE PROCESSED IN A COLUMN OF C
*      NE : NO. OF ELEMENTS IN A ROW OF C, DIVIDED BY 2.
*      RW : COMPLEX ARRAY OF LENGHT AT LEAST NV; IT MUST
*           BE INITIALIZED BY A CALL TO MFFTRP; IT REMAINS
*           UNCHANGED IN OUTPUT.
*
*  OUTPUT : POST-PROCESSED ARRAY C
*
*
      implicit double precision (a-h,o-z)
      complex*16 C(0:ISV-1,0:*),RW(0:*),T1,T2
*
      IF (NV.GT.1) THEN
      DO 200 IV=1,(NV-1)/2
       DO 190 IE=0,(NE-1)*ISE,ISE
*
      T1=C(IE,IV)
      T2=C(IE,NV-IV)
      C(IE,IV)=((T1+dCONJG(T2))+(RW(IV)*(T1-dCONJG(T2))))*0.5d0
      C(IE,NV-IV)=(dCONJG(T1+dCONJG(T2))-dCONJG(RW(IV)*(T1-dCONJG(T2))))
     .  *0.5d0
*
 190   CONTINUE
 200  CONTINUE
*
*
      IF(2*IV.EQ.NV) THEN
        DO 210 IE=0,(NE-1)*ISE,ISE
        C(IE,IV)=dCONJG(C(IE,IV))
 210  CONTINUE
*
      ENDIF
*
       ENDIF

      DO 300 IE=0,(NE-1)*ISE,ISE
        T1=C(IE,0)
        C(IE,0)=(dREAL(T1)+dIMAG(T1))
        C(IE,NV)=(dREAL(T1)-dIMAG(T1))
 300  CONTINUE
*
*
      END
      SUBROUTINE MFFTRI(C,ISV,ISE,NV,NE,RW)
*
*   PURPOSE:
*       THIS ROUTINE PERFORMS THE PRE-PROCESSING PHASE FOR
*       REAL 2-DIMENSIONAL INVERSE DFT'S (SEE FORMULA (2.7)
*       IN REF.[1]).
*       PRE-PROCESSING ACTS ON SEQUENTAL DATA BEFORE A CALL TO
*       MFFTOV AN BEFORE COMPUTING THE IDFT (A CALL TO MFFTIV)
*       AND EVENTUAL REORDERING (CALLS TO MFFTIV AND MFFTOV).
*       IT APPLIES TO A VECTOR-OF-VECTORS-OF-COMPLEX
*               C[IVS,NV [IES,NE]].
*       SEE REF.[1] FOR NOTATIONS.
*
*   ARGUMENTS:
*      INPUT:
*       C : DATA ARRAY, OUTPUT FROM MFFTDV, MFFTOV; TO BE DECLARED
*                      REAL C(ISE*2,NE)
*           IN THE CALLING PROGRAM.
*     ISV : SEPARATION OF ELEMENTS IN A COLUMN OF C (USUALLY 1)
*     ISE : SEPARATION OF ELEMENTS IN A ROW OF C, DIVIDED BY 2
*      NV : NO. OF ELEMENTS TO BE PROCESSED IN A COLUMN OF C
*      NE : NO. OF ELEMENTS IN A ROW OF C, DIVIDED BY 2.
*      RW : COMPLEX ARRAY OF LENGHT AT LEAST NV; IT MUST
*           BE INITIALIZED BY A CALL TO MFFTRP; IT REMAINS
*           UNCHANGED IN OUTPUT.
*
*  OUTPUT : POST-PROCESSED ARRAY C
*
*
      implicit double precision (a-h,o-z)
      complex*16 C(0:ISV-1,0:*),RW(0:*),T1,T2
*
*
      IF(NV.GT.1) THEN
*
      DO 200 IV=1,(NV-1)/2
        DO 190 IE=0,(NE-1)*ISE,ISE
        T1=C(IE,IV)
        T2=C(IE,NV-IV)
*
        C(IE,IV)=(T1+dCONJG(T2))+(dCONJG(RW(IV))*(T1-dCONJG(T2)))
        C(IE,NV-IV)=dCONJG(T1+dCONJG(T2))-dCONJG(dCONJG(RW(IV))*(T1-
     $              dCONJG(T2)))


 190    CONTINUE
 200   CONTINUE
*
*
        IF(2*IV.EQ.NV) THEN
*
        DO 210 IE=0,(NE-1)*ISE,ISE
        C(IE,IV)=2*dCONJG(C(IE,IV))
 210   CONTINUE
*
*
      ENDIF
*
      ENDIF
*
*
      DO 220 IE=0,(NE-1)*ISE,ISE
         RP=dREAL(C(IE,0))+dREAL(C(IE,NV))
         RM=dREAL(C(IE,0))-dREAL(C(IE,NV))
         C(IE,0)=dCMPLX(RP,RM)
 220  CONTINUE
*
*
      END
C --- Start of fft4 --
      SUBROUTINE MFFTRP(NN,RW)
*
*  THIS ROUTINE PREPARES THE PHASE FACTOR TABLES TO BE USED IN THE
*  POST-PROCESSING PHASE IN REAL TRANSFORMS, I.E. R2FFT AND R3FFT.
*
*  THE DEFINITION OF PHASE FACTORS WE USE IS THE FOLLOWING
*
*             RW(IV) = -I*EXP(-I*2*PI/NN*IV)
*
*  WHERE THE SYMBOLS ARE:
*
*  I: IMAGINARY UNIT
*  NN : NUMBER OF REAL ELEMENTS
*  IV: RUNNING INDEX FROM 0 TO NN-1
*
*
*
*
      implicit double precision (a-h,o-z)
      complex*16 RW(0:*)
*
*
      PI2=8*dATAN(1.d0)
      PHASE=PI2/NN
      RW(0)=(0.d0,-1.d0)
*
*
      DO 10 I=1,NN-1
      RW(I)=dCMPLX(-dSIN(I*PHASE),-dCOS(I*PHASE))
 10   CONTINUE
*
*
      END
      SUBROUTINE MFFTA4(C,FAC)
*
*   PURPOSE:
*       ELEMENTARY GENTLEMAN-SANDE RADIX 2 STEP APPLIED TO A VECTOR-OF
*       VECTORS-OF-COMPLEX C[IVS,NV [IES,NE]]. SEE REF.[1] FOR NOTATIONS
*       THIS ROUTINE CAN BE USED ONLY BY ROUTINE MFFTDV, WHICH CONTROLS
*       ITS OPERATION THROUGH THE MFFTPA COMMON
*
*   DUMMY ARGUMENTS :
*
*   C   ARRAY BEING FOURIER  TRANSFORMED
*   FAC PHASE FACTORS, PREPARED BY MFFTP; NOT MODIFIED IN OUTPUT
*
      implicit double precision (a-h,o-z)
      COMMON /MFFTPA/  IMS,IVS,IES,NM,NV,NE,MX,LX,MLIM,MSTEP,LLIM,LSTEP,
     $ NUSTEP,IVLIM,ILIM,MD2LIM,LD2LIM
      complex*16 C(0:NUSTEP-1,0:1),FAC(0:*)
      complex*16 T0,F


        IF(MX.GT.2*LX)THEN
          DO 100 LAM=0,LLIM,LSTEP
            MUF=LX
            DO 90 MU=LAM+MSTEP,LAM+MD2LIM,MSTEP
              F=dCONJG(FAC(MUF))
              DO 80 I=MU,MU+ILIM,IES
                T0=C(I,0)
                C(I,0)=T0+C(I,1)
                C(I,1)=(T0-C(I,1))*F
80            CONTINUE
              MUF=MUF+LX
90          CONTINUE
            MUF=MUF-LX
            DO 91 MU=LAM+MD2LIM+2*MSTEP,LAM+MLIM,MSTEP
              F=-FAC(MUF)
              DO 81 I=MU,MU+ILIM,IES
                T0=C(I,0)
                C(I,0)=T0+C(I,1)
                C(I,1)=(T0-C(I,1))*F
81            CONTINUE
              MUF=MUF-LX
91          CONTINUE
            DO 82 I=MD2LIM+MSTEP+LAM,MD2LIM+MSTEP+LAM+ILIM,IES
               T0=C(I,0)
              C(I,0)=T0+C(I,1)
              C(I,1)=dCMPLX(dIMAG(T0-C(I,1)),-dREAL(T0-C(I,1)))
82          CONTINUE
            DO 83 I=LAM,LAM+ILIM,IES
                T0=C(I,0)
                C(I,0)=T0+C(I,1)
                C(I,1)=T0-C(I,1)
83          CONTINUE
100       CONTINUE
        ELSE
          IF(MX.EQ.1)GOTO 1000
* IF MX > 1 COME HERE
            MUF=LX
            DO 200 MU=MSTEP,MD2LIM,MSTEP
              F=dCONJG(FAC(MUF))
              DO 190 LAM=MU,MU+LLIM,LSTEP
                DO 180 I=LAM,LAM+ILIM,IES
                  T0=C(I,0)
                  C(I,0)=T0+C(I,1)
                  C(I,1)=(T0-C(I,1))*F
  180           CONTINUE
  190         CONTINUE
              MUF=MUF+LX
200         CONTINUE
            MUF=MUF-LX
            DO 201 MU=MD2LIM+2*MSTEP,MLIM,MSTEP
              F=-FAC(MUF)
              DO 191 LAM=MU,MU+LLIM,LSTEP
                DO 181 I=LAM,LAM+ILIM,IES
                  T0=C(I,0)
                  C(I,0)=T0+C(I,1)
                  C(I,1)=(T0-C(I,1))*F
  181           CONTINUE
  191         CONTINUE
              MUF=MUF-LX
201         CONTINUE
             DO 192 LAM=MD2LIM+MSTEP,MD2LIM+MSTEP+LLIM,LSTEP
             DO 182 I=LAM,LAM+ILIM,IES
               T0=C(I,0)
               C(I,0)=T0+C(I,1)
               C(I,1)=dCMPLX(dIMAG(T0-C(I,1)),-dREAL(T0-C(I,1)))
182           CONTINUE
192         CONTINUE
1000        DO 193 LAM=0,LLIM,LSTEP
              DO 183 I=LAM,LAM+ILIM,IES
                T0=C(I,0)
                C(I,0)=T0+C(I,1)
                C(I,1)=T0-C(I,1)
183           CONTINUE
193         CONTINUE
        ENDIF
      END
      SUBROUTINE MFFTA5(C,FAC)
*
*   PURPOSE:
*       ELEMENTARY COOLEY-TUKEY RADIX 2 STEP APPLIED TO A VECTOR-OF
*       VECTORS-OF-COMPLEX C[IVS,NV [IES,NE]].
*       SEE REF.[1] FOR NOTATIONS.
*       THIS ROUTINE CAN BE USED ONLY BY ROUTINE MFFTIV, WHICH CONTROLS
*       ITS OPERATION THROUGH THE MFFTPA COMMON
*
*   DUMMY ARGUMENTS :
*
*   C   ARRAY BEING FOURIER  TRANSFORMED
*   FAC PHASE FACTORS, PREPARED BY MFFTP; NOT MODIFIED IN OUTPUT
*
      implicit double precision (a-h,o-z)
      COMMON /MFFTPA/  IMS,IVS,IES,NM,NV,NE,MX,LX,MLIM,MSTEP,LLIM,LSTEP,
     $ NUSTEP,IVLIM,ILIM,MD2LIM,LD2LIM
      complex*16 C(0:NUSTEP-1,0:*),T0,F
      complex*16 FAC(0:*)

        IF(2*MX.GE.LX)THEN
          IF(LX.EQ.1)GOTO 1000
          LAMF=MX
          DO 100 LAM=LSTEP,LD2LIM,LSTEP
            F=FAC(LAMF)
            DO 90 MU=LAM,LAM+MLIM,MSTEP
              DO 80 I=MU,MU+ILIM,IES
                T0=C(I,1)*F
                C(I,1)=C(I,0)-T0
                C(I,0)=C(I,0)+T0
80            CONTINUE
90          CONTINUE
            LAMF=LAMF+MX
100       CONTINUE
          LAMF=LAMF-MX
          DO 101 LAM=LD2LIM+2*LSTEP,LLIM,LSTEP
            F=-dCONJG(FAC(LAMF))
            DO 91 MU=LAM,LAM+MLIM,MSTEP
              DO 81 I=MU,MU+ILIM,IES
                T0=C(I,1)*F
                C(I,1)=C(I,0)-T0
                C(I,0)=C(I,0)+T0
81            CONTINUE
91          CONTINUE
            LAMF=LAMF-MX
101       CONTINUE
          DO 93 MU=LD2LIM+LSTEP,LD2LIM+LSTEP+MLIM,MSTEP

            DO 83 I=MU,MU+ILIM,IES
              T0=dCMPLX(-dIMAG(C(I,1)),dREAL(C(I,1)))
              C(I,1)=C(I,0)-T0
              C(I,0)=C(I,0)+T0
83          CONTINUE
93        CONTINUE
1000      DO 92 MU=0,MLIM,MSTEP

            DO 82 I=MU,MU+ILIM,IES
              T0=C(I,1)
              C(I,1)=C(I,0)-T0
              C(I,0)=C(I,0)+T0
82          CONTINUE
92        CONTINUE
        ELSE
          DO 200 MU=0,MLIM,MSTEP
            LAMF=MX
            DO 190 LAM=MU+LSTEP,MU+LD2LIM,LSTEP
              F=FAC(LAMF)
              DO 180 I=LAM,LAM+ILIM,IES
                T0=C(I,1)*F
                C(I,1)=C(I,0)-T0
                C(I,0)=C(I,0)+T0
180           CONTINUE
              LAMF=LAMF+MX
190         CONTINUE
            LAMF=LAMF-MX
            DO 191 LAM=MU+LD2LIM+2*LSTEP,MU+LLIM,LSTEP
              F=-dCONJG(FAC(LAMF))
              DO 181 I=LAM,LAM+ILIM,IES
                T0=C(I,1)*F
                C(I,1)=C(I,0)-T0
                C(I,0)=C(I,0)+T0
181           CONTINUE
              LAMF=LAMF-MX
191         CONTINUE
            DO 182 I=MU,MU+ILIM,IES
              T0=C(I,1)
              C(I,1)=C(I,0)-T0
              C(I,0)=C(I,0)+T0
182         CONTINUE
            DO 183 I=MU+LD2LIM+LSTEP,MU+LD2LIM+LSTEP+ILIM,IES
              T0=dCMPLX(-dIMAG(C(I,1)),dREAL(C(I,1)))
              C(I,1)=C(I,0)-T0
              C(I,0)=C(I,0)+T0
183         CONTINUE
200       CONTINUE
        ENDIF
      END
      SUBROUTINE MFFTA6(C,FAC)
*
*   PURPOSE:
*       ELEMENTARY GENTLEMAN-SANDE RADIX 2 STEP APPLIED TO A VECTOR-OF
*       2-VECTORS-OF-COMPLEX C[IMS,NM [IVS,NV [IES,NE]]].
*       SEE REF.[1] FOR NOTATIONS.
*       THIS ROUTINE CAN BE USED ONLY BY ROUTINE MFFTDM, WHICH CONTROLS
*       ITS OPERATION THROUGH THE MFFTPA COMMON
*
*   DUMMY ARGUMENTS :
*
*   C   ARRAY BEING FOURIER  TRANSFORMED
*   FAC PHASE FACTORS, PREPARED BY MFFTP; NOT MODIFIED IN OUTPUT
*
      implicit double precision (a-h,o-z)
      COMMON /MFFTPA/  IMS,IVS,IES,NM,NV,NE,MX,LX,MLIM,MSTEP,LLIM,LSTEP,
     $ NUSTEP,IVLIM,ILIM,MD2LIM,LD2LIM
      complex*16 C(0:NUSTEP-1,0:1),FAC(0:*)
      complex*16 T0,F


        IF(MX.GT.2*LX)THEN
          DO 100 LAM=0,LLIM,LSTEP
            MUF=LX
            DO 90 MU=LAM+MSTEP,LAM+MD2LIM,MSTEP
              F=dCONJG(FAC(MUF))
              DO 80  IV=MU,MU+IVLIM,IVS
              DO 80 I=IV,IV+ILIM,IES
                T0=C(I,0)
                C(I,0)=T0+C(I,1)
                C(I,1)=(T0-C(I,1))*F
80            CONTINUE
              MUF=MUF+LX
90          CONTINUE
            MUF=MUF-LX
            DO 91 MU=LAM+MD2LIM+2*MSTEP,LAM+MLIM,MSTEP
              F=-FAC(MUF)
              DO 81 IV=MU,MU+IVLIM,IVS
              DO 81 I=IV,IV+ILIM,IES
                T0=C(I,0)
                C(I,0)=T0+C(I,1)
                C(I,1)=(T0-C(I,1))*F
81            CONTINUE
              MUF=MUF-LX
91          CONTINUE
            DO 82 IV=MD2LIM+MSTEP+LAM,MD2LIM+MSTEP+LAM+IVLIM,IVS
            DO 82 I=IV,IV+ILIM,IES
               T0=C(I,0)
              C(I,0)=T0+C(I,1)
              C(I,1)=dCMPLX(dIMAG(T0-C(I,1)),-dREAL(T0-C(I,1)))
82          CONTINUE
            DO 83 IV=LAM,LAM+IVLIM,IVS
            DO 83 I=IV,IV+ILIM,IES
                T0=C(I,0)
                C(I,0)=T0+C(I,1)
                C(I,1)=T0-C(I,1)
83          CONTINUE
100       CONTINUE
        ELSE
          IF(MX.EQ.1)GOTO 1000
* IF MX > 1 COME HERE
            MUF=LX
            DO 200 MU=MSTEP,MD2LIM,MSTEP
              F=dCONJG(FAC(MUF))
              DO 190 LAM=MU,MU+LLIM,LSTEP
                DO 180 IV=LAM,LAM+IVLIM,IVS
                DO 180 I=IV,IV+ILIM,IES
                  T0=C(I,0)
                  C(I,0)=T0+C(I,1)
                  C(I,1)=(T0-C(I,1))*F
  180           CONTINUE
  190         CONTINUE
              MUF=MUF+LX
200         CONTINUE
            MUF=MUF-LX
            DO 201 MU=MD2LIM+2*MSTEP,MLIM,MSTEP
              F=-FAC(MUF)
              DO 191 LAM=MU,MU+LLIM,LSTEP
                DO 181 IV=LAM,LAM+IVLIM,IVS
                DO 181 I=IV,IV+ILIM,IES
                  T0=C(I,0)
                  C(I,0)=T0+C(I,1)
                  C(I,1)=(T0-C(I,1))*F
  181           CONTINUE
  191         CONTINUE
              MUF=MUF-LX
201         CONTINUE
             DO 192 LAM=MD2LIM+MSTEP,MD2LIM+MSTEP+LLIM,LSTEP
             DO 182 IV=LAM,LAM+IVLIM,IVS
             DO 182 I=IV,IV+ILIM,IES
               T0=C(I,0)
               C(I,0)=T0+C(I,1)
               C(I,1)=dCMPLX(dIMAG(T0-C(I,1)),-dREAL(T0-C(I,1)))
182           CONTINUE
192         CONTINUE
1000        DO 193 LAM=0,LLIM,LSTEP
              DO 183 IV=LAM,LAM+IVLIM,IVS
              DO 183 I=IV,IV+ILIM,IES
                T0=C(I,0)
                C(I,0)=T0+C(I,1)
                C(I,1)=T0-C(I,1)
183           CONTINUE
193         CONTINUE
        ENDIF
      END
      SUBROUTINE MFFTA7(C,FAC)
*
*   PURPOSE:
*       ELEMENTARY COOLEY-TUKEY RADIX 2 STEP APPLIED TO A VECTOR-OF
*       2-VECTORS-OF-COMPLEX C[IMS,NM [IVS,NV [IES,NE]]].
*       SEE REF.[1] FOR NOTATIONS.
*       THIS ROUTINE CAN BE USED ONLY BY ROUTINE MFFTIM, WHICH CONTROLS
*       ITS OPERATION THROUGH THE MFFTPA COMMON
*
*   DUMMY ARGUMENTS :
*
*   C   ARRAY BEING FOURIER  TRANSFORMED
*   FAC PHASE FACTORS, PREPARED BY MFFTP; NOT MODIFIED IN OUTPUT
*
      implicit double precision (a-h,o-z)
      COMMON /MFFTPA/  IMS,IVS,IES,NM,NV,NE,MX,LX,MLIM,MSTEP,LLIM,LSTEP,
     $ NUSTEP,IVLIM,ILIM,MD2LIM,LD2LIM
      complex*16 C(0:NUSTEP-1,0:1),FAC(0:*)
      complex*16 T0,F

        IF(2*MX.GT.LX)THEN
          IF(LX.EQ.1)GOTO 1000
*   ELSE HERE
          LAMF=MX
          DO 100 LAM=LSTEP,LD2LIM,LSTEP
            F=FAC(LAMF)
            DO 90 MU=LAM,LAM+MLIM,MSTEP
              DO 80 IV=MU,MU+IVLIM,IVS
              DO 80 I=IV,IV+ILIM,IES
                T0=C(I,1)*F
                C(I,1)=C(I,0)-T0
                C(I,0)=C(I,0)+T0
80            CONTINUE
90          CONTINUE
            LAMF=LAMF+MX
100       CONTINUE
          LAMF=LAMF-MX
          DO 101 LAM=LD2LIM+2*LSTEP,LLIM,LSTEP
            F=-dCONJG(FAC(LAMF))
            DO 91 MU=LAM,LAM+MLIM,MSTEP
              DO 81 IV=MU,MU+IVLIM,IVS
              DO 81 I=IV,IV+ILIM,IES
                T0=C(I,1)*F
                C(I,1)=C(I,0)-T0
                C(I,0)=C(I,0)+T0
81            CONTINUE
91          CONTINUE
            LAMF=LAMF-MX
101       CONTINUE
          DO 93 MU=LD2LIM+LSTEP,LD2LIM+LSTEP+MLIM,MSTEP

            DO 83 IV=MU,MU+IVLIM,IVS
            DO 83 I=IV,IV+ILIM,IES
              T0=dCMPLX(-dIMAG(C(I,1)),dREAL(C(I,1)))
              C(I,1)=C(I,0)-T0
              C(I,0)=C(I,0)+T0
83          CONTINUE
93        CONTINUE
1000      DO 92 MU=0,MLIM,MSTEP

            DO 82 IV=MU,MU+IVLIM,IVS
            DO 82 I=IV,IV+ILIM,IES
              T0=C(I,1)
              C(I,1)=C(I,0)-T0
              C(I,0)=C(I,0)+T0
82          CONTINUE
92        CONTINUE
        ELSE
          DO 200 MU=0,MLIM,MSTEP
            LAMF=MX
            DO 190 LAM=MU+LSTEP,MU+LD2LIM,LSTEP
              F=FAC(LAMF)
              DO 180 IV=LAM,LAM+IVLIM,IVS
              DO 180 I=IV,IV+ILIM,IES
                T0=C(I,1)*F
                C(I,1)=C(I,0)-T0
                C(I,0)=C(I,0)+T0
180           CONTINUE
              LAMF=LAMF+MX
190         CONTINUE
            LAMF=LAMF-MX
            DO 191 LAM=MU+LD2LIM+2*LSTEP,MU+LLIM,LSTEP
              F=-dCONJG(FAC(LAMF))
              DO 181 IV=LAM,LAM+IVLIM,IVS
              DO 181 I=IV,IV+ILIM,IES
                T0=C(I,1)*F
                C(I,1)=C(I,0)-T0
                C(I,0)=C(I,0)+T0
181           CONTINUE
              LAMF=LAMF-MX
191         CONTINUE
            DO 182 IV=MU,MU+IVLIM,IVS
            DO 182 I=IV,IV+ILIM,IES
              T0=C(I,1)
              C(I,1)=C(I,0)-T0
              C(I,0)=C(I,0)+T0
182         CONTINUE
            DO 183 IV=MU+LD2LIM+LSTEP,MU+LD2LIM+LSTEP+IVLIM,IVS
            DO 183 I=IV,IV+ILIM,IES
              T0=dCMPLX(-dIMAG(C(I,1)),dREAL(C(I,1)))
              C(I,1)=C(I,0)-T0
              C(I,0)=C(I,0)+T0
183         CONTINUE
200       CONTINUE
        ENDIF
      END
C --- Start of fft5 ---
      SUBROUTINE MFFTA8(C,FAC)
*
*   PURPOSE:
*       ELEMENTARY GENTLEMAN-SANDE RADIX-2 STEP APPLIED TO A VECTOR-OF-
*       2-VECTORS-OF-COMPLEX [IMS,NM [IVS,NV [IES,NE]]], OPTIMIZED FOR
*       SMALL NE MATRICES.
*       SEE REF.[1] FOR NOTATIONS.
*       THIS ROUTINE CAN BE USED ONLY BY ROUTINE MFFTDM, WHICH CONTROLS
*       ITS OPERATION THROUGH COMMON MFFTPA.
*
*   DUMMY ARGUMENTS :
*
*   C   ARRAY BEING FOURIER  TRANSFORMED
*   FAC PHASE FACTORS, PREPARED BY MFFTP; NOT MODIFIED IN OUTPUT
*
      implicit double precision (a-h,o-z)
      COMMON /MFFTPA/  IMS,IVS,IES,NM,NV,NE,MX,LX,MLIM,MSTEP,LLIM,LSTEP,
     $ NUSTEP,IVLIM,ILIM,MD2LIM,LD2LIM
      complex*16 C(0:NUSTEP-1,0:1),FAC(0:*),T0
*
      IF (MX.NE.1) THEN
*
      DO 200 LAM=0,LLIM,LSTEP
        DO 150 IV=LAM,LAM+IVLIM,IVS
          IMUF=0
          DO 100 IMU=IV,IV+ILIM
            T0=C(IMU,0)
            C(IMU,0)=T0+C(IMU,1)
            C(IMU,1)=(T0-C(IMU,1))*FAC(IMUF)
            IMUF=IMUF+1
100       CONTINUE
150      CONTINUE
200   CONTINUE
*
      ELSE
        DO 400 LAM=0,LLIM,LSTEP
          DO 350 IV=LAM,LAM+IVLIM,IVS
            DO 300 IMU=IV,IV+ILIM
            T0=C(IMU,0)
            C(IMU,0)=T0+C(IMU,1)
            C(IMU,1)=T0-C(IMU,1)
 300        CONTINUE
 350      CONTINUE
 400    CONTINUE
      ENDIF
*
      END
      SUBROUTINE MFFTA9(C,FAC)
*
*   PURPOSE:
*       ELEMENTARY COOLEY-TUKEY RADIX-2 STEP APPLIED TO A VECTOR-OF-
*       2-VECTORS-OF-COMPLEX [IMS,NM [IVS,NV [IES,NE]]], OPTIMIZED FOR
*       SMALL NE MATRICES.
*       SEE REF.[1] FOR NOTATIONS.
*       THIS ROUTINE CAN BE USED ONLY BY ROUTINE MFFTIM, WHICH CONTROLS
*       ITS OPERATION THROUGH COMMON MFFTPA.
*
      implicit double precision (a-h,o-z)
      COMMON /MFFTPA/  IMS,IVS,IES,NM,NV,NE,MX,LX,MLIM,MSTEP,LLIM,LSTEP,
     $ NUSTEP,IVLIM,ILIM,MD2LIM,LD2LIM
      complex*16 C(0:NUSTEP-1,0:1),FAC(0:*),T0
*
      IF(LX.NE.1) THEN
*
      DO 200 MU=0,MLIM,MSTEP
        DO 150 IV=MU,MU+IVLIM,IVS
          ILAMF=0
          DO 100 ILAM=IV,IV+ILIM
            T0=C(ILAM,1)*FAC(ILAMF)
            C(ILAM,1)=C(ILAM,0)-T0
            C(ILAM,0)=C(ILAM,0)+T0
            ILAMF=ILAMF+1
100       CONTINUE
150     CONTINUE
200   CONTINUE
*
      ELSE
      DO 400 MU=0,MLIM,MSTEP
        DO 350 IV=MU,MU+IVLIM,IVS
          DO 300 ILAM=IV,IV+ILIM
          T0=C(ILAM,1)
          C(ILAM,1)=C(ILAM,0)-T0
          C(ILAM,0)=C(ILAM,0)+T0
 300      CONTINUE
 350    CONTINUE
 400  CONTINUE
      ENDIF
*
      END
      SUBROUTINE MFFTB4(C,FAC)
*
*   PURPOSE:
*       ELEMENTARY GENTLEMAN-SANDE RADIX 3 STEP APPLIED TO A VECTOR-OF
*       VECTORS-OF-COMPLEX C[IVS,NV [IES,NE]].
*       SEE REF.[1] FOR NOTATIONS.
*       THIS ROUTINE CAN BE USED ONLY BY ROUTINE MFFTDV, WHICH CONTROLS
*       ITS OPERATION THROUGH THE MFFTPA COMMON
*
*   DUMMY ARGUMENTS :
*
*   C   ARRAY BEING FOURIER  TRANSFORMED
*   FAC PHASE FACTORS, PREPARED BY MFFTP; NOT MODIFIED IN OUTPUT
*
      implicit double precision (a-h,o-z)
      COMMON /MFFTPA/  IMS,IVS,IES,NM,NV,NE,MX,LX,MLIM,MSTEP,LLIM,LSTEP,
     $ NUSTEP,IVLIM,ILIM,MD2LIM,LD2LIM
      complex*16 C(0:NUSTEP-1,0:2),FAC(0:*)
      complex*16 T0,T1,T2,F1,F2

      double precision SIN60
      PARAMETER ( SIN60 =  8.6602540378443864d-1)

*..  MU > 1
            MUF=LX
            DO 200 MU=MSTEP,MLIM,MSTEP
              F1=dCONJG(FAC(MUF))
              F2=dCONJG(FAC(2*MUF))
              DO 190 LAM=MU,MU+LLIM,LSTEP
                DO 180 I=LAM,LAM+ILIM,IES
                T0=C(I,1)+C(I,2)
                T1=C(I,0)-0.5d0*T0
                T2=(C(I,1)-C(I,2))*SIN60
                C(I,0)=C(I,0)+T0
                C(I,1)=(T1-dCMPLX(-dIMAG(T2),dREAL(T2)))*F1
                C(I,2)=(T1+dCMPLX(-dIMAG(T2),dREAL(T2)))*F2
  180           CONTINUE
  190         CONTINUE
              MUF=MUF+LX
200         CONTINUE

*..  MU=0
1000        DO 193 LAM=0,LLIM,LSTEP
              DO 183 I=LAM,LAM+ILIM,IES
                T0=C(I,1)+C(I,2)
                T1=C(I,0)-0.5d0*T0
                T2=(C(I,1)-C(I,2))*SIN60
                C(I,0)=C(I,0)+T0
                C(I,1)=(T1-dCMPLX(-dIMAG(T2),dREAL(T2)))
                C(I,2)=(T1+dCMPLX(-dIMAG(T2),dREAL(T2)))
183           CONTINUE
193         CONTINUE
      END
      SUBROUTINE MFFTB5(C,FAC)
*
*   PURPOSE:
*       ELEMENTARY COOLEY-TUKEY RADIX 3 STEP APPLIED TO A VECTOR-OF
*       VECTORS-OF-COMPLEX C[IVS,NV [IES,NE]].
*       SEE REF.[1] FOR NOTATIONS.
*       THIS ROUTINE CAN BE USED ONLY BY ROUTINE MFFTIV, WHICH CONTROLS
*       ITS OPERATION THROUGH THE MFFTPA COMMON
*
*   DUMMY ARGUMENTS :
*
*   C   ARRAY BEING FOURIER  TRANSFORMED
*   FAC PHASE FACTORS, PREPARED BY MFFTP; NOT MODIFIED IN OUTPUT
*
      implicit double precision (a-h,o-z)
      COMMON /MFFTPA/  IMS,IVS,IES,NM,NV,NE,MX,LX,MLIM,MSTEP,LLIM,LSTEP,
     $ NUSTEP,IVLIM,ILIM,MD2LIM,LD2LIM
      complex*16 C(0:NUSTEP-1,0:2),FAC(0:*)
      complex*16 T0,T1,T2,F1,F2
      double precision SIN60
      PARAMETER ( SIN60 =  8.6602540378443864d-1)

*..  LAM > 0
          LAMF=MX
          DO 100 LAM=LSTEP,LLIM,LSTEP
            F1=FAC(LAMF)
            F2=FAC(2*LAMF)
            DO 90 MU=LAM,LAM+MLIM,MSTEP
              DO 80 I=MU,MU+ILIM,IES
                T0=C(I,1)*F1+C(I,2)*F2
                T2=(C(I,1)*F1-C(I,2)*F2)*SIN60
                T1=C(I,0)-0.5d0*T0
                C(I,0)=C(I,0)+T0
                C(I,1)=(T1+dCMPLX(-dIMAG(T2),dREAL(T2)))
                C(I,2)=(T1-dCMPLX(-dIMAG(T2),dREAL(T2)))
80            CONTINUE
90          CONTINUE
            LAMF=LAMF+MX
100       CONTINUE

*.. LAM=0
          DO 92 MU=0,MLIM,MSTEP
            DO 82 I=MU,MU+ILIM,IES
                T0=C(I,1)+C(I,2)
                T2=(C(I,1)-C(I,2))*SIN60
                T1=C(I,0)-0.5d0*T0
                C(I,0)=C(I,0)+T0
                C(I,1)=(T1+dCMPLX(-dIMAG(T2),dREAL(T2)))
                C(I,2)=(T1-dCMPLX(-dIMAG(T2),dREAL(T2)))
82          CONTINUE
92        CONTINUE
      END
      SUBROUTINE MFFTB6(C,FAC)
*
*   PURPOSE:
*       ELEMENTARY GENTLEMAN-SANDE RADIX 3 STEP APPLIED TO A VECTOR-OF
*       2-VECTORS-OF-COMPLEX C[IMS,NM [IVS,NV [IES,NE]]].
*       SEE REF.[1] FOR NOTATIONS.
*       THIS ROUTINE CAN BE USED ONLY BY ROUTINE MFFTDM, WHICH CONTROLS
*       ITS OPERATION THROUGH THE MFFTPA COMMON
*
*   DUMMY ARGUMENTS :
*
*   C   ARRAY BEING FOURIER  TRANSFORMED
*   FAC PHASE FACTORS, PREPARED BY MFFTP; NOT MODIFIED IN OUTPUT
*
      implicit double precision (a-h,o-z)
      COMMON /MFFTPA/  IMS,IVS,IES,NM,NV,NE,MX,LX,MLIM,MSTEP,LLIM,LSTEP,
     $ NUSTEP,IVLIM,ILIM,MD2LIM,LD2LIM
      complex*16 C(0:NUSTEP-1,0:2),FAC(0:*)
      complex*16 T0,T1,T2,F1,F2
      double precision SIN60
      PARAMETER ( SIN60 =  8.6602540378443864d-1)


*..  MU > 0
            MUF=LX
            DO 200 MU=MSTEP,MLIM,MSTEP
              F1=dCONJG(FAC(MUF))
              F2=dCONJG(FAC(MUF*2))
              DO 190 LAM=MU,MU+LLIM,LSTEP
                DO 180 IV=LAM,LAM+IVLIM,IVS
                DO 180 I=IV,IV+ILIM,IES
                  T0=C(I,1)+C(I,2)
                  T2=(C(I,1)-C(I,2))*SIN60
                  T1=C(I,0)-0.5d0*T0
                  C(I,0)=C(I,0)+T0
                  C(I,1)=(T1-dCMPLX(-dIMAG(T2),dREAL(T2)))*F1
                  C(I,2)=(T1+dCMPLX(-dIMAG(T2),dREAL(T2)))*F2
  180           CONTINUE
  190         CONTINUE
              MUF=MUF+LX
200         CONTINUE
            DO 193 LAM=0,LLIM,LSTEP
              DO 183 IV=LAM,LAM+IVLIM,IVS
              DO 183 I=IV,IV+ILIM,IES
                T0=C(I,1)+C(I,2)
                T2=(C(I,1)-C(I,2))*SIN60
                T1=C(I,0)-0.5d0*T0
                C(I,0)=C(I,0)+T0
                C(I,1)=(T1-dCMPLX(-dIMAG(T2),dREAL(T2)))
                C(I,2)=(T1+dCMPLX(-dIMAG(T2),dREAL(T2)))
183           CONTINUE
193         CONTINUE
      END
      SUBROUTINE MFFTB7(C,FAC)
*
*   PURPOSE:
*       ELEMENTARY COOLEY-TUKEY RADIX 3 STEP APPLIED TO A VECTOR-OF
*       2-VECTORS-OF-COMPLEX C[IMS,NM [IVS,NV [IES,NE]]].
*       SEE REF.[1] FOR NOTATIONS.
*       THIS ROUTINE CAN BE USED ONLY BY ROUTINE MFFTIM, WHICH CONTROLS
*       ITS OPERATION THROUGH THE MFFTPA COMMON
*
*   DUMMY ARGUMENTS :
*
*   C   ARRAY BEING FOURIER  TRANSFORMED
*   FAC PHASE FACTORS, PREPARED BY MFFTP; NOT MODIFIED IN OUTPUT
*
      implicit double precision (a-h,o-z)
      COMMON /MFFTPA/  IMS,IVS,IES,NM,NV,NE,MX,LX,MLIM,MSTEP,LLIM,LSTEP,
     $ NUSTEP,IVLIM,ILIM,MD2LIM,LD2LIM
      complex*16 C(0:NUSTEP-1,0:2),FAC(0:*)
      complex*16 T0,T1,T2,F1,F2
      double precision SIN60
      PARAMETER ( SIN60 =  8.6602540378443864d-1)
*..  LAM>0
          LAMF=MX
          DO 100 LAM=LSTEP,LLIM,LSTEP
            F1=FAC(LAMF)
            F2=FAC(LAMF*2)
            DO 90 MU=LAM,LAM+MLIM,MSTEP
              DO 80 IV=MU,MU+IVLIM,IVS
              DO 80 I=IV,IV+ILIM,IES
                T0=C(I,1)*F1+C(I,2)*F2
                T2=(C(I,1)*F1-C(I,2)*F2)*SIN60
                T1=C(I,0)-0.5d0*T0
                C(I,0)=C(I,0)+T0
                C(I,1)=(T1+dCMPLX(-dIMAG(T2),dREAL(T2)))
                C(I,2)=(T1-dCMPLX(-dIMAG(T2),dREAL(T2)))
80            CONTINUE
90          CONTINUE
            LAMF=LAMF+MX
100       CONTINUE
          DO 92 MU=0,MLIM,MSTEP
            DO 82 IV=MU,MU+IVLIM,IVS
            DO 82 I=IV,IV+ILIM,IES
                T0=C(I,1)+C(I,2)
                T2=(C(I,1)-C(I,2))*SIN60
                T1=C(I,0)-0.5d0*T0
                C(I,0)=C(I,0)+T0
                C(I,1)=(T1+dCMPLX(-dIMAG(T2),dREAL(T2)))
                C(I,2)=(T1-dCMPLX(-dIMAG(T2),dREAL(T2)))
82          CONTINUE
92        CONTINUE
      END
      SUBROUTINE MFFTB8(C,FAC)
*
*   PURPOSE:
*       ELEMENTARY GENTLEMAN-SANDE RADIX 3 STEP APPLIED TO A VECTOR-OF
*       2-VECTORS-OF-COMPLEX C[IMS,NM [IVS,NV [IES,NE]]].
*       SEE REF.[1] FOR NOTATIONS.
*       THIS ROUTINE CAN BE USED ONLY BY ROUTINE MFFTDM, WHICH CONTROLS
*       ITS OPERATION THROUGH THE MFFTPA COMMON
*
*   DUMMY ARGUMENTS :
*
*   C   ARRAY BEING FOURIER  TRANSFORMED
*   FAC PHASE FACTORS, PREPARED BY MFFTP; NOT MODIFIED IN OUTPUT
*
      implicit double precision (a-h,o-z)
      COMMON /MFFTPA/  IMS,IVS,IES,NM,NV,NE,MX,LX,MLIM,MSTEP,LLIM,LSTEP,
     $ NUSTEP,IVLIM,ILIM,MD2LIM,LD2LIM
      complex*16 C(0:NUSTEP-1,0:*),FAC(0:*)
      complex*16 T0,T1,T2,F1,F2
      double precision SIN60
      PARAMETER ( SIN60 =  8.6602540378443864d-1)


      IF(MX.NE.1)THEN
            DO 200 LAM=0,LLIM,LSTEP
              DO 190 IV=LAM,LAM+IVLIM,IVS
                IMUF=0
                DO 180 IMU=IV,IV+ILIM

                  T0=C(IMU,1)+C(IMU,2)
                  T2=(C(IMU,1)-C(IMU,2))*SIN60
                  T1=C(IMU,0)-0.5d0*T0
                  C(IMU,0)=C(IMU,0)+T0
                  C(IMU,1)=(T1-dCMPLX(-dIMAG(T2),dREAL(T2)))*FAC(IMUF)
                  C(IMU,2)=(T1+dCMPLX(-dIMAG(T2),dREAL(T2)))*FAC(IMUF+
     $                     NUSTEP)
                  IMUF=IMUF+1
  180           CONTINUE
  190         CONTINUE
200         CONTINUE
        ELSE
            DO 400 LAM=0,LLIM,LSTEP
              DO 390 IV=LAM,LAM+IVLIM,IVS
                DO 380 IMU=IV,IV+ILIM
                  T0=C(IMU,1)+C(IMU,2)
                  T2=(C(IMU,1)-C(IMU,2))*SIN60
                  T1=C(IMU,0)-0.5d0*T0
                  C(IMU,0)=C(IMU,0)+T0
                  C(IMU,1)=(T1-dCMPLX(-dIMAG(T2),dREAL(T2)))
                  C(IMU,2)=(T1+dCMPLX(-dIMAG(T2),dREAL(T2)))
380             CONTINUE
390           CONTINUE
400         CONTINUE
        ENDIF
      END
      SUBROUTINE MFFTB9(C,FAC)
*
*   PURPOSE:
*       ELEMENTARY COOLEY-TUKEY RADIX 3 STEP APPLIED TO A VECTOR-OF
*       2-VECTORS-OF-COMPLEX C[IMS,NM [IVS,NV [IES,NE]]].
*       SEE REF.[1] FOR NOTATIONS.
*       THIS ROUTINE CAN BE USED ONLY BY ROUTINE MFFTIM, WHICH CONTROLS
*       ITS OPERATION THROUGH THE MFFTPA COMMON
*
*   DUMMY ARGUMENTS :
*
*   C   ARRAY BEING FOURIER  TRANSFORMED
*   FAC PHASE FACTORS, PREPARED BY MFFTP; NOT MODIFIED IN OUTPUT
*
      implicit double precision (a-h,o-z)
      COMMON /MFFTPA/  IMS,IVS,IES,NM,NV,NE,MX,LX,MLIM,MSTEP,LLIM,LSTEP,
     $ NUSTEP,IVLIM,ILIM,MD2LIM,LD2LIM
      complex*16 C(0:NUSTEP-1,0:*),FAC(0:*)
      complex*16 T0,T1,T2,F1,F2
      double precision SIN60
      PARAMETER ( SIN60 =  8.6602540378443864d-1)

      IF(LX.NE.1)THEN
          DO 200 MU=0,MLIM,MSTEP
            DO 150 IV=MU,MU+IVLIM,IVS
              ILAMF=0
              DO 100 ILAM=IV,IV+ILIM
                T0=C(ILAM,1)*FAC(ILAMF)+C(ILAM,2)*FAC(ILAMF+NUSTEP)
                T2=(C(ILAM,1)*FAC(ILAMF)-C(ILAM,2)*FAC(ILAMF+NUSTEP))*
     $             SIN60
                T1=C(ILAM,0)-0.5d0*T0
                C(ILAM,0)=C(ILAM,0)+T0
                C(ILAM,1)=(T1+dCMPLX(-dIMAG(T2),dREAL(T2)))
                C(ILAM,2)=(T1-dCMPLX(-dIMAG(T2),dREAL(T2)))
                ILAMF=ILAMF+1
100           CONTINUE
150         CONTINUE
200       CONTINUE
      ELSE
          DO 400 MU=0,MLIM,MSTEP
            DO 350 IV=MU,MU+IVLIM,IVS
              DO 300 ILAM=IV,IV+ILIM
                T0=C(ILAM,1)+C(ILAM,2)
                T2=(C(ILAM,1)-C(ILAM,2))*SIN60
                T1=C(ILAM,0)-0.5d0*T0
                C(ILAM,0)=C(ILAM,0)+T0
                C(ILAM,1)=(T1+dCMPLX(-dIMAG(T2),dREAL(T2)))
                C(ILAM,2)=(T1-dCMPLX(-dIMAG(T2),dREAL(T2)))
300           CONTINUE
350         CONTINUE
400       CONTINUE
      ENDIF
      END
      SUBROUTINE MFFTC4(C,FAC)
*
*   PURPOSE:
*       ELEMENTARY GENTLEMAN-SANDE RADIX 5 STEP APPLIED TO A VECTOR-OF
*       VECTORS-OF-COMPLEX C[IVS,NVE[IES,NE]].
*       SEE REF.[1] FOR NOTATIONS.
*       THIS ROUTINE CAN BE USED ONLY BY ROUTINE MFFTDV, WHICH CONTROLS
*       ITS OPERATION THROUGH THE MFFTPA COMMON
*
*   DUMMY ARGUMENTS :
*
*   C   ARRAY BEING FOURIER  TRANSFORMED
*   FAC PHASE FACTORS, PREPARED BY MFFTP; NOT MODIFIED IN OUTPUT
*
      implicit double precision (a-h,o-z)
      COMMON /MFFTPA/  IMS,IVS,IES,NM,NV,NE,MX,LX,MLIM,MSTEP,LLIM,LSTEP,
     $ NUSTEP,IVLIM,ILIM,MD2LIM,LD2LIM
      complex*16 C(0:NUSTEP-1,0:4),FAC(0:*)
      complex*16 T1,T2,T3,T4,T5,F1,F2,F3,F4
      double precision SIN72,RAD5D4,S36D72
      PARAMETER (
     $ SIN72 =  9.51056516295153572116439333d-1,
     $ RAD5D4 =  5.59016994374947424102293417d-1,
     $ S36D72 =  6.18033988749894848204586834d-1 )
*..  MU > 1
            MUF=LX
            DO 200 MU=MSTEP,MLIM,MSTEP
              F1=dCONJG(FAC(MUF))
              F2=dCONJG(FAC(2*MUF))
              F3=dCONJG(FAC(3*MUF))
              F4=dCONJG(FAC(4*MUF))
              DO 190 LAM=MU,MU+LLIM,LSTEP
                DO 180 I=LAM,LAM+ILIM,IES
                  T1=C(I,1)+C(I,4)
                  T2=C(I,2)+C(I,3)
                  T3=(C(I,1)-C(I,4))*SIN72
                  T4=(C(I,2)-C(I,3))*SIN72
                  T5=T1+T2
                  T1=RAD5D4*(T1-T2)
                  T2=C(I,0)-0.25d0*T5
                  C(I,0)=C(I,0)+T5
                  T5=T2+T1
                  T2=T2-T1
                  T1=T3+S36D72*T4
                  T3=S36D72*T3-T4
                  C(I,1)=(T5-dCMPLX(-dIMAG(T1),dREAL(T1)))*F1
                  C(I,4)=(T5+dCMPLX(-dIMAG(T1),dREAL(T1)))*F4
                  C(I,2)=(T2-dCMPLX(-dIMAG(T3),dREAL(T3)))*F2
                  C(I,3)=(T2+dCMPLX(-dIMAG(T3),dREAL(T3)))*F3
  180           CONTINUE
  190         CONTINUE
              MUF=MUF+LX
200         CONTINUE
*..  MU=0
1000        DO 193 LAM=0,LLIM,LSTEP
              DO 183 I=LAM,LAM+ILIM,IES
                T1=C(I,1)+C(I,4)
                T2=C(I,2)+C(I,3)
                T3=(C(I,1)-C(I,4))*SIN72
                T4=(C(I,2)-C(I,3))*SIN72
                T5=T1+T2
                T1=RAD5D4*(T1-T2)
                T2=C(I,0)-0.25d0*T5
                C(I,0)=C(I,0)+T5
                T5=T2+T1
                T2=T2-T1
                T1=T3+S36D72*T4
                T3=S36D72*T3-T4
                C(I,1)=T5-dCMPLX(-dIMAG(T1),dREAL(T1))
                C(I,4)=T5+dCMPLX(-dIMAG(T1),dREAL(T1))
                C(I,2)=T2-dCMPLX(-dIMAG(T3),dREAL(T3))
                C(I,3)=T2+dCMPLX(-dIMAG(T3),dREAL(T3))
183           CONTINUE
193         CONTINUE
      END
      SUBROUTINE MFFTC5(C,FAC)
*
*   PURPOSE:
*       ELEMENTARY COOLEY-TUKEY RADIX 5 STEP APPLIED TO A VECTOR-OF
*       VECTORS-OF-COMPLEX C[IVS,NV [IES,NE]].
*       SEE REF.[1] FOR NOTATIONS.
*       THIS ROUTINE CAN BE USED ONLY BY ROUTINE MFFTIV, WHICH CONTROLS
*       ITS OPERATION THROUGH THE MFFTPA COMMON
*
*   DUMMY ARGUMENTS :
*
*   C   ARRAY BEING FOURIER  TRANSFORMED
*   FAC PHASE FACTORS, PREPARED BY MFFTP; NOT MODIFIED IN OUTPUT
*
      implicit double precision (a-h,o-z)
      COMMON /MFFTPA/  IMS,IVS,IES,NM,NV,NE,MX,LX,MLIM,MSTEP,LLIM,LSTEP,
     $ NUSTEP,IVLIM,ILIM,MD2LIM,LD2LIM
      complex*16 C(0:NUSTEP-1,0:4),FAC(0:*)
      complex*16 T1,T2,T3,T4,T5,F1,F2,F3,F4
      double precision SINT2,RAD5D4,S36D72
      PARAMETER (
     $ SIN72 =  9.51056516295153572116439333d-1,
     $ RAD5D4 =  5.59016994374947424102293417d-1,
     $ S36D72 =  6.18033988749894848204586834d-1 )
*..  LAM > 0
          LAMF=MX
          DO 100 LAM=LSTEP,LLIM,LSTEP
            F1=FAC(LAMF)
            F2=FAC(2*LAMF)
            F3=FAC(3*LAMF)
            F4=FAC(4*LAMF)
            DO 90 MU=LAM,LAM+MLIM,MSTEP
              DO 80 I=MU,MU+ILIM,IES
                T1=C(I,1)*F1+C(I,4)*F4
                T2=C(I,2)*F2+C(I,3)*F3
                T3=(C(I,1)*F1-C(I,4)*F4)*SIN72
                T4=(C(I,2)*F2-C(I,3)*F3)*SIN72
                T5=T1+T2
                T1=RAD5D4*(T1-T2)
                T2=C(I,0)-0.25d0*T5
                C(I,0)=C(I,0)+T5
                T5=T2+T1
                T2=T2-T1
                T1=T3+S36D72*T4
                T3=S36D72*T3-T4
                C(I,1)=T5+dCMPLX(-dIMAG(T1),dREAL(T1))
                C(I,4)=T5-dCMPLX(-dIMAG(T1),dREAL(T1))
                C(I,2)=T2+dCMPLX(-dIMAG(T3),dREAL(T3))
                C(I,3)=T2-dCMPLX(-dIMAG(T3),dREAL(T3))
80            CONTINUE
90          CONTINUE
            LAMF=LAMF+MX
100       CONTINUE

*.. LAM=0
          DO 92 MU=0,MLIM,MSTEP
            DO 82 I=MU,MU+ILIM,IES
              T1=C(I,1)+C(I,4)
              T2=C(I,2)+C(I,3)
              T3=(C(I,1)-C(I,4))*SIN72
              T4=(C(I,2)-C(I,3))*SIN72
              T5=T1+T2
              T1=RAD5D4*(T1-T2)
              T2=C(I,0)-0.25d0*T5
              C(I,0)=C(I,0)+T5
              T5=T2+T1
              T2=T2-T1
              T1=T3+S36D72*T4
              T3=S36D72*T3-T4
              C(I,1)=T5+dCMPLX(-dIMAG(T1),dREAL(T1))
              C(I,4)=T5-dCMPLX(-dIMAG(T1),dREAL(T1))
              C(I,2)=T2+dCMPLX(-dIMAG(T3),dREAL(T3))
              C(I,3)=T2-dCMPLX(-dIMAG(T3),dREAL(T3))
82          CONTINUE
92        CONTINUE
      END
C     ###################    FFT5 ENDS HERE    ##################
C --- Start of fft6 ---
      SUBROUTINE MFFTC6(C,FAC)
*
*   PURPOSE:
*       ELEMENTARY GENTLEMAN-SANDE RADIX 5 STEP APPLIED TO A VECTOR-OF
*       2-VECTORS-OF-COMPLEX C[IMS,NM [IVS,NV [IES,NE]]].
*       SEE REF.[1] FOR NOTATIONS.
*       THIS ROUTINE CAN BE USED ONLY BY ROUTINE MFFTDM, WHICH CONTROLS
*       ITS OPERATION THROUGH THE MFFTPA COMMON
*
*   DUMMY ARGUMENTS :
*
*   C   ARRAY BEING FOURIER  TRANSFORMED
*   FAC PHASE FACTORS, PREPARED BY MFFTP; NOT MODIFIED IN OUTPUT
*
      implicit double precision (a-h,o-z)
      COMMON /MFFTPA/  IMS,IVS,IES,NM,NV,NE,MX,LX,MLIM,MSTEP,LLIM,LSTEP,
     $ NUSTEP,IVLIM,ILIM,MD2LIM,LD2LIM
      complex*16 C(0:NUSTEP-1,0:4),FAC(0:*)
      complex*16 T1,T2,T3,T4,T5,F1,F2,F3,F4
      double precision SIN72,RAD5D4,S36D72
      PARAMETER (
     $ SIN72 =  9.51056516295153572116439333d-1,
     $ RAD5D4 =  5.59016994374947424102293417d-1,
     $ S36D72 =  6.18033988749894848204586834d-1 )
*..  MU > 0
            MUF=LX
            DO 200 MU=MSTEP,MLIM,MSTEP
              F1=dCONJG(FAC(MUF))
              F2=dCONJG(FAC(MUF*2))
              F3=dCONJG(FAC(MUF*3))
              F4=dCONJG(FAC(MUF*4))
              DO 190 LAM=MU,MU+LLIM,LSTEP
                DO 180 IV=LAM,LAM+IVLIM,IVS
                DO 180 I=IV,IV+ILIM,IES
                  T1=C(I,1)+C(I,4)
                  T2=C(I,2)+C(I,3)
                  T3=(C(I,1)-C(I,4))*SIN72
                  T4=(C(I,2)-C(I,3))*SIN72
                  T5=T1+T2
                  T1=RAD5D4*(T1-T2)
                  T2=C(I,0)-0.25d0*T5
                  C(I,0)=C(I,0)+T5
                  T5=T2+T1
                  T2=T2-T1
                  T1=T3+S36D72*T4
                  T3=S36D72*T3-T4
                  C(I,1)=(T5-dCMPLX(-dIMAG(T1),dREAL(T1)))*F1
                  C(I,4)=(T5+dCMPLX(-dIMAG(T1),dREAL(T1)))*F4
                  C(I,2)=(T2-dCMPLX(-dIMAG(T3),dREAL(T3)))*F2
                  C(I,3)=(T2+dCMPLX(-dIMAG(T3),dREAL(T3)))*F3
  180           CONTINUE
  190         CONTINUE
              MUF=MUF+LX
200         CONTINUE
            DO 193 LAM=0,LLIM,LSTEP
              DO 183 IV=LAM,LAM+IVLIM,IVS
              DO 183 I=IV,IV+ILIM,IES
                T1=C(I,1)+C(I,4)
                T2=C(I,2)+C(I,3)
                T3=(C(I,1)-C(I,4))*SIN72
                T4=(C(I,2)-C(I,3))*SIN72
                T5=T1+T2
                T1=RAD5D4*(T1-T2)
                T2=C(I,0)-0.25d0*T5
                C(I,0)=C(I,0)+T5
                T5=T2+T1
                T2=T2-T1
                T1=T3+S36D72*T4
                T3=S36D72*T3-T4
                C(I,1)=T5-dCMPLX(-dIMAG(T1),dREAL(T1))
                C(I,4)=T5+dCMPLX(-dIMAG(T1),dREAL(T1))
                C(I,2)=T2-dCMPLX(-dIMAG(T3),dREAL(T3))
                C(I,3)=T2+dCMPLX(-dIMAG(T3),dREAL(T3))
183           CONTINUE
193         CONTINUE
      END
      SUBROUTINE MFFTC7(C,FAC)
*
*   PURPOSE:
*       ELEMENTARY COOLEY-TUKEY RADIX 5 STEP APPLIED TO A VECTOR-OF
*       2-VECTORS-OF-COMPLEX C[IMS,NM [IVS,NV [IES,NE]]].
*       SEE REF.[1] FOR NOTATIONS.
*       THIS ROUTINE CAN BE USED ONLY BY ROUTINE MFFTIM, WHICH CONTROLS
*       ITS OPERATION THROUGH THE MFFTPA COMMON
*
*   DUMMY ARGUMENTS :
*
*   C   ARRAY BEING FOURIER  TRANSFORMED
*   FAC PHASE FACTORS, PREPARED BY MFFTP; NOT MODIFIED IN OUTPUT
*
      implicit double precision (a-h,o-z)
      COMMON /MFFTPA/  IMS,IVS,IES,NM,NV,NE,MX,LX,MLIM,MSTEP,LLIM,LSTEP,
     $ NUSTEP,IVLIM,ILIM,MD2LIM,LD2LIM
      complex*16 C(0:NUSTEP-1,0:4),FAC(0:*)
      complex*16 T1,T2,T3,T4,T5,F1,F2,F3,F4
      double precision SIN72,RAD5D4,S36D72
      PARAMETER (
     $ SIN72 =  9.51056516295153572116439333d-1,
     $ RAD5D4 =  5.59016994374947424102293417d-1,
     $ S36D72 =  6.18033988749894848204586834d-1 )
*..  LAM>0
          LAMF=MX
          DO 100 LAM=LSTEP,LLIM,LSTEP
            F1=FAC(LAMF)
            F2=FAC(LAMF*2)
            F3=FAC(LAMF*3)
            F4=FAC(LAMF*4)
            DO 90 MU=LAM,LAM+MLIM,MSTEP
              DO 80 IV=MU,MU+IVLIM,IVS
              DO 80 I=IV,IV+ILIM,IES
                T1=C(I,1)*F1+C(I,4)*F4
                T2=C(I,2)*F2+C(I,3)*F3
                T3=(C(I,1)*F1-C(I,4)*F4)*SIN72
                T4=(C(I,2)*F2-C(I,3)*F3)*SIN72
                T5=T1+T2
                T1=RAD5D4*(T1-T2)
                T2=C(I,0)-0.25d0*T5
                C(I,0)=C(I,0)+T5
                T5=T2+T1
                T2=T2-T1
                T1=T3+S36D72*T4
                T3=S36D72*T3-T4
                C(I,1)=T5+dCMPLX(-dIMAG(T1),dREAL(T1))
                C(I,4)=T5-dCMPLX(-dIMAG(T1),dREAL(T1))
                C(I,2)=T2+dCMPLX(-dIMAG(T3),dREAL(T3))
                C(I,3)=T2-dCMPLX(-dIMAG(T3),dREAL(T3))
80            CONTINUE
90          CONTINUE
            LAMF=LAMF+MX
100       CONTINUE
          DO 92 MU=0,MLIM,MSTEP
            DO 82 IV=MU,MU+IVLIM,IVS
            DO 82 I=IV,IV+ILIM,IES
              T1=C(I,1)+C(I,4)
              T2=C(I,2)+C(I,3)
              T3=(C(I,1)-C(I,4))*SIN72
              T4=(C(I,2)-C(I,3))*SIN72
              T5=T1+T2
              T1=RAD5D4*(T1-T2)
              T2=C(I,0)-0.25d0*T5
              C(I,0)=C(I,0)+T5
              T5=T2+T1
              T2=T2-T1
              T1=T3+S36D72*T4
              T3=S36D72*T3-T4
              C(I,1)=T5+dCMPLX(-dIMAG(T1),dREAL(T1))
              C(I,4)=T5-dCMPLX(-dIMAG(T1),dREAL(T1))
              C(I,2)=T2+dCMPLX(-dIMAG(T3),dREAL(T3))
              C(I,3)=T2-dCMPLX(-dIMAG(T3),dREAL(T3))
82          CONTINUE
92        CONTINUE
      END
      SUBROUTINE MFFTC8(C,FAC)
*
*   PURPOSE:
*       ELEMENTARY GENTLEMAN-SANDE RADIX 5 STEP APPLIED TO A VECTOR-OF
*       2-VECTORS-OF-COMPLEX C[IMS,NM [IVS,NV [IES,NE]]].
*       SEE REF.[1] FOR NOTATIONS.
*       THIS ROUTINE CAN BE USED ONLY BY ROUTINE MFFTDS, WHICH CONTROLS
*       ITS OPERATION THROUGH THE MFFTPA COMMON
*
*   DUMMY ARGUMENTS :
*
*   C   ARRAY BEING FOURIER  TRANSFORMED
*   FAC PHASE FACTORS, PREPARED BY MFFTP; NOT MODIFIED IN OUTPUT
*
      implicit double precision (a-h,o-z)
      COMMON /MFFTPA/  IMS,IVS,IES,NM,NV,NE,MX,LX,MLIM,MSTEP,LLIM,LSTEP,
     $ NUSTEP,IVLIM,ILIM,MD2LIM,LD2LIM
      complex*16 C(0:NUSTEP-1,0:4),FAC(0:*)
      complex*16 T1,T2,T3,T4,T5
      double precision SIN72,RAD5D4,S32D72
      PARAMETER (
     $ SIN72 =  9.51056516295153572116439333d-1,
     $ RAD5D4 =  5.59016994374947424102293417d-1,
     $ S36D72 =  6.18033988749894848204586834d-1 )
      IF(MX.NE.1)THEN
            DO 200 LAM=0,LLIM,LSTEP
              DO 190 IV=LAM,LAM+IVLIM,IVS
                IMUF=0
                IMUF2=NUSTEP
                IMUF3=2*NUSTEP
                IMUF4=3*NUSTEP
                DO 180 IMU=IV,IV+ILIM
                  T1=C(IMU,1)+C(IMU,4)
                  T2=C(IMU,2)+C(IMU,3)
                  T3=(C(IMU,1)-C(IMU,4))*SIN72
                  T4=(C(IMU,2)-C(IMU,3))*SIN72
                  T5=T1+T2
                  T1=RAD5D4*(T1-T2)
                  T2=C(IMU,0)-0.25d0*T5
                  C(IMU,0)=C(IMU,0)+T5
                  T5=T2+T1
                  T2=T2-T1
                  T1=T3+S36D72*T4
                  T3=S36D72*T3-T4
                  C(IMU,1)=(T5-dCMPLX(-dIMAG(T1),dREAL(T1)))*FAC(IMUF )
                  C(IMU,4)=(T5+dCMPLX(-dIMAG(T1),dREAL(T1)))*FAC(IMUF4)
                  C(IMU,2)=(T2-dCMPLX(-dIMAG(T3),dREAL(T3)))*FAC(IMUF2)
                  C(IMU,3)=(T2+dCMPLX(-dIMAG(T3),dREAL(T3)))*FAC(IMUF3)
                  IMUF=IMUF+1
                  IMUF2=IMUF2+1
                  IMUF3=IMUF3+1
                  IMUF4=IMUF4+1
  180           CONTINUE
  190         CONTINUE
200         CONTINUE
        ELSE
            DO 400 LAM=0,LLIM,LSTEP
              DO 390 IV=LAM,LAM+IVLIM,IVS
                DO 380 IMU=IV,IV+ILIM
                  T1=C(IMU,1)+C(IMU,4)
                  T2=C(IMU,2)+C(IMU,3)
                  T3=(C(IMU,1)-C(IMU,4))*SIN72
                  T4=(C(IMU,2)-C(IMU,3))*SIN72
                  T5=T1+T2
                  T1=RAD5D4*(T1-T2)
                  T2=C(IMU,0)-0.25d0*T5
                  C(IMU,0)=C(IMU,0)+T5
                  T5=T2+T1
                  T2=T2-T1
                  T1=T3+S36D72*T4
                  T3=S36D72*T3-T4
                  C(IMU,1)=T5-dCMPLX(-dIMAG(T1),dREAL(T1))
                  C(IMU,4)=T5+dCMPLX(-dIMAG(T1),dREAL(T1))
                  C(IMU,2)=T2-dCMPLX(-dIMAG(T3),dREAL(T3))
                  C(IMU,3)=T2+dCMPLX(-dIMAG(T3),dREAL(T3))
380             CONTINUE
390           CONTINUE
400         CONTINUE
        ENDIF
      END
      SUBROUTINE MFFTC9(C,FAC)
*
*   PURPOSE:
*       ELEMENTARY COOLEY-TUKEY RADIX 5 STEP APPLIED TO A VECTOR-OF
*       2-VECTORS-OF-COMPLEX C[IMS,NM [IVS,NV [IES,NE]]].
*       SEE REF.[1] FOR NOTATIONS.
*       THIS ROUTINE CAN BE USED ONLY BY ROUTINE MFFTIS, WHICH CONTROLS
*       ITS OPERATION THROUGH THE MFFTPA COMMON
*
*   DUMMY ARGUMENTS :
*
*   C   ARRAY BEING FOURIER  TRANSFORMED
*   FAC PHASE FACTORS, PREPARED BY MFFTP; NOT MODIFIED IN OUTPUT
*
      implicit double precision (a-h,o-z)
      COMMON /MFFTPA/  IMS,IVS,IES,NM,NV,NE,MX,LX,MLIM,MSTEP,LLIM,LSTEP,
     $ NUSTEP,IVLIM,ILIM,MD2LIM,LD2LIM
      complex*16 C(0:NUSTEP-1,0:4),FAC(0:*)
      complex*16 T1,T2,T3,T4,T5
      double precision SIN72,RAD5D4,S36D72
      PARAMETER (
     $ SIN72 =  9.51056516295153572116439333d-1,
     $ RAD5D4 =  5.59016994374947424102293417d-1,
     $ S36D72 =  6.18033988749894848204586834d-1 )

      IF(LX.NE.1)THEN
          DO 200 MU=0,MLIM,MSTEP
            DO 150 IV=MU,MU+IVLIM,IVS
              ILAMF=0
              ILAMF2=NUSTEP
              ILAMF3=2*NUSTEP
              ILAMF4=3*NUSTEP
              DO 100 ILAM=IV,IV+ILIM
                T1=C(ILAM,1)*FAC(ILAMF)+C(ILAM,4)*FAC(ILAMF4)
                T2=C(ILAM,2)*FAC(ILAMF2)+C(ILAM,3)*FAC(ILAMF3)
                T3=(C(ILAM,1)*FAC(ILAMF)-C(ILAM,4)*FAC(ILAMF4))*SIN72
                T4=(C(ILAM,2)*FAC(ILAMF2)-C(ILAM,3)*FAC(ILAMF3))*SIN72
                T5=T1+T2
                T1=RAD5D4*(T1-T2)
                T2=C(ILAM,0)-0.25d0*T5
                C(ILAM,0)=C(ILAM,0)+T5
                T5=T2+T1
                T2=T2-T1
                T1=T3+S36D72*T4
                T3=S36D72*T3-T4
                C(ILAM,1)=T5+dCMPLX(-dIMAG(T1),dREAL(T1))
                C(ILAM,4)=T5-dCMPLX(-dIMAG(T1),dREAL(T1))
                C(ILAM,2)=T2+dCMPLX(-dIMAG(T3),dREAL(T3))
                C(ILAM,3)=T2-dCMPLX(-dIMAG(T3),dREAL(T3))
                ILAMF=ILAMF+1
                ILAMF2=ILAMF2+1
                ILAMF3=ILAMF3+1
                ILAMF4=ILAMF4+1
100           CONTINUE
150         CONTINUE
200       CONTINUE
      ELSE
          DO 400 MU=0,MLIM,MSTEP
            DO 350 IV=MU,MU+IVLIM,IVS
              DO 300 ILAM=IV,IV+ILIM
                T1=C(ILAM,1)+C(ILAM,4)
                T2=C(ILAM,2)+C(ILAM,3)
                T3=(C(ILAM,1)-C(ILAM,4))*SIN72
                T4=(C(ILAM,2)-C(ILAM,3))*SIN72
                T5=T1+T2
                T1=RAD5D4*(T1-T2)
                T2=C(ILAM,0)-0.25d0*T5
                C(ILAM,0)=C(ILAM,0)+T5
                T5=T2+T1
                T2=T2-T1
                T1=T3+S36D72*T4
                T3=S36D72*T3-T4
                C(ILAM,1)=T5+dCMPLX(-dIMAG(T1),dREAL(T1))
                C(ILAM,4)=T5-dCMPLX(-dIMAG(T1),dREAL(T1))
                C(ILAM,2)=T2+dCMPLX(-dIMAG(T3),dREAL(T3))
                C(ILAM,3)=T2-dCMPLX(-dIMAG(T3),dREAL(T3))
300           CONTINUE
350         CONTINUE
400       CONTINUE
      ENDIF
      END
      SUBROUTINE MFFTP1(W,NM,IERR)
*
*   PURPOSE :
*     FACTORIZATION OF NM STORING THE POWERS OF EACH FACTOR IN W
*     ( NM = 2**W(1)*3**W(2)*... )
*     THE MAXIMUM FACTOR FOUND  IS STORED IN W(14)
*
      implicit double precision (a-h,o-z)
      PARAMETER (MAXFAC=3)
      INTEGER W(14),FACTOR(MAXFAC)
      INTEGER IDERR,FACERR,TBERR
      PARAMETER (IDERR=1,FACERR=2,TBERR=3)
      DATA (FACTOR(I),I=1,MAXFAC)/2,3,5/
      N=NM
      DO 100 I=1,MAXFAC
      W(I)=0
 10   IF(MOD(N,FACTOR(I)).EQ.0)THEN
      W(I)=W(I)+1
      N=N/FACTOR(I)
      GOTO 10
      ENDIF
      IF(N.EQ.1)GOTO 200
100   CONTINUE
      IERR=FACERR
      RETURN
200   W(14)=I
      END
      SUBROUTINE MFFTP2(INDX,INDXI,I2,IW,NM)
*
*     THIS ROUTINE COMPUTES TWO INDEX TABLES FOR THE
*     PERMUTATION DUE TO REPRESENTATION INVERSION ("BIT REVERSAL")
*     THE INDEX TABLES ARE STORED ONE AFTER THE OTHER, AND ARE
*     RECIPROCAL.
*
*     WARNING: BY "BIT REVERSAL" WE MEAN THE SHUFFLING OF INDEXES
*              AS REQUIRED BY IN-PLACE FFT ALGORITHMS, REGARDLESS
*              OF WHAT IS THEIR RADIX (I.E. 2,3,5).
*              THE SHUFFLING IS EFFECTIVELY AN 'INTEGER BIT REVERSAL'
*              ONLY IN CASE OF RADIX-2 ALGORITHMS.
*
      implicit double precision (a-h,o-z)
      INTEGER INDX(0:*),INDXI(0:*),I2(0:*),IW(14)
      PARAMETER (MAXFAC=3)
      INTEGER FACTOR(MAXFAC)
      DATA (FACTOR(I),I=1,MAXFAC)/2,3,5/
      DO 1 I=0,NM-1
        INDX(I)=I
1     CONTINUE
      IFAC=IW(14)
      LX=1
      MX=NM
      DO 30 IFAC=1,IFAC
        DO 10 I=1,IW(IFAC)-1,2
          MX=MX/FACTOR(IFAC)
          CALL MFFTP3(INDX,I2,MX,FACTOR(IFAC),LX)
          LX=LX*FACTOR(IFAC)
          MX=MX/FACTOR(IFAC)
          CALL MFFTP3(I2,INDX,MX,FACTOR(IFAC),LX)
          LX=LX*FACTOR(IFAC)
10      CONTINUE

*...  IF W(IFAC)ODD,THEN
        IF (I.EQ.IW(IFAC))THEN
          MX=MX/FACTOR(IFAC)
          CALL MFFTP3(INDX,I2,MX,FACTOR(IFAC),LX)
          LX=LX*FACTOR(IFAC)
          DO 20 I=0,NM-1
            INDX(I)=I2(I)
20        CONTINUE
        ENDIF
30    CONTINUE
*...     INVERSE PERMUTATION
         DO 40 I=0,NM-1
           I2(I)=INDX(I)
           INDXI(I)=I
40       CONTINUE
         DO 59 I=1,NM-3
51         IF(I2(I).NE.I)THEN
             IDEST=I2(I)
             IT=INDXI(I)
             INDXI(I)=INDXI(IDEST)
             INDXI(IDEST)=IT
             I2(I)=I2(IDEST)
             I2(IDEST)=IDEST
           GOTO 51
           ENDIF
59       CONTINUE

      END
      SUBROUTINE MFFTP3(INDX,I1,MX,NX,LX)
*
*     THIS SUBROUTINE PERFORMS A "BIT REVERSAL" PERMUTATION
*
      implicit double precision (a-h,o-z)
      INTEGER INDX(MX,NX,LX),I1(MX,LX,NX)
      DO 1 NU=1,NX
      DO 1 MU=1,MX
      DO 1 LAM=1,LX
        I1(MU,LAM,NU)=INDX(MU,NU,LAM)
1     CONTINUE
      END
      SUBROUTINE MFFTP4(EXPTAB,SPETAB,FACTAB,N,N1)
*
*     THIS SUBROUTINE BUILDS THE TWIDDLE FACTOR TABLES FOR USE
*     OF MFFT?S ROUTINES (SPECIAL OPTIMIZATION FOR SMALL
*     DATA MATRICES); IT MUST BE USED BY MFFTP ONLY.
*
*     PARAMETERS:
*     EXPTAB: TWIDDLE FACTOR TABLE
*     SPETAB: SPECIAL TWIDDLE FACTOR TABLE
*     FACTAB: FACTORIZATION OF N
*     N: ORDER OF THE TRANSFORM
*     N1: FIRST DIMENSION OF THE ARRAY TO BE TRANSFORMED (.GE.N)
*
      implicit double precision (a-h,o-z)
      INTEGER MAXFAC
      PARAMETER(MAXFAC=3)
      INTEGER FACTAB(14)
      complex*16 EXPTAB(0:*),SPETAB(0:*)
      INTEGER FACTOR(MAXFAC)
      DATA FACTOR/2,3,5/

      MX=N
      LX=1
      J=0
      DO 50 IFACT=FACTAB(14),1,-1
         NX=FACTOR(IFACT)
         DO 40 IPOW=1,FACTAB(IFACT)
          MX=MX/NX
          DO 30 NU=1,NX-1
            DO 20 MU=0,MX-1
              DO 10 I1=0,N1-1
                SPETAB(J)=dCONJG(EXPTAB(MU*LX*NU))
                J=J+1
10            CONTINUE
20          CONTINUE
30        CONTINUE
          LX=LX*NX
40      CONTINUE
50    CONTINUE
      MX=N
      LX=1
      J=N*N1
      DO 100 IFACT=1,FACTAB(14)
        NX=FACTOR(IFACT)
        DO 90 IPOW=1,FACTAB(IFACT)
          MX=MX/NX
          DO 80 NU=1,NX-1
            DO 70 LAMBDA=0,LX-1
              DO 60 I1=0,N1-1
                SPETAB(J)=EXPTAB(MX*LAMBDA*NU)
                J=J+1
60            CONTINUE
70          CONTINUE
80        CONTINUE
          LX=LX*NX
90      CONTINUE
100   CONTINUE
      END
         SUBROUTINE MFFTZ0(W1,ISE1,NE,W2,ISE2)
**** PURPOSE : VECTOR COPY ROUTINE
*    PARAMETERS :
*        W1 : VECTOR TO BE COPIED
*        ISE1: STRIDE OF W1
*        NE : NUMBER OF ELEMENTS
*        W2 : DESTINATION VECTOR
*        ISE2: STRIDE OF W2
      implicit double precision (a-h,o-z)
         complex*16 W1(0:*),W2(0:*)
         J=0
         DO 1 I=0,(NE-1)*ISE1,ISE1
         W2(J)=W1(I)
         J=J+ISE2
1     CONTINUE
         END
