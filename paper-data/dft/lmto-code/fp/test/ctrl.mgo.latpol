# Setup for an external potential of ncell MgO units.  ncell>1 => step potential ncell<-1 Fourier component
% const ncell=1
% ifdef abs(ncell)>1
% cconst abs(ncell)==5  nabc=6 ngz=88 gmax=10.5 v=.02  # gmax is chosen to make ngz an even number
% cconst abs(ncell)==6  nabc=6 ngz=112 gmax=10.5 v=.02  # gmax is chosen to make ngz an even number
% cconst abs(ncell)==8  nabc=6 ngz=150 gmax=10.5 v=.02  # gmax is chosen to make ngz an even number
% cconst abs(ncell)==10 nabc=6 ngz=88*2 gmax=10.5 v=.02  # gmax is chosen to make ngz an even number
% cconst abs(ncell)==15 nabc=6 ngz=280 gmax=10.9 v=.02  # gmax is chosen to make ngz an even number
% cconst abs(ncell)==18 nabc=6 ngz=280 gmax=10.8 v=.02  # gmax is chosen to make ngz an even number
% cconst abs(ncell)==20 nabc=6 ngz=384 gmax=10.9 v=.02  # gmax is chosen to make ngz an even number
% endif
% ifdef ncell>1
% cconst ncell==5 nabc=-40 ngz=88 gmax=10.5 v=.02  # gmax is chosen to make ngz an even number
# This one for a step potential
# % char0 vext "--vext~stepx={ngz/2}~ro={ncell}/4,{ncell}/4,{ncell}/4~l1=1,0,0~l2=0,1,0"
# This one is equivalent
% char0 vext "--vext~stepx={ngz/2}~o=0,0,{ngz/4}~l1=1,0,0~l2=0,1,0"
# This one yields the same eps and total energy, but the average potential is shifted by v/2
# % char0 vext "--vext~step={ngz/2}~ro={ncell}/4,{ncell}/4,{ncell}/4~l1=1,0,0~l2=0,1,0"
# This one breaks symmetry
# % char0 vext "--vext~stepx={ngz/2}~o=0,0,{ngz}/2~l1=1,0,0~l2=0,1,0"
# This one for a single Fourier component
% else
% char0 vext "--vext~igv=0,0,1"
% endif
% cconst abs(ncell)>1 supcel=2

TESTVXT
  lmfa mgo
  rm -f rst.mgo log.mgo mixm.mgo save.mgo
  lmf --pr35,40 mgo
  rm -f mixm.mgo
  lmf --pr35,40 mgo --rs=1,0 -vnit=1 
  rm -f mixm.mgo
  lmf --pr35,40 mgo --rs=1,0 -vnit=1 --vext~igv=0,0,0~v=.1
  rm -f mixm.mgo
  lmf --pr35,40 mgo --rs=1,0 -vnit=15 --vext~eps~igv=1,0,0~v=.1
  echo save for future use
  cp rst.mgo rst.mgo~

TESTVXM
  lmfa mgo
  rm -f rst.mgo log.mgo mixm.mgo save.mgo
  mpix -n 6 lmf-MPIK --pr35,40 mgo
  rm -f mixm.mgo
  mpix -n 6 lmf-MPIK --pr35,40 mgo --rs=1,0 -vnit=1 
  rm -f mixm.mgo
  mpix -n 6 lmf-MPIK --pr35,40 mgo --rs=1,0 -vnit=1 --vext~igv=0,0,0~v=.1
  rm -f mixm.mgo
  mpix -n 6 lmf-MPIK --pr35,40 mgo --rs=1,0 -vnit=15 --vext~eps~igv=1,0,0~v=.1
  echo save for future use
  cp rst.mgo rst.mgo~

# This job must be run after TESTVXT
# To see commands that would execute, do one of (either step potential or Fourier component):
# rdcmd --n -vncell=5 -cat:TSTEPS --noerr ctrl.mgo | sed 's/>>//'
# rdcmd --n -vncell=-5 -cat:TSTEPS --noerr ctrl.mgo | sed 's/>>//'
TSTEPS
% ifdef abs(ncell)>1
  cp rst.mgo~ rst.mgo
  echo p 1 0 0  0 1 0   0 0 {abs(ncell)} | lmscell --pr35,40 mgo --rs=1,0 -vnit=1 --wsitex~map~fn=site2
  echo displace supercell
  lmplan mgo -vmet=0 -vvextxy=t -vncell={ncell} --pledit~q
  echo Make ascii restart file for supercell
  lmf mgo '--rsedit~rs~scell site2'
  cp rst2.mgo rst.mgo
  lmf mgo -vmet=0 -vgmax={gmax} -vvextxy=t -vnkabc={nabc} -vncell={ncell} --rs=1,2 -vnit=0
  echo "confirm that the supercell is self-consistent (RMS DQ should be small)"
  lmf mgo -vmet=0 -vgmax={gmax} -vvextxy=t -vnkabc={nabc} -vncell={ncell} --quit=rho 
  echo save reference potential to file smpot0
  lmf mgo -vmet=0 -vgmax={gmax} -vvextxy=t -vnkabc={nabc} -vncell={ncell} --rs=2 {vext}~eps~pot0~v=.02
  echo self-consistent calculation with external potential
  rm -f mixm.mgo log.mgo save.mgo
  lmf mgo -vmet=0 -vgmax={gmax} -vvextxy=t -vnkabc={nabc} -vncell={ncell} --rs=2 {vext}~eps=3~v=.02
  lmf mgo -vmet=0 -vgmax={gmax} -vvextxy=t -vnkabc={nabc} -vncell={ncell} --rs=1 {vext}~eps~v=.02 --quit=pot
% endif
TSTEPM
% ifdef abs(ncell)>1
  cp rst.mgo~ rst.mgo
  echo p 1 0 0  0 1 0   0 0 {abs(ncell)} | lmscell --pr35,40 mgo --rs=1,0 -vnit=1 --wsitex~map~fn=site2
  echo displace supercell
  lmplan mgo -vmet=0 -vvextxy=t -vncell={ncell} --pledit~q
  echo Make ascii restart file for supercell
  lmf mgo '--rsedit~rs~scell site2'
  cp rst2.mgo rst.mgo
  lmf mgo -vmet=0 -vgmax={gmax} -vvextxy=t -vnkabc={nabc} -vncell={ncell} --rs=1,2 -vnit=0
  echo "confirm that the supercell is self-consistent (RMS DQ should be small)"
  mpix -n 13 lmf-MPIK mgo -vmet=0 -vgmax={gmax} -vvextxy=t -vnkabc={nabc} -vncell={ncell} --quit=rho 
  echo save reference potential to file smpot0
  lmf mgo -vmet=0 -vgmax={gmax} -vvextxy=t -vnkabc={nabc} -vncell={ncell} --rs=2 {vext}~eps~pot0~v=.02
  echo self-consistent calculation with external potential
  rm -f mixm.mgo log.mgo save.mgo
  mpix -n 13 lmf-MPIK mgo -vmet=0 -vgmax={gmax} -vvextxy=t -vnkabc={nabc} -vncell={ncell} --rs=2 {vext}~eps=3~v=.02
  lmf mgo -vmet=0 -vgmax={gmax} -vvextxy=t -vnkabc={nabc} -vncell={ncell} --rs=1 {vext}~eps~v=.02 --quit=pot
% endif
CLEAN
  rm -f ctrl.mgo atm.mgo basp0.mgo basp.mgo moms.mgo site.mgo site2.mgo smpot0.mgo rst.mgo~
END

# Variables entering into expressions parsed by input
% const nit=50 bigr=1
% const met=5
% const so=0 nsp=so?2:1
% const lxcf=2 lxcf1=0 lxcf2=0     # for PBE use: lxcf=0 lxcf1=101 lxcf2=130
% const sig=12 gwemax=2 gcutb=4.4 gcutx=3.6  # GW-specific
% const nkabc=6 nkgw=6 gmax=11

%ifdef abs(ncell)>1
EWALD AS=2.3 TOL=1d-12
%endif

VERS  LM:7 FP:7 # ASA:7
IO    SHOW=f HELP=f IACTIV=f VERBOS=35,35  OUTPUT=*
EXPRESS
# Lattice vectors and site positions
%ifdef supcel
  file=   site{supcel}
%endif
  file=   site

# Basis set
  gmax=   {gmax}                   # PW cutoff for charge density
  autobas[pnu=1 loc=1 lmto=5 mto=4 gw=1 pfloat=2]

# Self-consistency
  nit=    {nit}                    # Maximum number of iterations
  mix=    B2,b=.3,k=7              # Charge density mixing parameters
# mix=    B4,b=0.1
# mix=    B0,locm=4,b=0.27,b2=0,elind=0
  conv=   3e-6                     # Convergence tolerance (energy)
  convc=  5e-8                     # tolerance in RMS (output-input) density

# Brillouin zone
%ifdef abs(ncell)==8 && nkabc>0
  nkabc=  {nkabc},{nkabc},{nkabc/2}
%elseifd abs(ncell)>1 && nkabc>0
  nkabc=  {nkabc},{nkabc},1
%endif
  nkabc=  {nkabc}                  # 1 to 3 values.  Use n1<0 => |n1| ~ total number
  metal=  {met}                    # Management of k-point integration weights in metals

# Potential
  xcfun=  {lxcf},{lxcf1},{lxcf2}   # set lxcf=0 for libxc functionals

%ifdef vextxy
%ifdef abs(ncell)==8
SYMGRP m(1,0,1) m(1,-1,0)
%endif
SYMGRP  i r2(1,-1,0)
%endif
%ifdef vextz
SYMGRP  r4z
%endif
#SYMGRP i*r3(1,1,-1) r4x

HAM 
      FORCES={so==0} ELIND=-0.7 
      RDSIG={sig} SIGP[EMAX={gwemax}]  # Add self-energy to LDA
#     FRZWF=t
GW    NKABC={nkgw} GCUTB={gcutb} GCUTX={gcutx} DELRE=.01 .5 
      GSMEAR=0.003 PBTOL=1e-3
SPEC 
% ifdef bigr
   ATOM=Mg         Z= 12  R= 2.364085  LMX=3  LMXA=4  EREF=-398.9159
   ATOM=O          Z=  8  R= 2.127676  LMX=3  LMXA=4  EREF=-149.1822
   ATOM=E          Z=  0  R= 1.536655  LMX=1  LMXA=4
% else
   ATOM=Mg         Z= 12  R= 2.088958  LMX=3  LMXA=4  EREF=-398.9159
   ATOM=O          Z=  8  R= 1.891042  LMX=3  LMXA=4  EREF=-149.1822
   ATOM=E          Z=  0  R= 1.357823  LMX=1  LMXA=4
% endif
