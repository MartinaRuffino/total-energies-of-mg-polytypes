      subroutine mixrho(s_site,s_spec,s_lat,s_pot,smrnew,smrho,nsp,iter,
     .  mixmod,qval,elind,k1,k2,k3,dmxp)
C- Mix old and new charge densities
C ----------------------------------------------------------------------
Cio Structures
Cio  s_site :struct for site-specific data; see structures.h
Ci     Elts read:  spec pos
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:*
Cio    Passed to:  rhgcmp rhogkl ftlxp pvmix5 pvmix3 pvmix7
Cio  s_spec :struct for species-specific data; see structures.h
Ci     Elts read:  a nr rmt lmxl rsmv kmxv rg lfoca rfoca qc z ctail
Ci                 etail stc lmxb p pz
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:*
Cio    Passed to:  rhgcmp corprm rhogkl ftlxp pvmix5 pvmix3 pvmix7
Cio  s_lat  :struct containing lattice information; see structures.h
Ci     Elts read:  nabc ng vol alat plat qlat
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:kv gv
Cio    Passed to:  rhgcmp
Cio  s_pot  :struct for information about the potential; see structures.h
Ci     Elts read:  rnew rhat
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:*
Cio    Passed to:  *
Ci Inputs
Ci   nsp   :2 for spin-polarized case, otherwise 1
Ci   iter  :iteration number
Ci   mixmod:string containing iteration-dependent mixing (parmxp)
Ci   qval  :total valence charge, used to estimate Lindhard parameter
Ci         :elind if it is not supplied
Ci   elind :default Lindhard screening parameter
Ci   k1,k2,k3 dimensions smrho
Cio Inputs/Outputs
Cio   dmxp  :Default and other values of mixing parameters.
Cio         :The input defaults may be overridden by the string mixmod.
Cio         :Inputs (defaults)
Cio         :(1)  broy  :mixing scheme: 0->Anderson 1->Broyden
Cio         :(2)  beta  :linear mixing beta: nmix = (1-beta)nin + beta*nout
Cio         :(3)  wc    :Broyden weights for prior iterations
Cio         :(4,5) weights for n^+ + n^- and n^+ - n^- in spin pol cases
Cio                Avg, diff weighted by wt(1) and wt(2) in the mixing.
Cio                As special cases,
Cio                wt(2)=0 freezes the moments and mixes the charge only
Cio                wt(1)=0 freezes the charge and mixes the moments only
Cio         :(6)  mxsav : maximum number of prior iter to save on disk
Cio         :(7)  mmix  : maximum number of prior iter to mix
Cio         :(8)  nkill : kill mixing file after multiples nkill
Cio         :(9)  betv  : not used here
Cio         :(10) rmscst: not used here
Cio         :Outputs
Cio         :(11) rmsdel : rms (output-input) density
Cio         :(12) rmsl   : rms (output-input) local density
Cio         :(13) nmix   : number of prior iter actually mixed
Cio         :(14) broy   : actual mixing scheme used
Cio         :(15) beta   : actual mixing beta used
Cio         :(16-24) tj  : Anderson mixing coefficients
Cio         :(25)        : (spin polarized case only)
Cio                      : 1  if weight for n^+ + n^- is nonzero
Cio                      : 10 if weight for n^+ - n^- is nonzero
Cio                      : 11 if both nonzero
Cio   orhnew:On input, local parts of the density that generated the ham.
Cio   orhold:local parts of the density that the hamiltonian generated
Cio         :On output, the mixed density
Cio   smrho :On input, smooth density that generated the hamiltonian H
Cio         :On output mixed smooth density
Cio   smrnew:smooth density generated by the H(rhold,smrho)
Cio         :DESTROYED on output
Cl Local variables
Cl   locmix :governs transformation of local densities for mixing.
Cl          :100s digit
Cl          : 0, mix rho1+rho2, rho1-rho2
Cl          : 1, mix rho1, rho2
Cl          :10s digit: Controls weighting of spherical density that is
Cl          :    to be mixed, as described in Remarks.  Weighting is
Cl          :    done in pvmix9; see 10s digit mode in that routine.
Cl          :1s digit: partitioning between main and residual densities.
Cl          :   For detailed discussion of the partitioning, see Remarks
Cl          :   Also see Bugs, below
Cl          :0  The smooth part of the density and the spherical part of
Cl          :   the local densities are mixed w/ Anderson or Broyden mixing.
Cl          :   The residual is the nonspherical density.
Cl          :   This was the only mode in versions 6.11 and earlier.
Cl          :1  Anderson mixes local total charges only; all else is residual
Cl          :2  The following is mixed with Anderson/Broyden:
Cl          :   * the smooth density
Cl          :   * A G_kL expansion of the local densities
Cl          :   The difference betw/ the G_kL expansion and the local rho is the residual
Cl              CAUTION: not tested in a long time
Cl          :3  The following is mixed with Anderson/Broyden:
Cl          :   * the smooth density
Cl          :   * the l=0 part of (weighted) rho(1,2) (wt from 10s digit)
Cl          :   * P_kL expansion (rho1-rho2) w/ l=0 part zeroed out
Cl          :   The difference betw/ the P_kL expansion and rho1-rho2 is the residual
Cl          :4  The sm density is mixed with Anderson/Broyden using beta
Cl              The entire local density is linearily mixed using bet2
Cl   rms2   : <(rout-rin)**2>, where rin and rout are the input and
Cl          : screened output densities represented as a vector,
Cl          : including smoothed and local parts.  rmsdel changes with
Cl          : the choice of transformation of local densities;see locmix
Cl          : above.
Cl   rmsdel : (linked to dmxp(11)).
Cl          : On input, rmsdel=<(rout-rin)**2>, defined as rms2, above.
Cl          : On output, rmsdel is overwritten by rms2.
Cl   rmsuns : RMS difference in output-input sm. density, unscreened
Cl   rms    : RMS difference in output-input sm. density, screened
Cl   sumo   : integral of smrho
Cl   sums   : integral of screened smoothed output rho
Cl   kmxs   : k-cutoff for G_kL expansion of screening charge projected
Cl          : into local densities; see Remarks
Cl   kmxr   : k-cutoff for G_kL expansion used to smooth local densities
Cl          : for mixing
Cl   ng0    : condensed number of G vectors. That rho(G) is hermitian
Cl          : is exploited to reduce ng to ng0
Cl   qcell  : cell charge
Cb Bugs
Cb   Mixing scheme needs some revision.  For now, uses locmix=33
Cb   Problem: G-kL expansion doesn't represent rim density well; not
Cb          : good for rho1+rho2.
Cb   Better:  1. Use simpler trans: (rho1+rho2)/100 or so, and (rho1-rho2)
Cb            2. For nonspherical parts, mix coefficient to multipole in
Cb               the Anderson/Broyden scheme; linearly mix the rest.
Cr Remarks
Cr   To estimate the self-consistent density a model (Lindhard) dielectric
Cr   function is used.  A smooth "total density" is assembled on a mesh
Cr   from the smooth density + local contributions; the latter are
Cr   smoothed into a G_kL expansion of rho1-rho2 and added to the mesh
Cr   density.  This "mesh total density" is assembled for the input and
Cr   output densities smrho and smrnew, and the screening charge
Cr   (eps^-1 - 1) (smrnew(tot) - smrho(tot)) is obtained using the
Cr   Lindhard approximation for eps^-1.  The screening charge is then:
Cr
Cr     (1)  added to smrnew
Cr
Cr     (2)  added back onto local densities as a G_kL expansion
Cr          to both the true and smooth local mixed densities.
Cr
Cr   Finally, the (screened) output density is mixed with the input density
Cr   using an Anderson or Broyden mixing scheme.  Both mesh part and local
Cr   parts are mixed, the latter consists of the true, smooth, and core parts.
Cr
Cr   Note in the spin polarized case, charge and spin densities,
Cr   (rho+ + rho- and rho+ - rho-) are mixed, not rho+ and rho-.
Cr
Cr   The local densities may not be represented in their standard form.
Cr     * They are partitioned into a 'main part' and a 'residual part'
Cr       The 'main' part is mixed with Anderson/Broyden; the 'residual'
Cr       is linearly mixed.  The intention is to reduce the degrees of
Cr       freedom in the main part.
Cr     * The 'main' part is generated in a two-step process:
Cr          - local densities are scaled by a weighting function
Cr              rho1,rho2 -> w(r)*(rho1+rho2), rho1-rho2
Cr            where w(r) is controlled by parameter 10s digit locmix.
Cr            Weighting is done in routine pvmix9, which see.
Cr          - The transformed rho1,rho2 may be fit to some analytic
Cr            form, e.g. a G_kL expansion.  The form depends
Cr            on parameter locmix; see above.
Cr     * Whatever the construction of the 'main' part,
Cr       the 'residual' is the difference between the actual density and
Cr       the main part.  The 'residual' is linearly mixed.
Cr
Cr   The steps in this routine follow the path below.
Cr   (where the steps occur, comments refer to these numbers).
Cr   1.   smooth rho+,rho-  ->  smrho, smmag
Cr   2.   FT smrnew(r)-smrho(r) -> cn = smrho(G)
Cr   3.   rho1-rho2 -> smoothed, FT; added to smrho(G)
Cr   4.   cn = screening (eps^-1 - 1) smrho(G)
Cr   5.   Add screening to smrnew; smrnew(G) -> smrnew(r)
Cr   6.   smrnew = sm. screened nout, smrho,smrnew -> smooth rho+,rho-
Cr        At this stage, smrho = input smooth rho+,rho-
Cr                       smrnew = screened output rho+,rho-
Cr   7.   Add screening to rho1, rho2; scale if locmix > 0
Cr   8.   smrho,smrnew(r) -> smrho,smrnew(G)
Cr   9.  *Pack 'total' in,out densities into large matrix a;
Cr        'total' is not exactly entire density: some residual of the
Cr        local density is kept out.  mixrho has different ways to
Cr        make the residual; they are fixed by locmix described above
Cr       *Read prior iterations into a
Cr       *Write new array a with current iteration onto disk
Cr   10.  Linear mixing of residual local densities
Cr   11.  Make modified a when wt(1) or wt(2) restricts q or spin
Cr   12.  Mix input, output densities with Anderson/Broyden scheme
Cr   13.  Inverse of step 11.
Cr   14.  Poke contents of a into smrho,orhold
Cr   15.  Undo scaling of local rho (inverse of step 7)
Cu Updates
Cu   09 Sep 16 New 1st digit locmix=4
Cu   19 Nov 14 Some bug fixes for locmix mode 1; new beta1p2
Cu   05 Jul 13 Replace f77 pointers with f90 ones
Cu   10 Apr 12 Repackaged radial mesh integration quadrature
Cu   10 Nov 11 Begin migration to f90 structures
Cu   30 Jan 10 New 100s digit locm; locm=1 implemented
Cu   06 Oct 09 modularized MPI, no special compilation required.
Cu   18 Dec 08 properly treats constrained cases w=1,0 and w=0,1
Cu   30 Jun 06 Bug fix (memory leak)
Cu   15 Feb 02 (ATP) Added MPI parallelization
Cu   21 Nov 01 Linear transformation of local densities for mixing.
Cu             New modes locmix.
Cu   23 Oct 01 Local densities used for screening charge are more
Cr             accurately represented in G_kL expansion, k=0..kmxs
Cu   19 Oct 01 correctly uses elind override from mixing string
Cu   22 Mar 01 Bug fix for case mixing string is empty
Cu   22 Jun 00 spin polarized
Cu   30 May 00 Adapted from nfp mix_rho
C ----------------------------------------------------------------------
      use structures
      implicit none
C ... Passed parameters
      integer nsp,k1,k2,k3,iter
      character*(*) mixmod
      double precision qval,elind,dmxp(25)
      double complex smrnew(k1,k2,k3,nsp),smrho(k1,k2,k3,nsp)
C ... For structures
!      include 'structures.h'
      type(str_site)::  s_site(*)
      type(str_spec)::  s_spec(*)
      type(str_lat)::   s_lat
      type(str_pot)::   s_pot
C ... Dynamically allocated local arrays
      integer, allocatable :: ips0(:)
      real(8), allocatable,target :: amx(:)
      real(8), pointer :: aamx(:)
      real(8), allocatable :: rofi(:),rwgt(:)
      complex(8), allocatable :: wk(:)
      complex(8), allocatable :: cg1(:),cg2(:)
      complex(8), allocatable,target :: cn(:)
      complex(8), pointer :: cn2(:)
C     complex(8), allocatable :: cn(:)
      complex(8), allocatable :: co(:)
      complex(8), allocatable :: qkl(:)
      complex(8), allocatable :: fkl(:)
C ... Local parameters
      integer stdo,stdl,lgunit,nbas,i,i1,i2,i3,ib,ipl,ipr,is,k0,kmxv,
     .  locm0,locm1,locm2,lmxl,n1,n2,n3,ng,nglob,nlml,nr,nmixr,nmix,nda,
     .  mxsav,ifi,nlm0,kkk,nnnew,nnmix,ngabc(3),fopna,broy,nx,iprt,
     .  mpipid,nkill,isw,naa,kmxr,kmxs,locmix,offx,off2,intopt
      integer ng0
      equivalence (n1,ngabc(1)),(n2,ngabc(2)),(n3,ngabc(3))
      parameter (nlm0=81)
      double precision a,beta0,beta,bet2,dif,difx,difxu,fac,rms,rmt,
     .  sumo,summ,sums,top,vol,alat,tpiba,pi,dquns,rmsuns,q1,
     .  qin(2),qout(2),qscr(2),qmix(2),qcell,rms2,rms2f,wc,rsmv,qmx,
     .  wt(3),rmsdel,elin1,elin2,xx,ql1(2),ql2(2),beta1p2
      double complex xxc
      logical parmxp,ltmp
      character fnam*8
C     for MPI
      integer procid, master
      logical mlog,cmdopt
      character strn*120
      type(str_rhat),pointer ::  s_rold(:),s_rnew(:)

      s_rnew => s_pot%rnew
      s_rold => s_pot%rhat

      if (mixmod == 'none') return
      call tcn('mixrho')
      master = 0
      procid = mpipid(1)
      mlog = cmdopt('--mlog',6,0,strn)
      call pshpr(max(iprt(0),iprt(2)))  ! Push larger of 0th and 2nd element
!     print *, '!! mixrho'; call setpr(60)
      intopt = 10*nglob('lrquad')

C --- Setup ---
      nbas = nglob('nbas')
      stdo = nglob('stdo')
      stdl = nglob('stdl')
      call getpr(ipr)
      ipl = 2; if (stdl < 0) ipl = 0
      nx = 0
      kkk = k1*k2*k3
      pi = 4d0*datan(1d0)
      qmix(2) = 0
      ngabc = s_lat%nabc
      ng = s_lat%ng
      vol = s_lat%vol
      alat = s_lat%alat
      elin1 = elind
      locmix = 33
      kmxs = 3
      kmxr = 8

C --- Iteration-dependent mixing parameters ---
      broy  = dmxp(1)
      beta  = dmxp(2)
      wc    = dmxp(3)
      wt(1) = dmxp(4)
      wt(2) = dmxp(5)
      wt(3) = dmxp(4)
C     Flags parmxp that there are no extra elements to mix
      if (nx == 0) wt(3) = -9
      mxsav = nint(dmxp(6))
      nmix  = nint(dmxp(7))
      nkill = nint(dmxp(8))
      fnam  = 'mixm'
      rmsdel = dmxp(11)
      rms2 = 0
      elin2 = elin1
      beta1p2 = 1
      if (ipr >= 20) write(stdo,*) ' '
      if (.not. parmxp(iter,mixmod,len(mixmod),broy,nmix,wt,beta,bet2,
     .  elin1,elin2,locmix,fnam,wc,nkill,beta1p2,rms2))
     .  call rx('MIXRHO: parse in parmxp failed')

C     In case parmxp doesn't touch wt, unset flag
      if (wt(3) == -9) wt(3) = 0
      if (nmix == 0) broy = 0
C ... Initial printout
C      call awrit7(' Mix density with beta=%;4d'//
C     .  '%?;n;, Lindhard E=%;3d;;'//
C     .  '%?;(n==1);, Broyden scheme using n=%,1i;%j;'//
C     .  '%?;(n==0);, Anderson scheme using n=%,1i;%j;',
C     .  ' ',100,stdo,beta,isw(elin1 /= 0),elin1,broy,nmix,
C     .  broy,nmix)
C      call rx('done')

C ... Interactively reset mix-parms block
      i1 = 0
      i2 = 0
      if (index(mixmod,';') > 0) then
      call query('mix-parms-block',2,i1)
      call query('block-iter',2,i2)
      if (i1 > 0 .or. i2 > 0) then
        if (i2 <= 0) i2 = 1
        call parmx0(i1,i2,0d0)
        if (.not. parmxp(iter,mixmod,len(mixmod),broy,nmix,wt,beta,bet2,
     .    elin1,elin2,locmix,fnam,wc,nkill,beta1p2,rms2))
     .    call rx('MIXRHO: parse in parmxp failed')
      endif
      endif
      if (locmix >= 1000) then
        kmxr = mod(locmix/1000,10)
        locmix = locmix - 1000*kmxr
      endif
      locm0 = mod(locmix,10)
      locm1 = mod(locmix/10,10)
      locm2 = mod(locmix/100,10)
      if (locm2 /= 0 .and. locm1 /= 0) call rx(
     .  'MIXRHO: if 100s digit locmix is set, 10s digit must be zero')

      if (nsp == 1) wt(2) = 0
      if (wt(1)**2+wt(2)**2+wt(3)**2 == 0)
     .  call fexit(-1,111,' Exit -1 MIXRHO: '//
     .  'bad mixing weights w =%3:1;6d',wt)
      call dscal(3,1/dsqrt(wt(1)**2+wt(2)**2+wt(3)**2),wt,1)
      if (nmix < 0) nmix = mxsav
      ltmp = elin2 == elin1
      if (elin1 < 0d0) elin1 = -(3*pi**2*qval/vol)**.66666d0*elin1
      if (elin1 < .01d0) elin1 = 0
      if (ltmp) then
        elin2 = elin1
      else
        if (elin2 < 0d0) elin2 = -(3*pi**2*qval/vol)**.66666d0*elin2
        if (elin2 < .01d0) elin2 = 0
      endif

C ... Initial charges
      call rhoqm(smrho,k1,k2,k3,n1,n2,n3,nsp,vol,qin)
      call rhoqm(smrnew,k1,k2,k3,n1,n2,n3,nsp,vol,qout)

C --- Screen sm output rho; distribute screening rho over local rho ---
C ... 1. Overwrite smrho+, smrho- with smrho, smrho+ - smrho-
      if (nsp == 2) then
C       call zprm3('smrho, spin1',0,smrho,k1,k2,k3)
C       call zprm3('smrho, spin2',0,smrho(1,1,1,2),k1,k2,k3)
C       call zprm3('smrnw, spin1',0,smrnew,k1,k2,k3)
C       call zprm3('smrnw, spin2',0,smrnew(1,1,1,2),k1,k2,k3)
        call dsumdf(kkk*2,1d0,smrho,0,1,smrho(1,1,1,2),0,1)
        call dsumdf(kkk*2,1d0,smrnew,0,1,smrnew(1,1,1,2),0,1)
C       call zprm3('smrho, charge',0,smrho,k1,k2,k3)
C       call zprm3('smrho, moment',0,smrho(1,1,1,2),k1,k2,k3)
C       call zprm3('smrnw, charge',0,smrnew,k1,k2,k3)
C       call zprm3('smrnw, moment',0,smrnew(1,1,1,2),k1,k2,k3)
      endif

C ... <smrout-smrhoin> and <(smrout-smrhoin)**2>, unscreened smrout
      dquns = 0
      rmsuns = 0
      do  i3 = 1, n3
      do  i2 = 1, n2
      do  i1 = 1, n1
        dquns  = dquns + dble(smrnew(i1,i2,i3,1)-smrho(i1,i2,i3,1))
        rmsuns = rmsuns + dble(smrnew(i1,i2,i3,1)-smrho(i1,i2,i3,1))**2
      enddo
      enddo
      enddo

C ... debugging ... see Fourier components of input and output
C#ifdefC DBGVXT
C      call dbgsmrho('mixrho smrho',k1,k2,k3,s_lat,smrho)
C      call dbgsmrho('mixrho smrnew',k1,k2,k3,s_lat,smrnew)
C#endif

C ... 2. cn <- (smrnew - smrho)(G)
      allocate(cn(ng))
      allocate(wk(kkk))
      call dcopy(kkk*2,smrnew,1,wk,1)
      call dpadd(wk,smrho,1,kkk*2,-1d0)
      call fftz3(wk,n1,n2,n3,k1,k2,k3,1,0,-1)
      call gvgetf(ng,1,s_lat%kv,k1,k2,k3,wk,cn)
      deallocate(wk)

C ... 3. Sum of local densities on Fourier mesh (up+down)
      allocate(cg1(ng)); call dpzero(cg1,2*ng)
      allocate(cg2(ng)); call dpzero(cg2,2*ng)
      call rhgcmp(131,1,nbas,s_site,s_spec,s_lat,s_rold,kmxs,ng,cg1)
      call rhgcmp(131,1,nbas,s_site,s_spec,s_lat,s_rnew,kmxs,ng,cg2)
C     call gvputf(ng,1,s_lat%kv,k1,k2,k3,cg1,smrnew)
C     call fftz3(smrnew,n1,n2,n3,k1,k2,k3,1,0,1)
C     call zprm3('input local densities (r)',0,smrnew,k1,k2,k3)

C ... Add output-input difference in gaussian rho for change in total rho
C     call dpzero(cn,ng*2)
      if (.true.) then
      call daxpy(2*ng,1d0,cg2,1,cn,1)
      call daxpy(2*ng,-1d0,cg1,1,cn,1)
      endif
      deallocate(cg1,cg2)

C ... 4. Make cn = screening charge = (eps^-1 - 1) (n_out - n_in)
      tpiba = 2*pi/alat
      if (elin2 /= elin1) then
        allocate(cn2(ng))
        call dcopy(ng*2,cn,1,cn2,1)
        call lindsc(2,ng,s_lat%gv,tpiba,elin2,cn2)
      else
        cn2 => cn
      endif
      call lindsc(2,ng,s_lat%gv,tpiba,elin1,cn)

C ... 5. Add cn = screening charge into smrnew
      allocate(wk(kkk))
      call gvputf(ng,1,s_lat%kv,k1,k2,k3,cn,wk)
      call fftz3(wk,n1,n2,n3,k1,k2,k3,1,0,1)
C     call zprm3('unscreened smrnew',0,smrnew,k1,k2,k3)
      call dpadd(smrnew,wk,1,kkk*2,1d0)
      deallocate(wk)
C     call zprm3('screened smrnw, charge',0,smrnew,k1,k2,k3)
C     call zprm3('screened smrnw, moment',0,smrnew(1,1,1,2),k1,k2,k3)

C ... RMS differences screened and input sm density; count neg points
C     summ
      sumo = 0d0
      sums = 0d0
      summ = 0d0
      top = 0d0
      rms = 0d0
      nnnew = 0
      nnmix = 0
      do  i3 = 1, n3
      do  i2 = 1, n2
      do  i1 = 1, n1
        sumo = sumo + dble(smrho(i1,i2,i3,1))
        sums = sums + dble(smrnew(i1,i2,i3,1))
        dif = dble(smrnew(i1,i2,i3,1)-smrho(i1,i2,i3,1))
        rms = rms + dif*dif
        top = dmax1(top,dabs(dif))
        xxc = beta*smrnew(i1,i2,i3,1) + (1d0-beta)*smrho(i1,i2,i3,1)
        if (dble(smrnew(i1,i2,i3,1)) < 0) nnnew = nnnew+1
        if (dble(xxc) < 0) nnmix = nnmix+1
c       smrho(i1,i2,i3) = xxc
        summ = summ + dble(xxc)
      enddo
      enddo
      enddo
      fac = vol/(n1*n2*n3)
      rms = dsqrt(fac*rms/vol)
      rmsuns = dsqrt(fac*rmsuns/vol)
C     Defer printout until after file read prior iterations; see '100' below

C ... 6. Restore smrho+, smrho-
      if (nsp == 2) then
        call dsumdf(kkk*2,.5d0,smrho,0,1,smrho(1,1,1,2),0,1)
        call dsumdf(kkk*2,.5d0,smrnew,0,1,smrnew(1,1,1,2),0,1)
      endif
C     call zprm3('smrnew',0,smrnew,k1,k2,k3)

C --- 7. Project cn = screening density into local densities ---
      if (locm0 == 4) goto 80 ! No modification of local rho when linearly mixing it
      k0 = 20
      allocate(fkl((k0+1)*nlm0*nbas))
      call ftlxp(nbas,s_site,s_spec,alat,ng,s_lat%gv,cn2,k0,nlm0,fkl)
      do  ib = 1, nbas
        is = s_site(ib)%spec
        a = s_spec(is)%a
        nr = s_spec(is)%nr
        rmt = s_spec(is)%rmt
        lmxl = s_spec(is)%lmxl
        rsmv = s_spec(is)%rsmv
        kmxv = s_spec(is)%kmxv
        if (lmxl < 0) cycle
        nlml = (lmxl+1)**2
        if (nlml > nlm0) call rxi('mixrho: nlml > nlm0, need',nlml)
        allocate(rofi(nr),rwgt(nr))
        call radmsh(rmt,a,nr,rofi)
        call radwgt(intopt,rmt,a,nr,rwgt)

        if (ipr >= 55) then
          call awrit1(' mixrho input density, ib=%i',strn,100,0,ib)
          call shorho(3,strn,nr,nlml,nsp,rofi,rwgt,s_rold(ib)%rho1,s_rold(ib)%rho2)
          call awrit1(' mixrho output density, ib=%i',strn,100,0,ib)
          call shorho(3,strn,nr,nlml,nsp,rofi,rwgt,s_rnew(ib)%rho1,s_rnew(ib)%rho2)
        endif

C        if (ib == 3) then
C        print *, 'ib=',ib
C        call prrmsh('rhold1',rofi,s_rold(ib)%rho1,nr,nr,nlml*nsp)
C        call prrmsh('rhold2',rofi,s_rold(ib)%rho2,nr,nr,nlml*nsp)
C        call prrmsh('rhnew1',rofi,s_rnew(ib)%rho1,nr,nr,nlml*nsp)
C        call prrmsh('rhnew2',rofi,s_rnew(ib)%rho2,nr,nr,nlml*nsp)
C        endif

C       Overwrite rho+, rho- with total rho, moment
        call splrho(0,nsp,nr,nlml,s_rnew(ib)%rho1,s_rnew(ib)%rho2,s_rnew(ib)%rhoc)

C       if (ipr >= 80) then
C         call awrit1(' output rho, moment, ib=%i',strn,100,0,ib)
C         call shorho(3,strn,nr,nlml,nsp,rofi,rwgt,
C    .      s_rnew(ib)%rho1,s_rnew(ib)%rho2)
C       endif
C       if (ib == 3) then
C       print *, 'ib=',ib
C       call prrmsh('r1+2old',rofi,s_rold(ib)%rho1,nr,nr,nlml*nsp)
C       call prrmsh('r1-2old',rofi,s_rold(ib)%rho2,nr,nr,nlml*nsp)
C       call prrmsh('r1+2new',rofi,s_rnew(ib)%rho1,nr,nr,nlml*nsp)
C       call prrmsh('r1-2new',rofi,s_rnew(ib)%rho2,nr,nr,nlml*nsp)
C       endif

C   ... Add site-projected screening density to rhn1,rhn2
        call pkl2ro(110,ib,rsmv,kmxv,nr,nlml,1,rofi,rwgt,
     .    k0,nlm0,fkl,xx,s_rnew(ib)%rho1,s_rnew(ib)%rho2,qmx)
C       Restore rho+, rho-
        call splrho(1,nsp,nr,nlml,s_rnew(ib)%rho1,s_rnew(ib)%rho2,s_rnew(ib)%rhoc)

        if (ipr >= 80) then
          call awrit1(' mixrho output scr rho, ib=%i',strn,100,0,ib)
          call shorho(3,strn,nr,nlml,nsp,rofi,rwgt,s_rnew(ib)%rho1,s_rnew(ib)%rho2)
        endif

C  ...  Work with rho1+rho2, rho1-rho2; restore to rho1,rho2 at end
C        if (ib == 3) then
C        print *, 'ib=',ib
C        call prrmsh('rscold1',rofi,s_rold(ib)%rho1,nr,nr,nlml*nsp)
C        call prrmsh('rscold2',rofi,s_rold(ib)%rho2,nr,nr,nlml*nsp)
C        call prrmsh('rscnew1',rofi,s_rnew(ib)%rho1,nr,nr,nlml*nsp)
C        call prrmsh('rscnew2',rofi,s_rnew(ib)%rho2,nr,nr,nlml*nsp)
C        endif
        call pvmix9(1-locm2,0,nr,nlml*nsp,0,0d0,rofi,s_rold(ib)%rho1,s_rold(ib)%rho2)
        call pvmix9(1-locm2,0,nr,nlml*nsp,0,0d0,rofi,s_rnew(ib)%rho1,s_rnew(ib)%rho2)

C   ... Overwrite rnew(1)+rnew(2) with beta1p2*(rnew(1)+rnew(2)) + (1-beta1p2)*(rold(1)+rold(2))
        if (beta1p2 /= 1) then
          call dscal(nr*nlml*nsp,beta1p2,s_rnew(ib)%rho1,1)
          call daxpy(nr*nlml*nsp,1-beta1p2,s_rold(ib)%rho1,1,s_rnew(ib)%rho1,1)
        endif

C#ifdefC DEBUG
CC       Debugging check inverse op restores original
CC       call pvmix9(10*locm1,-1,nr,nlml*nsp,0,rf,rofi,s_rold(ib)%rho1,
CC    .    s_rold(ib)%rho2)
CC       call pvmix9(10*locm1,-1,nr,nlml*nsp,0,rf,rofi,s_rnew(ib)%rho1,
CC    .    s_rnew(ib)%rho2)
CC       call prrmsh('1 rest',rofi,s_rold(1)%rho1,nr,nr,nlml*nsp)
CC       call prrmsh('2 rest',rofi,s_rold(1)%rho2,nr,nr,nlml*nsp)
CC       stop
C#endif

        deallocate(rofi,rwgt)
      enddo ! Loop over sites
      deallocate(fkl)

   80 continue  ! Re-entry point for locm0 == 4
      if (.not. associated(cn2,cn)) deallocate(cn2)
      deallocate(cn)

C --- Fancy mixing of smoothed + some representation of local rho ---
C ... Count number of elts from local densities for fancy mixing scheme
      nda = 0
      do  ib = 1, nbas
        is = s_site(ib)%spec
        nr = s_spec(is)%nr
        lmxl = s_spec(is)%lmxl
        nlml = (lmxl+1)**2
        if (lmxl == -1 .or. locm0 == 4) cycle
        if (locm0 == 0) then      ! Include spherical part of local densities only
          nda = nda + 2*nr
        elseif (locm0 == 4) then  ! Linearly mix entire local density
        elseif (locm0 == 1) then  ! Mix total charge
          nda = nda + 2
C       also include nonspherical part, G_kL expansion
        elseif (locm0 >= 2) then
          nda = nda + 2*(kmxr+1)*nlml
C         and spherical part of rho1-rho2
          if (locm0 == 3) nda = nda + 2*nr
        else
          call rxi('bad locmix,',locmix)
        endif
      enddo

C ... 8. FFT smooth densities -> rho(G) for mixing
C     Find and include number of smooth mesh points.
      allocate(ips0(ng))
      call lgstar(0,ng,1,s_lat%gv,ng0,ips0,xx)
C     if (ng /= (ng0-1)*2+1) call rx('bug in mixrho')
      if (locm0 /= 1) then
        nda = nda + 2*ng0
        allocate(cn(ng*nsp),co(ng*nsp),wk(kkk*nsp))
        call dpcopy(smrnew,wk,1,kkk*2*nsp,1d0)
        call fftz3(wk,n1,n2,n3,k1,k2,k3,nsp,0,-1)
        call gvgetf(ng,nsp,s_lat%kv,k1,k2,k3,wk,cn)
C       call zprm('cn-u',2,cn,ng,ng,nsp)
        call lgstar(1,ng,nsp,s_lat%gv,i,ips0,cn)
C       call zprm('cn-c',2,cn,ng,ng0,nsp)
C       call lgstar(2,ng,nsp,s_lat%gv,i,ips0,cn)
C       call zprm('cn-u',2,cn,ng,ng,nsp)
        call dpcopy(smrho,wk,1,kkk*2*nsp,1d0)
        call fftz3(wk,n1,n2,n3,k1,k2,k3,nsp,0,-1)
        call gvgetf(ng,nsp,s_lat%kv,k1,k2,k3,wk,co)
C       call zprm('co-u',2,co,ng,ng,nsp)
        call lgstar(1,ng,nsp,s_lat%gv,i,ips0,co)
C       call zprm('co-c',2,co,ng,ng0,nsp)
        deallocate(wk)
      else ! locm0=1 : Linearly mix smrhnew,smrho with bet2
        ng0 = 0 ! istl density not run through mixing scheme
        allocate(cn(1),co(1))
C       Overwrite smrho+, smrho- with smrho, smrho+ - smrho-
        if (nsp == 2 .and. wt(1)*wt(2) == 0) then
          call dsumdf(kkk*2,1d0,smrho,0,1,smrho(1,1,1,2),0,1)
          call dsumdf(kkk*2,1d0,smrnew,0,1,smrnew(1,1,1,2),0,1)
        endif
C       Linearly mix with bet2; mixed density stored in smrho
        do  i = 1, nsp
          if (wt(1) == 0 .and. i == 1) cycle
          if (wt(2) == 0 .and. i == 2) cycle
          call dscal(kkk*2,1-bet2,smrho(1,1,1,i),1)
          call daxpy(kkk*2,bet2,smrnew(1,1,1,i),1,smrho(1,1,1,i),1)
        enddo
C       Restore smrho+, smrho-
        if (nsp == 2 .and. wt(1)*wt(2) == 0) then
          call dsumdf(kkk*2,.5d0,smrho,0,1,smrho(1,1,1,2),0,1)
          call dsumdf(kkk*2,.5d0,smrnew,0,1,smrnew(1,1,1,2),0,1)
        endif
      endif

C ... Allocate memory for mixing array
      ifi = nda*nsp*(mxsav+2)*2
      allocate(amx(ifi)); call dpzero(amx,ifi)
C ... Allocate memory for coffs to G_kL expansion of rho
      if (locm0 >= 2 .and. locm0 < 4) then
        ifi = (kmxr+1)*nlm0*nsp*4*nbas
        allocate(qkl(ifi)); call dpzero(qkl,2*ifi)
      else
        allocate(qkl(1))
      endif

C --- 9. Read prior iterations from disk; update with current iter ---
      if (procid == master) then
        ifi = fopna(fnam,-1,4)
        rewind ifi
      endif
      call mpibc1(ifi,1,2,mlog,'mixrho','ifi')

C     NB: For this code nx must be zero
C     print *, '!!'; kmxr = 2
      call pvmix5(nmix,mxsav,fnam,ifi,.true.,rmsdel,locmix,nbas,kmxr,nlm0,
     .  s_site,s_spec,s_rold,s_rnew,nsp,co,cn,ng,ng0,0,nda,amx,qkl,rms2,nmixr)

C#ifdefC DEBUG
CC     debugging check
CC      ib = 1
CC      is = s_site(ib)%spec
CC      is = s_site(ib)%spec
CC      nlml = (lmxl+1)**2
CC      allocate(rofi(nr),rwgt(nr))
CC      call radmsh(rmt,a,nr,rofi)
CC      call radwgt(intopt,rmt,a,nr,rwgt)
CC      call pkl2ro(1001,ib,rg,kmxr,nr,nlml,nsp,rofi,rwgt,
CC     .  kmxr,nlm0,xx,qkl,s_rold(ib)%rho1,xx,qmx)
CC      call prrmsh('rhots1',rofi,s_rold(ib)%rho1,nr,nr,nlml*nsp)
CC      stop
C#endif

      rmsdel = rms2
      nmix = min(nmix,nmixr)
C ... Write this and prior iterations onto disk
! Is this ..,s_spec,s_spec,s_rold,... intentional?
      call pvmix5(nmix,mxsav,fnam,-ifi,.true.,rmsdel,locmix,nbas,kmxr,
     .  nlm0,s_site,s_spec,s_spec,s_rold,nsp,co,cn,ng,ng0,0,nda,
     .  amx,qkl,rms2,nmixr)
      if (nkill < 0) then
        if (ipr >= 20) then
          strn = ' ...  deleting file '//fnam
          call awrit1('%a : nkill=%i',strn,100,-lgunit(1),-nkill)
        endif
        call dfclos(ifi)
      else
        call fclose(ifi)
      endif

C --- Printout smooth density mixing data ---
      if (nnnew+nnmix > 0 .and. ipr >= 20) call awrit2(
     .  ' mixrho: (warning) scr. and lin-mixed densities had'//
     .  ' %i and %i negative points',' ',100,stdo,nnnew,nnmix)
      call rhoqm(smrnew,k1,k2,k3,n1,n2,n3,nsp,vol,qscr)
C     if (ipr > 30) write(stdo,100)
C    .  sumo*fac,sumu*fac,sums*fac,rms,summ*fac
      if (ipr > 30) then
        xx = beta
        if (locm0 == 1) xx=bet2 ! sm density is in the residual, mixed with bet2
        write(stdo,100) qin(1),qout(1),qscr(1),rms,xx*qscr(1)+(1-xx)*qin(1)
C       if (nsp == 2) write(stdo,101) qin(2),qout(2),xx*qscr(2)+(1-xx)*qin(2)
        if (nsp == 2) call info5(30,0,0,' mmom%;17,6D%;14,6D%28f%;14,6D',
     .    qin(2),qout(2),xx*qscr(2)+(1-xx)*qin(2),0,0)
      endif
  100 format(' charges:',7x,'old',11x,'new',9x,'screened',
     .  6x,'rms diff',7x,'lin mix'/' smooth ',5f14.6)
C 101 format(' mmom   ',2f14.6,28x,f14.6)

C --- 10. Linear mixing of local densities ---
C     Generates:
C      rhold <-    (1-bet2)*rhold  + bet2*rhnew
C                - (1-bet2)*rhoref - bet2*rhnref
C     where rhoref created internally, and defined through locm0
C     Note: pvmix3 causes rhnew <- rhold
      call pvmix3(s_site,s_spec,s_rold,s_rnew,nbas,nsp,bet2,locmix,wt,
     .  kmxr,nlm0,qkl,1,difx)
      difxu = difx

C --- 11. Spin polarized case: separate weighting for spin channels ---
      if (nsp == 2 .or. nx > 0) then
        if (wt(2) /= 0 .and. nsp == 1)
     .    call rx1('mixrho wt(2)=%d invalid when nsp=1',wt(2))
C       Map to ASA call:
C             dim. of a     extra    #-mix   #-elts/spin  dim of aa
C       ASA    nda           nx      naa      npq            naa
C       FP     nda*nsp       0       naa      nda            naa
        if (nx > 0) call rx('mixrho not ready for nx=0')
        naa = 0 ! naa = number of mixing parameters after constraints imposed
        if (wt(1) /= 0) naa = naa+nda
        if (wt(2) /= 0) naa = naa+nda
        if (wt(3) /= 0) naa = naa+nx
        offx = 0                !offset to extra elements (none now)
        off2 = (nsp-1)*nda      !offset to spin down part of a

        allocate(aamx(naa*(mxsav+2)*2))
        call dpzero(aamx,naa*(mxsav+2)*2)
        call pqsclf(0,nda*nsp,nda,offx,off2,nx,naa,mxsav,wt,amx,aamx,rms2f)
        if (wt(1)*wt(2) /= 0) then
C          rms2f = rms2f * 2
        else
          call info2(20,0,0,' Constrained spin mixing, wt =%2:1;5d.'//
     .      '  Constrained rms DQ=%1,3;3e',wt,rms2f)
          rmsdel = rms2f
        endif
      else
        aamx => amx
        naa = nda
      endif

C --- 12. Mix the soup of densities ---
      beta0 = beta
      call pvmix6(broy,nmix,nmixr,mxsav,beta,wc,naa,aamx)

C ... 13. Restore matrix a to rho+, rho-
      if (nsp == 2 .or. nx > 0) then
        call pqsclb(nda*nsp,nda,offx,off2,nx,naa,mxsav,wt,amx,aamx)
        call pqsclc(nda*nsp,nda*nsp,nx,mxsav,amx)
      endif
      if (.not. associated(aamx,amx)) deallocate(aamx)

C      nlml = 16
C      call prrmsh('rho1, ante 7',rofi,s_rold(1)%rho1,nr,nr,nlml*nsp)
C      call prrmsh('rho2, ante 7',rofi,s_rold(1)%rho2,nr,nr,nlml*nsp)

C ... 14. Poke mixed smooth and local densities into smrho,s_rold
      allocate(wk(kkk))
      call pvmix7(s_site,s_spec,s_rold,s_rnew,nbas,nsp,nda,amx,
     .  n1,n2,n3,k1,k2,k3,locmix,wt,kmxr,nlm0,qkl,ng,ng0,s_lat%kv,
     .  ips0,s_lat%gv,co,wk,smrho)
      deallocate(wk)
      deallocate(qkl,cn,co,amx,ips0)

C      nlml = 16
C      call prrmsh('rho1 post 7',rofi,s_rold(1)%rho1,nr,nr,nlml*nsp)
C      call prrmsh('rho2 post 7',rofi,s_rold(1)%rho2,nr,nr,nlml*nsp)
C      stop

C      Debugging
C      call dsumdf(kkk*2,1d0,smrho,0,1,smrho(1,1,1,2),0,1)
C      call zprm3('mixed sm rho, charge',0,smrho,k1,k2,k3)
C      call zprm3('mixed sm rho, spin',0,smrho(1,1,1,2),k1,k2,k3)
C      call dsumdf(kkk*2,.5d0,smrho,0,1,smrho(1,1,1,2),0,1)
C      call zprm3('mixed sm rho, spin1',0,smrho,k1,k2,k3)
C      call zprm3('mixed sm rho, spin2',0,smrho(1,1,1,2),k1,k2,k3)

      if (ipr >= 55) then
        call rhoqm(smrho,k1,k2,k3,n1,n2,n3,nsp,vol,qscr)
        call info5(0,1,0,' mixed istl charge = %,6;6d'//
     .    '%?#(n==2)#  amom = %,6;6d#%j#',qscr,nsp,qscr(2),0,0)
      endif

C ... 15. Restore local densities: rho+ +/- rho-  -> rho+, rho-
      call dpzero(qmix,2)
      do  ib = 1, nbas
        is = s_site(ib)%spec
        a = s_spec(is)%a
        nr = s_spec(is)%nr
        rmt = s_spec(is)%rmt
        lmxl = s_spec(is)%lmxl
        rsmv = s_spec(is)%rsmv
        kmxv = s_spec(is)%kmxv
        if (lmxl < 0) cycle
        nlml = (lmxl+1)**2
        if (nlml > nlm0) call rxi('mixrho: nlml > nlm0, need',nlml)
        allocate(rofi(nr),rwgt(nr))
        call radmsh(rmt,a,nr,rofi)
        call radwgt(intopt,rmt,a,nr,rwgt)

        if (locm0 == 4) then ! No modification of local rho when linearly mixing it
        else
        call pvmix9(1-locm2,-1,nr,nlml*nsp,0,0d0,rofi,s_rold(ib)%rho1,s_rold(ib)%rho2)
        call pvmix9(1-locm2,-1,nr,nlml*nsp,0,0d0,rofi,s_rnew(ib)%rho1,s_rnew(ib)%rho2)
        endif

        if (ipr >= 55) then
          call awrit1(' mixed rho, ib=%i',strn,100,0,ib)
          call shorho(3,strn,nr,nlml,nsp,rofi,rwgt,s_rold(ib)%rho1,s_rold(ib)%rho2)
        endif

C       debugging
C#ifdefC DEBUG
C        if (ib == 1) then
C        call prrmsh('1 final',rofi,s_rold(ib)%rho1,nr,nr,nlml*nsp)
C        call prrmsh('2 final',rofi,s_rold(ib)%rho2,nr,nr,nlml*nsp)
C        endif
C#endif

C   ... Add net local charge to qmix
        call pvmixa(nr,nlml,nsp,s_rold(ib)%rho1,s_rold(ib)%rho2,rwgt,ql1,ql2)
        do  i = 1, nsp
          qmx = ql1(i)-ql2(i)
C         print *, 'spin, qmx',i,qmx
          if (i == 2) qmix(2) = qmix(2) + qmx-q1
          q1 = qmx
          qmix(1) = qmix(1) + qmx
        enddo

        deallocate(rofi,rwgt)
      enddo                     !Loop over sites

C ... Force density positive
C     call rhopos(smrho,k1,k2,k3,n1,n2,n3,nsp)

C ... Net interstitial charge and cell charge
      summ = 0
      do  i = 1, nsp
      do  i3 = 1, n3
      do  i2 = 1, n2
      do  i1 = 1, n1
C       smrho(i1,i2,i3,i) = smrho(i1,i2,i3,i) + .001
        summ = summ + dble(smrho(i1,i2,i3,i))
      enddo
      enddo
      enddo
      enddo
C     Net system charge
      qcell  = qval - summ*fac - qmix(1)

C     Add constant to smrho to force charge neutrality
      xx = qcell/(vol*nsp)
      summ = 0
      do  i = 1, nsp
      do  i3 = 1, n3
      do  i2 = 1, n2
      do  i1 = 1, n1
        smrho(i1,i2,i3,i) = smrho(i1,i2,i3,i) + xx
C       summ = summ + dble(smrho(i1,i2,i3,i))
      enddo
      enddo
      enddo
      enddo
C     qcell  = qval - summ*fac - qmix(1)
C     print *, 'qcell after shift',qcell; stop

C --- Clean up ---
      if (nmix < 0) dmxp(7) = -nmix
      if (beta0 /= beta) dmxp(2) = beta
      dmxp(11) = rmsdel
      dmxp(12) = difx
      dmxp(13) = iabs(nmix)
      dmxp(14) = broy
      dmxp(15) = beta
      if (broy == 1) dmxp(15) = 1
      dmxp(25) = 0
      if (wt(1) /= 0 .or. wt(2) /= 0) dmxp(25) = 1
      if (wt(3) /= 0) dmxp(25) = dmxp(25) + 10

C ... Printout
      if (ipr >= 10 .and. abs(qcell) > 1d-6) write(stdo,
     .  '('' add q='',f10.6,'' to preserve neutrality'')') qcell

      if (ipr >= 30) then
        write(stdo,450) ' unscreened ',rmsuns,difxu
        if (elin1 /= 0) write(stdo,450) '   screened ',rms,difx,rmsdel
  450   format(a,'rms difference:  smooth',f10.6,'   local',f10.6:
     .    '   tot',f10.6)
      elseif (ipr >= 20) then
        call awrit3(' rms smooth dq=%;3g  max local dq=%;3g  dq=%;3g',
     .    ' ',100,stdo,rms,difx,rmsdel)
      endif
      if (ipl > 1 .and. ipr > 1) then
        call awrit6('%xfp mix %?;n;elind %;4g  ;%j;'//
     .    '%?#(n==1)#Broyden n %1i wc %;3g#%2j#%-3j'//
     .    '%?#(n==0)#Anderson n %i beta %j%;3g#%3j#',
     .    strn,100,0,isw(elin1 /= 0),elin1,broy,nmix,wc,beta)
        call awrit3('%a  sm-dq %;3g  mx loc %;3g  dq %;3g',strn,100,
     .    -stdl,rms,difx,rmsdel)
      endif

C      call zprm3('exit sm rho, spin1',0,smrho(1,1,1,1),k1,k2,k3)
C      call zprm3('exit sm rho, spin2',0,smrho(1,1,1,2),k1,k2,k3)

      call poppr

      call tcx('mixrho')
      end

      subroutine pvmix3(s_site,s_spec,s_rold,s_rnew,nbas,nsp,betal,
     .  locmix,wt,kmxr,nlm0,qkl,keepn,difx)
C- Linearly mix local densities, possibly subtracting G_kL expansion
C ----------------------------------------------------------------------
Cio Structures
Cio  s_site :struct for site-specific data; see structures.h
Ci     Elts read: spec
Co     Stored:    *
Cio    Passed to: *
Cio  s_spec :struct for species-specific data; see structures.h
Ci     Elts read: a nr rmt rg lmxl
Co     Stored:    *
Cio    Passed to: *
Cio  s_rold
Ci     Elts read: rho2 rho1 rhoc
Co     Stored:    rho2 rho1 rhoc (see rhold, below)
Cio    Passed to: *
Cio  s_rnew
Ci     Elts read: rho2 rho1 rhoc (see rhnew, below)
Co     Stored:    rho2 rho1 rhoc possibly overwritten
Cio    Passed to: *
Ci   nsp   :2 for spin-polarized case, otherwise 1
Ci   betal :linear mixing parameter
Ci   locmix :governs transformation of local densities for mixing.
Ci          :See Local variables in subroutine mixrho.
Ci   kmxr   :k-cutoff for G_kL expansion when locmix=2; also dim. qkl
Ci   nlm0   :second dimension of qkl
Ci   qkl    :(locmix>=2) G_kL expansion of local densities
Ci          : qkl(:,:,isp,1,ib) = rho1(rhold), G_kL expansion
Ci          : qkl(:,:,isp,2,ib) = rho2(rhold), G_kL expansion
Ci          : qkl(:,:,isp,3,ib) = rho1(rhnew), G_kL expansion
Ci          : qkl(:,:,isp,4,ib) = rho2(rhnew), G_kL expansion
Ci   keepn  :0 s_rnew is preserved as is
Ci          :1 s_rnew is overwritten by input s_rold
Cio Inputs/Outputs
Cio  rhold  :(stored as s_rold%rho[12c]; see structures above)
Cio         :On input, input local densities, i.e. rho generating H,
Cio         :transformed to (unscaled) rho1+rho2 and rho1-rho2 (pvmix9)
Cio         :On output, rhold is overwritten by
Cio         :  rholin = (1-betal)*rhold  + betal*rhnew
Cio         :         - (1-betal)*rhoref - betal*rhnref
Cio         :reference rho is included for locmix = 1,2,3
Cio         :NB: for Matthias construction, nonsph part of rhold1-rhold2=0
Cio         :if betl=0, spherical part of transformed rholin(2)=0
Cio  rhnew  :(stored as s_new[12c]; see structures above)
Cio         :On input, local output densities (maybe screened)
Cio         :transformed to (unscaled) rho1+rho2 and rho1-rho2 (pvmix9)
Cio         :On output
Cio         :keepn = 0: Untouched on output
Cio         :keepn = 1: Overwritten by input orhold
Co Outputs
Co   difx   :maximum rms difference in rhonew-rhoold
Cr Remarks
Cr   If use rg=rf for locm1=1, also set in pvmix7.  In pvmix5, use rf*1
Cu Updates
Cu   05 Jul 13 Replace f77 pointers with f90 ones
Cu   10 Nov 11 Begin migration to f90 structures
Cu   10 Nov 09 New keepn; new modes locmix
Cu   21 Nov 01 First created
C ----------------------------------------------------------------------
      use structures
      implicit none
C ... Passed parameters
      integer nbas,nsp,kmxr,nlm0,locmix,keepn
      double precision difx,betal,wt(2),qkl(0:kmxr,nlm0,nsp,4,nbas)
C ... For structures
!      include 'structures.h'
      type(str_site)::  s_site(*)
      type(str_spec)::  s_spec(*)
      type(str_rhat)::  s_rold(*),s_rnew(*)
C ... Dynamically allocated local arrays
      real(8), allocatable :: rofi(:)
      real(8), allocatable :: rwgt(:)
      real(8), allocatable :: rho1(:)
      real(8), allocatable :: rho2(:)
      real(8), allocatable :: rho3(:)
      type(dp_wk_vec) :: s_rsm(4)
C ... Local parameters
      integer ib,is,nr,nlml,m,locm0,locm1,locm2,lmxl,intopt,nglob
      integer i,off2
      double precision a,rmt,rg,difa,rf,qo1(2),qo2(2),qn1(2),qn2(2),
     .  fac(2),xx

      locm0 = mod(locmix,10)
      locm1 = mod(locmix/10,10)
      locm2 = mod(locmix/100,10)
      difx  = 0
      intopt = 10*nglob('lrquad')

      do  ib = 1, nbas
        is = s_site(ib)%spec
        a = s_spec(is)%a
        nr = s_spec(is)%nr
        rmt = s_spec(is)%rmt
        rg = s_spec(is)%rg
        lmxl = s_spec(is)%lmxl
        if (lmxl == -1) cycle
        nlml = (lmxl+1)**2
        allocate(rofi(nr),rwgt(nr))
        call radmsh(rmt,a,nr,rofi)
        call radwgt(intopt,rmt,a,nr,rwgt)
        rf = rmt/3
        if (locm1 == 1) then
          rf = 100
        else
C         rg = rf
        endif

C       Debugging: q1 = q+(1+2),q-(1+2); q2 = q+(1-2),q-(1-2)
        call pvmixa(nr,nlml,nsp,s_rold(ib)%rho1,s_rold(ib)%rho2,rwgt,qo1,qo2)
        call pvmixa(nr,nlml,nsp,s_rnew(ib)%rho1,s_rnew(ib)%rho2,rwgt,qn1,qn2)
C#ifdefC DEBUG
C        print *, 'enter linear mix'
C        print *, 'qo',ib,qo1(1),qo2(1)
C        print *, 'qn',ib,qn1(1),qn2(1)
CC        call prrmsh('rho1 entering lin mix',rofi,
CC     .    s_rold(ib)%rho1,nr,nr,nlml*nsp)
CC        call prrmsh('rho2 entering lin mix',rofi,
CC     .    s_rold(ib)%rho2,nr,nr,nlml*nsp)
C#endif

C   ... Preserve s_rold to copy it to s_rnew at the end of this routine
        if (keepn == 1) then
          allocate(rho1(nr*nlml*nsp)); call dpzero(rho1,nr*nlml*nsp)
          allocate(rho2(nr*nlml*nsp)); call dpzero(rho2,nr*nlml*nsp)
          allocate(rho3(nr*nsp)); call dpzero(rho3,nr*nsp)
          call dcopy(nr*nlml*nsp,s_rold(ib)%rho1,1,rho1,1)
          call dcopy(nr*nlml*nsp,s_rold(ib)%rho2,1,rho2,1)
          call dcopy(nr*nsp,s_rold(ib)%rhoc,1,rho3,1)
        endif

C       rsm(1..4) are densities included in Anderson/Broyden mixing
C       rsm(1) = input true density
C       rsm(2) = input local smoothed density
C       rsm(3) = output local true density
C       rsm(4) = output local smoothed density
        do  m = 1, 4
          nullify(s_rsm(m)%p)
          if (locm0 == 4) exit
          allocate(s_rsm(m)%p(nr*nlml*nsp))
          call dpzero(s_rsm(m)%p,nr*nlml*nsp)
          if (locm0 >= 2) then
C           Generate on a mesh the interpolated density to be subtracted
            i = 1001
            if (wt(1) == 0) i = 11001
            if (wt(2) == 0) i = 21001
            call pkl2ro(i,1,rg,kmxr,nr,nlml,nsp,rofi,rwgt,
     .        kmxr,nlm0,xx,qkl(0,1,1,m,ib),s_rsm(m)%p,xx,difa)

C           Undo scaling of rho1+rho2 for linear mix
            if (locm0 == 3 .and. (m == 2 .or. m == 4)) then

C             qlk(1,2) -> scaled rho1+rho2, rho1-rho2
C             qkl(3,4) -> scaled rhn1+rhn2, rhn1-rhn2
C             if (m == 2) print *, m, 'old'
C             if (m == 4) print *, m, 'new'
C             call prrmsh('scaled rhosm1+2 from qkl',rofi,s_rsm(m-1)%p,
C     .         nr,nr,nlml*nsp)
C             call prrmsh('scaled rhosm1-2 from qkl',rofi,s_rsm(m)%p,
C     .         nr,nr,nlml*nsp)
              call pvmix9(10*locm1,-1,nr,nlml*nsp,0,rf,rofi,
     .            s_rsm(m-1)%p,s_rsm(m)%p)
C             if (ib == 3)
C    .          call shorho(3,'in pvmix3',nr,nlml,nsp,rofi,rwgt,
C    .          s_rsm(m-1)%p,s_rsm(m)%p)
C             call prrmsh('unscaled rhosm1+2',rofi,s_rsm(m-1)%p,
C    .          nr,nr,nlml*nsp)
C             call prrmsh('unscaled rhosm1-2',rofi,s_rsm(m)%p,
C    .          nr,nr,nlml*nsp)
            endif

          endif
        enddo

        if (locm0 == 1 .or. locm0 == 3) then
          call pvmixa(nr,nlml,nsp,s_rold(ib)%rho1,s_rold(ib)%rho2,
     .      rwgt,qo1,qo2)
          call pvmixa(nr,nlml,nsp,s_rnew(ib)%rho1,s_rnew(ib)%rho2,
     .      rwgt,qn1,qn2)
C         The following serve as reference densities to subtract:
C                 locm0=1                locm0=3
C         old:    rhold                  rhold
C         new:    qnew/qold * rhold      rhnew
          do  i = 1, nsp
            off2 = 1 + nr*nlml*(i-1)
            call dpscop(s_rold(ib)%rho1,s_rsm(1)%p,nr,off2,off2,1d0)
            call dpscop(s_rold(ib)%rho2,s_rsm(2)%p,nr,off2,off2,1d0)
            if (locm0 == 1) then
             fac(1) = qn1(i)/qo1(i)
             fac(2) = qn2(i)/qo2(i)
             call dpscop(s_rold(ib)%rho1,s_rsm(3)%p,nr,off2,off2,fac(1))
             call dpscop(s_rold(ib)%rho2,s_rsm(4)%p,nr,off2,off2,fac(2))
            elseif (locm0 == 3) then
             call dpscop(s_rnew(ib)%rho1,s_rsm(3)%p,nr,off2,off2,1d0)
             call dpscop(s_rnew(ib)%rho2,s_rsm(4)%p,nr,off2,off2,1d0)
            endif
          enddo
        endif

C   ... Constraints on rnew, smoothed rho
C        i = 10
C        if (wt(1) == 0) i = 110
C        if (wt(2) == 0) i = 210
C        call pvmix8(i,nr,nlml,nsp,s_rnew(ib)%rho1,s_rnew(ib)%rho2)
C        call pvmix8(i,nr,nlml,nsp,s_rsm(1)%p,s_rsm(2)%p)
C        call pvmix8(i,nr,nlml,nsp,s_rsm(3)%p,s_rsm(4)%p)

C   ... Linear mix local densities for this site
        call pvmix4(nr,nlml,nsp,rofi,locm0,locm2,wt,betal,ib,
     .    s_rsm(1)%p,s_rsm(2)%p,s_rsm(3)%p,s_rsm(4)%p,
     .    s_rold(ib)%rho1,s_rold(ib)%rho2,s_rold(ib)%rhoc,
     .    s_rnew(ib)%rho1,s_rnew(ib)%rho2,s_rnew(ib)%rhoc,
     .    rwgt,difa)
        difx  = dmax1(difx,difa)

C       Debugging
C#ifdefC DEBUG
C        call pvmixa(nr,nlml,nsp,s_rold(ib)%rho1,s_rold(ib)%rho2,
C     .    rwgt,qo1,qo2)
C        print *, 'end of pvmix3, finished linear mix'
C        print *, 'qm',ib,qo1(1),qo2(1)
CC        call prrmsh('rho1 after lin mix',rofi,
CC     .    s_rold(ib)%rho1,nr,nr,nlml*nsp)
CC        call prrmsh('rho2 after lin mix',rofi,
CC     .    s_rold(ib)%rho2,nr,nr,nlml*nsp)
C#endif

C   ... If keepn=1, put original s_rold into s_rnew
        if (keepn == 1) then
          call dcopy(nr*nlml*nsp,rho1,1,s_rnew(ib)%rho1,1)
          call dcopy(nr*nlml*nsp,rho2,1,s_rnew(ib)%rho2,1)
          call dcopy(nr*nsp,rho3,1,s_rnew(ib)%rhoc,1)
          deallocate(rho1,rho2,rho3)
        endif

        deallocate(rofi,rwgt)

        do  m = 1, 4
          if (associated(s_rsm(m)%p)) deallocate(s_rsm(m)%p)
        enddo

      enddo

      end

      subroutine pvmix4(nr,nlml,nsp,ri,locm0,locm2,wt,betal,ib,rhos1,
     .  rhos2,rhns1,rhns2,rho1,rho2,rho3,rhn1,rhn2,rhn3,rwgt,dif)
C- Linear mixing of local densities for one site
C ----------------------------------------------------------------------
Ci Inputs
Ci   nr    :number of radial mesh points
Ci   nlml  :L-cutoff for rho1,rho2
Ci   nsp   :2 for spin-polarized case, otherwise 1
Ci   ri    :radial mesh points
Ci   locm0 :>1 => work with difference rho-rhos
Ci   betal :Linear mixing parameter
Ci   ib    :site index (printout only)
Ci   rhos1 :reference input local true density, e.g. G_kL expansion
Ci         :Note: density is not scaled by radial weights (pvmix9)
Ci   rhos2 :reference input local smoothed density, e.g. G_kL expansion
Ci   rhns1 :reference output local true density, e.g. G_kL expansion
Ci         :Note: density is not scaled by radial weights (pvmix9)
Ci   rhns2 :reference output local smoothed density, e.g. G_kL expansion
Ci   rho1  :input local true density (generates output rho)
Ci   rho2  :input local smoothed density (generates output rho)
Ci   rho3  :input core charge (generates output rho)
Ci   rhn1  :output local true density (generated by input rho)
Ci   rhn2  :output local smoothed density (generated by input rho)
Ci   rhn3  :output core charge (generated by input rho)
Ci   rwgt  :radial mesh weights
Co Outputs
Co   dif   :integral (rho_out - rho_in)**2
Co   rho1,rho2,rho3 are overwritten by the linearly mixed densities
Co   rhn2,rhn2,rhn3 are not touched by this routine
Cr Remarks
Cu Updates
Cu   09 Dec 08 Suppress q,moment mixing when wt(1) or wt(2) is zero
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer nr,nlml,nsp,ib,locm0,locm2
      double precision dif,betal,wt(3)
      double precision ri(nr),rwgt(nr),
     .  rho1(nr,nlml,nsp),rho2(nr,nlml,nsp),rho3(nr,nsp),
     .  rhn1(nr,nlml,nsp),rhn2(nr,nlml,nsp),rhn3(nr,nsp),
     .  rhos1(nr,nlml,nsp),rhos2(nr,nlml,nsp),
     .  rhns1(nr,nlml,nsp),rhns2(nr,nlml,nsp)
C ... Local parameters
      integer i,ir,iprint,stdo,lgunit,np,npc
      double precision pi,srfpi,vsph,ddot,qnew,qold,qmix,rmt,
     .  amnew,amold,amix
C#ifdefC DEBUG
C      double precision ql1(2),ql2(2)
C#endif

C      if (ib == 3) then
C      print *, 'start of pvmix4'
C      call prrmsh('rho1',ri,rho1,nr,nr,nlml*nsp) ! rho1+rho2
C      call prrmsh('rho2',ri,rho2,nr,nr,nlml*nsp) ! rho1-rho2
C      call prrmsh('rhn1',ri,rhn1,nr,nr,nlml*nsp) ! rhscr1+rhscr2
C      call prrmsh('rhn2',ri,rhn2,nr,nr,nlml*nsp) ! rhscr1-rhscr2
C
C      call prrmsh('rhos1',ri,rhos1,nr,nr,nlml*nsp) ! rhos1+rhos2
C      call prrmsh('rhos2',ri,rhos2,nr,nr,nlml*nsp) ! rhos1-rhos2
C      call prrmsh('rhns1',ri,rhns1,nr,nr,nlml*nsp) ! rhscrs1+rhscrs2
C      call prrmsh('rhns2',ri,rhns2,nr,nr,nlml*nsp) ! rhscrs1-rhscrs2
C      endif

C ... Setup
      stdo = lgunit(1)
      pi = 4d0*datan(1d0)
      srfpi = dsqrt(4d0*pi)
      rmt = ri(nr)

C ... rho+,rho- -> rho,amag  and some integrated quantities
      call splrho(0,nsp,nr,nlml,rho1,rho2,rho3)
      call splrho(0,nsp,nr,nlml,rhn1,rhn2,rhn3)
C      qnew = srfpi*(ddot(nr,rhn1,1,rwgt,1) - ddot(nr,rhn2,1,rwgt,1))
C      qold = srfpi*(ddot(nr,rho1,1,rwgt,1) - ddot(nr,rho2,1,rwgt,1))
C      amnew = srfpi*(ddot(nr,rhn1(1,1,nsp),1,rwgt,1) -
C     .               ddot(nr,rhn2(1,1,nsp),1,rwgt,1))
C      amold = srfpi*(ddot(nr,rho1(1,1,nsp),1,rwgt,1) -
C     .               ddot(nr,rho2(1,1,nsp),1,rwgt,1))
C     Make q1-q2
      qnew = srfpi*ddot(nr,rhn2,1,rwgt,1)
      qold = srfpi*ddot(nr,rho2,1,rwgt,1)
      amnew = srfpi*ddot(nr,rhn2(1,1,nsp),1,rwgt,1)
      amold = srfpi*ddot(nr,rho2(1,1,nsp),1,rwgt,1)
      if (locm2 == 1) then
        qnew = srfpi*ddot(nr,rhn1,1,rwgt,1) - qnew
        qold = srfpi*ddot(nr,rho1,1,rwgt,1) - qold
        amnew = srfpi*ddot(nr,rhn1(1,1,nsp),1,rwgt,1) - amnew
        amold = srfpi*ddot(nr,rho1(1,1,nsp),1,rwgt,1) - amold
      endif

      dif = 0
      do  i  = 1, nsp
        if (wt(1) == 0 .and. i == 1) cycle
        if (wt(2) == 0 .and. i == 2) cycle
        do  ir = 1, nr
          dif  = dif + rwgt(ir)*(rhn2(ir,1,i)-rho2(ir,1,i))**2
        enddo
      enddo
      vsph = (4d0*pi/3d0)*rmt**3
      dif = dsqrt(dif/vsph)

C --- Overwrite rho with (1-betal)*rho + betal*rhn ---
C     wt(1)=0 => only mix spin part (set i=2)
C     wt(2)=0 => only mix charge part (set i=1)
      np = nr*nlml*nsp
      i = 1
      if (wt(1) == 0) then
        np = nr*nlml
        i = 2
      elseif (wt(2) == 0) then
        np = nr*nlml
        i = 1
      endif

C     print *, srfpi*(ddot(nr,rho1,1,rwgt,1)),
C    .  srfpi*ddot(nr,rho1(1,1,nsp),1,rwgt,1)
C     print *, srfpi*(ddot(nr,rho2,1,rwgt,1)),
C    .  srfpi*ddot(nr,rho2(1,1,nsp),1,rwgt,1)
      call dscal(np,1-betal,rho1(1,1,i),1)
      call daxpy(np,betal,rhn1(1,1,i),1,rho1(1,1,i),1)
      call dscal(np,1-betal,rho2(1,1,i),1)
      call daxpy(np,betal,rhn2(1,1,i),1,rho2(1,1,i),1)
C     print *,srfpi*(ddot(nr,rho1,1,rwgt,1)),
C    .  srfpi*ddot(nr,rho1(1,1,nsp),1,rwgt,1)
C     print *,srfpi*(ddot(nr,rho2,1,rwgt,1)),
C    .  srfpi*ddot(nr,rho2(1,1,nsp),1,rwgt,1)

      npc = nr*nsp
      if (wt(1) == 0 .or. wt(2) == 0) npc = nr
      call dscal(npc,1-betal,rho3(1,i),1)
      call daxpy(npc,betal,rhn3(1,i),1,rho3(1,i),1)

C ... Charges and mag. moments of mixed density
      qmix = srfpi*(ddot(nr,rho2,1,rwgt,1))
      if (nsp == 2) amix = srfpi*ddot(nr,rho2(1,1,nsp),1,rwgt,1)

C     debugging
C#ifdefC DEBUG
C      call pvmixa(nr,nlml,nsp,rho1,rho2,rwgt,ql1,ql2)
C      print *, 'pvmix4 after standard linear mix, q+ + q-'
C      print *, 'ql',ib,ql1(1),ql2(1)
C#endif

C --- Subtract smoothed (1-betal)*rhos + betal*rhns ---
      if (locm0 >= 1 .and. locm0 <= 3) then
        call splrho(20,nsp,nr,nlml,rhos1,rhos2,rho3)
        call splrho(20,nsp,nr,nlml,rhns1,rhns2,rhn3)
        np = nr*nlml*nsp
        call daxpy(np,-(1-betal),rhos1,1,rho1,1)
        call daxpy(np,-betal,rhns1,1,rho1,1)
        call daxpy(np,-(1-betal),rhos2,1,rho2,1)
        call daxpy(np,-betal,rhns2,1,rho2,1)
        call splrho(21,nsp,nr,nlml,rhos1,rhos2,rho3)
        call splrho(21,nsp,nr,nlml,rhns1,rhns2,rhn3)
      endif

C      print *,srfpi*(ddot(nr,rho1,1,rwgt,1)),
C     .  srfpi*ddot(nr,rho1(1,1,nsp),1,rwgt,1)
C      print *,srfpi*(ddot(nr,rho2,1,rwgt,1)),
C     .  srfpi*ddot(nr,rho2(1,1,nsp),1,rwgt,1)


C     debugging
C#ifdefC DEBUG
C      call pvmixa(nr,nlml,nsp,rho1,rho2,rwgt,ql1,ql2)
C      print *, 'pvmix4 linear mix after subtracting reference'
C      print *, 'ql',ib,ql1(1),ql2(1)
C#endif

C ... Restore rho,amag -> rho+,rho-
      call splrho(1,nsp,nr,nlml,rho1,rho2,rho3)
      call splrho(1,nsp,nr,nlml,rhn1,rhn2,rhn3)

      if (iprint() > 30) then
        write(stdo,100) ib,qold,qnew,qnew,dif,qmix
  100   format(' site ',i4,f12.6,5f14.6)
C  100   format(' site ',i4,f12.6,f14.6,14x,2f14.6)
C        if (nsp == 2) write(stdo,101) amold,amnew,amix
C  101   format(' mmom   ',2f14.6,28x,f14.6)
        if (nsp == 2) call info5(30,0,0,' mmom%;17,6D%;14,6D%28f%;14,6D',
     .     amold,amnew,amix,0,0)
      endif

      end

      subroutine pvmix5(nmix,mxsav,fnam,ifi,lbin,rmsdel,locmix,nbas,kmxr,nlm0,
     .  s_site,s_spec,s_rold,s_rnew,nsp,co,cn,ng,ng0,cnst,nda,a,qkl,rms2,nmixr)
C- Copy rho into holding array, read prior iterations from disk
C ----------------------------------------------------------------------
Cio Structures
Cio  s_site :struct for site-specific data; see structures.h
Ci     Elts read: spec rho1x rho2x rho2 rho1 rhoc rhocx
Ci       rho[12c]  are input local density (see rhold below)
Ci       rho[12c]x are output local density  (see rhnew below)
Co     Stored:    *
Cio    Passed to: rhogkl
Cio  s_spec :struct for species-specific data; see structures.h
Ci     Elts read: a nr rmt lmxl z qc rg
Co     Stored:    *
Cio    Passed to: rhogkl corprm
Ci Inputs
Ci   rhold :(stored as rho[12c] in s_site; see above)
Ci         :input local density this iteration,
Ci         :transformed into unscaled rho1+rho2 and rho1-rho2 (pvmix9)
Ci   rhnew :(stored as rho[12c]x in s_site; see above)
Ci         :output local density this iteration,
Ci         :transformed into unscaled rho1+rho2 and rho1-rho2 (pvmix9)
Ci   nmix  :number of prior iterations sought (for printout)
Ci   mxsav :max no. prior iteration to read, also dimensions a
Ci   fnam  :file name (for printout)
Ci   ifi   :file logical unit; sign delineates whether copying into
Ci         :or out of holding array
Ci   lbin  :T if binary read
Ci  rmsdel :Same as rms2 (see Outputs), from prior iteration.
Ci         :If no prior iteration, rsmdel=0.  For printout only.
Ci  locmix :governs mapping of local densities for mixing
Ci         :see Local variables in subroutine mixrho.
Ci  nbas   :size of basis
Ci   nsp   :2 for spin-polarized case, otherwise 1
Ci   co    :input smooth density this iteration, in FT form
Ci   cn    :output smooth density this iteration, in FT form
Ci   ng    :leading dimension of co,cn
Ci   ng0   :number of Fourier coefficients
Ci   cnst  :site-dependent vector marking whether to constrain
Ci         :selected mixing (not used here)
Co Inputs/Outputs
Cio  nmixr :(output for ifi>0) number of prior iter read from file
Cio        :(input  for ifi<0) number of prior iter written to file
Cio        :on output number of prior iterations read from file
Cio  a,nda :work array a and leading dimension (nda must be >= na)
Cio         a(*,i,1) holds f(xi) for iteration i-1
Cio         a(*,i,2) holds   xi  for iteration i-1
Co Outputs
Co  qkl    :(locmix>=2) G_kL expansion of local densities
Co         : qkl(:,:,isp,1,ib) = rho1(rhold), G_kL expansion
Co         : qkl(:,:,isp,2,ib) = rho2(rhold), G_kL expansion
Co         : qkl(:,:,isp,3,ib) = rho1(rhnew), G_kL expansion
Co         : qkl(:,:,isp,4,ib) = rho2(rhnew), G_kL expansion
Co         : Note: if locmix=3, l=0 part of qkl is zero'd:
Co         : qkl(:,1,:,:,1:nbas) = 0
Co  rms2   :rms difference in f-x, where f=output density and x the
Co          input density.  f and x include smoothed and local
Co          contributions, with the latter depending on choice of
Co          linear transformation; see locmix above.  Thus, there
Co          is some arbitrariness in rms2.
Cr Remarks
Cr   Content of a(*) = a(*,isp,:,:):
Cr   Case locmix = 0:
Cr     a(1:2*ng0) = Fourier coffs of sm density (hermitian => ng0<ng)
Cr     a(1+2*ng0:2*ng0+2*nr) = l=0 part of rho(1), rho(2)
Cr     ... nda = 2*ng0 + 2*nr
Cr   Case locmix = 1:
Cr     a(1:2*ng0) = Fourier coffs of sm density (hermitian => ng0<ng)
Cr     a(1+2*ng0:2*ng0+2*nr) = Weighted l=0 part of rho(1), rho(2)
Cr     ... nda = 2*ng0 + 2*nr
Cr   Case locmix = 2
Cr     a(1:2*ng0) = Fourier coffs of sm density (hermitian => ng0<ng)
Cr     a(1+2*ng0:2*ng0+(1+kmxr)*nlml) = P_kL expansion of rho1-rho2
Cr     ... nda = 2*ng0 + (1+kmxr)*nlml
Cr   Case locmix = 3
Cr     a(1:2*ng0) = Fourier coffs of sm density (hermitian => ng0<ng)
Cr     a(1+2*ng0:2*ng0+2*nr) = Weighted l=0 part of rho(1), rho(2)
Cr     a(1+k:2*ng0:2*ng0+2*nr+(1+kmxr)*nlml) = P_kL exp. of rho1-rho2
Cr                                             w/ l=0 part zeroed out
Cr     ... nda = 2*ng0 + 2*nr + (1+kmxr)*nlml
Cr   Case locmix = 4
Cr     a(1:2*ng0) = Fourier coffs of sm density (hermitian => ng0<ng)
Cu Updates
Cu   05 Jul 13 Replace f77 pointers with f90 ones
Cu   10 Nov 11 Begin migration to f90 structures
C -----------------------------------------------------------------
      use structures
      implicit none
C ... Passed parameters
      logical lbin
      integer ng,ng0,nda,nmix,mxsav,ifi,nbas,nr,nsp,cnst(0:1),locmix,
     .  kmxr,nlm0
      double precision a(nda,nsp,mxsav+2,2),rms2,rmsdel
      double precision co(2,ng,nsp),cn(2,ng,nsp),
     .  qkl(0:kmxr,nlm0,nsp,4,1)
      character fnam*8
C ... For structures
!      include 'structures.h'
      type(str_site)::  s_site(*)
      type(str_spec)::  s_spec(*)
      type(str_rhat):: s_rold(*),s_rnew(*)
C ... Dynamically allocated local arrays
      real(8), allocatable :: rofi(:)
      real(8), allocatable :: rwgt(:)
C ... Local parameters
      integer awrite,i,ib,iprint,is,j,k,lgunit,lmxl,locm0,
     .  locm1,m,mpipid,na,nlml,nmixr,np,off,stdo,intopt,nglob
      logical lcnst,lfdmp,lddump,lfail
      double precision ddot,rmt,aat,rf,ql1(2,2),ql2(2,2)
      double precision xx,qmom1(144*2,2),qmom2(144*2,2),srfpi
C     for MPI
      integer procid, master
      logical mlog,cmdopt
      character strn*120

      master = 0
      procid = mpipid(1)
      mlog = cmdopt('--mlog',6,0,strn)
      stdo = lgunit(1)
      lcnst = cnst(0) > 0
      locm0 = mod(locmix,10)
      locm1 = mod(locmix/10,10)
      srfpi = dsqrt(16d0*datan(1d0))
      intopt = 10*nglob('lrquad')

C --- Copy rho to a; calc. RMS error; read prior iter from ifi ---
      if (ifi > 0) then

C   ... FT Mesh density
        na = 1
        if (ng0 > 0) then
        do  i = 1, nsp
          call dpcopy(co(1,1,i),a(na+00,i,1,2),1,2*ng0,1d0)
          call dpcopy(cn(1,1,i),a(na+00,i,1,1),1,2*ng0,1d0)
        enddo
        endif
        na = 1 + 2*ng0

C   ... Site densities, depending on locm0
        do  ib = 1, nbas
        is = s_site(ib)%spec
        aat = s_spec(is)%a
        nr = s_spec(is)%nr
        rmt = s_spec(is)%rmt
        lmxl = s_spec(is)%lmxl
        if (lmxl == -1) cycle
        rf = rmt/3
        if (locm1 == 1) rf = 100
        nlml = (lmxl+1)**2
        allocate(rofi(nr),rwgt(nr))
        call radmsh(rmt,aat,nr,rofi)
        call radwgt(intopt,rmt,aat,nr,rwgt)

C   ... If site is constrained, freeze density at rhold (not checked)
        if (lcnst) then
          if (cnst(ib) /= 0) then
            do  i = 1, nsp
            off = 1+nr*nlml*(i-1)
            call dpscop(s_rold(ib)%rho1,s_rnew(ib)%rho1,nr,off,off,1d0)
            call dpscop(s_rold(ib)%rho2,s_rnew(ib)%rho2,nr,off,off,1d0)
            enddo
          endif
        endif

C   --- Copy local densities to mix matrix a, depending on locm0 ---
Ctest   mch tmp/rho1 tmp/rho2 -+ out.fe -- -coll 2,18  -px
C       call prrmsh('1 orig',rofi,s_site(1)%rho1,nr,nr,nlml*nsp)
C       call prrmsh('rhold2',rofi,s_site(1)%rho2,nr,nr,nlml*nsp)

C   ... rho1+rho2 -> weighted rho1+rho2, for mixing (old,new rho)

C        print *, '!!',srfpi*ddot(nr,s_rold(ib)%rho1(1,1),1,rwgt,1)
C        print *, '!!',srfpi*ddot(nr,s_rold(ib)%rho1(1,1+nlml),1,rwgt,1)

        call pvmix9(10*locm1,0,nr,nlml*nsp,0,rf,rofi,s_rold(ib)%rho1,s_rold(ib)%rho2)
        call pvmix9(10*locm1,0,nr,nlml*nsp,0,rf,rofi,s_rnew(ib)%rho1,s_rnew(ib)%rho2)
C       call prrmsh('1 scl',rofi,s_site(1)%rho1,nr,nr,nlml*nsp)
C       call prrmsh('2 scl',rofi,s_site(1)%rho2,nr,nr,nlml*nsp)
C       call prrmsh('1 scl',rofi,s_site(1)%rho1x,nr,nr,nlml*nsp)
C       call prrmsh('2 scl',rofi,s_site(1)%rho2x,nr,nr,nlml*nsp)
C       if (ib == 3) then
C         call shorho(3,'old after pvmix9',nr,nlml,nsp,rofi,
C    .      rwgt,s_rold(ib)%rho1,s_rold(ib)%rho2)
C         call shorho(3,'new after pvmix9',nr,nlml,nsp,rofi,
C    .      rwgt,s_rnew(ib)%rho1,s_rnew(ib)%rho2)
C       endif

C   ... (Scaled) sphere multipole moments for modes that use it
C       call pvmixa(nr,nlml,nsp,s_rold(ib)%rho1,s_rold(ib)%rho2,
C    .    rwgt,ql1,ql2)
C       call pvmixa(nr,nlml,nsp,s_rnew(ib)%rho1,s_rnew(ib)%rho2,
C    .    rwgt,ql1(1,2),ql2(1,2))
        call pvrhom(11,nlml,nr,nsp,rofi,rwgt,s_rold(ib)%rho1,
     .    s_rold(ib)%rho2,xx,xx,xx,xx,xx,xx,xx,qmom1)
        call pvrhom(12,nlml,nr,nsp,rofi,rwgt,s_rold(ib)%rho1,
     .    s_rold(ib)%rho2,xx,xx,xx,xx,xx,xx,xx,qmom2)
        call pvrhom(11,nlml,nr,nsp,rofi,rwgt,s_rnew(ib)%rho1,
     .    s_rnew(ib)%rho2,xx,xx,xx,xx,xx,xx,xx,qmom1(1,2))
        call pvrhom(12,nlml,nr,nsp,rofi,rwgt,s_rnew(ib)%rho1,
     .    s_rnew(ib)%rho2,xx,xx,xx,xx,xx,xx,xx,qmom2(1,2))

        ql1(1,1) = srfpi*qmom1(1,1) ! spin 1 old rho1+rho2
        ql2(1,1) = srfpi*qmom2(1,1) ! spin 1 old rho1-rho2
        ql1(1,2) = srfpi*qmom1(1,2) ! spin 1 new rho1+rho2
        ql2(1,2) = srfpi*qmom2(1,2) ! spin 1 new rho1-rho2
        if (nsp == 2) then
          ql1(2,1) = srfpi*qmom1(1+nlml,1) ! spin 2 old rho1+rho2
          ql2(2,1) = srfpi*qmom2(1+nlml,1) ! spin 2 old rho1-rho2
          ql1(2,2) = srfpi*qmom1(1+nlml,2) ! spin 2 new rho1+rho2
          ql2(2,2) = srfpi*qmom2(1+nlml,2) ! spin 2 new rho1-rho2
        endif

C   ... Copy spherical part of rho1+rho2 (scaled), rho1-rho2 to a
C       NB: Increment na after all actions takend w/ local densities
        if (locm0 == 0 .or. locm0 == 3) then
          do  i = 1, nsp
            off = 1+nr*nlml*(i-1)
            call dpscop(s_rold(ib)%rho1,a(na+00,i,1,2),nr,off,1,1d0)
            call dpscop(s_rold(ib)%rho2,a(na+nr,i,1,2),nr,off,1,1d0)
            call dpscop(s_rnew(ib)%rho1,a(na+00,i,1,1),nr,off,1,1d0)
            call dpscop(s_rnew(ib)%rho2,a(na+nr,i,1,1),nr,off,1,1d0)
C           print *, ib, dval(s_rnew(ib)%rho1,nr+off-1),
C     .                  dval(s_rnew(ib)%rho2,nr+off-1)
C           print*,ib,na+nr-1,na+2*nr-1,
C     .       a(na+nr-1,i,1,1),a(na+2*nr-1,i,1,1)
          enddo

        elseif (locm0 == 1) then
          do  i = 1, nsp
            a(na+00,i,1,2) = ql1(i,1) ! old q1+q2
            a(na+01,i,1,2) = ql2(i,1) ! old q1-q2
            a(na+00,i,1,1) = ql1(i,2) ! new q1+q2
            a(na+01,i,1,1) = ql2(i,2) ! new q1-q2
C#ifdefC DEBUG
C            if (ib == 3) then
C            print *, 'coff entering mixing a',
C     .          a(na+00,i,1,2),a(na+01,i,1,2)
C            print *, 'coff entering mixing a',
C     .          a(na+00,i,1,1),a(na+01,i,1,1)
C            endif
C#endif
          enddo
        endif
C       print *, 'a(nr)'
C       print *, a(na+nr-1,:,1,:)

C   ... locm0>=2 : qkl <- G_kL expansion of rho; copy coffs to a
        if (locm0 >= 2 .and. locm0 < 4) then
          do  i = 1, nsp
            call pshpr(iprint()-30)
            call rhogkl(ib,ib,i,2,rf*0,s_site,s_spec,s_rold,kmxr,
     .        qkl(0,1,i,1,ib))
            call rhogkl(ib,ib,i,3,rf*0,s_site,s_spec,s_rold,kmxr,
     .        qkl(0,1,i,2,ib))
            call rhogkl(ib,ib,i,10002,rf*0,s_site,s_spec,s_rnew,kmxr,
     .        qkl(0,1,i,3,ib))
            call rhogkl(ib,ib,i,10003,rf*0,s_site,s_spec,s_rnew,kmxr,
     .        qkl(0,1,i,4,ib))
            call poppr
C           Convert qkl for 2nd spin channel into true 2nd channel,
C           since rhogkl expansion combines channels 1+2
            if (i == 2) then
              j = (1+kmxr)*nlm0
C             qkl(nsp=2) -> qkl(nsp=1) - qkl(nsp=2)
              do  m = 1, 4
               call dpsadd(qkl(0,1,1,m,ib),qkl(0,1,1,m,ib),j,1+j,1,-1d0)
              enddo
            endif

C           locm0=3 : zero out spherical part of G_kL
C           print *, '!! skip zero qkl'
            if (locm0 == 3) then
              do  m = 1, 4
                call dpzero(qkl(0,1,i,m,ib),kmxr+1)
              enddo
            endif

C           Copy qkl into a
            np = (1+kmxr)*nlml
            call dpscop(qkl(0,1,i,1,ib),a(na+2*nr+00,i,1,2),np,1,1,1d0)
            call dpscop(qkl(0,1,i,2,ib),a(na+2*nr+np,i,1,2),np,1,1,1d0)
            call dpscop(qkl(0,1,i,3,ib),a(na+2*nr+00,i,1,1),np,1,1,1d0)
            call dpscop(qkl(0,1,i,4,ib),a(na+2*nr+np,i,1,1),np,1,1,1d0)

          enddo                 ! end of spin loop
C         call prmx('qkl',qkl,1+kmxr,1+kmxr,nlm0*nsp)
        endif

C   ... Undo weighting of rho1+rho2
        call pvmix9(10*locm1,-1,nr,nlml*nsp,0,rf,rofi,s_rold(ib)%rho1,s_rold(ib)%rho2)
        call pvmix9(10*locm1,-1,nr,nlml*nsp,0,rf,rofi,s_rnew(ib)%rho1,s_rnew(ib)%rho2)
C       call prrmsh('1 rest',rofi,s_site(1)%rho1,nr,nr,nlml*nsp)
C       call prrmsh('2 rest',rofi,s_site(1)%rho2,nr,nr,nlml*nsp)

C   ... Increment index na to a
        if (locm0 == 0) then
          na = na + 2*nr
        elseif (locm0 == 1) then
          na = na + 2
        elseif (locm0 == 2) then
          na = na + 2*np
        elseif (locm0 == 3) then
          na = na + 2*nr + 2*np
        elseif (locm0 == 4) then
        endif

        deallocate(rofi,rwgt)
        enddo                     !Loop over sites
        na = na-1
        if (nda /= na) call rx('mixrho: bug in pvmix5')
        na = na*nsp
C       call prmx('a',a,nda,na,1)
        rms2 = dsqrt(dabs(ddot(na,a,1,a,1)     -
     .             2*ddot(na,a,1,a(1,1,1,2),1) +
     .               ddot(na,a(1,1,1,2),1,a(1,1,1,2),1))/(na-0))*nsp
        if (mxsav == 0) return
C   ... File I/O of previous iterations; nmixr is number actually read
        nmixr = 0

C    ... File read: not MPI compatible
C        if (lbin) read (ifi,err=31,end=31) nmixr, na
C        if (.not. lbin) read (ifi,*,err=31,end=31) nmixr, na
C        if (nda*nsp /= na) then
C          call awrit2(' mixrho:  expecting %i elements but found %i ...'
C     .      //' discarding file',' ',100,stdo,nda*nsp,na)
C          nmixr = 0
C          goto 31
C        endif
C        k = min(mxsav,nmixr)
C        do  j = 1, k
C          if (lbin) then
C            if (.not. lddump(a(1,1,j+1,1),na,ifi)) goto 31
C            if (.not. lddump(a(1,1,j+1,2),na,ifi)) goto 31
C          else
C            if (.not. lfdmp(a(1,1,j+1,1),na,ifi)) goto 31
C            if (.not. lfdmp(a(1,1,j+1,2),na,ifi)) goto 31
C          endif
C          nmixr = j
C        enddo
C   31   continue
C   ... MPI-compatible file read

        lfail = .true.
        if (procid == master) then
          lfail = .false.
          if (lbin) read (ifi,err=311,end=311) nmixr, na
          if (.not. lbin) read (ifi,*,err=311,end=311) nmixr, na
          goto 312
  311     continue
          lfail = .true.
  312     continue
        endif
        call mpibc1(lfail,1,1,mlog,'mixrho','read error')
        call mpibc1(nmixr,1,2,mlog,'mixrho','nmixr')
        call mpibc1(na,1,2,mlog,'mixrho','na')
        if (lfail) goto 31
        if (nda*nsp /= na) then
          call info2(10,0,0,' mixrho:  expecting %i elements but '//
     .      'found %i ... discarding file',nda*nsp,na)
          nmixr = 0
          goto 31
        endif
        k = min(mxsav,nmixr)
        if (procid == master) then
          lfail = .false.
          do  j = 1, k
            if (lbin) then
              if (.not. lddump(a(1,1,j+1,1),na,ifi)) lfail = .true.
              if (.not. lddump(a(1,1,j+1,2),na,ifi)) lfail = .true.
            else
              if (.not. lfdmp(a(1,1,j+1,1),na,ifi)) lfail = .true.
              if (.not. lfdmp(a(1,1,j+1,2),na,ifi)) lfail = .true.
            endif
              if (lfail) exit
            nmixr = j
          enddo
        endif
        call mpibc1(nmixr,1,2,mlog,'mixrho','nmixr')
        if (nmixr > 0) then
          call mpibc1(a,nda*nsp*(mxsav+2)*2,4,mlog,'mixrho','mix')
        endif
   31   continue
        if (iprint() >= 20) then
          j = awrite('%x mixrho:  sought %i iter from file',
     .      strn,len(strn),0,nmix,0,0,0,0,0,0,0)
          strn(j+2:len(strn)) = fnam
          call awrit2('%a; read %i.  RMS DQ=%1,3;3e',strn,100,0,nmixr,rms2)
          if (rmsdel /= 0) call awrit1('%a  last it=%1,3;3e',strn,100,0,rmsdel)
          call awrit0('%a',strn,-len(strn),-stdo)
        endif
C       call prm('a after read',a,nda*nsp,nda*nsp,(mxsav+2)*2)

C --- Save iterations on disk ---
      elseif (procid == master) then
        rewind (-ifi)
        if (lbin) write (-ifi) min(nmix+1,mxsav), nda*nsp
        if (.not. lbin) write (-ifi,*) min(nmix+1,mxsav), nda*nsp
        do  j = 1, min(nmix+1,mxsav)
          if (lbin) then
            call dpdump(a(1,1,j,1),nda*nsp,ifi)
            call dpdump(a(1,1,j,2),nda*nsp,ifi)
          else
            call dfdump(a(1,1,j,1),nda*nsp,ifi)
            call dfdump(a(1,1,j,2),nda*nsp,ifi)
          endif
        enddo
C       call prm('a after write',a,nda*nsp,nda*nsp,(mxsav+2)*2)
        endif

      end

      subroutine pvmix6(broy,nmix,mmix,mxsav,beta,wc,nda,a)
C- Mixing of the total density
C ------------------------------------------------------------------
Ci  broy   : 0 for Anderson mixing
Ci         : 1 for Broyden mixing
Ci  nmix   : nmix: number of iter to try and mix
Ci  mmix   : number of iterates available to mix
Ci  mxsav  : second dimension of a
Cio Inputs/Outputs
Cio  a     :On input:
Cio         (*,i,1)  output vector for prev. iteration i
Cio         (*,i,2)  input  vector for prev. iteration i
Cio        :On output:
Cio         (*,0,1) and (*,0,2) estimated new vector
Cio         (*,i,1), i>1 destroyed
Cr  Remarks
Cr    Broyden mixing adapted from Duane Johnson.  Notation:
Cr    x^(m): input vector for iteration m
Cr    F^(m): difference between output and input vector in iteration m
C ------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer nda,nmix,mmix,mxsav,broy
      double precision beta,a(nda,0:mxsav+1,2)
C ... Local parameters
      integer j,iprint,amix
      double precision tjmax,tj(10),norm(100),kpvt(10),wc,wctrue,rms2
C     integer idamax
C     double precision dval,rmskm(100),rmsmx
      parameter (tjmax = 5d0)

C ... This is the result of linear mixing, q=0 smooth rho
C     sqmix = a(1,0,1)*beta + a(1,0,2)*(1-beta)

C --- Anderson mixing ---
      if (nmix == 0 .or. nmix == 1 .or. broy == 0) then
C ... amix needs f-x for prior iterations
      do  j = 1, nmix
        call daxpy(nda,-1d0,a(1,j,2),1,a(1,j,1),1)
      enddo
      call query('beta',4,beta)
      nmix = amix(nda,nmix,mxsav,0,beta,iprint(),tjmax,norm,kpvt,a,tj,
     .  rms2)
C      if (iprint() >= 20) write(stdo,101) strn,rms2,(tj(j), j=1,nmix)
C  101 format(1x,a4,':     rms diff',f10.6:'  tj=',5f8.3)
C     call prm('a out',a,nda,nda,(mxsav+2)*2)
C ... Copy x*=a(*,0,2) to a(*,0,1)
      call dcopy(nda,a(1,0,2),1,a(1,0,1),1)

C --- Broyden mixing, Duane Johnson's approach ---
      elseif (broy == 1) then
        call pqmixb(nda,nmix,mmix,mxsav,beta,wc,rms2,a,wctrue)
C   ... Copy x*=a(*,0,2) to a(*,0,1)
        call dcopy(nda,a(1,0,2),1,a(1,0,1),1)
      else
        call rx('pvmix6: bad value for broy')
      endif

C ... Add the change relative to linear mixing
C     sqmix = (a(1,0,1) - sqmix)*vol

      end

      subroutine pvmix7(s_site,s_spec,s_rho,s_rsav,nbas,nsp,nda,a,
     .  n1,n2,n3,k1,k2,k3,locmix,wt,kmxr,nlm0,qkl,ng,ng0,kv,ips0,gv,
     .  crho,wk,smrho)
C- Restore mixed density into specific arrays; assemble mixed local rho
C ----------------------------------------------------------------------
Cio Structures
Cio  s_site :struct for site-specific data; see structures.h
Ci     Elts read: spec rho2 rho1x rho2x rho1
Ci       rho[12c]  are mixed local density (see rhmix below)
Ci       rho[12c]x are ref local density  (see rhref below)
Co     Stored:    *
Cio    Passed to: *
Cio  s_spec :struct for species-specific data; see structures.h
Ci     Elts read: a nr rmt lmxl rg
Co     Stored:    *
Cio    Passed to: *
Cio  s_rho : the mixed local density
Ci     Elts read:  *
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:rho1 rho2
Cio    Passed to:  *
Cio  s_rsav  : the input local density, used to restore constrained parts of the mixed density
Ci     Elts read:  *
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:rho1 rho2
Cio    Passed to:  *
Ci Inputs
Ci   nbas  :size of basis
Ci   nsp   :2 for spin-polarized case, otherwise 1
Ci   nda   :leading dimension of a
Ci   a     :mixed density from pvmix6, smoothed + local densities
Ci         :For local parts, a contains SCALED rho1+rho2, rho1-rho2
Ci         :If locmix =  0,1, or 3, a contains spherical part on mesh
Ci         :If locmix =  2,3 a full rho, GkL expansion
Ci   n1..3 :FT mesh
Ci   k1..3 :dimensions smrho
Ci   locmix:mixing mode for local densities
Ci   ng    :number of FT G-vectors
Ci   ng0   :condensed number of G vector (excluding hermitian equiv)
Ci   kv    :indices for gather/scatter operations (gvlist.f)
Ci   ips0  :permutation array mapping ng0 vectors to ng vectors (lgstar)
Ci   gv    :list of reciprocal lattice vectors G (gvlist.f)
Ci   crho  :FT coefficients of smrho(G)
Ci   wk    :complex work array of dimension (k1,k2,k3)
Ci   smrho :smooth density that generated the hamiltonian
Cio Inputs/Outputs
Cio   rhmix:On input: local density that generated the hamiltonian,
Cio        :a portion of which which has been linearly mixed (pvmix4)
Cio        :rhmix(1) contains rho1+rho2;
Cio        :rhmix(2) contains rho1-rho2; see pvmix9
Cio        :On output:
Cio        :mixed local density is returned, in rho1+rho2,rho10rho2 form
Cio  rhref :mixed local density?
Co Outputs
Co   smrho :real space smooth density overwritten by mixed smooth density
Cr Remarks
Cu Updates
Cu   05 Jul 13 Replace f77 pointers with f90 ones
Cu   10 Nov 11 Begin migration to f90 structures
C ----------------------------------------------------------------------
      use structures
      implicit none
C ... Passed parameters
      integer nsp,n1,n2,n3,k1,k2,k3,ng,ng0,nda,na,nr,nbas,locmix,
     .  kv(ng,3),ips0(ng),kmxr,nlm0
      double precision gv(ng,3),a(nda,nsp),
     .  qkl(0:kmxr,nlm0,nsp,4,nbas),rf,wt(2)
      double complex crho(ng,nsp),smrho(k1,k2,k3,nsp),wk(k1,k2,k3)
C ... For structures
!      include 'structures.h'
      type(str_site)::  s_site(*)
      type(str_spec)::  s_spec(*)
      type(str_rhat):: s_rho(*),s_rsav(*)
C ... Dynamically allocated local arrays
      real(8), allocatable :: rofi(:)
      real(8), allocatable :: rwgt(:)
      type(dp_wk_vec) :: s_rsm(2)
C ... Local parameters
      integer i,ib,is,intopt,nglob,lmxl,locm0,locm1,m,nlml,np,off
      double precision aat,rmt,rg,xx,ql1(2),ql2(2),fac,fac2
      double precision qmom1(144*2),qmom2(144*2),srfpi,facmax
      parameter (facmax=5d0)

      locm0 = mod(locmix,10)
      locm1 = mod(locmix/10,10)
      srfpi = dsqrt(16d0*datan(1d0))
      intopt = 10*nglob('lrquad')

C ... Restore mixed smoothed density
      if (ng0 > 0) then
      do  i = 1, nsp
C       Add difference of mixed, old to minimize perturbation
        call dscal(2*ng0,-1d0,crho(1,i),1)
        call daxpy(2*ng0,1d0,a(1,i),1,crho(1,i),1)
C       call zprm('del cn-compress',0,crho,ng0,ng0,nsp)
        call lgstar(2,ng,1,gv,m,ips0,crho(1,i))
C       call zprm('del cn-mixed',0,crho,ng,ng,nsp)
        call gvputf(ng,1,kv,k1,k2,k3,crho(1,i),wk)
        call fftz3(wk,n1,n2,n3,k1,k2,k3,1,0,1)
        call daxpy(2*k1*k2*k3,1d0,wk,1,smrho(1,1,1,i),1)
      enddo
      endif

      if (locm0 == 4) return

C ... Update local densities
C     if (wt(1) == 0 .and. wt(2) == 0) return
      na = 1 + 2*ng0
      do  ib = 1, nbas
        is = s_site(ib)%spec
        aat = s_spec(is)%a
        nr = s_spec(is)%nr
        rmt = s_spec(is)%rmt
        lmxl = s_spec(is)%lmxl
        if (lmxl == -1) cycle
        rg = s_spec(is)%rg
        rf = rmt/3
        if (locm1 == 1) then
          rf = 100
        else
C         rg = rf
        endif
        nlml = (lmxl+1)**2
        allocate(rofi(nr),rwgt(nr))
        call radmsh(rmt,aat,nr,rofi)
        call radwgt(intopt,rmt,aat,nr,rwgt)

C       debugging: zero out residual density
C        call dpzero(s_rho(ib)%rho1,nr*nlml*nsp); print *, '!!'
C        call dpzero(s_rho(ib)%rho2,nr*nlml*nsp)

C   ... Scale lin mix rho1+rho2 to combine with A- or B-mixed density
C       call prrmsh('1 mix7a',rofi,s_rho(ib)%rho1,nr,nr,nlml*nsp)
C       call prrmsh('2 mix7a',rofi,s_rho(ib)%rho2,nr,nr,nlml*nsp)
        call pvmix9(10*locm1,0,nr,nlml*nsp,0,rf,rofi,
     .    s_rho(ib)%rho1,s_rho(ib)%rho2)
C       call prrmsh('1 mix7b',rofi,s_rho(ib)%rho1,nr,nr,nlml*nsp)
C       call prrmsh('2 mix7b',rofi,s_rho(ib)%rho1,nr,nr,nlml*nsp)

C   ... (Scaled) sphere multipole moments for modes that use it
C        call pvmixa(nr,nlml,nsp,s_rsav(ib)%rho1,s_rsav(ib)%rho2,
C     .    rwgt,ql1,ql2)

        call pvrhom(11,nlml,nr,nsp,rofi,rwgt,s_rsav(ib)%rho1,
     .    s_rsav(ib)%rho2,xx,xx,xx,xx,xx,xx,xx,qmom1)
        call pvrhom(12,nlml,nr,nsp,rofi,rwgt,s_rsav(ib)%rho1,
     .    s_rsav(ib)%rho2,xx,xx,xx,xx,xx,xx,xx,qmom2)
        ql1(1) = srfpi*qmom1(1)
        ql2(1) = srfpi*qmom2(1)
        if (nsp == 2) then
          ql1(2) = srfpi*qmom1(1+nlml)
          ql2(2) = srfpi*qmom2(1+nlml)
        endif

C   ... Overwrite spherical part of rhmix with scaled mixed rho
        if (locm0 == 0 .or. locm0 == 3) then
          do  i = 1, nsp
            off = 1 + nr*nlml*(i-1)
            call dpscop(a(na+00,i),s_rho(ib)%rho1,nr,1,off,1d0)
            call dpscop(a(na+nr,i),s_rho(ib)%rho2,nr,1,off,1d0)
          enddo
          na = na + 2*nr
        elseif (locm0 == 1) then  ! mixing charges

C          if (ib <= 2) then
C            call shorho(3,'ref,ib=',nr,nlml,nsp,rofi,rwgt,
C     .        s_rsav(ib)%rho1,s_rsav(ib)%rho2)
C            call shorho(3,'linear mixed, ib=',nr,nlml,nsp,rofi,
C     .        rwgt,s_rho(ib)%rho1,s_rho(ib)%rho2)
C          endif

C         Work with rho, mom, to satisfy constraints
          if (wt(1) == 0 .or. wt(2) == 0) then
            call splrho(20,nsp,nr,nlml,s_rsav(ib)%rho1,s_rsav(ib)%rho2,xx)
            call splrho(20,nsp,nr,nlml,s_rho(ib)%rho1,s_rho(ib)%rho2,xx)

C           This block probably not needed?  These parts of s_rho are restored below.
            np = nr*nlml
            if (wt(1) == 0) then
              call dvset(s_rho(ib)%rho1,1,np,0d0)
              call dvset(s_rho(ib)%rho2,1,np,0d0)
            endif
            if (wt(2) == 0 .and. nsp == 2) then
              call dvset(s_rho(ib)%rho1,1+np,np+np,0d0)
              call dvset(s_rho(ib)%rho2,1+np,np+np,0d0)
            endif

C            if (ib <= 2) then
C              call shorho(3,'ref, after cnst',nr,nlml,nsp,rofi,
C     .          rwgt,s_rsav(ib)%rho1,s_rsav(ib)%rho2)
C              call shorho(3,'lin mixed, after cst',nr,nlml,nsp,rofi,
C     .          rwgt,s_rho(ib)%rho1,s_rho(ib)%rho2)
C            endif

          endif
          do  i = 1, nsp
            off = 1 + nr*nlml*(i-1)

            fac = 1
            fac2 = 1
            if (wt(1) /= 0 .and. wt(2) /= 0) then
              fac = a(na+00,i)/ql1(i)
              fac2= a(na+01,i)/ql2(i)
            elseif (wt(1) == 0) then
              if (i == 1) then
                call dpscop(s_rsav(ib)%rho1,s_rho(ib)%rho1,np,1,1,1d0)
                call dpscop(s_rsav(ib)%rho2,s_rho(ib)%rho2,np,1,1,1d0)
                cycle
              endif
              if (abs(ql1(1)-ql1(2)) > 1d-6) then
                fac = (a(na+00,1)-a(na+00,2))/(ql1(1)-ql1(2))
              endif
              if (abs(ql2(1)-ql2(2)) > 1d-6) then
                fac2 = (a(na+01,1)-a(na+01,2))/(ql2(1)-ql2(2))
              endif
            elseif (wt(2) == 0) then
              if (i == 2) then
                call dpscop(s_rsav(ib)%rho1,s_rho(ib)%rho1,np,off,off,1d0)
                call dpscop(s_rsav(ib)%rho2,s_rho(ib)%rho2,np,off,off,1d0)
                cycle
              endif
              fac = (a(na+00,1)+a(na+00,2))/(ql1(1)+ql1(2))
              fac2= (a(na+01,1)+a(na+01,2))/(ql2(1)+ql2(2))
            endif

C       ... Limit factors deviating strongly from 1, imi
            if (fac < 0) then
              call info2(20,0,0,' mixrho (warning) negative '//
     .          'rho1 scaling site %i: fac=%d',ib,fac)
            endif
            if (abs(fac) > facmax) then
              call info5(20,0,0,' mixrho (warning) reduce large rho1 '//
     .          'scaling site %i: fac=%d -> %d',ib,fac,facmax,0,0)
              fac = dsign(1d0,fac)*facmax
            endif
            if (fac2 < 0) then
              call info2(20,0,0,' mixrho (warning) negative '//
     .          'rho2 scaling site %i: fac=%d',ib,fac2)
            endif
            if (abs(fac2) > facmax) then
              call info5(20,0,0,' mixrho (warning) reduce large rho2 '//
     .          'scaling site %i: fac=%d -> %d',ib,fac2,facmax,0,0)
              fac2 = dsign(1d0,fac2)*facmax
            endif

C           call dpscop(s_rsav(ib)%rho1,s_rho(ib)%rho1,nr,off,off,fac)
            call dpsadd(s_rho(ib)%rho1,s_rsav(ib)%rho1,nr,off,off,fac)
C           call dpscop(s_rsav(ib)%rho2,s_rho(ib)%rho2,nr,off,off,fac2)
            call dpsadd(s_rho(ib)%rho2,s_rsav(ib)%rho2,nr,off,off,fac2)

C            if (ib <= 2) then
C              call shorho(3,'mix,1+2,spin1+2,ib=2',nr,nlml,nsp,rofi,
C     .          rwgt,s_rho(ib)%rho1,s_rho(ib)%rho2)
C            endif

          enddo
          if (wt(1) == 0 .or. wt(2) == 0) then
          call splrho(21,nsp,nr,nlml,s_rsav(ib)%rho1,s_rsav(ib)%rho2,xx)
          call splrho(21,nsp,nr,nlml,s_rho(ib)%rho1,s_rho(ib)%rho2,xx)
          endif

C          if (ib <= 2) then
C            call shorho(3,'mix,rho1+2,ib=2',nr,nlml,nsp,rofi,
C     .        rwgt,s_rho(ib)%rho1,s_rho(ib)%rho2)
C          endif

          na = na + 2
        endif
C       call prrmsh('1 mix7c',rofi,s_site(1)%rho1,nr,nr,nlml*nsp)
C       call prrmsh('2 mix7c',rofi,s_site(1)%rho2,nr,nr,nlml*nsp)

C   ... Mixing mode 2,3: add mixed fit (scaled) density to existing rhmix
        if (locm0 >= 2) then

C         call prrmsh('1 scale',rofi,s_rho(ib)%rho1,nr,nr,nlml*nsp)
          np = (1+kmxr)*nlml
          do  m = 1, 2
            allocate(s_rsm(m)%p(nr*nlml*nsp))
            do  i = 1, nsp
              call dpscop(a(na+np*(m-1),i),qkl(0,1,i,m,ib),np,1,1,1d0)
            enddo
            i = 1001
            if (wt(1) == 0) i = 11001
            if (wt(2) == 0) i = 21001
            call pkl2ro(i,1,rg,kmxr,nr,nlml,nsp,rofi,rwgt,
     .        kmxr,nlm0,xx,qkl(0,1,1,m,ib),s_rsm(m)%p,xx,xx)
          enddo
C         Don't undo scaling of smoothed density since rho1+rho2 scaled
C          call pvmix9(10*locm1,-1,nr,nlml*nsp,0,rf,rofi,
C     .      s_rsm(1)%p,s_rsm(2)%p)
C         Add to rhmix(1,2)
          call daxpy(nr*nlml*nsp,1d0,s_rsm(1)%p,1,s_rho(ib)%rho1,1)
          call daxpy(nr*nlml*nsp,1d0,s_rsm(2)%p,1,s_rho(ib)%rho2,1)
          deallocate(s_rsm(1)%p,s_rsm(2)%p)

          na = na + 2*np
        endif
C       call prrmsh('1 mix7d',rofi,s_rho(ib)%rho1,nr,nr,nlml*nsp)
C       call prrmsh('2 mix7d',rofi,s_rho(ib)%rho2,nr,nr,nlml*nsp)

C   ... Undo scaling
        call pvmix9(10*locm1,-1,nr,nlml*nsp,0,rf,rofi,s_rho(ib)%rho1,s_rho(ib)%rho2)

C       Debugging
C#ifdefC DEBUG
C        call pvmixa(nr,nlml,nsp,s_rho(ib)%rho1,s_rho(ib)%rho2,
C     .    rwgt,ql1,ql2)
C        print *, 'charges at end of pvmix7'
C        print *, 'ql',ib,ql1(1),ql2(1)
C        if (ib == 3) then
CC        call prrmsh('rho1,mix',rofi,s_rho(ib)%rho1,nr,nr,nlml*nsp)
CC        call prrmsh('rho2,mix',rofi,s_rho(ib)%rho2,nr,nr,nlml*nsp)
C        endif
C#endif

        deallocate(rofi,rwgt)
      enddo                     !Loop over sites

      na = na-1
      if (nda /= na) call rx('mixrho: bug in pvmix7')

      end

C      subroutine pvmix8(mode,nr,nlml,nsp,rho1,rho2)
CC- Handle possible constraints for change in smooth density
CC ----------------------------------------------------------------------
CCi Inputs
CCi   mode  :a compound of digits :
CCi         :10s digit
CCi         :  0 apply to rho1 only; rho2 is not touched
CCi         :  1 apply to both rho1 and rho2
CCi         :100s digit for spin polarized case
CCi         :  1 zero out charge, rho1+ + rho1- (and rho2+ + rho2-)
CCi         :  2 zero out spin, rho1+ - rho1- (and rho2+ + rho2-)
CCi   nr    :number of radial mesh points
CCi   nlml  :L-cutoff for rho1,rho2
CCi   nsp   :2 for spin-polarized case, otherwise 1
CCio Inputs/Outputs
CCio  rho1  :overwritten with constraints controlled by mode
CCio  rho2  :overwritten with constraints controlled by mode
CCr Remarks
CCu Updates
CCu   16 Dec 08 First created
CC ----------------------------------------------------------------------
C      implicit none
CC ... Passed parameters
C      integer mode,nr,nlml,nsp
C      double precision rho1(nr,nlml,nsp),rho2(nr,nlml,nsp)
CC ... Local parameters
C      integer np,mode0,mode1,mode2,i
C      double precision xx
C
CC ... Setup
C      mode0 = mod(mode,10)
C      mode1 = mod(mode/10,10)
C      mode2 = mod(mode/100,10)
C      np = nr*nlml
C      if (mode2 == 0 .or. nsp /= 2) return
C
C      i = 20                   ! No core
C      if (mode1 == 0) i = 30 ! No rho2
C      call splrho(i,nsp,nr,nlml,rho1,rho2,xx)
C      if (mode2 == 1) then   ! Zero density
C        call dpzero(rho1(1,1,1),np)
C        if (mode1 /= 0) then ! Including rho2
C          call dpzero(rho2(1,1,1),np)
C        endif
C      endif
C      if (mode2 == 2) then   ! Zero spin
C        call dpzero(rho1(1,1,nsp),np)
C        if (mode1 /= 0) then ! Including rho2
C          call dpzero(rho2(1,1,nsp),np)
C        endif
C      endif
C      call splrho(i+1,nsp,nr,nlml,rho1,rho2,xx)
C
C      end
      subroutine pvmix9(mode,linv,nr,nlml,off,rf,rofi,rho1,rho2)
C- Transformation of local densities rho1,rho2 for mixing
C ----------------------------------------------------------------------
Ci Inputs
Ci   mode  :transformation mode; see Remarks
Ci         : mode  transform
Ci         : 1s digit
Ci         : <=0    do nothing
Ci         :  1     rho1 <= rho1+rho2  rho2 <= rho1-rho2
Ci         : 10s digit
Ci         : 10     scale rho1 by 1/rf
Ci         : 20     scale rho1 by 1/(1+(r/rf)**2)
Ci         : 30     scale rho1 by gaussian exp(-(r/rf)**2)
Ci   linv  :0  forward transform
Ci         :-1 inverse transform
Ci   nr    :number of radial mesh points
Ci   nlml  :number of L channels
Ci   off   :offset to start of first point (0 for first point)
Ci   rf    :factor used in scaling; see mode
Cio Inputs/Outputs
Ci   rho1  :On input, local true density, or the transformation
Ci         :of it if the inverse is to be made
Ci         :On output, some linear combination of rho1,rho2.
Ci   rho2  :On input, local smoothed density, or the transformation
Ci         :of it if the inverse is to be made
Ci         :On output, some linear combination of rho1,rho2
Cr Remarks
Cr   This routine takes as input rho1,rho2 and returns in
Cr   rho1,rho2 some linear combination of them, depending on mode
Cr   If linv=1, the inverse transform is done.
Cu Updates
Cu   18 Nov 01 First created
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer mode,nr,nlml,linv,off
      double precision rho1(nr,nlml),rho2(nr,nlml),rofi(nr),rf
C ... Local parameters
      integer i,ilm,mode0,mode1
      double precision ri

      if (mode <= 0) return
      mode0 = mod(mode,10)
      mode1 = mod(mode/10,10)
      call sanrg(.true.,linv,-1,0,'pvmix9:','linv')
      call sanrg(.true.,mode0,0,1,'pvmix9:','1s digit mode')
      call sanrg(.true.,mode1,0,3,'pvmix9:','10s digit mode')

C ... Forward
      if (linv == 0) then
        if (mode0 == 1) then
          call dsumdf(nr*nlml,1d0,rho1,off,1,rho2,off,1)
        endif

        if (mode1 /= 0) then
        do  ilm = 1, nlml
        do  i = 1, nr
          ri = rofi(i)/rf
          if (mode1 == 3) then
            rho1(i+off,ilm) = rho1(i+off,ilm) * exp(-ri**2)
          elseif (mode1 == 2) then
            rho1(i+off,ilm) = rho1(i+off,ilm) / (1 + ri**2)
          elseif (mode1 == 1) then
            rho1(i+off,ilm) = rho1(i+off,ilm) / rf
          endif
        enddo
        enddo
        endif

C ... Inverse
      else
        if (mode1 /= 0) then
        do  ilm = 1, nlml
        do  i = 1, nr
          ri = rofi(i)/rf
          if (mode1 == 3) then
            rho1(i+off,ilm) = rho1(i+off,ilm) * exp(ri**2)
          elseif (mode1 == 2) then
            rho1(i+off,ilm) = rho1(i+off,ilm) * (1 + ri**2)
          elseif (mode1 == 1) then
            rho1(i+off,ilm) = rho1(i+off,ilm) * rf
          endif
        enddo
        enddo
        endif

        if (mode0 == 1) then
          call dsumdf(nr*nlml,0.5d0,rho1,off,1,rho2,off,1)
        endif

      endif

C      call prrmsh('pvmix9 rho1',rofi,rho1,nr,nr,nlml)
C      call prrmsh('pvmix9,rho2',rofi,rho2,nr,nr,nlml)

      end

      subroutine pvmixa(nr,nlml,nsp,rho1,rho2,rwgt,q1,q2)
C- Charges from local density
C ----------------------------------------------------------------------
Ci Inputs
Ci   nr    :number of radial mesh points
Ci   nlml  :L-cutoff for charge density on radial mesh
Ci   nsp   :2 for spin-polarized case, otherwise 1
Ci   rho1  :local true density, tabulated on a radial mesh
Ci   rho2  :local smoothed density, tabulated on a radial mesh
Ci   rwgt  :radial mesh weights
Co Outputs
Co   q1    :q1(isp) = rho1 charge in channel isp
Co   q2    :q2(isp) = rho2 charge in channel isp
Cr Remarks
Cr
Cu Updates
Cu  09 Nov 09 First created
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer nr,nlml,nsp
      double precision rho1(nr,nlml,nsp),rho2(nr,nlml,nsp),q1(2),q2(2)
      double precision rwgt(nr)
C ... Local parameters
      integer i
      double precision ddot,srfpi

      srfpi = dsqrt(16d0*datan(1d0))
      do  i = 1, nsp
        q1(i) = srfpi*ddot(nr,rho1(1,1,i),1,rwgt,1)
        q2(i) = srfpi*ddot(nr,rho2(1,1,i),1,rwgt,1)
      enddo

      end
