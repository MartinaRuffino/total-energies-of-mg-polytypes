      subroutine iodmftdc(s_dmft,sigdc,nsp,ifi)
C- I/O of DMFT double counting terms
C ----------------------------------------------------------------------
Ci Inputs
Cio Structures
Cio  s_dmft
Ci     Elts read:  dcmode ndsig ncix l nicix
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:ncix nicix icix
Cio    Passed to:  ineqcix
Co Outputs
Co   sigdc :double counting, with same structure as delta
Co   ifi   :file logical unit, returned if data read from file
Cs Command-line switches
Cs   --dc~switches | --ldadc~switches  specifies how d.c. to be read.
Cs   The list must consist of
Cs        EITHER: nicix elements (constant for channels within a cix block)
Cs        OR:     ndsig elements (each channel gets its own d.c.)
Cs   Data can be generated by
Cs     1. an estimate for the omega->infinity limit of s_dmft%sig
Cs   Switches to create data
Cs     ~siginf[=#]  Absent the number, the d.c. term is taken from s_dmft%sig(nomg)
Cs                  Else, the omega->infty limit is estimated by extrapolating to 0
Cs                  a least-squares fit of sig to a linear function in 1/omega^2.
Cs     ~fn=filnam   If present, the d.c. estimate is written to filnam
Cs   Example 1:  --dc~siginf=2~fn=mydc
Cs
Cs   Data can be taken from
Cs     1. Data embedded in the command-line argument, following ~dc=
Cs     2. a file, the name following ~fn= in the command-line switch
Cs     Either way, the number of elements parsed must be nicix or ndsig
Cs     1. a list dc=... within the command-line argument --dc... or --ldadc...
Cs   Switches to read data
Cs     ~dc=... | ~fn=...
Cs                  One of these is required.  See above
Cs     ~cix         explicitly tells iodmft to read one scalar per cix block
Cs     ~spinav      Replace d.c. with spin-average (magnetic case only)
Cs   Example 1: a spin-polarized case with one cix block of d electrons.
Cs      --dc~spinav~dc=1,2,3,4,5,5,4,3,2,1
Cs   Example 2: two cix blocks, constant d.c. for each channel within a block
Cs      --dc~dc=1,2
Cs   Example 3: read d.c. from file
Cs      --dc~spinav~fn=mydc
Cl Local variables
Cl         :
Cb Bugs
Cb    this routine assumes spin is outer index, consistent with readindmfl.  Need check.
Cr Remarks
Cr   This is the main routine for estimating or reading double counting terms.
Cr   Its behavior is controlled by command line argument --dc~...
Cu Updates
Cu   16 Sep 18 (MvS) New ~siginf
Cu   29 Jun 18 (MvS) First created
C ----------------------------------------------------------------------
      use structures, only: str_dmft
      implicit none
C ... Passed parameters
      integer nsp,ifi
      double precision sigdc(*)
!       include 'structures.h'
      type(str_dmft)::  s_dmft
C ... Dynamically allocated local arrays
      integer, allocatable :: nicix(:)
      real(8), allocatable :: wk(:,:)
C ... Local parameters
      character(len=1) :: dc,strn*160
      integer i,j,k,nr,nc,cix,icix,nm,idsig,ndsig,ndsig2,dcmode,isp,procid
      integer nfit,ichan,isigind,nomg,idsig0
      double precision xx,ry,norm(2,2),rhs(2),cof(2),rmsfit,avgs,rmss
      real(8), parameter :: evbyry = 13.60569193d0 !? 1ry = 13.605 693 009(84) ev
      procedure(integer) :: isw,wordsw,fxst,fopna,rdm,a2vec,mpipid
      procedure(logical) :: cmdopt
      procedure(real(8)) :: ry2ev

      procid = mpipid(1)
!     dcmode = s_dmft%dcmode
      ndsig = s_dmft%ndsig
      ndsig2 = ndsig/2          ! offset to second spin, if there is one
      allocate(nicix(s_dmft%ncix))
      call ineqcix(s_dmft,s_dmft%ncix,nicix)
      call dpzero(sigdc,ndsig)
      dc = ' '
      if (cmdopt('--dc',4,0,strn)) then
        dc = strn(5:5)
      elseif (cmdopt('--ldadc',7,0,strn)) then
        dc = strn(8:8)
      else
        dcmode = 0
        return
      endif
      s_dmft%dcmode = 1
      ry = ry2eV(0)

C     Read from master node only
      if (procid == 0) then

C ... Extract from sigma(infinity)
      k = wordsw(strn,dc,'siginf','',j)
      if (k > 0) then
        j = k+7
        nfit = 1
        if (strn(j:j) == '=') then
          if (a2vec(strn,len(strn),j,2,', '//dc,3,1,1,i,nfit) /= 1)
     .      call rx('iodmftdc: failed to parse '//strn(k+1:))
        endif
        call info2(20,1,0,
     .    ' iodmftdc: estimate dc from sigma(inf) for %i block%-1j%?#(n==1)##s#. '//
     .    '%?#(n==1)#Use last freq in sigma#Fit sigma, last %-1j%i freq#'//
     .    '%N cix  icix   fit err      mean   std dev',
     .    s_dmft%nicix,nfit)

        if (nfit<0 .or. nfit>s_dmft%nomg-1) call rxi('bad value for nfit:',nfit)
        j = 0; idsig = 0; idsig0 = 1; nomg = s_dmft%nomg
        do  cix = 1, s_dmft%ncix ! loop all cix, selecting inequivalent ones
          if (nicix(cix) >= 0) cycle ! nicix(:)<0 => first of equivalent cix
          icix = iabs(s_dmft%icix(cix))
          avgs = 0; rmss = 0; nr = 0; rmsfit = 0
          do  ichan = s_dmft%nzsigi(cix-1)+1, s_dmft%nzsigi(cix)
            idsig = idsig+1
            isigind = s_dmft%iasig(4,ichan) ! iasig(4) knows about afm indexing
C       ... Use last point
            if (nfit <= 1) then
              sigdc(idsig) = s_dmft%sig(nomg,2*isigind-1)
C       ... Fit sig_i to A x_i + C, x_i = 1/w_i^2
            else
              call dpzero(norm,4); call dpzero(rhs,2)
              do  j = nomg-nfit+1, nomg
                xx = 1/(ry*s_dmft%omg(j))**2
                norm(2,2) = norm(2,2) + 1
                norm(1,2) = norm(1,2) + xx
                norm(2,1) = norm(2,1) + xx
                norm(1,1) = norm(1,1) + xx*xx
                rhs(1) = rhs(1) + xx*ry*s_dmft%sig(j,2*isigind-1)
                rhs(2) = rhs(2) + ry*s_dmft%sig(j,2*isigind-1)
              enddo
              call dinv22(norm,norm)
              cof(1) = norm(1,1)*rhs(1) + norm(1,2)*rhs(2)
              cof(2) = norm(2,1)*rhs(1) + norm(2,2)*rhs(2)
              sigdc(idsig) = cof(2)
              do  j = nomg-nfit+1, nomg
                xx = 1/(ry*s_dmft%omg(j))**2
                rmsfit = rmsfit + (cof(1)*xx + cof(2) - ry*s_dmft%sig(j,2*isigind-1))**2
              enddo
            endif
            avgs = avgs + sigdc(idsig); rmss = rmss + sigdc(idsig)**2; nr = nr+1
          enddo
          avgs = avgs / nr; rmsfit = sqrt(rmsfit/(nr*nfit))
          rmss = sqrt(max(rmss/nr - avgs*avgs,0d0))
          call info5(20,0,0,'%,4i %,4i%4f%,3;3g%20p%;12,5D%:1,5;5d',
     .      cix,icix,rmsfit,avgs,rmss)
          call info2(35,0,0,' dc%n:1,5;5d',nr,sigdc(idsig0))
          idsig0 = idsig+1
       enddo

        call rxx(idsig /= ndsig,'iodmftdc: problem with indexing cix blocks')

C   ... Record sigdc in file
        k = wordsw(strn,dc,'fn=','',j) + 4
        if (k > 4) then
          j = scan(strn(k:),dc//' ') + k-2
          ifi = fopna(strn(k:j),-1,0); rewind ifi
          call info2(20,0,0,' writing d.c. to file '//strn(k:j)//
     .      ', %i elements ... ',idsig,2)
          call awrit2('%% rows %i cols %i',' ',80,ifi,1,idsig)
          write(ifi,"(100f12.6)") sigdc(1:idsig)
        endif
        call rx0('completed dc estimate')
      endif

C ... Read numbers from file
      k = wordsw(strn,dc,'fn=','',j) + 4
      if (k > 4) then
        j = scan(strn(k:),dc//' ') + k-2
!       if (fxst(strn(k:j)) /= 1) call rx('iodmftdc : missing file '//strn(k:j))
        ifi = fopna(strn(k:j),-1,1); rewind ifi
        nr = 0; nc = 0
        i = rdm(ifi,0,0,' ',sigdc,nr,nc)
        call info2(20,0,-1,' iodmftdc: reading d.c. from file '//strn(k:j)//
     .    ', %i elements ... ',nr*nc,2)
        rewind ifi
        allocate(wk(nr,nc))
        i = rdm(ifi,0,nr*nc,' ',wk,nr,nc)
        call info2(20,0,0,'%?#(n==1)#ok#read failed#',i,2)
        i = nr*nc
C ... or from command line
      else
        ifi = 0
        j = wordsw(strn,'','dc=','',j) + 2
        if (j < 3) call rx('iodmftdc: failed to find "dc=" in argument '//strn)
        allocate(wk(ndsig,2))
        i = a2vec(strn,len(strn),j,4,', '//dc,3,2,ndsig,wk(1,2),wk)
        call info2(20,0,0,' iodmftdc: reading d.c. from command-line ... parsed %i element(s)',i,2)
      endif

C     ... Distribute
      if (i == ndsig .and. wordsw(strn,dc,'cix','',j) == 0) then
        call dcopy(ndsig,wk,1,sigdc,1)
      elseif (i == s_dmft%nicix) then ! one element for each inequivalent cix block
        j = 0; idsig = 0
        do  cix = 1, s_dmft%ncix ! loop all cix, selecting inequivalent ones
          if (nicix(cix) >= 0) cycle ! nicix(:)<0 => first of equivalent cix
          icix = iabs(s_dmft%icix(cix))
          nm = 2*s_dmft%l(icix)+1
          j = j+1
          do  isp = 0, nsp-1
            forall (i=idsig+ndsig2*isp+1:idsig+ndsig2*isp+nm) sigdc(i) = wk(j,1)
          enddo
          idsig = idsig+nm
       enddo
        call rxx(idsig*nsp/=ndsig,'iodmftdc: problem with indexing cix blocks')
      else
        call rx2('iodmftdc expects either nicix=%i or ndsig=%i elements',s_dmft%nicix,ndsig)
      endif
      deallocate(wk)

C ... Spin average (assumes 2nd spin follows first.  Need check)
      if (wordsw(strn,dc,'spinav','',j) > 0) then
        if (nsp /= 2 .or. mod(ndsig,2) /= 0) call rx('spinav not compatible with nsp=1')
        allocate(wk(ndsig,1))
        call dcopy(ndsig,sigdc,1,wk,1)
        call dscal(ndsig2,1d0/2,sigdc,1)
        call dpadd(sigdc,wk(1+ndsig2,1),1,ndsig2,1d0/2)
        call dcopy(ndsig2,sigdc,1,sigdc(1+ndsig2),1)
        deallocate(wk)
      endif

      endif ! master node

      call mpibc1(sigdc,ndsig,4,.false.,'','')

      call info2(30,0,0,' iodmftdc: dc = %n:1;6d',ndsig,sigdc)
      if (any(sigdc(1:ndsig)<0)) call rx('sigdc cannot be negative!')

      sigdc(1:ndsig) = sigdc(1:ndsig)/eVbyRy ! Assume sigmaDC a constant (as in Kristjian's implementation)

      end
