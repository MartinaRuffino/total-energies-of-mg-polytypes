#!/bin/tcsh -f

# A shell script testing operation of fp suite
# set verbose

alias call 'set retcall = \!\!:2 ; set callarg = \!\!:3 ; goto \!\!:1'
alias runjob 'set retcall = \!\!:1; set outfile = \!\!:2 ; set callarg = \!\!:3 ; goto runjob'
alias runrdcmd 'set retcall = \!\!:1; set rdcmdfmt = \!\!:2 ; set outfile = \!\!:3 ; set callarg = \!\!:4 ; goto runrdcmd'
alias findcmd  'set retcall = \!\!:1 ; set prog_cmd = \!\!:2 ; set path_name = \!\!:3 ; set make_path = \!\!:4 ; goto findcmd'
alias extract_res_n 'set retcall = \!\!:1; set testvar = \!\!:2 ; set refvar = \!\!:3 ; set keyword = \!\!:4  ; set arg_number = \!\!:5 ; set occur_number = \!\!:6 ; set sed_strn = \!\!:7 ; goto extract_res_n'
alias compare_res 'set retcall = \!\!:1; set keyword = \!\!:2 ; set testvar = \!\!:3 ; set refvar = \!\!:4 ; set tol = \!\!:5 ; set passvar = \!\!:6 ; goto compare_res'
alias compare_res_0 'set retcall = \!\!:1; set keyword = \!\!:2 ; set testvar = \!\!:3 ; set tol = \!\!:4 ; set passvar = \!\!:5 ; goto compare_res_0'
alias compare_resf 'set retcall = \!\!:1; set testvar = \!\!:2 ; set refvar = \!\!:3 ; set keyword = \!\!:4  ; set arg_number = \!\!:5 ; set occur_number = \!\!:6 ; set sed_strn = \!\!:7 ; goto compare_resf'
alias zcmpmfiles_res_0 'set retcall = \!\!:1; set keyword = \!\!:2 ; set tol = \!\!:3 ; set passvar = \!\!:4 ; set ndig = \!\!:5 ; set srcfile = \!\!:6 ; set reffile = \!\!:7 ; goto zcmpmfiles_res_0 '
alias zcmpmfiles_res_tol 'set retcall = \!\!:1; set keyword = \!\!:2 ; set tol = \!\!:3 ; set passvar = \!\!:4 ; set ndig = \!\!:5 ; set srcfile = \!\!:6 ; set reffile = \!\!:7 set nlines = \!\!:8; goto zcmpmfiles_res_tol '
alias cnvt_d_fmt  'set retcall = \!\!:1; set testvar = \!\!:2 ; set testval = \!\!:3 ; goto cnvt_d_fmt'
alias query 'set retcall = \!\!:1 ; set retcall2 = \!\!:2 ; set callarg = \!\!:3 ; goto query'

set allargs = ($argv)
set a
set slow
set testfile = $0
set testdir = $testfile:h
set topdir  = `cd $testdir/../..; pwd`
set tmpdir = $cwd
set space = '        '
set failed = 0
alias zcat 'gunzip -c'
alias zcat 'cat'

# set noindmfl

# Prepend current working-directory, top-level and related dir to path
set path = ($cwd $topdir $topdir/utils $topdir/testing $path)

set plot = `which fplot`
if (-x "$plot") then
  if `$plot -h | sed -n 1,1p | awk '{print ($1 == "fplot")}'` set have_fplot
endif
set mcx = `which mcx`
if (-x "$mcx") then
  if `$mcx --h |& sed -n 1,1p | awk '{print ($7 == "(vsn" && ($8 * 1 >= 1.04))}'` set have_mc
endif
set pldos = `which pldos`
if (-x "$pldos") then
  if `$pldos -h | sed -n 1,1p | awk '{print ($2 == "pldos")}'` set have_pldos
endif
# see if ghostscript is available
set gs = `which gs`
if (-x "$gs") then
  if `$gs --help | sed -n 1,1p | awk '{print ($2 == "Ghostscript")}'` set have_ghostscript
endif

# see if gnu grep is available
echo X | grep -A 1 X > & /dev/null
set retval = $status
if ($retval == 0) set gnu_grep

# --- Pick off switches ---
while (`echo $1 | sed -e 's/\(.\).*/\1/' `  ==  "-")

  set arg1 = $1; shift
  if ($?verb) echo test.dmft: parsing switch $arg1
  switch ($arg1)
    case "--quiet":
      set quiet
      unset slow
      breaksw
    case "--add0":
      set add0 = `which add0`
      if (! -x "$add0") then
        echo "test.dmft (abort): missing add0"
        exit
      endif
      breaksw
    case "--poszer":
      set poszer = `which poszer`
      if (! -x "$poszer") then
        echo "test.dmft (abort): missing poszer"
        exit
      endif
      breaksw
    case "--MPIK":
      set MPI
      set MPIK
      unset MPI
      breaksw
    case "--MPI":
      set MPI
      set MPIK
      unset MPIK
      breaksw
    case "--clean":
      set clean
      breaksw
    case "--veryclean":
      set clean
      set veryclean
      breaksw
    case "--no-iact*":
      unset slow
      breaksw
    case "--haveout":
      set haveout
      breaksw
    case "--list":
      goto showtests
      breaksw

    case "--whichexec"
      set quiet; unset quiet
      findcmd chk00 lmfdmft "$path" "$topdir"
      chk00:
      exit 0
      breaksw

    case "--libxc":
      set libxc
      breaksw

    case "--indmfl=no"
      set noindmfl
      breaksw

    case "--indmfl=yes"
      set noindmfl
      unset noindmfl
      breaksw

    case "--noplot*":
      set noplot
      set have_pldos
      unset have_pldos
      set have_fplot
      unset have_fplot
      breaksw
    case "--verb*":
      set verb = 1
      breaksw
    case "--so4":
      set so4
      breaksw

    case "--all":
      set mater_lst = (lsco ni niso nio lscoq ybco)
      set joblist
      while (`echo $1 | sed -e 's/\([0-9][0-9]*\)/-/'`  ==  "-")
        set joblist = ($joblist $1)
        shift
      end
      set pass
      set failed
      foreach i ($mater_lst)
        $testfile `echo $allargs | sed s/--all//g | sed -e 's/\([0-9][0-9]*\)//g' | sed -e 's/-add/-add0/g'` $i $joblist
        set retval = $status
        if ($retval != 0) then
          unset pass
          set failed = ($failed $i)
#  	  echo " $testfile : failed test $i ... aborting"
#            exit -1
        endif
      end
      if ($?clean) then
        exit
      else if ($?pass) then
        echo "$space all tests PASSED ($mater_lst)"
        exit
      else
        echo "$space checks FAILED for the following materials:  $failed"
        exit -1
      endif

    default:
      echo unrecognized switch $arg1
      goto usage
  endsw

end

echo ' '
echo "         ---- test.dmft: test DMFT driver program lmfdmft ---"

# --- use lsco as default in the absence of specific choice ---
if ($#argv == 0) then
  set ext = lsco
  echo "$space .... no file extension specified; use input file ctrl.$ext"
else
  set ext = $argv[1]
  shift
endif

if (! -e $testdir/$ext/ctrl.$ext) then
   echo ' '
   echo " test.dmft aborting ... missing file $testdir/ctrl.$ext"
   goto usage
endif

# Set joblisti = jobs set up for given material and copy lists
if ($ext == "lsco") then
  set joblisti = (1 2)
  echo '         Case lsco: DMFT setup for the Cu d orbitals in La2 Cu O4'
  set cplst = ($testdir/$ext/{ctrl.$ext,basp.$ext,indmfl.$ext})
else if ($ext == "ybco") then
  set joblisti = (1)
  echo '         Case ybco: Make hybridiztion function for given sig.inp'
  set cplst = ($testdir/$ext/{{ctrl,basp,sigm,rst,syml,indmfl,site}.$ext,sig.inp})
else if ($ext == "lscoq") then
  set joblisti = (1 2)
  echo '         Case lscoq: DMFT setup for the Cu d orbitals in La2 Cu O4, QSGW starting point'
  set cplst = ($testdir/$ext/{{ctrl,basp,sigm,rst,syml,syml2,indmfl,dos,site}.$ext,sig.inp})
  set sdostol = 1e-1
else if ($ext == "ni") then
  set joblisti = (1 2 3)
  echo '         Case Ni: DMFT setup for the Ni d orbitals in elemental Ni, QSGW starting point'
  set cplst = ($testdir/$ext/{{ctrl,indmfl,rst,sigm,site}.ni,atparms})
  set rmlst = specialspec1
  set dqtol3 = 1e-6
else if ($ext == "niso") then
  set joblisti = (1 4)
  echo '         Case niso: Test with QSGW+DMFT starting point in elemental Ni'
  set cplst = ($testdir/$ext/{{ctrl,basp,indmfl,rst,sigm,site,syml2,socscl}.niso,sig.inp})
  set rmlst = ({gii,syml2,site,sigm,rst,indmfl,ctrl,basp,sig2,gii,se,se,wkp,moms,evec,proj,out.lmfdmft-gk,log,gloc,gkloc}.$ext sig.inp sigm.in)
  set eimptol = 1e-5
else if ($ext == "nio") then
  set joblisti = (1)
  echo '         Case nio: Test DMFT from QSGW+DMFT starting point in AFM nio'
  set cplst = ($testdir/../../gwd/test/$ext.code2/{basp.$ext,rst.$ext,sigm.in,site.$ext} $testdir/$ext/{ctrl.$ext,indmfl.$ext,sig.inp})
  set rmlst = ({gii,syml2,site,sigm,rst,indmfl,ctrl,basp,sig2,gii,se,se,wkp,moms,evec,proj,out.lmfdmft-gk,log,gloc,gkloc}.$ext sig.inp)
  set eimptol = 1e-5
else
  echo test.dmft: No test case for $ext
  exit -1
endif
if ( $?joblist == 0 ) then
set joblist = ($argv)
if ( $#joblist == 0 ) set joblist = (1 2 3)
endif

echo $joblist | grep 1 >/dev/null
if ($status) goto chk1e
echo $joblisti | grep 1 >/dev/null
if ($status) goto chk1e

cat <<EOF

         --- Test 1.  Basic check of lmfdmft ---
         Checks that the hybridization function (delta.$ext) and impurity level (eimp1.$ext)
         are correctly generated.

EOF

if (! $?quiet) then
if ($ext == "lsco") then
cat <<EOF
         The lsco test illustrates the DMFT driver to CTQMC for Cu d states, in an LDA potential.
         This test uses a potential from a Mattheis construction for testing purposes.
         A realistic calculation make the LDA density self-consistent first.

         lmfdmft is run three times:
           1. (job=0) makes lattice.lsco and class.lsco
           2. (job=1) makes file sig.inp and stops (no sig.inp is supplied to the program)
           3. (job=1) runs the DMFT setup, making delta and eimp

         This test uses Haule's k-independent normalization (KNORM=0).
         You can alternatively try a k-dependent normalization after this test completes:
           lmfdmft lsco -vnk=4 --rs=0,0 --ldadc=82.2 -job=1 -vknorm=1
         The two kinds of normalization should generate very similar delta.lsco and eimp.lsco.
         Compare eimp calculated by lmfdmft against the test result:
	   diff eimp1.lsco dmft/test/lsco/eimp1.knorm1.lsco

         You can also test the Fermi level finder in "insulator mode".
           lmfdmft lsco -vnk=4 --rs=0,0 --ldadc=82.2 -job=1 -vzinsul=.001
         The Fermi level, delta, and eimp1  should be practically unchanged.
         Compare eimp against the test result:
	   diff eimp1.lsco dmft/test/lsco/eimp1.insulmode.lsco

EOF
else if ($ext == "lscoq") then
cat <<EOF
         The lscoq test checks the DMFT driver to CTQMC for Cu d states, in an QSGW potential.

EOF
else if ($ext == "ybco") then
cat <<EOF
         The ybco test checks the DMFT driver in an QSGW potential for 3 (2 independent) correlation blocks

EOF
else if ($ext == "ni") then
cat <<EOF
         The ni test checks the DMFT driver to CTQMC for d states, in a QSGW potential, for ferromagnetic Ni.

         A second pass is made using --gprt:mode=3 to create local Green's functions in files gloc.ni and gkloc.ni

EOF
else if ($ext == "niso") then
cat <<EOF
         The niso test checks the DMFT driver to CTQMC for d states, in a QSGW potential, for ferromagnetic Ni with SO coupling.

         A second pass is made using --gprt:mode=3 to create local Green's functions in files gloc.niso and gkloc.niso

EOF
else if ($ext == "nio") then
cat <<EOF
         The nio test checks the DMFT driver to CTQMC in antiferromagnetic NiO, starting QSGW potential"

EOF
endif # materials system
endif # ! quiet

set refout=$testdir/$ext/out.lmfdmft.$ext testout=out.lmfdmft.$ext

if (! -e $refout) then
  echo "$space ... skipping test : missing reference file $refout"
  goto chk1e
endif

set pass
#  echo DEBUG ; goto chk12
query chk11 chk1e 'run this test'
chk11:
# ... Look for executables
findcmd chk11a rdcmd "$path" "optional"
chk11a:
findcmd chk11b lmf "$path" "$topdir"
chk11b:
findcmd chk11c lmfdmft "$path" "optional"
chk11c:

if ($?haveout) goto chk12a

# echo 'DEBUG'; goto chk12a

# ... Setup: remove existing files and copy new ones
echo "$space rm -f {{ctrl,log,mixm,moms,out.lmfdmft,rst,wkp,delta,eimp,eimp1,gmloc,gmlocinv,proj_plot_dmftub,proj_plot_dmftu,olapm_zinv,olapm_cmpinv,gmlocbefinv,olpprint,olpeigen,proj_renormdmftu,dosdmftu,iorb,sigm}.$ext,dmftomegas,evlk,sig.inp}"
             rm -f {{ctrl,log,mixm,moms,out.lmfdmft,rst,wkp,delta,eimp,eimp1,gmloc,gmlocinv,proj_plot_dmftub,proj_plot_dmftu,olapm_zinv,olapm_cmpinv,gmlocbefinv,olpprint,olpeigen,proj_renormdmftu,dosdmftu,iorb,sigm}.$ext,dmftomegas,evlk,sig.inp}
if ($?rmlst) then
echo "$space rm -f $rmlst"
             rm -f $rmlst
endif

if ($?clean) then
  touch ctrl.$ext
  echo "$space" rm *.$ext
                rm *.$ext
  goto chk1e
else
  echo "$space cp $cplst ."
               cp $cplst .
endif

if ($ext == "nio") then
  echo "$space cp sigm.in sigm.nio"
               cp sigm.in sigm.nio
endif

if ($?noindmfl) then
  echo "$space ... removing file indmfl.$ext"
  rm -f indmfl.$ext
endif

# ... Run lmfdmft program
if ($?MPIK && ! $?clean) then
  egrep  '^TMPDMFT' ctrl.$ext >/dev/null
  if ($status) then
    echo "$space ... no category TMPDMFT ... skipping MPI calculation"
    goto chk1e
  endif
  runrdcmd chk12 %11f $testout "-cat:TMPDMFT --noerr ctrl.$ext"
else if (! $?clean) then
  runrdcmd chk12 %11f $testout "-cat:TSTDMFT --noerr ctrl.$ext"
else
  if (-e ctrl.$ext) then
    runrdcmd chk11e %11f . "-cat:CLEAN --noerr ctrl.$ext"
chk11e:
  endif
  echo "$space rm -f ctrl.$ext semi.mater"
               rm -f ctrl.$ext semi.mater
  goto chk1e
endif
chk12:

if ($?add0) then
  echo -n "         ..." ; $add0 $testout
else if ($?poszer) then
  echo -n "         ..." ; $poszer $testout
endif

if ($?add0) then
  echo -n "         ..." ; $add0 lattice.$ext
else if ($?poszer) then
  echo -n "         ..." ; $poszer lattice.$ext
endif


chk12a:

if (! $?quiet) then

 call zdiffiles chk1d0 "CPU -1 $testout $refout"
chk1d0:

endif

# pass checks

if ! ($?eimptol) set eimptol = 2e-6

if (-r lattice.$ext) then
zcmpmfiles_res_0 chk1cka "Max deviation in lattice.$ext from reference $testdir/$ext/lattice.$ext" $eimptol pass 6 lattice.$ext $testdir/$ext/lattice.$ext
chk1cka:
endif
zcmpmfiles_res_0 chk1ckb "Max deviation in eimp1.$ext from reference $testdir/$ext/eimp1.$ext" $eimptol pass 6 eimp1.$ext $testdir/$ext/eimp1.$ext
chk1ckb:
zcmpmfiles_res_0 chk1ckc "Max deviation in delta.$ext from reference $testdir/$ext/delta.$ext" $eimptol pass 6 delta.$ext $testdir/$ext/delta.$ext
chk1ckc:

if (-e gloc.$ext && -e $testdir/$ext/gloc.$ext) then
set ndig = 4
set retval = `cmp -l gloc.$ext $testdir/$ext/gloc.$ext |& grep -v EOF | wc | awk '{printf "%d", $1}'`
echo -n "$space ... files gloc.$ext and $testdir/$ext/gloc.$ext equivalent to $ndig digits? ... "
if ($retval == 0) then
  echo yes
else
  echo -n "no ... to 3 digits? ... "
  set ndig = 3
  call zcmpnfiles cha1a1 "$ndig gloc.$ext $testdir/$ext/gloc.$ext"
  cha1a1:
  if ($retval == 0) then
    echo yes
  else if (`echo ' ' | awk -v ndiff=$retval -v ntot=$ncharfile '{print (100*ndiff/ntot<1.)}'` == 1) then
    echo ok "($retval difference(s) of $ncharfile)"
  else
    echo no "($retval difference(s) remaining of $ncharfile)"
    unset pass
  endif
endif
endif

if (-e gkloc.$ext && -e $testdir/$ext/gkloc.$ext) then
set ndig = 4  nl = 50
echo -n "$space ... files gkloc.$ext and $testdir/$ext/gkloc.$ext equivalent to $ndig digits? ... "
call zcmpnfiles cha1a2 "nlines=$nl $ndig gkloc.$ext $testdir/$ext/gkloc.$ext"
  cha1a2:
  if ($retval == 0) then
    echo yes
  else if (`echo ' ' | awk -v ndiff=$retval -v ntot=$ncharfile '{print (100*ndiff/ntot<1.)}'` == 1) then
    echo ok "($retval difference(s) of $ncharfile)"
  else
    echo no "($retval difference(s) remaining of $ncharfile)"
    unset pass
  endif
endif

chk1e0:

if ($?pass) then
    echo "$space test 1 PASSED ($ext)"
else
    echo "$space test 1 FAILED ($ext)"
    set failed = ($failed 1)
endif

chk1e:

echo $joblist | grep 2 >/dev/null
if ($status) goto chk2e
echo $joblisti | grep 2 >/dev/null
if ($status) goto chk2e


cat <<EOF

         --- Test 2.  Basic check lmfdmft's DOS maker ---

EOF

if (! $?quiet) then
if ($ext == "lsco") then
cat <<EOF
         Test 2 generates the DOS in two ways:
            using lmf's implementation of the tetrahedron method (DOS for noninteracting hamiltonian)
            using lmfdmft's implementation of G on the Matsubara frequencies (DOS by analytic continuation).
            Note: this expression is only correct near the Fermi level, or if sigma is static

         The lsco test compares an LDA calculation of the DOS, using DMFT machinery
         with Green's functions calculated on the Matsubara axis.
         In this test there is no dynamical self-energy

EOF
else if ($ext == "lscoq") then
cat <<EOF
         The lscoq test calculates the interacting band structure and DOS for a self-energy generated by QSGW+DMFT.
         It does the following:
         1. Compares the DOS from the QSGW hamiltonian computed by lmf to file dos.lscoq
            It is not calculated in this test, but the following command should generate it:
            lmf lscoq -vnkabc=12 --dos@npts=721@ef0@rdm@window=-6/13.606,6/13.606 --quit=dos
         2. Uses a Pade approximation to analytically continue the self-energy to the real axis
         3. Runs lmfdmft and lmfgws along symmetry lines to make a band structure
         4. Runs lmfdmft on a regular mesh of points to make the DOS.

EOF
else if ($ext == "ni") then
cat <<EOF
         Test 2 generates the DOS in two ways:
            using lmf's implementation of the tetrahedron method (DOS for noninteracting hamiltonian)
            using lmfdmft's implementation of G on the Matsubara frequencies (DOS by analytic continuation).
            Note: this expression is only correct near the Fermi level, or if sigma is static

         with Green's functions calculated on the Matsubara axis.
         The ni test calculates the DOS for spin polarized elemental Ni.
         In this test there is no dynamical self-energy.

EOF
endif # materials system
endif # ! quiet

set refout=$testdir/$ext/out.lmfdmft-dos.$ext testout=out.lmfdmft-dos.$ext

if (! -e $refout) then
  echo "$space ... skipping test : missing reference file $refout"
  goto chk2e
endif

set pass
query chk21 chk2e 'run this test'
chk21:
# ... Look for executables
findcmd chk21a rdcmd "$path" "optional"
chk21a:
findcmd chk21b lmf "$path" "$topdir"
chk21b:
findcmd chk21c lmfdmft "$path" "optional"
chk21c:

if ($?haveout) goto chk22

# ... Setup: remove existing files and copy new ones
echo "$space rm -f {{ctrl,log,mixm,moms,out.lmfdmft,rst,wkp,delta,eimp,eimp1,gmloc,gmlocinv,proj_plot_dmftub,proj_plot_dmftu,olapm_zinv,olapm_cmpinv,gmlocbefinv,olpprint,olpeigen,proj_renormdmftu,dosdmftu,iorb}.lsco,dmftomegas,evlk,sig.inp}"
             rm -f {{ctrl,log,mixm,moms,out.lmfdmft,rst,wkp,delta,eimp,eimp1,gmloc,gmlocinv,proj_plot_dmftub,proj_plot_dmftu,olapm_zinv,olapm_cmpinv,gmlocbefinv,olpprint,olpeigen,proj_renormdmftu,dosdmftu,iorb}.lsco,dmftomegas,evlk,sig.inp}

if ($?clean) then
  touch ctrl.$ext
  echo "$space" rm *.$ext
                rm *.$ext
  goto chk2e
else
  echo "$space rm -f sigm.$ext"
               rm -f sigm.$ext
  echo "$space cp $cplst ."
               cp $cplst .
endif

if ($?noindmfl) then
  echo "$space ... removing file indmfl.$ext"
  rm -f indmfl.$ext
endif

# ... Run lmf and lmfdmft programs for dos
if ($?MPIK && ! $?clean) then
  egrep  '^TMPDOS' ctrl.$ext >/dev/null
  if ($status) then
    echo "$space ... no category TMPDOS ... skipping MPI calculation"
    goto chk2e
  endif
  runrdcmd chk22 %11f $testout "-cat:TMPDOS --noerr ctrl.$ext"
else
  runrdcmd chk22 %11f $testout "-cat:TSTDDOS --noerr ctrl.$ext"
endif

if ($?add0) then
  echo -n "         ..." ; $add0 $testout
else if ($?poszer) then
  echo -n "         ..." ; $poszer $testout
endif

if ($?add0) then
  echo -n "         ..." ; $add0 lattice.$ext
else if ($?poszer) then
  echo -n "         ..." ; $poszer lattice.$ext
endif

chk22:

if (! $?quiet) then
 call zdiffiles chk2d0 "CPU -1 $testout $refout"
chk2d0:

endif

if ! ($?sdostol) set sdostol = 1e-4
if ! ($?dostol) set dostol = 1e-4

# pass checks
if ($ext == "lscoq") then
set nl = 2000
zcmpmfiles_res_tol chk2a1 "Max deviation in ($nl lines) spq.$ext from reference $testdir/$ext/spq.$ext" $dostol pass 6 spq.$ext $testdir/$ext/spq.$ext $nl
chk2a1:
zcmpmfiles_res_tol chk2a2 "Max deviation in ($nl lines) dos.$ext from reference $testdir/$ext/dos.$ext" $dostol pass 6 dos.$ext $testdir/$ext/dos.$ext $nl
chk2a2:
zcmpmfiles_res_tol chk2a3 "Max deviation in ($nl lines) sdos.$ext from reference $testdir/$ext/sdos.$ext" $sdostol pass 6 sdos.$ext $testdir/$ext/sdos.$ext $nl
chk2a3:

# Materials other than lscoq
else

# Compare dos to reference
set ndig = 4
set retval = `cmp -l doslmf.$ext $testdir/$ext/doslmf.$ext |& grep -v EOF | wc | awk '{printf "%d", $1}'`
echo -n "$space ... files doslmf.$ext and $testdir/$ext/doslmf.$ext equivalent to $ndig digits? ... "
if ($retval == 0) then
  echo yes
else
  echo -n "no ... to 3 digits? ... "
  set ndig = 3
  call zcmpnfiles cha2a1 "$ndig doslmf.$ext $testdir/$ext/doslmf.$ext"
  cha2a1:
  if ($retval == 0) then
    echo yes
  else if (`echo ' ' | awk -v ndiff=$retval -v ntot=$ncharfile '{print (100*ndiff/ntot<1.)}'` == 1) then
    echo ok "($retval difference(s) of $ncharfile)"
  else
    echo no "($retval difference(s) remaining of $ncharfile)"
    unset pass
  endif
endif

set ndig = 4
set retval = `cmp -l doslmfdmft.$ext $testdir/$ext/doslmfdmft.$ext |& grep -v EOF | wc | awk '{printf "%d", $1}'`
echo -n "$space ... files doslmfdmft.$ext and $testdir/$ext/doslmfdmft.$ext equivalent to $ndig digits? ... "
if ($retval == 0) then
  echo yes
else
  echo -n "no ... to 3 digits? ... "
  set ndig = 3
  call zcmpnfiles cha2a2 "$ndig doslmfdmft.$ext $testdir/$ext/doslmfdmft.$ext"
  cha2a2:
  if ($retval == 0) then
    echo yes
  else if (`echo ' ' | awk -v ndiff=$retval -v ntot=$ncharfile '{print (100*ndiff/ntot<1.)}'` == 1) then
    echo ok "($retval difference(s) of $ncharfile)"
  else
    echo no "($retval difference(s) remaining of $ncharfile)"
    unset pass
  endif
endif
endif


if ($?pass) then
    echo "$space test 2 PASSED ($ext)"
else
    echo "$space test 2 FAILED ($ext)"
    set failed = ($failed 2)
endif

chk2e:

echo $joblist | grep 3 >/dev/null
if ($status) goto chk3e
echo $joblisti | grep 3 >/dev/null
if ($status) goto chk3e
cat <<EOF

         --- Test 3.  Check of lmfdmft's density maker ---
         Checks the output density generated by lmfdmft

EOF
endif

if (! $?quiet) then
if ($ext == "lsco") then
echo "$space lsco not set up for job 3"
goto chk3e
else if ($ext == "lscoq") then
echo "$space lscoq not set up for job 3"
goto chk3e
else if ($ext == "ni") then
set tqtol3 = 1e-6
cat <<EOF
         This test compares the density generated:
         1. By lmf, using tetrahedron (fully self-consistent QSGW potential)
         2. By lmf, using Fermi function at kT=1/50 eV (effects of finite T)
         3. By lmfdmft, which should compare to 2.

EOF
endif # materials system
endif # ! quiet

set refout=$testdir/$ext/out.lmfdmft-rho.$ext testout=out.lmfdmft.$ext
if (! -e $refout) then
  echo "$space ... skipping test : missing reference file $refout"
  goto chk3e
endif

set pass
#  echo DEBUG ; goto chk32
query chk31 chk3e 'run this test'
chk31:
# ... Look for executables
findcmd chk31a rdcmd "$path" "optional"
chk31a:
findcmd chk31b lmf "$path" "$topdir"
chk31b:
findcmd chk31c lmfdmft "$path" "optional"
chk31c:

if ($?haveout) goto chk32a

# ... Setup: remove existing files and copy new ones
echo "$space rm -f {{ctrl,log,mixm,moms,out.lmfdmft,rst,wkp,delta,eimp,eimp1,gmloc,gmlocinv,proj_plot_dmftub,proj_plot_dmftu,olapm_zinv,olapm_cmpinv,gmlocbefinv,olpprint,olpeigen,proj_renormdmftu,dosdmftu,iorb,sigm}.$ext,dmftomegas,evlk,sig.inp}"
             rm -f {{ctrl,log,mixm,moms,out.lmfdmft,rst,wkp,delta,eimp,eimp1,gmloc,gmlocinv,proj_plot_dmftub,proj_plot_dmftu,olapm_zinv,olapm_cmpinv,gmlocbefinv,olpprint,olpeigen,proj_renormdmftu,dosdmftu,iorb,sigm}.$ext,dmftomegas,evlk,sig.inp}
if ($?rmlst) then
echo "$space rm -f $rmlst"
             rm -f $rmlst
endif

if ($?clean) then
  touch ctrl.$ext
  echo "$space" rm *.$ext
                rm *.$ext
  goto chk3e
else
  echo "$space cp $cplst ."
               cp $cplst .
endif

if ($?noindmfl) then
  echo "$space ... removing file indmfl.$ext"
  rm -f indmfl.$ext
endif

# ... Run lmfdmft program
if ($?MPIK && ! $?clean) then
  egrep  '^TMDMRHO' ctrl.$ext >/dev/null
  if ($status) then
    echo "$space ... no category TMDMRHO ... skipping MPI calculation"
    goto chk3e
  endif
  runrdcmd chk32 %11f $testout "-cat:TMDMRHO --noerr ctrl.$ext"
else if (! $?clean) then
  runrdcmd chk32 %11f $testout "-cat:TDMRHO --noerr ctrl.$ext"
else
  if (-e ctrl.$ext) then
    runrdcmd chk31e %11f . "-cat:CLEAN --noerr ctrl.$ext"
chk31e:
  endif
  echo "$space rm -f ctrl.$ext semi.mater"
               rm -f ctrl.$ext semi.mater
  goto chk3e
endif
chk32:

if ($?add0) then
  echo -n "         ..." ; $add0 $testout
else if ($?poszer) then
  echo -n "         ..." ; $poszer $testout
endif

if ($?add0) then
  echo -n "         ..." ; $add0 lattice.$ext
else if ($?poszer) then
  echo -n "         ..." ; $poszer lattice.$ext
endif

if (! $?quiet) then
 call zdiffiles chk3d0 "CPU -1 $testout $refout"
chk3d0:
endif

chk32a:

# pass checks

if ("$ext" == ni) then
  set dqtetr   = (`extract-lines 'START LMF' Exit 1 $testout | grep 'RMS DQ=' | vextract . DQ`)
  set dqFermi  = (`extract-lines 'START LMF' Exit 2 $testout | grep 'RMS DQ=' | vextract . DQ`)
  set dqDMFT   = (`extract-lines 'START LMF' Exit 4 $testout | grep 'RMS DQ=' | vextract . DQ`)
endif

if (! $?quiet) then
if ("$ext" == ni) then
  echo
  echo "$space lmf RMS DQ, tetrahedron integration   = $dqtetr"
  echo "$space lmf RMS DQ, Fermi function integr     = $dqFermi"
  echo "$space lmfdmft RMS DQ, Matsubara frequencies = $dqDMFT"
  echo

endif  # ni
endif

call qprint chk36 "$space ... automatic pass checks :"
chk36:

if ("$ext" == ni) then
compare_res chk36a "Compare RMS DQ, lmf(Fermi) to lmfdmft(Matsubara):" $dqFermi $dqDMFT $dqtol3 pass
chk36a:
endif

if ($?pass) then
    echo "$space test 3 PASSED ($ext)"
else
    echo "$space test 3 FAILED ($ext)"
    set failed = ($failed 3)
endif

chk3e:
echo $joblist | grep 4 >/dev/null
if ($status) goto chk4e
echo $joblisti | grep 4 >/dev/null
if ($status) goto chk4e
cat <<EOF

         --- Test 4.  Miscellaneous check of lmfdmft ---
EOF

if ($?quiet) goto chk40
if ($ext != "niso") then
  echo "$space $ext not set up for job 4"
else if ($ext == "niso") then
set tqtol3 = 1e-6
cat <<EOF

         This test for Ni (niso) starts from a QSGW+DMFT setup and does the following:
         1. Extrapolate sig.inp to the real axis using lmfdmft's Pade extrapolation feature
         2. Make k-resolved diagonal g_ii(k,omega) along lines in syml2  (mode 18)
         3. Make k-resolved diagonal sigm(k,omega) along lines in syml2  (mode 19)
         These quantities are remade with SO coupling added.
         The full cubic crystal symmetry is artificially retained to compare SO and non-SO cases.

EOF
endif # materials system
chk40:
set pass

# ... Look for executables
findcmd chk41a rdcmd "$path" "optional"
chk41a:
findcmd chk41b lmf "$path" "$topdir"
chk41b:
findcmd chk41c lmfdmft "$path" "optional"
chk41c:

set refout=$testdir/$ext/out.lmfdmft-gk.$ext testout=out.lmfdmft-gk.$ext
if (! -e $refout) then
  echo "$space ... skipping test for gkloc: missing reference file $refout"
  goto chk4e
endif

query chk41 chk4e 'run this test'
chk41:

if ($?haveout) goto chk43a

# ... Setup: remove existing files and copy new ones
if ($?rmlst) then
echo "$space rm -f $rmlst"
             rm -f $rmlst
endif

if ($?clean) then
  touch ctrl.$ext
  echo "$space" rm *.$ext
                rm *.$ext
  goto chk4e
else
  echo "$space cp $cplst ."
               cp $cplst .
endif

if ($?noindmfl) then
  echo "$space ... removing file indmfl.$ext"
  rm -f indmfl.$ext
endif

# ... Run lmfdmft program
egrep  '^TSTMISC' ctrl.$ext >/dev/null
if (! $status && ! $?MPIK && ! $?clean) then
  runrdcmd chk42 %11f $testout "-cat:TSTMISC --noerr ctrl.$ext"
endif
chk42:

egrep  '^TMPMISC' ctrl.$ext >/dev/null
if (! $status && $?MPIK && ! $?clean) then
  runrdcmd chk43 %11f $testout "-cat:TMPMISC --noerr ctrl.$ext"
endif
chk43:

if ($?clean && -e ctrl.$ext) then
  runrdcmd chk4e %11f . "-cat:CLEAN --noerr ctrl.$ext"
endif

if ($?add0) then
  echo -n "         ..." ; $add0 $testout
else if ($?poszer) then
  echo -n "         ..." ; $poszer $testout
endif

if ($?add0) then
  echo -n "         ..." ; $add0 lattice.$ext
else if ($?poszer) then
  echo -n "         ..." ; $poszer lattice.$ext
endif

if (! $?quiet) then
 call zdiffiles chk4d0 "CPU -1 $testout $refout"
chk4d0:
endif

chk43a:

# pass checks

if ("$ext" == niso) then
  set dqtetr   = (`extract-lines 'START LMF' Exit 1 $testout | grep 'RMS DQ=' | vextract . DQ`)
  set dqFermi  = (`extract-lines 'START LMF' Exit 2 $testout | grep 'RMS DQ=' | vextract . DQ`)
  set dqDMFT   = (`extract-lines 'START LMF' Exit 4 $testout | grep 'RMS DQ=' | vextract . DQ`)
endif

if (! $?quiet) then
if ("$ext" == ni) then
  echo
  echo "$space lmf RMS DQ, tetrahedron integration   = $dqtetr"
  echo "$space lmf RMS DQ, Fermi function integr     = $dqFermi"
  echo "$space lmfdmft RMS DQ, Matsubara frequencies = $dqDMFT"
  echo

endif  # ni
endif  # ! quiet

call qprint chk46 "$space ... automatic pass checks :"
chk46:

if ("$ext" == niso) then
set nl = 200
set sigtol = 1e-6

zcmpmfiles_res_tol chk46a "Max deviation in ($nl lines) sig2.$ext from reference $testdir/$ext/sig2.$ext" $sigtol pass 8 sig2.$ext $testdir/$ext/sig2.$ext $nl
chk46a:
set nl = 700
zcmpmfiles_res_tol chk46b "Max deviation in ($nl lines) se.$ext from reference $testdir/$ext/se.$ext" $sigtol pass 8 se.$ext $testdir/$ext/se.$ext $nl
chk46b:
# zcmpmfiles_res_tol chk46c "Max deviation in ($nl lines) se.$ext from reference $testdir/$ext/se.$ext" $sigtol pass 8 se.$ext $testdir/$ext/se.$ext $nl
# chk46c:

if (-e gii.$ext) then
call zcmpnfiles chk46c "nlines=$nl 4 gii.$ext $testdir/$ext/gii.$ext"
chk46c:
if ("$retval" == 0) then
  echo "$space files $zcmpnargs[2] and $zcmpnargs[3] show no differences ... ok"
else if ("$retval" < 20 ) then
  echo "$space $retval differences comparing $zcmpnargs[2] $zcmpnargs[3] ... ok"
else
  echo "$space $retval differences comparing $zcmpnargs[2] $zcmpnargs[3]  ... FAILED"
  unset pass
endif
endif  # gii
endif  # niso

if ($?pass) then
    echo "$space test 4 PASSED ($ext)"
else
    echo "$space test 4 FAILED ($ext)"
    set failed = ($failed 4)
endif

chk4e:

# --- Summary ---
echo ' '
if ($#failed <= 1) then
    if ($?clean) exit 0
    echo "$space $testfile : all tests PASSED ($ext)"
    echo " "
    exit 0
else
    shift failed
    echo "$space $testfile : These tests FAILED:" $failed
    echo " "
    exit -1
endif

# ---------------- runjob --------------
exit
runjob:
  set quitjob=$retcall
  if ($outfile == ".") then
    echo "$space $callarg"
    echo " "
    $callarg
    set retval = $status
    if ($retval != 0) goto cleanup
    goto $quitjob
  endif

  if (`echo $outfile | awk '{print substr($1,1,2)}'` == '>>') then
    set appfile = `echo $outfile | awk '{print substr($1,3)}'`
    echo "$space $callarg  >> $appfile"
    $callarg >> $appfile
    set retval = $status
  else
    echo "$space $callarg  > $outfile"
    $callarg > $outfile
    set retval = $status
  endif
  if ($retval != 0) goto cleanup
  goto $quitjob

# ---------------- compare_resf --------------
# Extracts one element of a line in files $testout and $refout containing a keyword.
# Variables testout and refout point to file names and must be set beforehand ($refout is gzipped file)
# usage: compare_resf retcall testvar refvar keyword arg_number occur_number sed_strn
#   Variables testout and refout referring to file names must be set
#   testvar      : put result from file $testout into this variable
#   refvar       : put result from file $refout (compressed) into this variable
#   keyword    	 : string line must contain
#   arg_number 	 : extracts $arg_number'th entry in line, as defined by awk
#   occur_number : argument from $occur_number'th line; if zero, use last line
#   sed_strn     : purge this string from result before assigning
exit
compare_resf:
  set quitjob=$retcall
# echo $retcall $testvar $refvar $keyword $arg_number $occur_number $sed_strn
  set $testvar = `grep "$keyword" $testout | awk -v ncnt=0 -v num=$arg_number -v count=$occur_number '{ncnt+=1; if (ncnt==count || count == 0) {print $num}}' | sed "s/$sed_strn//" | tail -1`
  set $refvar = `zcat $refout | grep "$keyword" | awk -v ncnt=0 -v num=$arg_number -v count=$occur_number '{ncnt+=1; if (ncnt==count || count == 0) {print $num}}' | sed "s/$sed_strn//" | tail -1`
  goto $quitjob

# ---------------- extract_res_n --------------
# Extracts nth token in a line containing a keyword
# usage: extract_res_n retcall testvar refvar keyword arg_number occur_number sed_strn
#   Variables testout and refout referring to file names must be set ($refout is gzipped file)
#   keyword      : string line must contain
#   testvar      : put result from file $testout into this variable
#   refvar       : put result from file $refout (compressed) into this variable
#   arg_number   : extracts $arg_number'th entry in line, as defined by awk
#   occur_number : argument from $occur_number'th line; if zero, use last line
#   sed_strn     : delete this string with from result before assigning
exit
extract_res_n:
  set quitjob=$retcall
#  echo $retcall $testvar $refvar $keyword $arg_number $occur_number $sed_strn
  set $testvar = `grep "$keyword" $testout | awk -v ncnt=0 -v num=$arg_number -v count=$occur_number '{ncnt+=1; if (ncnt==count || count == 0) {print $num}}' | sed "s/$sed_strn//" | tail -1`
  set $refvar = `gunzip -c $refout | grep "$keyword" | awk -v ncnt=0 -v num=$arg_number -v count=$occur_number '{ncnt+=1; if (ncnt==count || count == 0) {print $num}}' | sed "s/$sed_strn//" | tail -1`
  goto $quitjob

# ---------------- runrdcmd --------------
exit
runrdcmd:
  set quitjob=$retcall
  if ($outfile == ".") then
    echo "$space Invoking rdcmd will execute the following job(s):"
    $rdcmd -f:$rdcmdfmt --n $callarg
    echo "$space $rdcmd '-f:rdcmd:%2f' $callarg"
                 $rdcmd '-f:rdcmd:%2f' $callarg
    set retval = $status
  else
    if (`echo $outfile | awk '{print substr($1,1,2)}'` == '>>') then
      set appfile = `echo $outfile | awk '{print substr($1,3)}'`
      echo "$space $callarg  >> $appfile"
      exit
#      $callarg >> $appfile
      set retval = $status
    else
      echo "$space ... the following job(s) will be executed by invoking "\""rdcmd $callarg"\"
      $rdcmd -f:$rdcmdfmt --n $callarg
      echo "$space ... starting invocation of rdcmd:"
      echo "$space $rdcmd '-f:#rdcmd:%2f' $callarg  >& $outfile"
      $rdcmd '-f:rdcmd:%2f' $callarg >& $outfile
      set retval = $status
    endif
  endif

  if ($retval == 0) then
    echo "$space Job(s) completed successfully; output in $outfile"
    if ($?poszer) then
      echo -n "         ..." ; $poszer $outfile
    else if ($?add0) then
      echo -n "         ..." ; $add0 $outfile
    endif
    goto $quitjob
  else
    echo "$space ...oops... the following command returned with nonzero exit status:"
    echo -n "$space   "
    grep $rdcmd:t{:} $outfile | tail -1 | sed 's/rdcmd:  //'
    goto cleanup
  endif

# ---------------- cleanup --------------
exit
cleanup:
  if ($retval != 0) echo "$space job returned with error status $retval"
  if ($retval != 0) echo "$space ... $testfile aborting"
  exit $retval

# ---------------- diffiles --------------
# calling argument should consist of four strings:
# 1st string = string that terminates diff
# 2nd string = integer that counts how many times terminator should occur before terminating
# 3nd string = first file name
# 4th string = second file name
# example: call diffiles chk69 "CPU 3 $testout $refout"
exit
diffiles:
  set quitjob=$retcall
  if ($?quiet) goto $quitjob
  set files = ($callarg)
  set endstr = $files[1]
  shift files
  set nend = $files[1]
  shift files
  if ($nend == "-1") then
    set nend = `grep "$endstr" $files[1] | wc | awk '{print $1}'`
  endif

#    echo difffiles : $quitjob $nend
#    grep $endstr $files[1]

  query diff11 $quitjob "compare $files"
diff11:
  diff $files | awk -v endstr=$endstr -v nend=$nend -v endl=0 -v endr=0 '{if ($1 == "<" && endl < nend) print ; if ($1 == ">" && endr < nend) print ; if ($1 == ">" || $1 == "<" || endl >= nend && endr >= nend) ; else {print} ; if ($1 == "<" && $2 == endstr) {endl+=1}; if ($1 == ">" && $2 == endstr) {endr+=1};}' | sed -n 1,50p
  goto $quitjob

# ---------------- zdiffiles --------------
# calling argument should consist of four strings:
# 1st string = string that terminates zdiff
# 2nd string = integer that counts how many times terminator should occur before terminating
#              -1 -> last occurence
# 3nd string = first file name
# 4th string = second file name
# example: call zdiffiles chk69 "CPU 3 $testout $refout"
exit
zdiffiles:
  set quitjob=$retcall
  if ($?quiet) goto $quitjob
  set files = ($callarg)
  set endstr = $files[1]
  shift files
  set nend = $files[1]
  shift files

  if ($nend == "-1") then
    set nend = `grep "$endstr" $files[1] | wc | awk '{print $1}'`
  endif

  if ( $?slow == 0 ) echo "$space ... compare $files"
  query zdiff11 $quitjob "compare $files"
zdiff11:
  zdiff -Icpudel -Iwritten $files | awk -v endstr="$endstr" -v nend=$nend -v endl=0 -v endr=0 '{if ($1 == "<" && endl < nend) print ; if ($1 == ">" && endr < nend) print ; if ($1 == ">" || $1 == "<" || endl >= nend && endr >= nend) ; else {print} ; if ($1 == "<" && $2 == endstr) {endl+=1}; if ($1 == ">" && $2 == endstr) {endr+=1};}' | sed -n 1,50p
  echo " "
  goto $quitjob

# ---------------- compare_res --------------
# Compares two numbers $testvar-$refvar and unsets $passvar if |testvar-refvar|<tol
# usage: compares_res retcall keyword testvar refvar tol passvar
#   keyword      : label (for printout)
#   testvar      : first number
#   refvar       : second number
#   tol          : tolerance
#   passvar      : $passvar is unset if |testvar-refvar|<tol
exit
compare_res:
  set quitjob=$retcall
# echo $retcall $keyword $testvar $refvar $tol $passvar
  set toll = `echo $tol | sed s/d/e/`
  echo -n "$space $keyword ($testvar) within tol ($toll) of reference ($refvar)? ... "
  if (`echo $testvar $refvar | awk -v tol=$toll '{{k=($1-$2)>0?($1-$2):($2-$1);tl=1.001*tol} print (k<=tl)}'`) then
    echo yes
  else
    echo no
    unset $passvar
  endif
  goto $quitjob

# ---------------- compare_res_0 --------------
# Compares a number $testvar and unsets $passvar if |testvar|<tol
# usage: compares_res_0 retcall keyword testvar tol passvar
# Example:
# compare_res_0 chk274a "Max deviation in pdos from reference" $retval $pdostol pass
#   keyword      : label (for printout)
#   testvar      : first number
#   tol          : tolerance
#   passvar      : $passvar is unset if |testvar|<tol
exit
compare_res_0:
  set quitjob=$retcall
#  echo $retcall $keyword $testvar $tol $passvar
  set toll = `echo $tol | sed s/d/e/`
  echo -n "$space $keyword ($testvar) within tol ($toll)? ... "
  if (`echo $testvar 0 | awk -v tol=$toll '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k<=tol)}'`) then
    echo yes
  else
    echo no
    unset $passvar
  endif
  goto $quitjob

# ---------------- zcmpmfiles_res_0 --------------
# Compares two files, stripping all but numerical fields.
# Checks for max absolute difference and unsets $passvar if difference<$tol
# Files with .gz or .Z extensions are assumed to be gzipped.
# usage: zcmpmfiles_res_0 retcall keyword testvar tol passvar ndig srcfile reffile
#   retcall      : return to this point in script on exit
#   keyword      : label (for printout)
#   tol          : tolerance in maximum allowed deviation
#   passvar      : $passvar is unset if |testvar|<tol
#   ndig         : number of digits numbers in file are stripped to
#   srcfile      : first file to compare
#   reffile      : second file to compare
# Example:
# zcmpmfiles_res_0 chk1ck "Max deviation in bnds.$ext from reference" $bndstol pass 4 bnds.$ext $testdir/bnds.$ext.gz
exit
zcmpmfiles_res_0:
  set quitjobl=$retcall
# echo $retcall $keyword $tol $?passvar $ndig $srcfile $reffile

  unset retval
  call zcmpmfiles zcmpmfilesx "$ndig $srcfile $reffile"
zcmpmfilesx:
  echo -n "$space $keyword ($retval) within tol ($tol)? ... "
  if (`echo $retval 0 | awk -v tol=$tol '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k<=tol)}'`) then
    echo yes
  else
    echo no
    unset $passvar
  endif
  goto $quitjobl

# ---------------- zcmpmfiles_res_tol --------------
# Compares two files, stripping all but numerical fields.
# Checks for max absolute difference and unsets $passvar if difference<$tol
# Files with .gz or .Z extensions are assumed to be gzipped.
# usage: zcmpnfiles_res_tol retcall keyword testvar tol passvar ndig srcfile reffile nlines
# See also zcmpmfiles_res_0, which accomplished the same thing but without nlines
#   retcall      : return to this point in script on exit
#   keyword      : label (for printout)
#   tol          : tolerance in maximum allowed deviation
#   passvar      : $passvar is unset if |testvar|<tol
#   ndig         : number of digits numbers in file are stripped to
#   srcfile      : first file to compare
#   reffile      : second file to compare
#   nlines       : number of lines to compare. Use 0 for all lines.  Inoperative if either file is a zipped file.
# Example:
# zcmpmfiles_res_tol chk1ck "Max deviation in bnds.$ext from reference" $bndstol pass 4 bnds.$ext $testdir/bnds.$ext.gz 0
exit
zcmpmfiles_res_tol:
  set quitjobl=$retcall
# echo $retcall $keyword $tol $?passvar $ndig $srcfile $reffile $nlines

  unset retval
  if ($nlines == 0) then
    call zcmpmfiles zcmpmfilesy "$ndig $srcfile $reffile"
  else
    call zcmpmfiles zcmpmfilesy "nlines=$nlines $ndig $srcfile $reffile"
  endif
zcmpmfilesy:
  echo -n "$space $keyword ($retval) within tol ($tol)? ... "
  if (`echo $retval 0 | awk -v tol=$tol '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k<=tol)}'`) then
    echo yes
  else
    echo no
    unset $passvar
  endif
  goto $quitjobl

# ---------------- zcmpnfiles --------------
# Compares two files, treating each field as a number.
# call arguments should contain 3 strings: n test-file reference-file
# |n| = number of digits which numbers are truncated to.
# If n<0, sort files before comparing them
# Alternatively call arguments can contain 4 strings : nlines=# n test-file reference-file
# nlines=# specifies that the check is made on the first # lines only
# Files with .gz or .Z extensions are assumed to be gzipped.
# (nlines doesn't work with gzipped files; sorry)
# Returns with retval = number of differences in reduced files.
# Example :  call zcmpnfiles chk25 "6 dos-cls.$ext $testdir/dos-cls.$ext.gz"
# Creates temporary files $tmpdir/tmp_compnfile_1 $tmpdir/tmp_compnfile_2
exit
zcmpnfiles:
  set quitjob=$retcall
  set zcmpnargs = ($callarg)

  set nlines ; unset nlines
  switch ($zcmpnargs[1])
    case "nlines=*":
      set nlines = `echo $zcmpnargs[1] | sed s/nlines=//`
      @ nlines = $nlines  # Checks to make sure this is an integer
      shift zcmpnargs

    default:
  endsw

  set digits = $zcmpnargs[1]
  if ($digits < 0) then
    @ digits = - $digits
    set lsort
  endif
# set a = ' { for (i = NF; i > 0; --i) printf " %.'$digits'f", $i; printf "\n" }'
# set a = ' { for (i = 1; i <= NF; i++) { k = sprintf("%.'$digits'f",$i); if (k+k == 0) k = 0 ; printf "%s ", k}; printf "\n" }'
  set a = ' { for (i = 1; i <= NF; i++) { k = sprintf("%.'$digits'f",$i); if (k+k == 0) k = 0 ; printf "%s ", k}; print "" }'

  set fn1 = $tmpdir/tmp_compnfile_1
  set fn2 = $tmpdir/tmp_compnfile_2
  if ("$zcmpnargs[2]:e" == 'gz' || "$zcmpnargs[2]:e" == 'Z') then
    set cat1 = 'gunzip -c'
  else
    set cat1 = cat
    if ($?nlines) then
      set cat1 = "head -$nlines"
    endif
  endif
  if ("$zcmpnargs[3]:e" == 'gz' || "$zcmpnargs[3]:e" == 'Z') then
    set cat2 = 'gunzip -c'
  else
    set cat2 = cat
    if ($?nlines) then
      set cat2 = "head -$nlines"
    endif
  endif

  if ($?lsort) then
    $cat1  $zcmpnargs[2] | sed s/D-/E-/g | sed s/D+/E+/g | sort | awk "$a" | sed 's/\([0-9]\)-/\1 -/g' > $fn1
    $cat2  $zcmpnargs[3] | sed s/D-/E-/g | sed s/D+/E+/g | sort | awk "$a" | sed 's/\([0-9]\)-/\1 -/g' > $fn2
  else
    $cat1  $zcmpnargs[2] | sed s/D-/E-/g | sed s/D+/E+/g | sed 's/\([0-9]\)-/\1 -/g' | awk "$a" > $fn1
    $cat2  $zcmpnargs[3] | sed s/D-/E-/g | sed s/D+/E+/g | sed 's/\([0-9]\)-/\1 -/g' | awk "$a" > $fn2
  endif
  set ncharfile = `wc $fn1 | awk '{print $3}'`
  set nwordfile = `wc $fn1 | awk '{print $2}'`
  set nlinefile = `wc $fn1 | awk '{print $1}'`
  cmp $fn1 $fn2 >/dev/null
  set retval = $status
  set retval2 = $retval

  if ($retval == 0) rm -f $fn1 $fn2
  if ($retval == 0) goto $quitjob

  set retval = `cmp -l $fn1 $fn2 |& grep -v EOF | wc | awk '{printf "%d", $1}'`
  set retval2 = `diff -d $tmpdir/tmp_compnfile_1 $tmpdir/tmp_compnfile_2 | wc |& awk '{print  $1}'`
  if ($retval == 0) set retval = '-1'
  rm -f $fn1 $fn2
  goto $quitjob

# ---------------- zcmpmfiles --------------
# Compares two files, treating each field as a number.
# Call arguments should contain 3 strings: no-digits test-file reference-file
# Alternatively call arguments can contain 4 strings : nlines=# n test-file reference-file
# nlines=# specifies that the check is made on the first # lines only
# Files with .gz or .Z extensions are assumed to be gzipped.
# Returns with retval = max numerical difference
# Example :  call zcmpmfiles chk25 "6 dos-cls.$ext $testdir/dos-cls.$ext.gz"
# Creates temporary files $tmpdir/tmp_compnfile_1 $tmpdir/tmp_compnfile_2
exit
zcmpmfiles:
  set quitjob=$retcall
  set zcmpnargs = ($callarg)

  set nlines ; unset nlines
  switch ($zcmpnargs[1])
    case "nlines=*":
      set nlines = `echo $zcmpnargs[1] | sed s/nlines=//`
      @ nlines = $nlines  # Checks to make sure this is an integer
      shift zcmpnargs

    default:
  endsw

  set digits = $zcmpnargs[1]
# set a = ' { for (i = NF; i > 0; --i) printf " %.'$digits'f", $i; printf "\n" }'
  set a = ' { for (i = 1; i <= NF; i++) { k = sprintf("%.'$digits'f",$i); if (k+k == 0) k = 0 ; printf "%s ", k}; printf "\n" }'

  set fn1 = $tmpdir/tmp_compnfile_1
  set fn2 = $tmpdir/tmp_compnfile_2
  if ("$zcmpnargs[2]:e" == 'gz' || "$zcmpnargs[2]:e" == 'Z') then
    set cat1 = 'gunzip -c'
  else
    set cat1 = cat
    if ($?nlines) then
      set cat1 = "head -$nlines"
    endif
  endif
  if ("$zcmpnargs[3]:e" == 'gz' || "$zcmpnargs[3]:e" == 'Z') then
    set cat2 = 'gunzip -c'
  else
    set cat2 = cat
    if ($?nlines) then
      set cat2 = "head -$nlines"
    endif
  endif

  $cat1  $zcmpnargs[2] | sed s/D-/E-/g | sed s/D+/E+/g | awk "$a" > $fn1
  $cat2  $zcmpnargs[3] | sed s/D-/E-/g | sed s/D+/E+/g | awk "$a" > $fn2

# wc $fn1 $fn2

  set retval = `diff -y --width=300 $fn1 $fn2 | grep '|' | awk -v top=0 '{n=split($0,a,"|"); n1=split(a[1],b1); n2=split(a[2],b2); { j=0; while (j++ < n1) if (j <= n1 && j<=n2) {x = (b1[j]-b2[j])>0?(b1[j]-b2[j]):(b2[j]-b1[j]); top = (top-x)>0?top:x; }}} END {printf "%12.4e\n", top}'`
  rm -f $fn1 $fn2
  goto $quitjob

# ---------------- qprint (print only quiet not set) --------------
exit
qprint:
  set quitjob=$retcall
  if ($?quiet) goto $quitjob
  echo "$callarg"
  goto $quitjob

# ---------------- showout --------------
exit
showout:
  set quitjob=$retcall
  if ($?quiet) goto $quitjob
  echo ' '
  echo "$space ... Compare $callarg to line(s) in file $refout":
  grep "$callarg" $testout
  if (`cat $testout | grep "$callarg" | wc | awk '{print $1}'` > 1) echo ' ---'
  zcat $refout | grep "$callarg"
  goto $quitjob

# ---------------- findcmd --------------
# Finds an executable program within the supplied path
# Usage: findcmd return_label executable_command path_name make_path
# If $executable_command is not found, findcmd does one of the following:
# If make_path = 'no' : returns silently.
# Otherwise findcmd aborts with a message, which assumes
# $make_path is the path where $executable_command is made.
exit
findcmd:
set found = 'no'
foreach ac_dir ($path_name)
 if (-x $ac_dir/$prog_cmd) then
   set $prog_cmd = $ac_dir/$prog_cmd
   set found = 'yes'
   break
 endif
end
if (! $?quiet) then
  if ($found == 'yes') echo "$space ... using executable $ac_dir/$prog_cmd"
  if ($found == 'no')  echo "$space ... no executable $prog_cmd found in path"
endif

if ($found == 'no' && $make_path != "no") then
  echo "  "
  echo "  Sorry, $testfile cannot find program '"$prog_cmd"' it needs to execute."
  echo "  '"$prog_cmd"' was not found in supplied path, or in the following:"
  echo "        $topdir"
# echo "  ... This script ($testfile) requires binary "'"rdcmd"'" to run."
  echo "  You must create or put '"$prog_cmd"' in your path before invoking this script."
  echo "  Normally '"$prog_cmd"' is created as part of the installation process."
  echo "  Invoking '"make $prog_cmd"' in $make_path should create it."
  echo "  $testfile aborting ..."
  exit -1
endif
goto $retcall

# ---------------- query --------------
exit
query:
  unset skip
  if ($?slow != 0) then
    echo "$space"'*'"hit <return> to $callarg, s <return> to skip it."
    set a = ($<)
    if ($a == "") goto $retcall
    switch ($a)
      case "quit":
      case "q":
      case "a":
        exit
      case "i":
        unset slow
        breaksw
      case "s":
        set skip
        breaksw
      case "t":
        time
        goto query
      default:
        echo 'q to quit; i unsets slow; s skips this job, t shows time'
        goto query
    endsw
  endif
  if ($?skip) goto $retcall2
  goto $retcall

# ---------------- List tests --------------
showtests:
cat <<EOF
  Usage: invoke with:   $testfile [switches] material-name job-list

   Material:    tests
       lsco:    Tests the DMFT driver starting from non-self-consistent LDA (a Mattheis construction of the density)
      lscoq:    Tests the DMFT driver with a QSGW potential, and with a DMFT-generated self-energy
         ni:    Tests the DMFT driver with a QSGW potential in a spin polarized case.  There is no DMFT self-energy
                job 3 tests the density maker
       niso:    Tests the DMFT driver with a QSGW potential and DMFT self-energy in a spin polarized, spin-orbit coupled case.
       ybco:    Tests the DMFT driver with a QSGW potential and DMFT self-energy with multiple correlation blocks.

  jobs:   1: Basic check of program lmfdmft
          2: Compares DOS generated by lmf to that generated by lmfdmft
          3: Checks the DMFT density maker

EOF
exit

# ---------------- usage: --------------
usage:
cat <<EOF
 usage: test.dmft [switches] [file-extension] [testcase-list]
        e.g., "test.dmft copt 1"
        If file-extension is missing, test.dmft uses copt
        Switches:
        --list       list available materials and tests (no tests are made)
        --no-iactive runs tests without prompting user
        --quiet      runs tests with minimal output and without prompting user
        --all        run through a default list of test cases
        --noplot     skip any steps that generate a plot'
        --clean      clean up files generated by this script
        --add0       add suppressed or leading zeros in output for real numbers \`.nnn'
        --poszer     strips (-) sign from numbers represented as 0
        --indmfl=yes read correlation data from indmfl.ext
        --whichexec  prints out which lmfdmft executable it finds in path and exits
        --MPIK       Runs lmfdmft in MPIK mode
                     Run the MPI job as
                     mpirun -n # lmfdmft ...

EOF
exit -1
