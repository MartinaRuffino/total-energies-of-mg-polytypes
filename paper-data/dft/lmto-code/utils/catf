#!/bin/tcsh
# Extracts a portion of an ascii file

# for checking ...
# catf -stop:s=echo:n=-2 -start:l=11::s=CCOMP:n=2 ccomp-files > out
# diff out out.00							     
# catf -stop:l=100 -start:l=11::s=CCOMP:n=2 ccomp-files > out	     
# diff out out.01							     
# catf -stop:s=echo:n=-2 -start:l=11::s=CCOMP:n=2 ccomp-files > out
# catf -stop:s=echo:n=-2 -start:l=11 ccomp-files > out	     
# diff out out.10							     
# catf -stop:l=100 -start:l=11: ccomp-files > out		     
# diff out out.11							     
# catf -start:l=11: ccomp-files > out				     
# diff out out.12							     
# catf -start:l=11::s=CCOMP:n=2 ccomp-files > out		     
# diff out out.02							     

alias call 'set retcall = \!\!:2 ; set callarg = \!\!:3 ; goto \!\!:1'


# defaults
set startk startl
set stopk stopl
set bcount = 1
set ecount = 1
set blineno = 1
# erel is s switch telling catf to increment 'stop' counter after 'start' already found
set erel = 0

 set prog = $0:t
 while ($#argv > 0)
   switch ("$1")
     case -h:
     case --h:
     case -help:
     case --help:
       goto usage
 
     case --debug
       set debug
       shift; breaksw

     case --x
       set exclude
       shift; breaksw

     case "-start*":
       set startk = `echo $1 | awk '{print substr($1,7,1)}'`
#      set startl = "`echo $1 | sed s/-start//`"
       set startl = `echo $1 | awk '{print substr($1,7)}'`
       shift; breaksw

     case "-stop*":
       set stopk = `echo $1 | awk '{print substr($1,6,1)}'`
#      set stopl = "`echo $1 | sed s/-stop//`"
       set stopl = `echo $1 | awk '{print substr($1,6)}'`
       shift; breaksw

     case "-*":
       echo "$prog (aborting): unrecognized switch $1"
       exit -1

     default:
       goto end-of-switches
       exit -1
   endsw
 end
end-of-switches:

if ($#argv == 0) goto usage
if ($?debug) echo "start switches: $startl"
if ($?debug) echo " stop switches: $stopl"

call gettok chk11 "$startl $startk"
chk11:
if ($retval == 0) goto chk12
  if ($?debug) echo found start token : $nextarg
  switch ("$nextarg")
    case "":
      breaksw

    case "rel":
      set brel
      breaksw

    case "l=*":
      set blineno = `echo $nextarg | awk '{print substr($1,3)}'`
      if ($?debug) echo blineno = $blineno
      breaksw

    case "s=*":
      set bregex = `echo $nextarg | awk '{print substr($1,3)}'`
      if ($?debug) echo bregex = $bregex
      breaksw

    case "n=*":
      set bcount = `echo $nextarg | awk '{print substr($1,3)}'`
      if ($?debug) echo bcount = $bcount
      breaksw

    default:
      echo "$prog : unrecognized token, $nextarg"
      goto usage
  endsw
call gettok chk12 "$retstrn $startk"
chk12:
if ($retval == 1) goto chk11
	
call gettok chk21 "$stopl $stopk"
chk21:
if ($retval == 0) goto chk22
  if ($?debug) echo found stop token : $nextarg
  switch ("$nextarg")
    case "":
      breaksw

    case "rel":
      set erel = 1
      breaksw

    case "l=*":
      set elineno = `echo $nextarg | awk '{print substr($1,3)}'`
      if ($?debug) echo elineno = $elineno
      breaksw

    case "s=*":
      set eregex = `echo $nextarg | awk '{print substr($1,3)}'`
      if ($?debug) echo eregex = $eregex
      breaksw

    case "n=*":
      set ecount = `echo $nextarg | awk '{print substr($1,3)}'`
      if ($?debug) echo ecount = $ecount
      breaksw

    default:
      echo "$prog : unrecognized token, $nextarg"
      goto usage
  endsw
call gettok chk22 "$retstrn $stopk"
chk22:
if ($retval == 1) goto chk21

#   $testdir/zdiff $files | awk -v endstr="$endstr" -v nend=$nend -v endl=0 -v endr=0 '{if ($1 == "<" && endl < nend) print ; if ($1 == ">" && endr < nend) print ; if ($1 == ">" || $1 == "<" || endl >= nend && endr >= nend) ; else {print} ; if ($1 == "<" && $2 == endstr) {endl+=1}; if ($1 == ">" && $2 == endstr) {endr+=1};}' | head -50

if ($?debug) echo file name : $1
if (! -e "$1") then
  echo $prog : missing file $1 ..
  exit -1
  goto usage
endif

# if start count < 0 , turn into positive count
switch ("$bcount")
  case "-*":
    set i = `awk -v begstr="$bregex" '{if (match($0,begstr) > 0) print $0}' "$1" | wc`
    @ bcount = $i[1] + $bcount + 1
    if ($?debug) echo bcount shifted to $bcount
  default:
endsw
    
# if end count < 0 , turn into positive count
switch ("$ecount")
  case "-*":
    set i = `awk -v endstr="$eregex" '{if (match($0,endstr) > 0) print $0}' "$1" | wc`
    @ ecount = $i[1] + $ecount + 1
    if ($?debug) echo ecount shifted to $ecount
  default:
endsw
    
if ($?debug) echo ------------------- start of file extract --------------------
# ... starting, ending points are both regex
if ($?bregex && $?eregex && $?exclude) then
  awk -v begstr="$bregex" -v nbeg=$bcount -v endstr="$eregex" -v nend=$ecount -v ibeg=0 -v iend=0 -v erel=$erel \
    '{if (match($0,begstr) > 0) ibeg+=1;  if (ibeg >= nbeg && iend < nend) ; else {print}; if (! (ibeg < nbeg && erel == 1) && match($0,endstr) > 0) iend+=1}' "$1"

else if ($?bregex && $?eregex) then
  awk -v begstr="$bregex" -v nbeg=$bcount -v endstr="$eregex" -v nend=$ecount -v ibeg=0 -v iend=0 -v erel=$erel \
    '{if (match($0,begstr) > 0) ibeg+=1;  if (ibeg >= nbeg && iend < nend) {print}; if (! (ibeg < nbeg && erel == 1) && match($0,endstr) > 0) iend+=1}' "$1"
#   '{if (match($0,begstr) > 0) ibeg+=1;  if (ibeg >= nbeg && iend < nend) {print}; if (match($0,endstr) > 0) {if (! (ibeg < nbeg && erel == 1)) iend+=1}}' "$1"
#   '{if (match($0,begstr) > 0) ibeg+=1;  if (ibeg >= nbeg && iend < nend) {print}; if (match($0,endstr) > 0) iend+=1; if (ibeg < nbeg && erel == 1) iend=0}' "$1"

# ... starting point a line number; ending points is regex
else if ($?blineno && $?eregex && $?exclude) then
  awk -v blineno="$blineno" -v endstr="$eregex" -v nend=$ecount -v ibeg=0 -v iend=0 -v erel=$erel \
    '{if (NR >= blineno && iend < nend) ; else {print}; if (match($0,endstr) > 0) iend+=1; if (NR < blineno && erel == 1) iend=0}' "$1"

else if ($?blineno && $?eregex) then
  awk -v blineno="$blineno" -v endstr="$eregex" -v nend=$ecount -v ibeg=0 -v iend=0 -v erel=$erel \
    '{if (NR >= blineno && iend < nend) {print}; if (match($0,endstr) > 0) iend+=1; if (NR < blineno && erel == 1) iend=0}' "$1"

# ... starting point a regex ; ending point is line number
else if ($?bregex && $?elineno && $?exclude) then
 awk -v begstr="$bregex" -v nbeg=$bcount -v ibeg=0 -v elineno="$elineno" -v erel=$erel\
    '{if (match($0,begstr) > 0) {if (ibeg == nbeg-1 && erel == 1) elineno += NR; ibeg+=1}; if (ibeg >= nbeg && NR <= elineno) ; else {print}}' "$1"

else if ($?bregex && $?elineno) then
 awk -v begstr="$bregex" -v nbeg=$bcount -v ibeg=0 -v elineno="$elineno" -v erel=$erel\
    '{if (match($0,begstr) > 0) {if (ibeg == nbeg-1 && erel == 1) elineno += NR; ibeg+=1}; if (ibeg >= nbeg && NR <= elineno) {print}}' "$1"

# ... starting point a regex, no ending point
else if ($?bregex && $?exclude) then
 awk -v begstr="$bregex" -v nbeg=$bcount -v ibeg=0 -v erel=$erel\
    '{if (match($0,begstr) > 0) ibeg+=1;  if (ibeg >= nbeg) ; else {print}}' "$1"

else if ($?bregex) then
 awk -v begstr="$bregex" -v nbeg=$bcount -v ibeg=0 -v erel=$erel\
    '{if (match($0,begstr) > 0) ibeg+=1;  if (ibeg >= nbeg) {print}}' "$1"

# ... starting, ending points are both line numbers
else if ($?blineno && $?elineno && $?exclude) then
#  awk -v blineno="$blineno" -v elineno="$elineno"  -v erel=$erel '{{if (NR == blineno && erel == 1) elineno += NR;} if (NR >= blineno && NR <= elineno) print NR}' "$1"
   echo BUG in catf

else if ($?blineno && $?elineno && $?erel) then
#  awk -v blineno="$blineno" -v elineno="$elineno"  -v erel=$erel '{{if (NR == blineno && erel == 1) elineno += NR-1;} if (NR >= blineno && NR <= elineno) print NR,erel}' "$1"
   awk -v blineno="$blineno" -v elineno="$elineno"  -v erel=$erel '{{if (NR == blineno && erel == 1) elineno += NR-1;} if (NR >= blineno && NR <= elineno) print }' "$1"

# ... starting point a line number, no ending point
else if ($?exclude) then
  awk -v blineno="$blineno" '{if (NR >= blineno) ; else print}' "$1"

else
  awk -v blineno="$blineno" '{if (NR >= blineno) print}' "$1"
endif

if ($?debug) echo ------------------- end of file extract --------------------

# ---------------- gettok --------------
# Returns the string sandwiched between 1st and 2nd occurence of a separator
# and returns the string, stripped to the 2nd occurence of the separator
# Calling argument should consist of two strings:
#   1st string = string to parse for a token
#   2nd string = string separator
#
# gettok does the following:
#  2. sets variable nextarg the string sandwiched betw/ 1st and 2nd occurence of sep
#  1. sets variable retstrn the string stripped until 2nd occurence of sep
#  3. sets variable retval to zero if there are no more tokens; else to 1
#
# Example: call gettok chk69 ":abc:123:xyz :"
#  returns:
#  nextarg = abc
#  retstrn = 
exit
gettok:
  set quitjob=$retcall

  set nextarg
  set retval = 0
  set list = ($callarg[1])
  if ($#list < 2) goto $quitjob
#   echo list is $list[1] and $list[2]
  set retval = `echo $list[1] | awk -v k=$list[2] '{print match($0,k)}'`
#   echo retval is $retval
  set nextarg = `echo $list[1] | awk -v k=$list[2] '{split($0,a,k); print a[2]}'`
  set retstrn = `echo $list[1]  | awk -v k=$list[2] '{pnow=match($0,k); pnext=match(substr($0,1+pnow),k); if (pnext > 0) print substr($0,1+pnext)}'`
#   echo nextarg is $#nextarg $nextarg
#   echo retstrn is $retstrn
  goto $quitjob


# --- usage ---
exit 0
usage:
  echo  "usage: $prog [-start[:options] [-stop[:options] filename"
  echo  "       prints to stdout an ascii file, or a portion of one."
  echo  " "
  echo  "       Switches:"
  echo  "       -start[:options] tells  $prog  when to start printing (default=1st line)"
  echo  "       -stop[:options]  tells  $prog  when to stop printing"
  echo  "       --x              excludes lines within -start, -stop"
  echo  ' '
  echo  '       *Options for -start and -stop consist of one or more keywords:'
  echo  '        Keywords are separated by ":", or whatever character immediately'
  echo  '        follows the  -start or -stop  switch.'  keywords are:
  echo  ' '
  echo  '          l=#     start(stop) extracting at line number #'
  echo  ' '
  echo  '          s=regex start(stop) extracting at regular expression regex'
  echo  ' '
  echo  '          rel     "(relative)" begin stop counter after encountering first'
  echo  '                  start line.  For now, "rel" only applies to stop switch.'
  echo  ' '
  echo  '          n=#     start(stop) extracting after the nth occurence of regex.'
  echo  '                  If #<0 counting is relative to the end'
  echo  ' '
  echo  '          It is nonsensical to use both l=# and s=regex in a single switch.'
  echo  '          Also, n=# is meaningful only in conjunction with s=regex'
  echo  ' '
  echo  '       Examples:'
  echo  '          catf -start:l=2 -stop:l=4 name                prints lines 2..4'
  echo  '          catf -start:l=2 -stop:rel:l=4 name            prints lines 2..6'
  echo  '          catf -start:s=echo:n=2 -stop:rel:l=2 name     starts printing after 2nd occurence of "echo"'
  echo  '                                                        and prints that line plus the next two'
  echo  '          catf -start/s=Switches:/ -stop/s=Examples:/ name  prints lines between "Switches:" and "Examples:"'
  echo  '          catf -start:n=-1:s=BNDASA name                print all lines after last occurence of BNDASA'

  exit -1
