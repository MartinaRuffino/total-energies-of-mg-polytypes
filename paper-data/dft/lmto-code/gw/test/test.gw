#!/bin/tcsh -f

# A shell script testing operation of gw code
# set verbose

alias call 'set retcall = \!\!:2 ; set callarg = \!\!:3 ; goto \!\!:1'
alias runjob 'set retcall = \!\!:1; set outfile = \!\!:2 ; set callarg = \!\!:3 ; goto runjob'
alias runrdcmd 'set retcall = \!\!:1; set rdcmdfmt = \!\!:2 ; set outfile = \!\!:3 ; set callarg = \!\!:4 ; goto runrdcmd'
alias findcmd  'set retcall = \!\!:1 ; set prog_cmd = \!\!:2 ; set path_name = \!\!:3 ; set make_path = \!\!:4 ; goto findcmd'
alias compare_res 'set retcall = \!\!:1; set testvar = \!\!:2 ; set refvar = \!\!:3 ; set keyword = \!\!:4  ; set arg_number = \!\!:5 ; set occur_number = \!\!:6 ; set sed_strn = \!\!:7 ; goto compare_res'
alias cnvt_d_fmt  'set retcall = \!\!:1; set testvar = \!\!:2 ; set testval = \!\!:3 ; goto cnvt_d_fmt'
alias query 'set retcall = \!\!:1 ; set retcall2 = \!\!:2 ; set callarg = \!\!:3 ; goto query'
alias zcmpmc 'set retcall = \!\!:1; set keyword = \!\!:2 ; set tol = \!\!:3 ; set passvar = \!\!:4 ; set ndig = \!\!:5 ; set srcfile = \!\!:6 ; set reffile = \!\!:7 ; goto zcmpmc '
alias zcmpmfiles_res_0 'set retcall = \!\!:1; set keyword = \!\!:2 ; set tol = \!\!:3 ; set passvar = \!\!:4 ; set ndig = \!\!:5 ; set srcfile = \!\!:6 ; set reffile = \!\!:7 ; goto zcmpmfiles_res_0 '
alias zcmpmfiles_res_tol 'set retcall = \!\!:1; set keyword = \!\!:2 ; set tol = \!\!:3 ; set passvar = \!\!:4 ; set ndig = \!\!:5 ; set srcfile = \!\!:6 ; set reffile = \!\!:7 set nlines = \!\!:8; goto zcmpmfiles_res_tol '
alias zcmpmfiles_res_mc 'set retcall = \!\!:1; set keyword = \!\!:2 ; set tol = \!\!:3 ; set passvar = \!\!:4 ; set ndig = \!\!:5 ; set srcfile = \!\!:6 ; set reffile = \!\!:7; set nlines = \!\!:8;; set count = \!\!:9; goto zcmpmfiles_res_mc'

set allargs = ($argv)

set a
set slow
set testfile = $0
set testdir = $testfile:h
set topdir  = `cd $testdir/../..; pwd`
set tmpdir = $cwd
set extract = $topdir/extract-lines
set space = '        '
set failed = 0
alias zcat 'gunzip -c'
alias zcat 'cat'

#alias mpix mpirun

# Prepend current working-directory, top-level and related dir to path
set path = ($cwd $topdir $topdir/utils $topdir/testing $path)

set plot = `which fplot`
if (-x "$plot") then
  if `$plot -h | sed -n 1,1p | awk '{print ($2 == "fplot")}'` set have_fplot
endif
set mcx = `which mcx`
if (-x "$mcx") then
  if `$mcx --h |& sed -n 1,1p | awk '{print ($7 == "(vsn" && ($8 * 1 >= 1.072))}'` set have_mc
endif
set pldos = `which pldos`
if (-x "$pldos") then
  if `$pldos -h | sed -n 1,1p | awk '{print ($2 == "pldos")}'` set have_pldos
endif
set plbnds = `which plbnds`
if (-x "$plbnds") then
  if `$plbnds -h | sed -n 1,1p | awk '{print ($2 == "plbnds")}'` set have_plbnds
endif
# see if ghostscript is available
set gs = `which gs`
if (-x "$gs") then
  if `$gs --help | sed -n 1,1p | awk '{print ($2 == "Ghostscript")}'` set have_ghostscript
endif
# see if gnu grep is available
echo X | grep -A 1 X > & /dev/null
set retval = $status
if ($retval == 0) set gnu_grep

unset mpi

# --- Pick off switches ---
while (`echo $1 | sed -e 's/\(.\).*/\1/' `  ==  "-")

  set arg1 = $1; shift
  if ($?verb) echo test.gw: parsing switch $arg1
  switch ($arg1)
    case "--quiet":
      set quiet
      unset slow
      breaksw

    case "--add0":
      set add0 = `which add0`
      if (! -x "$add0") then
        echo "test.dmft (abort): missing add0"
        exit
      endif
      breaksw
    case "--poszer":
      set poszer = `which poszer`
      if (! -x "$poszer") then
        echo "test.dmft (abort): missing poszer"
        exit
      endif
      breaksw

    case "--clean":
      set clean
      breaksw

    case "--veryclean":
      set clean
      set veryclean
      breaksw

    case "--noplot*":
      set noplot
      set have_pldos
      unset have_pldos
      set have_fplot
      unset have_fplot
      breaksw

    case "--no-iact*":
      unset slow
      breaksw

    case "--haveout":
      set haveout
      breaksw

    case "--list":
      goto showtests
      breaksw

    case "--whichexec"
      set quiet; unset quiet
      findcmd chk00 lmfgwd "$path" "$topdir"
      chk00:
      findcmd chk01 lmfgws "$path" "$topdir"
      chk01:
      exit 0
      breaksw

    case "--verb*":
      set verb = 1
      breaksw

    case "--GWversion*":
      set gwversion = `echo $arg1  | sed -e 's/--GWversion//'`
      breaksw

    case "--timereversaloff"
      set timereversaloff
      breaksw

    case "--eibzmodeoff"
      set eibzmodeoff
      breaksw

    case "--offbz"
      set offbz
      breaksw

    case "--so3":
      set so3
      breaksw

    case "--mpi=*":
    case "--mpi":
      set mpi = ($arg1)
      breaksw

    case "--openmp=*":
    case "--openmp":
      set mpi = ($arg1)
      breaksw

    case "--all":
      set mater_lst = (cr3si6)
      set joblist
      while (`echo $1 | sed -e 's/\([0-9][0-9]*\)/-/'`  ==  "-")
        set joblist = ($joblist $1)
        shift
      end
      set pass
      set failed
      foreach i ($mater_lst)
        echo "$space ... invoking $testfile `echo $allargs | sed s/--all//g` $i $joblist"
        $testfile `echo $allargs | sed s/--all//g` $i $joblist
        set retval = $status
        if ($retval != 0) then
          unset pass
          set failed = ($failed $i)
        endif
      end
      if ($?clean) then
        exit
      else if ($?pass) then
        echo "$space $testfile : all tests PASSED ($mater_lst)"
        exit
      else
        echo "$space $testfile : tests FAILED for the following materials:  $failed"
        exit -1
      endif

    default:
      echo unrecognized switch $arg1
      goto usage
  endsw

end

echo ' '
echo "         ---- test.gw: test lmfgw ---"

# --- use cr3si6 as default in the absence of specific choice ---
if ($#argv == 0) then
  set ext = cr3si6
  echo "$space .... no file extension specified; use input file ctrl.$ext"
else
  set ext = $argv[1]
  shift
endif

if (! -e $testdir/$ext/ctrl.$ext) then
   echo ' '
   echo " test.gw aborting ... missing file $testdir/$ext/ctrl.$ext"
   goto usage
endif

if ($ext == "mno") then
  echo '         Case mno: a antiferromagnetic oxide with three classes and four atoms.'
  echo '         Other checks:'
  echo '         Checks special AFM symmetry operation'
  echo ' '
  set cplst = ($testdir/$ext/{ctrl.mno})
  set drmsqtol1 = 1e-5
else if ($ext == "cr3si6") then
  set rmlst4 = ({sigm,evec,gw1,gw2,gwb,log,normchk,vxc,gwa,ctrl.preprocessed,mixm,rst,save,moms,sigii,wkp,atm,ctrl,rsta}.cr3si6 0run)
  set cplst = ($testdir/$ext/{GWinput,basp.cr3si6,ctrl.cr3si6,site.cr3si6})
  set gwscargs = "--maxit=0 --wt --tol=2e-5 -vnit=100 --sym"
else
  echo test.gw: No test case for $ext
  exit -1
endif
endif

set extcode = $ext.code2

if ( $?joblist == 0 ) then
set joblist = ($argv)
if ( $#joblist == 0 ) set joblist = (1)
endif

echo $joblist | grep 1 >/dev/null
if ($status) goto chk1e
cat <<EOF

         --- Test 1.  Basic check of lmfgw ---

EOF

if ($ext == "coo2") then
cat <<EOF
         Test case coo2 tests the radial product basis maker 
         and computes matrix elements of the Hartree potential.
         It should be run after coo2 test 4.

EOF
  set lmgwargs1 = '--pr55,30 -vsig=0 --job=1'
  set rmlst1 = (out.tprodbas2 out.tprodbas4)
  set ext = coo2
endif
if ($ext == "cr3si6") then
cat <<EOF
         Test case cr3si6 tests so far:
         1. The radial product basis, and radial matrix elements of it
         2. The full product basis, and matrix elements of it
         3. (Hartree) matrix elements of the bare coulomb interaction

EOF
  set lmgwargs1 = '--no-iactive --checkrpb -vnit=100'
# This one to run lmfgwd test
# set lmgwargs1 = '--tprodbas:wvcoud:mode=134 --job=1 --gwcode=2 --no-iactive -vnit=100'
  set ext = cr3si6
  set rmlst1 = ({ctrl,rst,mixm,sigm,basp,site}.$ext out.lmgwsc GWinput GWinput.gw out.tprodbas4)
  set cplst1 = ($cplst)
endif

set pass
set testout=out.lmfgw refout=$testdir/$ext/out.lmfgw

if (! $?lmgwargs1) echo "$space no test set up for job $ext ... skipping this test"
if (! -e $refout) then
  echo "$space no file $refout ... skipping this test"
  goto chk1ce
endif

query chk11 chk1e 'run this test'
chk11:

# ... Look for executables
findcmd chk11a lmfgw "$path" "required"
chk11a:
findcmd chk11b lmgwsc "$path" "required"
chk11b:

if ($?haveout) goto chk12b0

if ($?clean) then
  if ($?rmlst1) then
    echo "$space rm -f -r $rmlst1"
                 rm -f -r $rmlst1
   goto chk1e
  endif
endif

if ($?cplst1) then
  if ($?rmlst1) then
    echo "$space rm -f -r $rmlst1"
                 rm -f -r $rmlst1
  endif
  echo "$space cp `echo $cplst | sed s/GWinput/GWinput.gw/` ."
               cp `echo $cplst | sed s/GWinput/GWinput.gw/` .
  echo "$space mv GWinput.gw GWinput"
               mv GWinput.gw GWinput
endif

if (! -e ctrl.$ext) then
  echo "$space no file ctrl.$ext ... skipping this test"
  goto chk1ce
endif

if ($ext == "cr3si6") then
  if (! $?mpi) set mpi
  rm -f switches-for-lm; touch switches-for-lm
  runjob chk12b0 out.lmgwsc "lmgwsc $mpi --stop=setup $ext"
  chk12b0:  
  rm -f $testout
  runjob chk12b1 $testout "$lmfgw --checkrpb=2 --gradpb --stop=prbas `cat switches-for-lm` $ext"
  chk12b1:
  runjob chk12b2 '>>'$testout "$lmfgw $lmgwargs1 `cat switches-for-lm` $ext"
  chk12b2:
  echo "$space $lmfgw exited normally."
  set i = 6  tol = 1e-6 exclude = 'CPU|written|LMFGW'
  zcmpmfiles_res_mc chk12b3 "Max deviation in $testout from ref $refout" $tol pass $i $testout $refout -1 0
  chk12b3:
  unset exclude

  goto chk1ce
endif

chk1ce:
if ($?clean) goto chk1e
if ($?pass) then
    echo "$space test 1 PASSED ($ext)"
else
    echo "$space test 1 FAILED ($ext)"
    set failed = ($failed 1)
endif

chk1e:

# --- Summary ---
echo ' '
if ($?clean) exit 0
if ($#failed <= 1) then
    echo "$space all tests PASSED ($ext)"
    echo " "
    exit 0
else
    shift failed
    echo "$space $testfile : These tests FAILED ($ext):" $failed
    echo " "
    exit -1
endif

# ---------------- runjob --------------
exit
runjob:
  set quitjob=$retcall
  if ($outfile == ".") then
    echo "$space $callarg"
    echo " "
    $callarg
    set retval = $status
    if ($retval != 0) goto cleanup
    goto $quitjob
  endif

  if (`echo $outfile | awk '{print substr($1,1,2)}'` == '>>') then
    set appfile = `echo $outfile | awk '{print substr($1,3)}'`
    echo "$space $callarg  >> $appfile"
    $callarg >> $appfile
    set retval = $status
  else
    echo "$space $callarg  > $outfile"
    $callarg > $outfile
    set retval = $status
  endif
  if ($retval != 0) goto cleanup
  goto $quitjob

# ---------------- compare_res --------------
# Extracts one element of a line containing a keyword
# usage: compare_res retcall testvar refvar keyword arg_number occur_number sed_strn
#   Variables testout and refout referring to file names must be set ($refout is gzipped file)
#   keyword      : string line must contain
#   testvar      : put result from file $testout into this variable
#   refvar       : put result from file $refout (compressed) into this variable
#   arg_number   : extracts $arg_number'th entry in line, as defined by awk
#   occur_number : argument from $occur_number'th line; if zero, use last line
#   sed_strn     : delete this string with from result before assigning
# Example : compare_res chk12 efa erfa "etot=" 2 0 etot=
exit
compare_res:
  set quitjob=$retcall
#  echo $retcall $testvar $refvar $keyword $arg_number $occur_number $sed_strn
  set $testvar = `grep "$keyword" $testout | awk -v ncnt=0 -v num=$arg_number -v count=$occur_number '{ncnt+=1; if (ncnt==count || count == 0) {print $num}}' | sed "s/$sed_strn//" | tail -1`
  set $refvar = `zcat $refout | grep "$keyword" | awk -v ncnt=0 -v num=$arg_number -v count=$occur_number '{ncnt+=1; if (ncnt==count || count == 0) {print $num}}' | sed "s/$sed_strn//" | tail -1`
  goto $quitjob

# ---------------- runrdcmd --------------
exit
runrdcmd:
  set quitjob=$retcall
  if ($outfile == ".") then
    $rdcmd -f:$rdcmdfmt $callarg
    set retval = $status
    echo ' '
    if ($retval == 0) then
      echo "$space Job(s) completed successfully"
      goto $quitjob
    endif
  else
    if (`echo $outfile | awk '{print substr($1,1,2)}'` == '>>') then
      set appfile = `echo $outfile | awk '{print substr($1,3)}'`
      echo "$space $callarg  >> $appfile"
      exit
#      $callarg >> $appfile
      set retval = $status
    else
      echo "$space Invoking rdcmd will execute the following job(s):"
      $rdcmd -f:$rdcmdfmt --n $callarg
      echo "$space $rdcmd '-f:#rdcmd:%2f' $callarg  >& $outfile"
      $rdcmd '-f:rdcmd:%2f' $callarg >& $outfile
      set retval = $status
    endif
  endif

  if ($retval == 0) then
    echo "$space Job(s) completed successfully; output in $outfile"
    if ($?poszer) then
      echo -n "         ..." ; $poszer $outfile
    else if ($?add0) then
      echo -n "         ..." ; $add0 $outfile
    endif
    goto $quitjob
  else
    echo "$space ...oops... the following command returned with nonzero exit status:"
    echo -n "$space   "
    grep $rdcmd:t{:} $outfile | tail -1 | sed 's/rdcmd:  //'
    goto cleanup
  endif

# ---------------- cleanup --------------
exit
cleanup:
  if ($retval != 0) echo "$space job returned with error status $retval"
  if ($retval != 0) echo "$space ... $testfile aborting"
  exit $retval

# ---------------- diffiles --------------
exit
diffiles:
  set quitjob=$retcall
  if ($?quiet) goto $quitjob
  set files = "$callarg"
  query diff11 $quitjob "compare $files"
diff11:
  diff $files | sed -n 1,50p
  goto $quitjob

# ---------------- zdiffiles --------------
# File differences, with additional check for numerical differences
# callarg should consist of four strings; there is an optional fifth and sixth
# 1st word = string that terminates diff
# 2nd word = counts how many times terminator should occur before terminating
#            -1 -> last occurence
# 3nd word = first file name
# 4th word = second file name
# 5th word = (optional) tolerance.  Numerical differences < tolerance are counted as 0
#            If present, and not "-", passed to mcx as the argument to ~tol=
# 6th word = (optional) if present, it is used instead of mcexcl
#
# Returns ndif = number of differences, and maxdif = difference (if mcx is available)
# Example: call zdiffiles chk69 "CPU 3 $testout $refout"
exit
zdiffiles:

  set quitjob=$retcall

  set noglob
  set files = ($callarg)
  unset noglob

  set endstr = $files[1]
  shift files
  set nend = $files[1]
  shift files

  if ($nend == "-1") then
    set nend = `grep "$endstr" $files[1] | wc | awk '{print $1}'`
  endif

  if ($?quiet) goto zdiffiles2

  if ( $?slow == 0 ) echo "$space ... compare $files[1] $files[2]"
  query zdiff1 $quitjob "compare $files[1] $files[2]"
zdiff1:
  zdiff -Icpudel -Iwritten $files[1] $files[2] | awk -v endstr="$endstr" -v nend=$nend -v endl=0 -v endr=0 '{if ($1 == "<" && endl < nend) print ; if ($1 == ">" && endr < nend) print ; if ($1 == ">" || $1 == "<" || endl >= nend && endr >= nend) ; else {print} ; if ($1 == "<" && $2 == endstr) {endl+=1}; if ($1 == ">" && $2 == endstr) {endr+=1};}' | sed -n 1,50p
  echo " "

zdiffiles2:
  if (! $?mcx) goto $quitjob

  if (! $?mcexcll) set mcexcll
  if (! $?mcexcl) set mcexcl
  if ($?mcexcl) set mcexcll = "$mcexcl"
  if ($#files > 3) then
    set mcexcll = "$files[4]"
  endif

  if (! $?mcterm) set mcterm
# Don't do this step ... check that each test initializes its own gmaxdif
# if (! $?gmaxdif) set gmaxdif = 0
  set toldif
  if ($#files > 2) then
    if ("$files[3]" != "-") set toldif = "~tol=$files[3]"
  endif

  set maxdif = `$mcx -cmpf~fn1=$files[1]~fn2=$files[2]~max$toldif$mcterm$mcexcll`
  set ndif = `$mcx -cmpf~fn1=$files[1]~fn2=$files[2]~ndiff$toldif$mcterm$mcexcll`
#  set gmaxdif = `echo $gmaxdif $maxdif  | awk '{print ($1>$2)?$1:$2}'`

  echo "$space $ndif numerical differences in $files[1] compared to ref, max diff = $maxdif"
  if ($?slow > 0 && $?verb) then
    echo
    echo "$space The following make a detailed comparison of numerical differences:"
    echo "$space $mcx -cmpf~fn1=$files[1]~fn2=$files[2]~vverb$toldif$mcterm$mcexcll"

    query zdiff2  $quitjob "show comparison"
zdiff2:
    $mcx -cmpf~fn1=$files[1]~fn2=$files[2]~vverb$toldif$mcterm$mcexcll
    echo
    echo "$space"'*'"hit <return> to continue"
    set a = ($<)
  endif
  if (! $?quiet) echo
  goto $quitjob

# ---------------- zdiffilesx --------------
# Identical to zdiffiles, but gmaxdif is accumulated
# callarg should consist of four strings; there is an optional fifth and sixth
# 1st word = string that terminates diff
# 2nd word = counts how many times terminator should occur before terminating
#            -1 -> last occurence
# 3nd word = first file name
# 4th word = second file name
# 5th word = (optional) tolerance.  Numerical differences < tolerance are counted as 0
#            If present, and not "-", passed to mcx as the argument to ~tol=
# 6th word = (optional) if present, it is used instead of mcexcl
#
# Returns ndif = number of differences, and maxdif = difference (if mcx is available)
exit
zdiffilesx:

  set quitjob=$retcall

  set noglob
  set files = ($callarg)
  unset noglob

  set endstr = $files[1]
  shift files
  set nend = $files[1]
  shift files

  if ($nend == "-1") then
    set nend = `grep "$endstr" $files[1] | wc | awk '{print $1}'`
  endif

  if ($?quiet) goto zdiffilesx2

  if ( $?slow == 0 ) echo "$space ... compare $files[1] $files[2]"
  query zdiffx1 $quitjob "compare $files[1] $files[2]"
zdiffx1:
  zdiff -Icpudel -Iwritten $files[1] $files[2] | awk -v endstr="$endstr" -v nend=$nend -v endl=0 -v endr=0 '{if ($1 == "<" && endl < nend) print ; if ($1 == ">" && endr < nend) print ; if ($1 == ">" || $1 == "<" || endl >= nend && endr >= nend) ; else {print} ; if ($1 == "<" && $2 == endstr) {endl+=1}; if ($1 == ">" && $2 == endstr) {endr+=1};}' | sed -n 1,50p
  echo " "

zdiffilesx2:
  if (! $?mcx) goto $quitjob

  if (! $?mcexcll) set mcexcll
  if (! $?mcexcl) set mcexcl
  if ($?mcexcl) set mcexcll = "$mcexcl"
  if ($#files > 3) then
    set mcexcll = "$files[4]"
  endif

  if (! $?mcterm) set mcterm
# Don't do this step ... check that each test initializes its own gmaxdif
# if (! $?gmaxdif) set gmaxdif = 0
  set toldif
  if ($#files > 2) then
    if ("$files[3]" != "-") set toldif = "~tol=$files[3]"
  endif

  set maxdif = `$mcx -cmpf~fn1=$files[1]~fn2=$files[2]~max$toldif$mcterm$mcexcll`
  set ndif = `$mcx -cmpf~fn1=$files[1]~fn2=$files[2]~ndiff$toldif$mcterm$mcexcll`
  if (! $?gmaxdif) set gmaxdif = 0
  set gmaxdif = `echo $gmaxdif $maxdif  | awk '{print ($1>$2)?$1:$2}'`

  echo "$space $ndif numerical differences in $files[1] compared to ref, max diff = $maxdif"
  if ($?slow > 0 && $?verb) then
    echo
    echo "$space The following make a detailed comparison of numerical differences:"
    echo "$space $mcx -cmpf~fn1=$files[1]~fn2=$files[2]~vverb$toldif$mcterm$mcexcll"

    query zdiffx2  $quitjob "show comparison"
zdiffx2:
    $mcx -cmpf~fn1=$files[1]~fn2=$files[2]~vverb$toldif$mcterm$mcexcll
    echo
    echo "$space"'*'"hit <return> to continue"
    set a = ($<)
  endif
  if (! $?quiet) echo
  goto $quitjob

# ---------------- zcmpmc --------------
# Compares two files readable with numerical data only by mcx (see also zcmpmfiles_res_mc)
# Checks for max absolute difference and unsets $passvar if difference<$tol
# usage: zcmpmc retcall keyword testvar tol passvar ndig srcfile reffile
#   retcall      : return to this point in script on exit
#   keyword      : label (for printout)
#   tol          : tolerance in maximum allowed deviation
#   passvar      : $passvar is unset if |testvar|<tol
#   ndig         : number of digits numbers in file are stripped to (not used now)
#   srcfile      : first file to compare
#   reffile      : second file to compare
# variable $mcx must point to the mcx calculator
# Example:
# zcmpmc chk1ck "Max deviation in bnds.$ext from reference" $bndstol pass 4 bnds.$ext $testdir/bnds.$ext.gz
exit
zcmpmc:
  set quitjobl=$retcall
# echo $retcall $keyword $tol $?passvar $ndig $srcfile $reffile

  unset retval
  cmp $srcfile $reffile > /dev/null
  set retval = $status

# Could set px:ndig here ...
  if ($retval != "0") then
   if (`$mcx $srcfile $reffile -- -px:12 -abs -max:g | wc | awk '{print $1}'` == 3) set retval = 0
  endif
  if ($retval != "0") then
    set retval = `$mcx $srcfile $reffile -- -px:12 -abs -max:g | tail -1 | awk '{print $3}' | $mcx -f1pg12.3 . | tail -1`
  endif
  echo -n "$space $keyword ($retval) within tol ($tol)? ... "
  if (`echo $retval 0 | awk -v tol=$tol '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k<=tol)}'`) then
    echo yes
  else
    echo no
    unset $passvar
  endif
  goto $quitjobl

# ---------------- zcmpmfiles_res_0 --------------
# Compares two files, stripping all but numerical fields.
# Checks for max absolute difference and unsets $passvar if difference<$tol
# Files with .gz or .Z extensions are assumed to be gzipped.
# usage: zcmpmfiles_res_0 retcall keyword testvar tol passvar ndig srcfile reffile
# See also zcmpmfiles_res_tol, which accomplished the same thing but with extra argument nlines
#   retcall      : return to this point in script on exit
#   keyword      : label (for printout)
#   tol          : tolerance in maximum allowed deviation
#   passvar      : $passvar is unset if |testvar|<tol
#   ndig         : number of digits numbers in file are stripped to
#   srcfile      : first file to compare
#   reffile      : second file to compare
# Note:
# If use_mc is set, this script uses mcx -cmpf~max to evaluate the max difference
# Example:
# zcmpmfiles_res_0 chk1ck "Max deviation in bnds.$ext from reference" $bndstol pass 4 bnds.$ext $testdir/bnds.$ext.gz
exit
zcmpmfiles_res_0:
  set quitjobl=$retcall
# echo $retcall $keyword $tol $?passvar $ndig $srcfile $reffile

  unset retval

  if ($?use_mc) then
    # set retval = `$mcx -cmpf~fn1=$srcfile~fn2=$reffile~tol=1d-$ndig~max`
    set retval = `$mcx -cmpf~fn1=$srcfile~fn2=$reffile~tol=1d-15~max`
    goto zcmpmfilesx
  endif

  call zcmpmfiles zcmpmfilesx "$ndig $srcfile $reffile"
zcmpmfilesx:
  echo -n "$space $keyword ($retval) within tol ($tol)? ... "
  if (`echo $retval 0 | awk -v tol=$tol '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k<=tol)}'`) then
    echo yes
  else
    echo no
    unset $passvar
  endif
  goto $quitjobl

# ---------------- zcmpmfiles_res_mc --------------
# Compares numerical arguments in two files, using mcx -cmpf
# If mcx is not installed, calls zcmpnfiles_res_tol with the same arguments but the last
# usage: zcmpnfiles_res_mc retcall keyword tol passvar ndig srcfile reffile nlines count
#   retcall      : return to this point in script on exit
#   keyword      : label (for printout)
#   tol          : tolerance in maximum allowed deviation
#   passvar      : $passvar is unset if numerical value of word > tol, count occurences
#   ndig         : number of digits numbers in file are stripped to
#   srcfile      : first file to compare
#   reffile      : second file to compare
#   nlines       : number of lines to compare. Use 0 to include all lines.
#                : Use -1 to create differences with unix diff -y, followed by mcx -cmpf~diffy
#   count        : maximum number of deviations to permit before unsetting passvar.
#
# Checks for max absolute difference and unsets $passvar if difference<$tol fewer than count times
# If variable exclude is set, it is used as a regular expression to exclude lines containing it
# Example:
# zcmpmfiles_res_mc chk1ck "Max deviation in bnds.$ext from reference" $bndstol pass 4 bnds.$ext $testdir/bnds.$ext.gz 0 1
# Updates
# 21 Sep 2018 Added diff -y option (nlines=-1)
exit
zcmpmfiles_res_mc:
  set quitjobl=$retcall
# echo $retcall $keyword $tol $?passvar $ndig $srcfile $reffile $nlines $count

  if (! $?mcx) then
    echo "$space OOPS! missing mcx calculator ... skipping test $keyword"
    goto $quitjobl
  endif

  set fn1 = $tmpdir/tmp_compnfile_1
  set fn2 = $tmpdir/tmp_compnfile_2
  set fn3 = $tmpdir/tmp_compnfile_3

  if ($?exclude) then
    cat   $srcfile | sed 's:\([1-9]\)-:\1 -:g' | egrep -v "$exclude" > $fn1
    cat   $reffile | sed 's:\([1-9]\)-:\1 -:g' | egrep -v "$exclude" > $fn2
  else
    cat   $srcfile | sed 's:\([1-9]\)-:\1 -:g' > $fn1
    cat   $reffile | sed 's:\([1-9]\)-:\1 -:g' > $fn2
  endif

  set nl
  if ($nlines > 0) set nl = "~ln=$nlines"

  if ($nlines < 0) then
    diff -W 320 -y $fn1 $fn2 | expand > $fn3
#   echo $mcx -cmpf$nl~fn1=$fn3~diffy=320~tol=1d-15~max
    set retval = `$mcx -cmpf$nl~fn1=$fn3~diffy=320~tol=1d-15~max`
#   echo retval $retval
    set ndiff = `$mcx -cmpf$nl~fn1=$fn1~diffy=320~tol=1d-$ndig~ndiff`
#   echo ndiff $ndiff
  else
#   echo $mcx -cmpf$nl~fn1=$fn1~fn2=$fn2~tol=1d-$ndig~max~verb
    set retval = `$mcx -cmpf$nl~fn1=$fn1~fn2=$fn2~tol=1d-15~max`
#   echo retval $retval
    set ndiff = `$mcx -cmpf$nl~fn1=$fn1~fn2=$fn2~tol=1d-$ndig~ndiff`
#   echo ndiff $ndiff
  endif

  echo -n "$space $keyword ($retval) within tol ($tol)? ... "
  if (`echo $retval 0 | awk -v tol=$tol '{print ($1 <= tol)}'`) then
    echo yes
  else if ($count > 0) then
    echo -n "no ... fewer than $count occurences? ..."
    if (`echo $ndiff 0 | awk -v count=$count '{print ($1 <= count)}'`) then
      echo yes
    else
      echo no
      unset $passvar
    endif
  else
    echo no
    unset $passvar
  endif
  goto $quitjobl

# ---------------- zcmpmfiles_res_tol --------------
# Compares two files, stripping all but numerical fields.
# Note: zcmpmfiles_res_mc is more effective if you have mcx installed
# Checks for max absolute difference and unsets $passvar if difference<$tol
# Files with .gz or .Z extensions are assumed to be gzipped.
# usage: zcmpnfiles_res_tol retcall keyword testvar tol passvar ndig srcfile reffile nlines
# See also zcmpmfiles_res_0, which accomplished the same thing but without nlines
#   retcall      : return to this point in script on exit
#   keyword      : label (for printout)
#   tol          : tolerance in maximum allowed deviation
#   passvar      : $passvar is unset if |testvar|<tol
#   nlines=#     : (optional)
#   ndig         : number of digits numbers in file are stripped to
#   srcfile      : first file to compare
#   reffile      : second file to compare
#   nlines       : number of lines to compare. Use 0 for all lines.  Inoperative if either file is a zipped file.
# Example:
# zcmpmfiles_res_tol chk1ck "Max deviation in bnds.$ext from reference" $bndstol pass 4 bnds.$ext $testdir/bnds.$ext.gz 0
exit
zcmpmfiles_res_tol:
  set quitjobl=$retcall
# echo $retcall $keyword $tol $?passvar $ndig $srcfile $reffile $nlines

  unset retval
  if ($nlines == 0) then
    call zcmpmfiles zcmpmfilesx "$ndig $srcfile $reffile"
  else
    call zcmpmfiles zcmpmfilesx "nlines=$nlines $ndig $srcfile $reffile"
  endif
zcmpmfilesx:
  echo -n "$space $keyword ($retval) within tol ($tol)? ... "
  if (`echo $retval 0 | awk -v tol=$tol '{{k=($1-$2)>0?($1-$2):($2-$1);} print (k<=tol)}'`) then
    echo yes
  else
    echo no
    unset $passvar
  endif
  goto $quitjobl

# ---------------- zcmpnfiles --------------
# Compares two files, treating each field as a number.
# call arguments should contain 3 strings: n test-file reference-file
# |n| = number of digits which numbers are truncated to.
# If n<0, sort files before comparing them
# Alternatively call arguments can contain 4 strings : nlines=# n test-file reference-file
# nlines=# specifies that the check is made on the first # lines only
# Files with .gz or .Z extensions are assumed to be gzipped.
# (nlines doesn't work with gzipped files; sorry)
# Returns with retval = number of differences in reduced files.
# Example :  call zcmpnfiles chk25 "6 dos-cls.$ext $testdir/dos-cls.$ext.gz"
# Creates temporary files $tmpdir/tmp_compnfile_1 $tmpdir/tmp_compnfile_2
exit
zcmpnfiles:
  set quitjob=$retcall
  set zcmpnargs = ($callarg)

  set nlines ; unset nlines
  switch ($zcmpnargs[1])
    case "nlines=*":
      set nlines = `echo $zcmpnargs[1] | sed s/nlines=//`
      @ nlines = $nlines  # Checks to make sure this is an integer
      shift zcmpnargs

    default:
  endsw

  set lsort; unset lsort
  @ digits = $zcmpnargs[1]
  if ($digits < 0) then
    @ digits = - $digits
    set lsort
  endif
# set a = ' { for (i = NF; i > 0; --i) printf " %.'$digits'f", $i; printf "\n" }'
# set a = ' { for (i = 1; i <= NF; i++) { k = sprintf("%.'$digits'f",$i); if (k+k == 0) k = 0 ; printf "%s ", k}; printf "\n" }'
  set a = ' { for (i = 1; i <= NF; i++) { k = sprintf("%.'$digits'f",$i); if (k+k == 0) k = 0 ; printf "%s ", k}; print "" }'

  set fn1 = $tmpdir/tmp_compnfile_1
  set fn2 = $tmpdir/tmp_compnfile_2
  if ("$zcmpnargs[2]:e" == 'gz' || "$zcmpnargs[2]:e" == 'Z') then
    set cat1 = 'gunzip -c'
  else
    set cat1 = cat
    if ($?nlines) then
      set cat1 = "head -$nlines"
    endif
  endif
  if ("$zcmpnargs[3]:e" == 'gz' || "$zcmpnargs[3]:e" == 'Z') then
    set cat2 = 'gunzip -c'
  else
    set cat2 = cat
    if ($?nlines) then
      set cat2 = "head -$nlines"
    endif
  endif

  # if (! $?quiet) then
  #   if ($?lsort) then
  #   if ($?exclude) then
  #     echo "$cat1 $zcmpnargs[2] | sed 's:\([1-9]\)-:\1 -:g' | egrep -v "$exclude" | sed s/D-/E-/g | sed s/D+/E+/g | sort | awk '"$a"' >" $fn1
  #     echo "$cat2 $zcmpnargs[3] | sed 's:\([1-9]\)-:\1 -:g' | egrep -v "$exclude" | sed s/D-/E-/g | sed s/D+/E+/g | sort | awk '"$a"' >" $fn2
  #   else
  #     echo "$cat1 $zcmpnargs[2] | sed 's:\([1-9]\)-:\1 -:g' | sed s/D-/E-/g | sed s/D+/E+/g | sort | awk '"$a"' >" $fn1
  #     echo "$cat2 $zcmpnargs[3] | sed 's:\([1-9]\)-:\1 -:g' | sed s/D-/E-/g | sed s/D+/E+/g | sort | awk '"$a"' >" $fn2
  #   endif
  #   else
  #   if ($?exclude) then
  #     echo "$cat1 $zcmpnargs[2] | sed 's:\([1-9]\)-:\1 -:g' | egrep -v "$exclude" | sed s/D-/E-/g | sed s/D+/E+/g | awk '"$a"' >" $fn1
  #     echo "$cat2 $zcmpnargs[3] | sed 's:\([1-9]\)-:\1 -:g' | egrep -v "$exclude" | sed s/D-/E-/g | sed s/D+/E+/g | awk '"$a"' >" $fn2
  #   else
  #     echo "$cat1 $zcmpnargs[2] | sed 's:\([1-9]\)-:\1 -:g' | sed s/D-/E-/g | sed s/D+/E+/g | awk '"$a"' >" $fn1
  #     echo "$cat2 $zcmpnargs[3] | sed 's:\([1-9]\)-:\1 -:g' | sed s/D-/E-/g | sed s/D+/E+/g | awk '"$a"' >" $fn2
  #   endif
  #   endif
  # endif

  if ($?lsort) then

    if ($?exclude) then
      $cat1  $zcmpnargs[2] | sed 's:\([1-9]\)-:\1 -:g' | egrep -v "$exclude" | sed s/D-/E-/g | sed s/D+/E+/g | sort | awk "$a" > $fn1
      $cat2  $zcmpnargs[3] | sed 's:\([1-9]\)-:\1 -:g' | egrep -v "$exclude" | sed s/D-/E-/g | sed s/D+/E+/g | sort | awk "$a" > $fn2
    else
      $cat1  $zcmpnargs[2] | sed 's:\([1-9]\)-:\1 -:g' | sed s/D-/E-/g | sed s/D+/E+/g | sort | awk "$a" > $fn1
      $cat2  $zcmpnargs[3] | sed 's:\([1-9]\)-:\1 -:g' | sed s/D-/E-/g | sed s/D+/E+/g | sort | awk "$a" > $fn2
    endif
  else

    if ($?exclude) then
      $cat1  $zcmpnargs[2] | sed 's:\([1-9]\)-:\1 -:g' | egrep -v "$exclude" | sed s/D-/E-/g | sed s/D+/E+/g | awk "$a" > $fn1
      $cat2  $zcmpnargs[3] | sed 's:\([1-9]\)-:\1 -:g' | egrep -v "$exclude" | sed s/D-/E-/g | sed s/D+/E+/g | awk "$a" > $fn2
    else
      $cat1  $zcmpnargs[2] | sed 's:\([1-9]\)-:\1 -:g' | sed s/D-/E-/g | sed s/D+/E+/g | awk "$a" > $fn1
      $cat2  $zcmpnargs[3] | sed 's:\([1-9]\)-:\1 -:g' | sed s/D-/E-/g | sed s/D+/E+/g | awk "$a" > $fn2
    endif
  endif

  set ncharfile = `wc $fn1 | awk '{print $3}'`
  set nwordfile = `wc $fn1 | awk '{print $2}'`
  set nlinefile = `wc $fn1 | awk '{print $1}'`

  cmp $fn1 $fn2 >/dev/null
  set retval = $status

  if ($retval == 0) then
    rm -f $fn1 $fn2 $fn3
    goto $quitjob
  endif

  set retval = `cmp -l $fn1 $fn2 |& grep -v EOF | wc | awk '{printf "%d", $1}'`
  if ($retval == 0) set retval = '-1'
  rm -f $fn1 $fn2 $fn3
  goto $quitjob

# ---------------- zcmpmfiles --------------
# Compares two files, treating each field as a number.
# Call arguments should contain 3 strings: no-digits test-file reference-file
# Alternatively call arguments can contain 4 strings : nlines=# n test-file reference-file
# nlines=# specifies that the check is made on the first # lines only
# Files with .gz or .Z extensions are assumed to be gzipped.
# Returns with retval = max numerical difference
# Example :  call zcmpmfiles chk25 "6 dos-cls.$ext $testdir/dos-cls.$ext.gz"
# Creates temporary files $tmpdir/tmp_compnfile_1 $tmpdir/tmp_compnfile_2
exit
zcmpmfiles:
  set quitjob=$retcall
  set zcmpnargs = ($callarg)

  set nlines ; unset nlines
  switch ($zcmpnargs[1])
    case "nlines=*":
      set nlines = `echo $zcmpnargs[1] | sed s/nlines=//`
      @ nlines = $nlines  # Checks to make sure this is an integer
      shift zcmpnargs

    default:
  endsw

  set digits = $zcmpnargs[1]
# set a = ' { for (i = NF; i > 0; --i) printf " %.'$digits'f", $i; printf "\n" }'
  set a = ' { for (i = 1; i <= NF; i++) { k = sprintf("%.'$digits'f",$i); if (k+k == 0) k = 0 ; printf "%s ", k}; printf "\n" }'

  set fn1 = $tmpdir/tmp_compnfile_1
  set fn2 = $tmpdir/tmp_compnfile_2
  if ("$zcmpnargs[2]:e" == 'gz' || "$zcmpnargs[2]:e" == 'Z') then
    set cat1 = 'gunzip -c'
  else
    set cat1 = cat
    if ($?nlines) then
      set cat1 = "head -$nlines"
    endif
  endif
  if ("$zcmpnargs[3]:e" == 'gz' || "$zcmpnargs[3]:e" == 'Z') then
    set cat2 = 'gunzip -c'
  else
    set cat2 = cat
    if ($?nlines) then
      set cat2 = "head -$nlines"
    endif
  endif

  $cat1  $zcmpnargs[2] | sed s/D-/E-/g | sed s/D+/E+/g | awk "$a" > $fn1
  $cat2  $zcmpnargs[3] | sed s/D-/E-/g | sed s/D+/E+/g | awk "$a" > $fn2

# wc $fn1 $fn2

  set retval = `diff -y --width=300 $fn1 $fn2 | grep '|' | awk -v top=0 '{n=split($0,a,"|"); n1=split(a[1],b1); n2=split(a[2],b2); { j=0; while (j++ < n1) if (j <= n1 && j<=n2) {x = (b1[j]-b2[j])>0?(b1[j]-b2[j]):(b2[j]-b1[j]); top = (top-x)>0?top:x; }}} END {printf "%12.4e\n", top}'`
  rm -f $fn1 $fn2
  goto $quitjob

# ---------------- qprint (print only quiet not set) --------------
exit
qprint:
  set quitjob=$retcall
  if ($?quiet) goto $quitjob
  echo "$callarg"
  goto $quitjob

# ---------------- showout --------------
exit
showout:
  set quitjob=$retcall
  if ($?quiet) goto $quitjob
  echo ' '
  echo "$space ... Compare $callarg to line(s) in file $refout":
  grep "$callarg" $testout
  if (`cat $testout | grep "$callarg" | wc | awk '{print $1}'` > 1) echo ' ---'
  zcat $refout | grep "$callarg"
  goto $quitjob

# ---------------- findcmd --------------
# Finds an executable program within the supplied path
# Usage: findcmd return_label executable_command path_name make_path
# If $executable_command is not found, findcmd does one of the following:
# If make_path = 'no' : returns silently.
# Otherwise findcmd aborts with a message, which assumes
# $make_path is the path where $executable_command is made.
exit
findcmd:
set found = 'no'
foreach ac_dir ($path_name)
 if (-x $ac_dir/$prog_cmd) then
   set $prog_cmd = $ac_dir/$prog_cmd
   set found = 'yes'
   break
 endif
end
if (! $?quiet) then
  if ($found == 'yes') echo "$space ... using executable $ac_dir/$prog_cmd"
  if ($found == 'no')  echo "$space ... no executable $prog_cmd found in path"
endif

# echo make_path $make_path

if ($found == 'no' && $make_path != "optional") then
  echo "  "
  echo "  Sorry, $testfile cannot find program '"$prog_cmd"' it needs to execute."
  echo "  '"$prog_cmd"' was not found in supplied path, or in the following:"
  echo "        $topdir"
# echo "  ... This script ($testfile) requires binary "'"rdcmd"'" to run."
  echo "  You must create or put '"$prog_cmd"' in your path before invoking this script."
  echo "  Normally '"$prog_cmd"' is created as part of the installation process."
  echo "  Invoking '"make $prog_cmd"' in $make_path should create it."
  echo "  $testfile aborting ..."
  exit -1
endif
goto $retcall

# ---------------- query --------------
exit
query:
  unset skip
  if ($?slow != 0) then
    if ("$retcall" == "$retcall2") then
    echo "$space"'*'"hit <return> to $callarg"
    else
    echo "$space"'*'"hit <return> to $callarg, s <return> to skip it."
    endif
    set a = ($<)
    if ($a == "") goto $retcall
    switch ($a)
      case "quit":
      case "q":
      case "a":
        exit
      case "i":
        unset slow
        breaksw
      case "s":
        set skip
        breaksw
      case "t":
        time
        goto query
      default:
        echo 'q to quit; i unsets slow; s skips this job, t shows time'
        goto query
    endsw
  endif
  if ($?skip) goto $retcall2
  goto $retcall

# ---------------- List tests --------------
showtests:
cat <<EOF
  Usage: invoke with:   $testfile [switches] name [job]

   name    tests
    ... the following apply to job 1: mainly they test the GW driver lmfgwd
    si        tests lmf and driver lmfgwd for a simple case
              Also runs optics using lmf (no local fields)
              On completion, the script suggests tests illustrating other features
    mno       tests lmfgwd for MnO, an antiferromagnetic insulator
    gas       tests lmfgwd for GaAs, with low-lying local orbitals
    cu        tests lmfgwd for Cu, a metal, including the Cu 4d state as a local orbital

    na        another test with local orbitals

    ... The following apply to jobs 2,3,4.  These tests require that the GW package be installed
    si2       tests operation of GW code for an insulator, (jobs 2 and 4)
    fe        tests 1-shot and 1 iteration of QSGW for a metal (jobs 2, 4, 5)
    coo2      0th iteration of QSGW for a difficult material (jobs 2, 4, 7 --code2 only)
              Job 7 tests matrix elements of Hartree potential
    six       tests operation of GW code for an insulator with floating orbitals
    jell      tests operation of GW code for jellium at Na lattice constant with 1 electron
    cr3si6    0th iteration of QSGW for a material with many equivalent atoms (jobs 4,7 --code2 only)
              Job 7 tests product basis maker

    ... The following applies to job6.  Requires that the GW package be installed
    nio       dielectric function.  Also can compare to epsilon(omega) to lmf optics calculation (--withlmfoptics)
    zbmnas    transverse spin susceptibility (no local fields)

  jobs:  1: tests driver lmfgwd (main function of this script)
         2: one-shot calculations
         3: RPA total energy (not working)
         4: QSGW calculation
         5: tests generation of the energy-dependent self-energy
            Job 4 must be completed before running this test
         6: tests susceptibility
         7: Miscellaneous checks of the GW suite, e.g. tests product basis maker (coo2)
EOF
exit

# ---------------- usage: --------------
usage:
cat <<EOF
 usage: test.gwd [switches] [file-extension|--all] [testcase-list]
        e.g., "test.gwd mno 1"
        If file-extension is missing, test.gwd uses si
        Switches:
        --list       lists the tests you can run
        --quiet      runs tests with minimal output and without prompting user
        --no-iactive runs tests without prompting user
        --code2      Test GW driver, Sep12 version (gwcode=2)
        --all        run through a default list of test cases
        --noplot     skip any steps that generate a plot'
        --clean      clean up files generated by this script
        --GWversion# Set GWversion to # in GWinput
        --timereversaloff  Turn off time reversal symmetry
        --eibzmodeoff      Turn off symmetrization in the inner k loop
        --so2|so3    Add SO coupling, LzSz or LzSz + L+S- perturbatively (Fe only)
        --add0       add suppressed or leading zeros in output for real numbers \`.nnn'
        --poszer     strips (-) sign from numbers represented as 0
	--openmp=#   Run open-MP versions of certain executables
        --whichexec  prints out which lmfgwd executable it finds in path and exits
	--mpi=#1,#2  Run MPIK for lmf,lmfgwd #1 processors, open-MP for certain executables with #2 processors
	--withlmfoptics Compares optics to lmf optics (Only for NiO so far)


EOF
exit -1
