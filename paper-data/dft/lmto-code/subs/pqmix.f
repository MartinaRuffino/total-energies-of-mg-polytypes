      subroutine pqmix(nclass,nl,lmx,nsp,nx,iter,mixmod,dmxp,cnst,
     .  pold,qold,qrold,xold,pnu,qnu,qnur,xnew)
C- Iteration-dependent Anderson or Broyden mixing of P and Q
C ------------------------------------------------------------------
Ci Inputs:
Ci   nclass:number of inequivalent classes
Ci   nl    :(global maximum l) + 1
Ci   lmx   :lmx(j) = maximum l for atom j
Ci   nsp   :2 for spin-polarized case, otherwise 1
Ci   nx    :number of extra numbers to include in mix, kept in xold and nnew
Ci   iter  :iteration number
Ci   mixmod: string containing iteration-dependent mixing (parmxp)
Ci   nsp,nl,lmx:number of spins, l's, and lmax for each site
Ci   cnst  :if 0th element is <= zero, do nothing. Els cnst(i) applies to class i
Ci         :if cnst >  0, copy pold->pnu
Ci         :if cnst /= 0, copy qold->qnu
Ci   pold  :original principal quantum number that with qold generated pnu,qnu
Ci   qold  :original moments that together with pold generated pnu,qnu
Ci   qrold :original relativistic moments.  qrold(1)=-1 => moments do not exist
Ci   xold  :vector of initial value of extra parameters to include in mix
Cio Inputs/Outputs:
Ci   dmxp  : holds a vector of default values for mixing parms,
Ci           and also some output generated by pqmix.
Ci    Mixing parameters, and entries to dmxp holding default values:
Ci    1(I): mixing mode (assigned to local variable broy)
Ci          0, use Anderson mixing
Ci          1  use Broyden mixing, D. Johnson's approach
Ci          2, use C. G. mixing
Ci    2: beta (linear and Anderson mixing only) weighting of output to
Ci           input in making new vector: beta*output + (1-beta)*input
Ci    3: wc  Broyden mixing parameter (see routine Broyden).
Ci           wc<0: set wc_true = abs(wc) * RMS DQ, where RMS DQ is the
Ci           inverse of the RMS difference of input and output vector
Ci    4,5:wt(1,2):(nsp=2 only): pqmix mixes sum (up+down) and difference
Ci                (up-down) of the two spin channels.  They are weighted
Ci                by wt(1) and wt(2) in the mixing.  As special cases,
Ci                wt(2)=0 freezes the moments and mixes the charge only
Ci                wt(1)=0 freezes the charge and mixes the moments only
Ci    6(I): mxsav retain on disc a maximum of mxsav previous iterations.
Ci    7(I): mmix  mix this iteration a maximum of nmix prior iterations.
Ci                If mmix<0, choose a default.
Ci    8(I): nkill if nonzero, mixing file is killed after each multiple
Ci                of nkill iterations
Ci    9: betv
Ci   10: rmscst
Ci   34: wa       (AKA wt(3)) weight with which to include extra numbers
Ci                into the mixing procedure
Co   ... 11-20 are outputs.
Co   11: rmsdel   rms change in mixing vector
Co   12: rms2     rms change in Q only
Co   13: nmix     number of prior iter actually included in the mix
Co   14: broy
Co   15: actual mixing beta used (may be changed interactively)
Co   16-24: tj    Anderson mixing, linear combination of prior iter;
Co                Broyden mixing, Actual wc used
Co   25:          1 if wt ne 0, 10 if wa ne 0, 11 if all nonzero
Co
Cio  pnu,qnu:princ quantum number generated generated by hamiltonian
Co Outputs:
Cio  pnu,qnu:mixed principal quantum number and moments
Cio  qnur   :mixed relativistic moments (ignored if qrold(1) is -1)
Ci   xnew   :vector of extra parameters, mixed.
Cl Local variables
Cl    mmix: max no. prior iterations available from disk.
Cr Remarks:
Cr   Original Broyden version written by C. T. Chan, Ames Laboratory.
Cr   See D. Vanderbilt, S. G. Louie in Phys. Rev B 30, 6118 (1984).
Cr   The Broyden method requires a first estimation for the Jacobian
Cr   if no prior information is available.  Therefore, for the first
Cr   iteration, linear mixing is applied to calculate a first
Cr   Jacobian matrix J^(1) as well as beta^(1) and gamma^(1).
Cu Updates
Cu   13 Sep 18 New --mixonlyp switch
Cu   20 Feb 15 Optionally mix relativistic moments qnur
Cu   25 Jun 13 Replace f77 pointers with f90 ones
Cu   04 Sep 03 Allow default wa to have independent value
Cu   26 Apr 03 Added MPI calls
C ----------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer broy
      character*(*) mixmod
      integer nclass,nl,nsp,nx,lmx(nclass),iter,cnst(0:nclass)
      double precision dmxp(34),
     .  qrold(4,nl,2*nl,2,2,nclass),qnur(4,nl,2*nl,2,2,nclass),
     .  pnu(nl,nsp,nclass), qnu(3,nl,nsp,nclass), xnew(nx),
     .  pold(nl,nsp,nclass),qold(3,nl,nsp,nclass),xold(nx)
C ... Dynamically allocated local arrays
      integer, allocatable :: cnstl(:)
      real(8), allocatable,target :: a(:,:)
      real(8), pointer :: aa(:,:)
C ... Local parameters
      logical lcnst,lrel2,onlyp
      integer,parameter :: NULLI=-99999
      integer mmix,nda,ic,l,nelts,idum,j,mxsav,nmix,na,naa,
     .  nkill,ifi,npq,npqr,i1,i2,stdo
      integer mpipid,procid
      character outs*80,fnam*8
      double precision wt(3),rmsdel,rms2,wc,beta,beta0,elind,rms2f,xx
      procedure(logical) :: parmxp
      procedure(integer) :: awrite,lgunit,iprint,fopna,nglob
      procedure(logical) :: cmdopt

C ... MPI: only master does mixing
      procid = mpipid(1)
      stdo = nglob('stdo')
      lrel2 = qrold(1,1,1,1,1,1) > NULLI+1  ! Fully relativistic case
C#ifndef ALENA
C     lrel2 = .false.
C#endif
      if (procid /= 0) goto 999

C --- Local copy of cnst, possibly to modify because b2 is 0 ---
      allocate(cnstl(0:nclass))
      call icopy(nclass+1,cnst,1,cnstl,1)
      onlyp = cmdopt('--mixonlyp',10,0,outs)
      if (onlyp) then
        if (cnst(0) == 0) call iinit(cnstl,nclass+1)
        cnst(0) = 1
        do  ic = 1, nclass
          if (cnstl(ic) == 0) cnstl(ic) = -1
        enddo
        if (lrel2) call rx('pqmix not ready for --mixonlyp and lrel=2')
      endif

      if (iprint() > 30) write(stdo,*) ' '
      lcnst = cnst(0) > 0
      if (lrel2 .and. nx /= 0) call rx('pqmix not ready for nx>0 and lrel=2')

C --- Count number of mixing elements; get rms err for parmxp ---
      npq = 0; npqr = 0; rms2 = 0
      do  ic = 1, nclass
        if (lcnst) then
          if (cnstl(ic) > 0) cycle
        endif
        do  l = 0, lmx(ic)
          npq = npq+4
          if (lcnst) then
            if (cnstl(ic) < 0) npq = npq-3
          endif
          npqr = npqr + 32*nl
        enddo
      enddo
      if (lrel2) then  ! Either mix qnu or qnur
        npq = 0
        nda = npqr
      else
        npqr = 0
        nda = npq*nsp
      endif
      nda = nda + nx
C ... this call reads nothing from disk since nmix=0.  Returns rms2
      nmix = 0
      allocate(a(nda,(0+2)*2)); call dpzero(a,nda*(0+2)*2)
      call pqmxio(nmix,nmix,1,.true.,lrel2,nclass,nl,nsp,nx,lmx,
     .  pnu,pold,qnu,qnur,qold,qrold,xnew,xold,cnstl,nda,a,na,rms2)
      deallocate(a)

C --- Iteration-dependent mixing parameters ---
      broy  = nint(dmxp(1))
      beta  = dmxp(2)
      wc    = dmxp(3)
      wt(1) = dmxp(4)
      wt(2) = dmxp(5)
      wt(3) = dmxp(34)
      if (nx == 0) wt(3) = -9
      mxsav = nint(dmxp(6))
      nmix  = nint(dmxp(7))
      nkill = nint(dmxp(8))
      elind = dmxp(33)
      fnam  = 'mixm'
      rmsdel = dmxp(11)
      xx = 0
      if (.not. parmxp(iter,mixmod,len(mixmod),broy,nmix,wt,beta,xx,elind,xx,xx,
     .  fnam,wc,nkill,dmxp(9),rms2)) call rx('PQMIX: parse in parmxp failed')
C ... Interactively reset mix-parms block
      i1 = 0
      i2 = 0
      if (index(mixmod,';') > 0) then
      call query('mix-parms-block',2,i1)
      call query('block-iter',2,i2)
      if (i1 > 0 .or. i2 > 0) then
        if (i2 <= 0) i2 = 1
        call parmx0(i1,i2,0d0)
        if (.not. parmxp(iter,mixmod,len(mixmod),broy,nmix,wt,beta,xx,elind,xx,xx,
     .    fnam,wc,nkill,dmxp(9),rms2)) call rx('PQMIX: parse in parmxp failed')
      endif
      endif
      if (nsp == 1) wt(2) = 0
      if (wt(1)**2+wt(2)**2+wt(3)**2 == 0)
     .  call fexit(-1,111,' Exit -1 PQMIX: bad mixing weights w =%3:1;6d',wt)
      call dscal(3,1/dsqrt(wt(1)**2+wt(2)**2+wt(3)**2),wt,1)

C --- Determine number of previous iterations available from disk ---
      mmix = 0
      ifi = fopna(fnam,-1,4); rewind ifi
        read (ifi,err=5,end=5) idum,nelts
      if (nelts /= na) then
        call info2(20,0,0,' PQMIX: expecting %i elements but found %i ... discarding file',na,nelts)
C        call awrit2(' PQMIX: expecting %i elements but found %i ... '//
C     .    'discarding file',' ',80,lgunit(1),na,nelts)
        goto 5
      endif
      call info2(41,0,0,' PQMIX: file '//trim(fnam)//' contains %i elements',nelts,0)
C      if (iprint() > 40) call awrit1(' PQMIX: file '//fnam//
C     .  '%a contains %i elements',' ',80,lgunit(1),nelts)
      mmix = idum
    5 continue

C --- Copy new P,Q into work array a; read prior iter from disk ---
      allocate(a(nda,(mxsav+2)*2)); call dpzero(a,nda*(mxsav+2)*2)
      call pqmxio(mmix,mxsav,ifi,.true.,lrel2,nclass,nl,nsp,nx,lmx,
     .  pnu,pold,qnu,qnur,qold,qrold,xnew,xold,cnstl,nda,a,na,rms2)
C     print *,'sum a',sum(a)

C --- Initial printout ---
      if (iprint() >= 20) then
        j = awrite(' PQMIX:  read %i iter from file',outs,len(outs),0,mmix,0,0,0,0,0,0,0)
        outs(j+2:len(outs)) = fnam
        call awrit1('%a.  RMS DQ=%1,3;3e',outs,80,0,rms2)
        if (rmsdel /= 0) call awrit1('%a  last it=%1,3;3e',outs,80,0,rmsdel)
        do  j = 1, 2
          call awrit0('%a',outs,-len(outs),-lgunit(j))
        enddo
      endif
      rmsdel = rms2

C --- Save updated P,Q on disk ---
      rewind ifi
      write(ifi) min(mmix+1,mxsav), na
      call pqmxio(mmix+1,mxsav,-ifi,.true.,lrel2,nclass,nl,nsp,nx,lmx,
     .  pnu,pold,qnu,qnur,qold,qrold,xnew,xold,cnstl,nda,a,na,rms2)
      if (nkill < 0) then
        if (iprint() >= 20) then
          outs = '    ...  deleting file '//fnam
          call awrit1('%a : nkill=%i',outs,80,-lgunit(1),-nkill)
        endif
        call dfclos(ifi)
      else
        call fclose(ifi)
      endif

C --- Spin polarized case: shuffle average and delta moments ---
C     if (nsp == 2 .or. nx > 0) then
      if (nsp == 2 .and. npq > 0 .or. nx > 0) then
        if (wt(2) /= 0 .and. nsp == 1) call rx('pqmix bug in wt(2)')
        naa = 0
        if (wt(1) /= 0) naa = naa+npq
        if (wt(2) /= 0) naa = naa+npq
        if (wt(3) /= 0) naa = naa+nx
        allocate(aa(naa,(mxsav+2)*2)); call dpzero(aa,naa*(mxsav+2)*2)
        call pqsclf(0,nda,npq,npq*nsp,(nsp-1)*npq,nx,naa,mxsav,wt,a,aa,rms2f)
      else
        aa => a
        naa = na
      endif

C --- Broyden mixing, Duane Johnson's approach ---
      if (broy == 1 .and. mmix /= 0) call pqmixb(naa,nmix,mmix,mxsav,beta,wc,rms2,aa,dmxp(16))

C --- Broyden mixing, old style ---
C     if (broy .and. mmix /= 0) call pqmixb(naa,nmix,mmix,mxsav,wc,rms2,aa,dmxp(16))

      if (broy == 2) call pqmixc(naa,nmix,mmix,mxsav,beta,rms2,aa,dmxp(16))

C --- Anderson mixing ---
      beta0 = beta
      if (broy == 0 .or. (broy == 1 .and. (mmix == 0 .or. nmix == 0))) then
        call pqmixa(naa,nmix,mmix,mxsav,beta,rms2,aa,dmxp(16))
        broy = 0
      endif

C --- Spin polarized case: undo shuffle ---
      if (nsp == 2 .and. npq > 0 .or. nx > 0) then
        call pqsclb(nda,npq,npq*nsp,(nsp-1)*npq,nx,naa,mxsav,wt,a,aa)
      endif

C --- Copy mixed P,Q from holding array into P,Q arrays ---
      call pqmxup(na,lrel2,mxsav,nclass,nl,nsp,nx,lmx,pnu,qnu,qnur,xnew,
     .  pold,qold,qrold,xold,cnstl,nda,a,rms2)

C --- Clean up and exit ---
      if (nmix < 0) dmxp(7) = -nmix
      if (beta0 /= beta) dmxp(2) = beta
      dmxp(11) = rmsdel
      dmxp(12) = rms2
      dmxp(13) = iabs(nmix)
      dmxp(14) = broy
      dmxp(15) = beta
      if (broy == 1) dmxp(15) = 1
      if (nsp == 2 .and. npq > 0 .or. nx > 0) deallocate(aa)
      deallocate(a)
      dmxp(25) = 0
      if (wt(1) /= 0 .or. wt(2) /= 0) dmxp(25) = 1
      if (wt(3) /= 0) dmxp(25) = dmxp(25) + 10
      call parmx0(0,0,rmsdel)
      deallocate(cnstl)

C --- MPI broadcast everything to be returned back from pqmix ---
  999 continue
      if (lrel2) then
        call mpibc1(qnur,4*nl*2*nl*2*2*nclass,4,.false.,'pqmix','qnur')
      else
        call mpibc1(pnu,nl*nsp*nclass,4,.false.,'pqmix','pnu')
        call mpibc1(qnu,3*nl*nsp*nclass,4,.false.,'pqmix','qnu')
      endif
      call mpibc1(xnew,nx,4,.false.,'pqmix','xnew')
      call mpibc1(dmxp,34,4,.false.,'pqmix','dmxp')

C      print *, 'qold',qold(1,1,1,1)
C      print *, 'qnu',qnu(1,1,1,1)
C       pause

      end
      subroutine pqsclf(mode,nda,npq,offx,off2,nx,na,mxsav,wt,a,a2,rms2)
C- Split into (a+ + a-) and (a+ - a-); include extra data
C ------------------------------------------------------------------
Ci Inputs
Ci   mode  :1 a is already split into (a+ + a-) and (a+ - a-)
Ci   nda   :leading dimension of a
Ci   npq   :number of elements to spin-split with wt(1),wt(2)
Ci   offx  :(nx>0)offset to location in a of extra elements
Ci   off2  :offset to spin-down (should be 0 for nsp=1)
Ci   nx    :number of extra data to weight with w3
Ci   na    :dimension of a2 and number of data with nonzero weight
Ci   wt    :1,2 for P,Q (up+dn) and (up-dn), and wt(3) for extra
Ci   a     :(na,1:2,i,1) output vector for prev. iteration i
Ci         :(na,1:2,i,2) input  vector for prev. iteration i
Co Outputs
Co   a2    :(*,i,1) output charge and moments, scaled by weights
Co         :(*,i,2) input  charge and moments, scaled by weights
Co   rms2  :root mean square of a2(:,0,1)-a2(:,0,2)
Cr Remarks
Cr   q = a2(1) = wt1*(a(1)+a(2)) and mom = a2(2) = wt2*(a(1)-a(2))
Cr   If wt(1) or wt(2) is zero, a2 holds q or mom only.
Cr   na: no. elts to mix: 2*na if wt1,wt2 ne 0, otherwise na
C ------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer mode,nda,npq,nx,mxsav,na,offx,off2
      double precision wt(3),a(nda,0:mxsav+1,2),a2(na,0:mxsav+1,2),rms2,ddot
C ... Local parameters
      integer is,ia,ja

C      print *, '!!'; wt(1) = 1 ; wt(2) = 1
      ja = 0
      if (wt(1) == 0 .and. wt(2) == 0) goto 11
      do  is = 0, mxsav+1
        ja = 0
        do  ia = 1, npq

C         if ((ia == -3221 .or. ia == 1) .and. is == 0) then
C           print *, 'hi',ia,wt(1:2)
C           print 987, 'rhold+,-',a(ia,is,2),a(ia+off2,is,2)
C           print 987, 'rhnew+,-',a(ia,is,1),a(ia+off2,is,1)
C  987      format(a,2x,4f12.6)
CC          pause
C         endif

          if (wt(1) /= 0 .and. mode == 0) then
            ja = ja+1
C           Given (rhnew+ + rhnew-)*wt(1) ,  (rhold+ + rhold-)*wt(1)
            a2(ja,is,1) = (a(ia,is,1) + a(ia+off2,is,1))*wt(1)
            a2(ja,is,2) = (a(ia,is,2) + a(ia+off2,is,2))*wt(1)
          elseif (wt(1) /= 0) then
            ja = ja+1
            a2(ja,is,1) = a(ia,is,1)*wt(1)
            a2(ja,is,2) = a(ia,is,2)*wt(1)
          endif
          if (wt(2) /= 0 .and. mode == 0) then
            ja = ja+1
C           Given (rhnew+ - rhnew-)*wt(2) ,  (rhold+ - rhold-)*wt(2)
            a2(ja,is,1) = (a(ia,is,1) - a(ia+off2,is,1))*wt(2)
            a2(ja,is,2) = (a(ia,is,2) - a(ia+off2,is,2))*wt(2)
          elseif (wt(2) /= 0) then
            ja = ja+1
            a2(ja,is,1) = a(ia+off2,is,1)*wt(2)
            a2(ja,is,2) = a(ia+off2,is,2)*wt(2)
          endif
        enddo
      enddo
   11 continue

      if (wt(3) /= 0) then
        do  ia = 1, nx
          ja = ja+1
          do  is = 0, mxsav+1
            a2(ja,is,1) = a(ia+offx,is,1)*wt(3)
            a2(ja,is,2) = a(ia+offx,is,2)*wt(3)
          enddo
        enddo
      endif

      rms2 = dsqrt(dabs(ddot(na,a2,1,a2,1)     -
     .           2*ddot(na,a2,1,a2(1,0,2),1) +
     .             ddot(na,a2(1,0,2),1,a2(1,0,2),1))/(na-0))

      if (ja /= na) call rx('pqsclf: element mismatch')

      end
      subroutine pqsclb(nda,npq,offx,off2,nx,na,mxsav,wt,a,a2)
C- Undo split into wt1*q and wt2*mom done by pqsclf
C ----------------------------------------------------------------------
Ci Inputs
Ci   nda   :leading dimension of a
Ci   npq   :number of P,Q
Ci   offx  :offset to location in a of extra elements
Ci   off2  :offset to spin-down (should be 0 for nsp=1)
Ci   nx    :number of extra data
Ci   na    :dimensions a2; number of data with nonzero weight
Ci   wt    :1,2 for P,Q (up+dn) and (up-dn), and wt(3) for extra
Ci   a2    :mixed q,mom scaled by weights, or portion of a with nonzero weights
Co Outputs
Co   a     :a2 is unscaled and restored into a
Cr Remarks
Cu Updates
Cu   10 Dec 08
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer nda,na,npq,nx,mxsav,offx,off2
      double precision wt(3),a(nda,0:mxsav+1,2),a2(na,0:mxsav+1,2)
C ... Local parameters
      integer is,ia,ja
      double precision sum,diff

      if (wt(1) == 0 .and. wt(2) == 0) then
        ja = 0
      elseif (wt(1) /= 0 .and. wt(2) /= 0) then
        do  is = 0, mxsav+1
        ja = 1
        do  ia = 1, npq
C          if ((ia == 3221 .or. ia == -3) .and. is == 0) then
C            print *, 'hi',ia,wt(1:2)
C            print 987, 'mxold+,-',
C     .        (a2(ja,is,2)/wt(1) + a2(ja+1,is,2)/wt(2))/2,
C     .        (a2(ja,is,2)/wt(1) - a2(ja+1,is,2)/wt(2))/2
C            print 987, 'mxnew+,-',
C     .        (a2(ja,is,1)/wt(1) + a2(ja+1,is,1)/wt(2))/2,
C     .        (a2(ja,is,1)/wt(1) - a2(ja+1,is,1)/wt(2))/2
CC 987       format(a,2x,4f12.6)
CC           pause
C          endif
C         mixed  rhonew+,rhold+
          a(ia,is,1)     = (a2(ja,is,1)/wt(1) + a2(ja+1,is,1)/wt(2))/2
          a(ia,is,2)     = (a2(ja,is,2)/wt(1) + a2(ja+1,is,2)/wt(2))/2
C         mixed  rhonew-,rhold-
          a(ia+npq,is,1) = (a2(ja,is,1)/wt(1) - a2(ja+1,is,1)/wt(2))/2
          a(ia+npq,is,2) = (a2(ja,is,2)/wt(1) - a2(ja+1,is,2)/wt(2))/2
          ja = ja+2
        enddo
        enddo
        ja = 2*npq
      elseif (wt(1) /= 0) then
        diff = 0
        do  ia = 1, npq
        do  is = 0, mxsav+1
          ja = ia+off2
          sum  = a2(ia,is,1)/wt(1)
          diff = (a(ia,is,1) - a(ja,is,1))
          a(ia,is,1) = (sum + diff)/2
          a(ja,is,1) = (sum - diff)/2
          sum  = a2(ia,is,2)/wt(1)
          diff = (a(ia,is,2) - a(ja,is,2))
          a(ia,is,2) = (sum + diff)/2
          a(ja,is,2) = (sum - diff)/2
        enddo
        enddo
        ja = npq
      elseif (wt(2) /= 0) then
        do  ia = 1, npq
        do  is = 0, mxsav+1
          ja = ia+npq

C         if ((ia == -3221 .or. ia == 1) .and. is == 0) then
C            print *, 'hi',ia,wt(1:2)
C            print 987, 'given qold, mixed (+)-(-)',
C     .        (a(ia,is,2) + a(ja,is,2)),a2(ia,is,2)
C            sum  = (a(ia,is,2) + a(ja,is,2))
C            diff = a2(ia,is,2)/wt(2)
C            print 987, 'mixed +,-                ',
C     .        (sum + diff)/2, (sum - diff)/2
C  987       format(a,2x,4f12.6)
C          endif

C         given rhnew+ + rhnew- ; mixed  rhnew+ - rhnew-
          sum  = (a(ia,is,1) + a(ja,is,1))
          diff = a2(ia,is,1)/wt(2)
          a(ia,is,1) = (sum + diff)/2
          a(ja,is,1) = (sum - diff)/2
C         sum = given rhold+ + rhold- ; diff = mixed  rhold+ - rhold-
          sum  = (a(ia,is,2) + a(ja,is,2))
          diff = a2(ia,is,2)/wt(2)
          a(ia,is,2) = (sum + diff)/2
          a(ja,is,2) = (sum - diff)/2
        enddo
        enddo
        ja = npq
      endif

C --- Extra mixing data ---
      if (wt(3) /= 0) then
        do  is = 0, mxsav+1
        do  ia = 1, nx
          a(ia+offx,is,1) = a2(ia+ja,is,1)/wt(3)
          a(ia+offx,is,2) = a2(ia+ja,is,2)/wt(3)
        enddo
        enddo
      endif

      end

      subroutine pqsclc(nda,npq,nx,mxsav,a)
C- Copy a(:,0,2) into a(:,0,1)
C ----------------------------------------------------------------------
Ci Inputs
Ci   nda   :leading dimension of a
Ci   npq   :number of P,Q
Ci   nx    :number of extra data
Cio Inputs/Outputs
Cio  a     :On input
Cio        :(*,0,1) mixed output vector
Cio        :(*,0,2) mixed input vector
Cio        :On output
Cio        :(*,0,2) -> (*,0,1)
Cr Remarks
Cu Updates
Cu   10 Dec 08 First created
C ----------------------------------------------------------------------
      implicit none
      integer nda,npq,nx,mxsav
      double precision a(nda,0:mxsav+1,2)
      integer is,ia

      is = 0
      do  ia = 1, npq+nx
C        if (a(ia,is,1) /= a(ia,is,2)) then
C          call rx('pqsclc: oops')
C        endif
        a(ia,is,1) = a(ia,is,2)
      enddo
C     stop 'here'

      end

      subroutine pqmixa(nda,nmix,mmix,mxsav,beta,rms2,a,tj)
C- Anderson mixing of a vector
C ----------------------------------------------------------------------
Ci  mmix: number of iterates available to mix
Cio nmix: nmix > 0: number of iter to try and mix
Ci        nmix < 0: use mmix instead of nmix.
Co  nmix: (abs)  number of iter actually mixed.
Co        (sign) <0, intended that caller update nmix for next call.
Cu Updates
Cu  25 Jun 13 Replace f77 pointers with f90 ones
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer nda,nmix,mmix,mxsav
      double precision rms2,tj(*),a(nda,0:mxsav+1,2),beta
C ... Dynamically allocated local arrays
      integer, allocatable :: kpvt(:)
      real(8), allocatable :: norm(:)
      real(8), allocatable :: aa(:)
C ... Local parameters
      integer im,imix,jmix,iprint,amix,stdo,nglob
      double precision tjmax
      parameter (tjmax = 10d0)

C ... default nmix
      stdo = nglob('stdo')
      if (nmix < 0) nmix = 2
      nmix = min(mmix,nmix)
      allocate(norm(mxsav**2))
      allocate(kpvt(mxsav))
      if (beta < 0) nmix = -nmix
C ... imix is a local copy of nmix
      imix = nmix
      if (imix < 0) imix = mmix
C ... save PQ array
      allocate(aa(nda*(mxsav+2)*2))
      call dcopy(nda*(mxsav+2)*2,a,1,aa,1)

C ... for iterations 1,2,... amix needs F-x
   10 continue
      do  jmix = 1, nmix
        call daxpy(nda,-1d0,a(1,jmix,2),1,a(1,jmix,1),1)
      enddo

      call query('beta',4,beta)
      jmix = min(mmix,iabs(imix))
      imix = amix(nda,jmix,mxsav,0,dabs(beta),iprint(),tjmax,
     .  norm,kpvt,a,tj,rms2)
      im = imix
      if (iprint() > 30) call query('redo, nmix=',2,imix)
      if (iabs(imix) > mmix .and. imix /= im)
     .  call awrit1(' (warning) only %i iter available',
     .  ' ',80,stdo,mmix)
      if (im /= imix) then
        call dcopy(nda*(mxsav+2)*2,aa,1,a,1)
        goto 10
      endif
      nmix = imix

C ... Restore PQ array, updating new x
      call dpscop(a,aa,nda,1+nda*(mxsav+2),1+nda*(mxsav+2),1d0)
      call dcopy(nda*(mxsav+2)*2,aa,1,a,1)
      deallocate(aa,norm,kpvt)

      end
C      subroutine pqmixb(nda,nmix,mmix,mxsav,wc,rms2,a,wctrue)
CC- Broyden mixing of a vector, old style
CC ------------------------------------------------------------------
CCi  mmix: number of iterates available to mix
CCi  a:    (*,i,1)  output values for prev. iteration i
CCi        (*,i,2)  input  values for prev. iteration i
CCio nmix: nmix > 0: number of iter to try and mix
CCi        nmix < 0: use mmix instead of nmix.
CCo  nmix: (abs)  number of iter actually mixed.
CCo        (sign) <0, intended that caller update nmix for next call.
CCr  Notations:
CCr  x^(m): input vector for iteration m
CCr  F^(m): difference between output and input vector in iteration m
CC ------------------------------------------------------------------
C      implicit none
C      integer nda,nmix,mmix,mxsav
C      double precision wc,rms2,wctrue,a(nda,0:mxsav+1,2)
C      double precision tol,ddot,dFm,diff,dval
C      parameter (tol=1d-12)
C      integer im,info,i,j,iprint,i1mach,imix,jmix,
C     .  obt,obtx,ojac,obet,ogam,okpvt,oFmp1,oxmp1,odFm,odxm
C
CC --- Allocate some arrays ---
C      call defdr(obt,nda)
C      call defdr(obtx,nda)
C      call defdr(ojac,nda**2)
C      call defdr(obet,nda**2)
C      call defdr(ogam,nda**2)
C      call defdr(oFmp1,nda)
C      call defdr(oxmp1,nda)
C      call defdr(odFm,nda)
C      call defdr(odxm,nda)
C      okpvt = obt
C      wctrue = 0
CC ... imix is a local copy of nmix
C      imix = nmix
C      if (imix < 0) imix = mmix
C
CC --- First Jacobian matrix ---
CC ... See Eq. A6; for beta, eq. A14; for gamma, eq. A15.
CC ... x^(2) = x^(1) + [J^(1)]**(-1) * F^(m), so
CC     J^(1) = F^(1) / [x^(2) - x^(1)]
CC     Also, beta^(1) = 1 and gamma^(1) = J^(1)
C    1 continue
C      call dpzero(w(ojac),nda**2)
C      call dpzero(w(obet),nda**2)
C      call dpzero(w(ogam),nda**2)
C      call dcopy(nda,a(1,mmix,1),1,w(odFm),1)
C      call daxpy(nda,-1d0,a(1,mmix,2),1,w(odFm),1)
C      call dcopy(nda,a(1,mmix-1,2),1,w(oxmp1),1)
C      call dcopy(nda,a(1,mmix,2),1,w(odxm),1)
C      j = 1
C      do  20  i = 1, nda
C        call dvset(w(ogam),j,j,1d0)
C        call dvset(w(obet),j,j,1d0)
C        diff = dval(w(oxmp1),i) - dval(w(odxm),i)
C        dFm  = dval(w(odFm),i)
C        if (dabs(diff) > tol .and. dFm /= 0)
C     .    call dvset(w(ogam),j,j,dFm/diff)
C        j = j + 1 + nda
C   20 continue
C
CC --- Starting from iteration mmix, build the Jacobian matrix ---
C      jmix = min(mmix,iabs(imix))
C      do  10  im = jmix, 1, -1
CC  ...  F^(m+1) -> a(*,im-1,1)  x^(m+1) -> a(*,im-1,2)
CC  ...  dF^(m)  -> a(*,im,1)    dx^(m)  -> a(*,im,2)
C        call dcopy(nda,a(1,im-1,2),1,w(oxmp1),1)
C        call dcopy(nda,a(1,im-1,1),1,w(oFmp1),1)
C        call daxpy(nda,-1d0,w(oxmp1),1,w(oFmp1),1)
C        call dcopy(nda,w(oxmp1),1,w(odxm),1)
C        call dcopy(nda,w(oFmp1),1,w(odFm),1)
C        call daxpy(nda,-1d0,a(1,im,2),1,w(odxm),1)
C        call daxpy(nda,-1d0,a(1,im,1),1,w(odFm),1)
C        call daxpy(nda, 1d0,a(1,im,2),1,w(odFm),1)
C        rms2 = dsqrt(ddot(nda,w(oFmp1),1,w(oFmp1),1)/(nda-0))
C
CC ---   Determine wc_true if wc < 0 ---
C        if (wc < 0) then
C          wctrue = -wc/dsqrt(nda*rms2**2)
C        else
C          wctrue = wc
C        endif
C
CC ---   Broyden updates gamma,beta,J, making J^(m+1) ---
C        call broydn(w(ojac),w(odFm),w(odxm),w(obet),w(ogam),
C     .    w(obt),w(obtx),nda,wctrue)
C
CC ---   Factor Jacobian; linear mixing if singular ---
C        call dgefa(w(ojac),nda,nda,w(okpvt),info)
C        if (info /= 0) then
C          if (iprint() >= 30)
C     .      call awrit1(' PQMIXB Broyden iter %i: Jacobian matrix '//
C     .      'singular',' ',80,i1mach(2),jmix-im+1)
C        else
CC     ... Solve J^(m+1) * y = F^(m+1)  with  y = x^(m+2) - x^(m+1)
C          call dgesl(w(ojac),nda,nda,w(okpvt),w(oFmp1),0)
CC     ... Make x^(m+2) = y + x^(m+1)
C          call daxpy(nda,1d0,w(oFmp1),1,w(oxmp1),1)
C          if (iprint() > 40 .or. iprint() >= 30 .and. im == 1)
C     .      call awrit5(' PQMIXB  Broyden iter %i:  rms(F-x)='//
C     .      '%1;3e  rms(dx)=%1;3e  wc=%1;3g  nelts=%i',' ',80,i1mach(2),
C     .      jmix-im+1,dsqrt(ddot(nda,w(oFmp1),1,w(oFmp1),1)/nda),
C     .      rms2,wctrue,nda)
C        endif
C
C   10 continue
C
CC --- Check for interactive change of nmix ---
CC NB negative sign signals request for permanent change in nmix
C      im = imix
C      if (iprint() > 30) call query('redo, nmix=',2,imix)
C      if (iabs(imix) > mmix .and. imix /= im)
C     .  call awrit1(' (warning) only %i iter available',
C     .  ' ',80,i1mach(2),mmix)
C      if (im /= imix) goto 1
C      nmix = imix
CC ... If no prior iter allowed, give up on nmix
C      if (nmix == 0) return
C
CC --- Printout ---
C      if (iprint() > 40) then
C        print 310
C        do  12  i = 1, nda
C          if (dabs(a(i,0,1)-a(i,0,2)) >= 5d-9)  print 311, i,
C     .      a(i,0,2),a(i,0,1),a(i,0,1)-a(i,0,2),dval(w(oxmp1),i)
C   12   continue
C  311   format(i5,4f14.6)
C  310   format(14x,'Old',11x,' New',9x,'Diff',10x,'Mixed')
C      endif
C
CC --- Save x^(m+2) into a(*,0,2) and exit ---
C      if (info /= 0) then
C        nmix = 0
C        return
C      endif
C      call dcopy(nda,w(oxmp1),1,a(1,0,2),1)
C      call rlse(obt)
C      end
      subroutine pqmixb(nda,nmix,mmix,mxsav,beta,wc,rms2,a,wctrue)
C- Broyden mixing of a vector, Duane Johnson's approach
C ------------------------------------------------------------------
Ci  mmix: number of iterates available to mix
Ci  a:    (*,i,1)  output values for prev. iteration i
Ci        (*,i,2)  input  values for prev. iteration i
Cio nmix: nmix > 0: number of iter to try and mix
Ci        nmix < 0: use mmix instead of nmix.
Co  nmix: (abs)  number of iter actually mixed.
Co        (sign) <0, intended that caller update nmix for next call.
Cr  Notations:
Cr  x^(m): input vector for iteration m
Cr  F^(m): difference between output and input vector in iteration m
Cu Updates
C ------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer nda,nmix,mmix,mxsav
      double precision beta,rms2,wctrue,a(nda,0:mxsav+1,2)
C ... Dynamically allocated local arrays
      real(8), allocatable :: xmp1(:)
C      real(8), allocatable :: f(:)
C      real(8), allocatable :: ui(:)
C      real(8), allocatable :: vti(:)
C      real(8), allocatable :: xold(:)
C      real(8), allocatable :: df(:)
      real(8), allocatable :: dx(:)
      real(8), allocatable :: wk(:)
C ... Local parameters
      double precision ddot,dval,wc
      integer im,km,i,iprint,imix,jmix,stdo,broyj
      procedure(integer) :: nglob

C --- Setup ---
      stdo = nglob('stdo')

      allocate(xmp1(nda))
      allocate(dx(nda))

C ... imix is a local copy of nmix
      imix = nmix
      if (imix < 0) imix = mmix

C --- Starting from iteration mmix, build the Jacobian matrix ---
   10 continue
      jmix = min(mmix,iabs(imix))
C     call defdr(owk,nda*2*(jmix+2))
      allocate(wk(nda*2*(jmix+2)))
      do  km = 1, jmix
C   ... this loops from most-distant to most-recent
        im = jmix-km+1
C   ... this loops from most-recent to most-distant
C       im = km

        call dcopy(nda,a(1,im-1,1),1,dx,1)
        call daxpy(nda,-1d0,a(1,im-1,2),1,dx,1)
        rms2 = dsqrt(ddot(nda,dx,1,dx,1)/(nda-0))

C ---   Determine wc_true if wc < 0 ---
        if (wc < 0) then
          wctrue = -wc/100/dsqrt(nda*rms2**2)
          wctrue = min(max(wctrue,1d0),1d4)
        else
          wctrue = wc
        endif
        if (km == 1) wctrue = .01d0

        i = iprint()
        if (km /= jmix) i = i-20
        i = broyj(nda,a(1,im-1,2),dx,km,0,i,beta,0d0,0d0,0d0,
     .    wctrue,wk,nda,xmp1)
      enddo

C --- Check for interactive change of nmix ---
C NB negative sign signals request for permanent change in nmix
      im = imix
      if (iprint() > 30) call query('redo, nmix=',2,imix)
      if (iabs(imix) > mmix .and. imix /= im)
     .  call awrit1(' (warning) only %i iter available',
     .  ' ',80,stdo,mmix)
      if (im /= imix) then
        deallocate(wk)
        goto 10
      endif
      nmix = imix
C ... If no prior iter allowed, give up on nmix
      if (nmix /= 0) then
C --- Printout ---
        if (iprint() > 60 .or. (iprint() >= 40 .and. nda <= 100)) then
          write(stdo,"(14x,'Old',11x,' New',9x,'Diff',10x,'Mixed')")
          do  i = 1, nda
            if (dabs(a(i,0,1)-a(i,0,2)) >= 5d-9)
     .        write(stdo,"(i5,4F14.6)") i,a(i,0,2),a(i,0,1),a(i,0,1)-a(i,0,2),dval(xmp1,i)
          enddo
        endif
C       Save x^(m+2) into a(*,0,2)
        call dcopy(nda,xmp1,1,a(1,0,2),1)
      end if
      deallocate(xmp1,dx,wk)
      end
      subroutine pqmixc(nda,nmix,mmix,mxsav,beta,rms2,a,xn)
C- C. G. mixing of a vector
C ------------------------------------------------------------------
Ci  mmix: number of iterates available to mix
Ci  a:    (*,i,1)  output values for prev. iteration i
Ci        (*,i,2)  input  values for prev. iteration i
Cio nmix: nmix > 0: number of iter to try and mix
Ci        nmix < 0: use mmix instead of nmix.
Co  nmix: (abs)  number of iter actually mixed.
Co        (sign) <0, intended that caller update nmix for next call.
Co  xn:   projection along line minimization.
Co        (sign) <0, new line minimization
Cr  Notations:
Cr  x^(m): input vector for iteration m
Cr  F^(m): difference between output and input vector in iteration m
Cu Updates
Cu   5 Jul 13 Replace f77 pointers with f90 ones
C ------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer nda,nmix,mmix,mxsav
      double precision beta,rms2,xn,a(nda,0:mxsav+1,2)
C ... Dynamically allocated local arrays
      real(8), allocatable :: p(:)
      real(8), allocatable :: dx(:)
C ... Local parameters
      double precision ddot,dval,dxmx,xtoll,grfac,wk(0:26),xx
      save wk
      integer ir,imix,jmix,km,iprint,i,idx,idamax,stdo,nglob

C --- Setup ---
      stdo = nglob('stdo')
C      call defdr(op, nda*6)
C      call defdr(odx,nda)
      allocate(p(nda*6),dx(nda))

C ... imix is a local copy of nmix
      imix = nmix
      if (imix < 0) imix = mmix

C --- Starting from iteration mmix, build the Jacobian matrix ---
   10 continue
      jmix = min(mmix,iabs(imix))
      ir = 0
      do  km = jmix, 0, -1

        call dcopy(nda,a(1,km,2),1,dx,1)
        call daxpy(nda,-1d0,a(1,km,1),1,dx,1)
        rms2 = dsqrt(ddot(nda,dx,1,dx,1)/(nda-0))
        idx = idamax(nda,dx,1)
        dxmx = beta*abs(dval(dx,idx))
        xtoll = dxmx/10
        grfac = min(2d0,1/beta)
        call pshpr(80)
        wk(0) = xn
        call drgrzr(nda,a(1,km,2),dx,p,xx,xtoll,dxmx,
     .    1d-10,1d-10,grfac,wk,' ',00040,ir)
        xn = wk(0)
        call poppr

      enddo
      if (ir == -1) xn = -xn

C --- Check for interactive change of nmix ---
C NB negative sign signals request for permanent change in nmix
      km = imix
      if (iprint() > 30) call query('redo, nmix=',2,imix)
      if (iabs(imix) > mmix .and. imix /= km)
     .  call awrit1(' (warning) only %i iter available',
     .  ' ',80,stdo,mmix)
      if (km /= imix) goto 10
      nmix = imix

C --- Printout ---
      if (iprint() > 40) then
        write(stdo,1)
    1   format(14x,'Old',11x,' New',9x,'Diff',10x,'Mixed')
        do  i = 1, nda
          if (dabs(a(i,0,1)-a(i,0,2)) >= 5d-9) write(stdo,2)
     .      i,a(i,0,2),a(i,0,1),a(i,0,1)-a(i,0,2),dval(p,i)
    2     format(i5,4F14.6)
        enddo
      endif

C --- Save x^(m+2) into a(*,0,2) and exit ---
      call dcopy(nda,p,1,a(1,0,2),1)
      deallocate(p,dx)
      end
      subroutine pqmxup(na,lrel2,mxsav,nclass,nl,nsp,nx,lmx,
     .  pnu,qnu,qnur,xnew,pold,qold,qrold,xold,cnst,nda,a,rms2)
C- Copy from holding array into P,Q
      implicit none
C ... Passed parameters
      logical lrel2
      integer k,nda,mxsav,nclass,nl,nsp,nx,lmx(nclass),cnst(0:*)
      double precision a(nda,0:mxsav+1,2),rms2,
     .  qrold(4,nl,2*nl*2*2,nclass),qnur(4,nl,2*nl*2*2,nclass),
     .  pnu(nl,nsp,nclass), qnu(3,nl,nsp,nclass), xnew(nx),
     .  pold(nl,nsp,nclass),qold(3,nl,nsp,nclass),xold(nx)
C ... Local parameters
      double precision ddot
      integer ic,isp,l,na,i
      logical lcnst

      lcnst = cnst(0) > 0
      na = 1
      rms2 = 0
      do  isp = 1, nsp
      if (lrel2 .and. isp == 2) cycle
      do  ic = 1, nclass
        if (lcnst) then
          if (cnst(ic) /= 0) cycle
        endif
        do  l = 0, lmx(ic)
          if (lrel2) then
            do  k = 1, 2*nl*2*2
              rms2 = rms2 + (qrold(1,l+1,k,ic) - a(na+1-1+4*(k-1),0,2))**2
              do  i = 1, 4
                qnur(i,l+1,k,ic) = a(na+i-1+4*(k-1),0,2)
              enddo
            enddo
            na = na + 4*2*nl*2*2
          else
            pnu(l+1,isp,ic) = a(na,0,2)
            rms2 = rms2 + (qold(1,l+1,isp,ic) - a(na+1,0,2))**2
            do  i = 1, 3
              qnu(i,l+1,isp,ic) = a(na+i,0,2)
            enddo
            na = na+4
          endif
        enddo
      enddo
      enddo

      if (nx > 0) then
        call dcopy(nx,a(na,0,2),1,xnew,1)
        rms2 =  rms2 + ddot(nx,xnew,1,xnew,1) - 2*ddot(nx,xnew,1,xold,1) + ddot(nx,xold,1,xold,1)
        na = na + nx
      endif

      rms2 = dsqrt(4*rms2/(na-0))
      end
      subroutine pqmxio(nmix,mxsav,ifi,lbin,lrel2,nclass,nl,nsp,nx,lmx,
     .  pnu,pold,qnu,qnur,qold,qrold,xnew,xold,cnst,nda,a,na,rms2)
C- Copy P,Q into holding array, read prior P,Q from disk
C -----------------------------------------------------------------
Ci  nmix  :number of prior iterations sought; returns no. actually read
Ci  mxsav :maximum number of prior iter to save, and dimensions a
Ci  ifi   : >0, copy pnu,qnu to a(1..nda,0,1), pold,qold to a(1..nda,0,2)
Ci          read prior iter into a(1..nda,1..nmix,1..2)
Ci          <0  write a(1..nda,1..nmix,1..2) to disk
Ci          (NB: Does not update pnu,qnu from a)
Ci  lbin  :T: read prior iterations from binary file, else ascii file
Ci  nclass:number of inequivalent classes
Ci  nl    :(global maximum l) + 1
Ci  nsp   :2 for spin-polarized case, otherwise 1
Ci  nx    :number of p,q and number of extra data xnew,xold
Ci  lmx   :lmx(j) = maximum l for atom j
Ci  pnu   :boundary conditions.  If Dl = log. deriv. at rmax,
Ci         pnu = .5 - atan(Dl)/pi + (princ.quant.number).
Ci  qnu   :energy-weighted moments of the sphere charges
Ci  qold  :old moments
Ci  xnew  :additional parameters to be included in mix
Ci  xold  :additional parameters to be included in mix
Ci  cnst  :for each class,
Ci        :if > 0, copy pold->pnu  if nonzero, copy qold->qnu
Ci  nda   :leading dimension of a (must be at least na)
Cio Inputs/Outputs
Cio (Inputs for ifi<0, outputs for ifi>0)
Cio  a    :array containing input,output of prior iterations.
Cio       :a is updated with input,output from last iteration.
Cio       :and prior iterations are read from file ifi
Cio  na   :number of values included into mix
Co Outputs
Ci  rms2  :rms change in parameters to be mixed.
C -----------------------------------------------------------------
      implicit none
C ... Passed parameters
      logical lbin,lrel2
      integer nda,nmix,mxsav,ifi,nclass,nl,nsp,lmx(nclass),nx,cnst(0:nclass)
      double precision a(nda,0:mxsav+1,2),rms2,
     .  qrold(4,nl,2*nl*2*2,nclass),qnur(4,nl,2*nl*2*2,nclass),
     .  pnu(nl,nsp,nclass), qnu(3,nl,nsp,nclass), xnew(nx),
     .  pold(nl,nsp,nclass),qold(3,nl,nsp,nclass),xold(nx)
C ... Local parameters
      integer ic,na,isp,i,j,k,l,iprint,mmix,stdo,nglob
      logical lcnst
      procedure(real(8)) :: ddot

      stdo = nglob('stdo')
      lcnst = cnst(0) > 0

C --- Copy p,q to a; calc. RMS error; read prior iter from ifi ---
      if (ifi > 0) then
        na = 1
        do  isp = 1, nsp
        do  ic = 1, nclass
          if (lcnst) then
            if (cnst(ic) /= 0 .and. lrel2)
     .        call rx('pqmxio: constraints not implemented with lrel=2')
            do  l = 0, lmx(ic)
              if (cnst(ic) >  0) pnu(l+1,isp,ic) = pold(l+1,isp,ic)
              if (cnst(ic) /= 0) qnu(1:3,l+1,isp,ic) = qold(1:3,l+1,isp,ic)
            enddo
            if (cnst(ic) > 0) cycle
          endif
C          if (lrel2) then  ! Experimental ... qnu updated automatically
C            do  l = 0, lmx(ic)
C              pnu(l+1,isp,ic) = pold(l+1,isp,ic)
C              do  i = 1, 3
C                qnu(i,l+1,isp,ic) = qold(i,l+1,isp,ic)
C              enddo
C            enddo
C          endif
          if (lrel2 .and. isp == 2) cycle
          do  l = 0, lmx(ic)
            if (lrel2) then
              do  k = 1, 2*nl*2*2
                do  i = 1, 4
                  a(na+i-1+4*(k-1),0,1) = qnur(i,l+1,k,ic)
                  a(na+i-1+4*(k-1),0,2) = qrold(i,l+1,k,ic)
                enddo
              enddo
              na = na + 4*2*nl*2*2
            else
              a(na,0,1) = pnu(l+1,isp,ic)
              a(na,0,2) = pold(l+1,isp,ic)
              if (lcnst) then
              if (cnst(ic) < 0) na = na+1
              if (cnst(ic) < 0) cycle
              endif
              do  i = 1, 3
                a(na+i,0,1) = qnu(i,l+1,isp,ic)
                a(na+i,0,2) = qold(i,l+1,isp,ic)
              enddo
              na = na+4
            endif
          enddo
          enddo
        enddo

C   ... Append extra vector to a
        call dcopy(nx,xnew,1,a(na,0,1),1)
        call dcopy(nx,xold,1,a(na,0,2),1)
        na = na + nx - 1
        rms2 =  dsqrt(dabs(ddot(na,a,1,a,1) - 2*ddot(na,a,1,a(1,0,2),1) + ddot(na,a(1,0,2),1,a(1,0,2),1))/(na-0))
C        call prmx('a1',a,na,na,1)
C        call prmx('a2',a(1,0,2),na,na,1)
        mmix = 0
        if (lbin) then
          do  j = 1, min(nmix,mxsav)
            read (ifi,err=5,end=5) ((a(i,j,k),i=1,na),k=1,2)
            mmix = j
          enddo
        else
          do  j = 1, min(nmix,mxsav)
            read (ifi,1,err=5,end=5) ((a(i,j,k),i=1,na),k=1,2)
            mmix = j
          enddo
        endif
        goto 10
    5   continue
        call info2(30/10,0,0,' PQMXIO:  sought %i mixing iter from disk, but read %i',nmix,mmix)
        if (iprint() >= 30/10) call awrit2(
     .    ' PQMXIO:  sought %i mixing iter from disk, but read %i',' ',80,stdo,nmix,mmix)
   10   continue
        nmix = mmix
C --- Save iterations to disk ---
      elseif (lbin) then
        do  j = 0, min(nmix,mxsav)-1
          write (-ifi) ((a(i,j,k),i=1,na),k=1,2)
        enddo
      else
        do  j = 0, min(nmix,mxsav)-1
          write (-ifi,1) ((a(i,j,k),i=1,na),k=1,2)
        enddo
      endif
    1 format(1p,4d20.13)
      end
C testing ...
C      subroutine fmain
C      implicit none
C      integer nclass,nl,nsp
C      parameter (nclass=2,nl=3,nsp=2)
C      integer lmx(nclass),fadd,mxsav,mmix,nmix,ifi,nlspc,fopn,i,wksize,
C     .  nx,iter,fopna
C      double precision pnu(nl,nsp,nclass),pold(nl,nsp,nclass),
C     .  qnu(3,nl,nsp,nclass),qold(3,nl,nsp,nclass),wj(10),rms2,
C     .  rmsdel,pwk(nl,nsp,nclass),qwk(3,nl,nsp,nclass),
C     .  xnew(100),xold(100),dmxprm(20)
C      character*82 mixmod
C      parameter (wksize=250000)
C      call finits(2,0,0,ifi)
C      call initqu(.true.)
C      i = 51
C      call pshpr(i)
C
C      mixmod = 'B,w=0,1,wa=1,fn=mm,k=2'
C      mixmod = 'B,n=3,w=0,1,wa=1,fn=mm,k=3'
C      mixmod = 'B,w=1,2,wa=1,b=.4,n=3;B,b=.02,w=2,1,n=3'
C      dmxprm(1) = 0.0d0
C      dmxprm(2) = 1.0d0
C      dmxprm(3) = -1.0d0
C      dmxprm(4) = 1.0d0
C      dmxprm(5) = 1.0d0
C      dmxprm(6) = 50.0d0
C      dmxprm(7) = -1.0d0
C      dmxprm(8) = -1.0d0
C      dmxprm(9) = 1.0d0
C      dmxprm(10) = -1.0d0
C      dmxprm(11) = 0.0d0
C      dmxprm(12) = 0.0d0
C      dmxprm(13) = 0.0d0
C      dmxprm(14) = 0.0d0
C      dmxprm(15) = 0.0d0
C      dmxprm(16) = 0.0d0
C      dmxprm(17) = 0.0d0
C      dmxprm(18) = 0.0d0
C      dmxprm(19) = 0.0d0
C      dmxprm(20) = 0.0d0
C      print *, 'iter?'
C      read(*,*) iter
C*     iter = 5
C      nx = 9*nclass
C
C      ifi = fadd('LOG',10,0)
C      nlspc = nl*nsp*nclass
C      do  2  i = 1, nclass
C    2 lmx(i) = 2
C
C      ifi = fopna('MIXV',-1,0)
C      do  10  i = 1, 1
C      call dfdump(pnu,nlspc,ifi)
C      call dfdump(pold,nlspc,ifi)
C      call dfdump(qnu,3*nlspc,ifi)
C      call dfdump(qold,3*nlspc,ifi)
C      call dfdump(xnew,nx,ifi)
C      call dfdump(xold,nx,ifi)
C      if (i > 1) then
C        call snot(1*nl*nsp*nclass,pwk,pold)
C        call snot(3*nl*nsp*nclass,qwk,qold)
C      endif
C      call pqmix(nclass,nl,lmx,nsp,nx,iter,mixmod,dmxprm,0,
C     .  pold,qold,xold,pnu,qnu,xnew)
C      stop 'patch call to shoctl'
C      call shoctl(nclass,'xx',nl,nsp,lmx,pnu,qnu,
C     .  0,pnu,fopn('LOG'))
C
C   10 continue
C      end
C      subroutine snot(n,f1,f2)
C      implicit none
C      integer n,i
C      double precision f1(n),f2(n)
C
C      write(*,110)
C      do  12  i = 1, n
C        if (dabs(f1(i)-f2(i)) >= 5d-9)
C     .  write(*,111) i,f1(i),f2(i),f1(i)-f2(i)
C   12 continue
C  111 format(i5,4f14.6)
C  110 format(14x,'OLD',11X,' NEW',9X,'DIFF',10X,'MIXED')
C      end
