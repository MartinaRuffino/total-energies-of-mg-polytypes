      subroutine nwit(nvario,iter,maxit,lhf,lhk,etol,qtol,qdiff,htol,hdiff,
     .  svflg,amom,etot,lsc)
C- Add to save file, determine whether to continue execution
C ----------------------------------------------------------------------
Ci Inputs
Ci   nvario:number of variables in variables table to i/o
Ci   iter  :current iteration number
Ci   maxit :maximum number of iterations
Ci   lhf   :T if result is generated by overlapped free atoms
Ci         :(only affects key character in save file)
Ci   lhk   :1, if HK energy is available
Ci         :Add 10 to use HK energy for convergence, if available
Ci   etol  :energy tolerance for convergence.  If 0, criterion not used
Ci         :Energy change from prior iteration is compared to etol.
Ci   qtol  :charge tolerance for convergence.  If 0, criterion not used
Ci   qdiff :change in charge
Ci   htol  :tolerance in h parameter for convergence.  If 0, criterion not used
Ci   hdiff :value of h this iteration
Ci   svflg :string of characters.  svflg(lsc+1) is written as the
Ci         :first character in the save file
Ci   amom  :magnetic moment
Ci   etot  :etot(1) = HF energy; etot(2) = KS energy
Co Outputs
Co   lsc   :0 self-consistency achieved (diffe<=etol, qdiff<=qtol)
Co         :1 if not self-consistent, but encountered max. no. iter.
Co         :2 Harris energy from overlap of free atoms (iter=1 and lhf=t)
Co         :3 otherwise
Cr Remarks
Cr   There are three convergence criteria:
Cr      diffe <= etol     qdiff <= qtol     hdiff <= htol
Cr   Criteria with tolerance = 0 are not used
Cr   diffe and qdiff are meant to be energy and charge tolerances
Cr   htol can be whatever the calling program specifies, e.g.
Cr        maximum value in correction to forces
Cu Updates
Cu   20 Sep 17 Added htol,hdiff
Cu   14 Jan 05 Eliminate sctrl from argument list
Cu   11 Jan 05 Add 10's digit option to lhk
Cu   10 Mar 03 Split off nwitsv to make separately callable
Cu   07 Jun 01 Revised and split off from lmfp.
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      logical lhf
      character*4 svflg
      integer iter,maxit,lhk,lsc,nvario
      double precision etol,qtol,qdiff,htol,hdiff,amom,etot(2)
C ... Local parameters
      integer nsp,stdo,lbl
      logical more,letol,lqtol,lhtol,ipr
      double precision :: ehf1=0,ehk1=0,diffe
      character flg*3
      procedure(integer) :: nglob,iprint

      stdo = nglob('stdo')
      nsp  = nglob('nsp')
      ipr = iprint() > 0
C     Assume not self-consistent
      lsc = 3
      more = .true.
      if (iter >= maxit) then
        lsc = 1
        more = .false.
      endif
      if (lhf) lsc = 2

C --- Decide whether to iterate on ---
      assign 904 to lbl
      if (maxit > 999 .or. iter > 999) assign 903 to lbl
      if (mod(lhk,10) == 1 .and. ipr)
     .  write(stdo,lbl) iter,maxit,etot(1),etot(2)
      if (mod(lhk,10) == 0 .and. ipr)
     .  write(stdo,lbl) iter,maxit,etot(1)
  903 format(/  ' it',i4,'  of',i4,'    ehf=',f15.6:'   ehk=',f15.6)
  904 format(/'   it',i3,'  of',i3,'    ehf=',f15.6:'   ehk=',f15.6)
      if (iter > 1 .or. etol == 0) then
        diffe = etot(1)-ehf1
        if (lhk == 11) diffe = etot(2)-ehk1

C       Three convergence criteria.  Stop if all are .true.
        letol = dabs(diffe) <= etol .or. etol <= 0
        lqtol = dabs(qdiff) <= qtol .or. qtol <= 0
        lhtol = dabs(hdiff) <= htol .or. htol <= 0
        if (letol .and. lqtol .and. lhtol) then
          more = .false.
          lsc = 0
        endif

C       Subsequent iterations
        if (iter > 1 .and. ipr) then
          if (mod(lhk,10) == 1) write(stdo,905) ehf1,ehk1
          if (mod(lhk,10) == 0) write(stdo,906) ehf1
          if (htol > 0) then
            call info8(10,0,0,
     .        ' diffe(q,h)=%;10,6D (%;8,6D,%1;3,3g)%4ftol=%;9,6D (%;8,6D,%1;3,3g)   more=%l',
     .        diffe,qdiff,hdiff,etol,qtol,htol,more,8)
          else
            call info5(10,0,0,
     .        ' diffe(q)=%;10,6D (%;8,6D)%4ftol=%;9,6D (%;8,6D)   more=%l',
     .        diffe,qdiff,etol,qtol,more)
          endif

C       First iteration
        elseif (ipr) then
          if (htol > 0) then
            call info5(10,0,0,
     .        ' diffq(h)=%;10,6D (%;8,6D)%4ftol=%;9,6D (%;8,6D)   more=%l',
     .        qdiff,hdiff,qtol,htol,more)
          else
            call info5(10,0,0,'%16frms dq=%;10,6D%4ftol=%;9,6D  more=%l',
     .        qdiff,qtol,more,4,5)
          endif
        endif
C       write(lgunit(2),907) diffe,qdiff,etol,qtol
  905   format(' From last iter',4x,'ehf=',f15.6,'   ehk=',f15.6)
C     .    /' diffe(q)=',f10.6,' (',f8.6,')',
C     .    '    tol=',f9.6,' (',f8.6,')','   more=',l1)
  906   format(' From last iter',4x,'ehf=',f15.6)
C     .    /' diffe(q)=',f10.6,' (',f8.6,')',
C     .    '    tol=',f9.6,' (',f8.6,')','   more=',l1)
  907   format(16x,'rms dq=',f10.6,8x,'tol=',f9.6,'   more=',l1)

      endif

C ... Save for future iterations
      ehk1 = etot(2)
      ehf1 = etot(1)

C --- Write out to save file --
      flg = svflg(lsc+1:lsc+1) // '67'
      if (ipr) call nwitsv(1+2,nvario,flg,nsp,amom,etot)

C      xv(1) = amom
C      call dcopy(2,etot,1,xv(2),1)
C      call awrit1('%?;n;mmom,;;ehf,ehk',sout,len(sout),0,nsp-1)
C      i = 1
C      if (nsp == 1) i = 2
C      ifi = fopna('SAVE',-1,0)
C      call poseof(ifi)
C      flg = svflg(lsc+1:lsc+1)
C      call iosave(flg,sout,xv(i),-ifi,nvario)
C      call fclr('SAVE',ifi)
C      call iosave(flg,sout,xv(i),-stdo,nvario)

C      iter = iter+1
C      if (more) call query('maxit',2,maxit)
C      if (iter >= maxit+1) lsc = 1

      end

      subroutine nwitsv(iflst,nvario,flg,nsp,amom,etot)
C- Write to save file
C ----------------------------------------------------------------------
Ci Inputs
Ci   iflst :specifies which files to output
Ci         :1s bit => write to 'save'
Ci         :2s bit => write to stdo
Ci         :4s bit => write to stdl
Ci   nvario:number of variables in variables table to i/o
Ci   flg   :label; see iosave for meaning
Ci   nsp   :2 for spin-polarized case, otherwise 1
Ci   amom  :system magnetic moment for spin-pol case
Ci   etot  :etot(1) = HF energy; etot(2) = KS energy
Co Outputs
Co   energy data is written to ...
Cr Remarks
Cr
Cu Updates
Cu   10 Mar 03 Cut out from nwit to make separately callable
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer iflst,nvario,nsp
      character flg*(*)
      double precision amom,etot(2)
C ... Local parameters
      integer fopna,ifi,i,lgunit,getdig
      double precision xv(3)
      character*80 sout

      i = 0
      sout = ' '
      if (nsp == 2) then
        i = i+1
        xv(i) = amom
        call awrit0('%a,mmom',sout,len(sout),0)
      endif
      if (etot(1) /= 0) then
        i = i+1
        xv(i) = etot(1)
        call awrit0('%a,ehf',sout,len(sout),0)
      endif
      if (etot(2) /= 0) then
        i = i+1
        xv(i) = etot(2)
        call awrit0('%a,ehk',sout,len(sout),0)
      endif

C ... Write to file list
      do  i = 1, 3
        if (getdig(iflst,i-1,2) /= 0) then
          if (i == 1) ifi = fopna('SAVE',-1,0)
          if (i == 1) call poseof(ifi)
          if (i == 2) ifi = lgunit(1)
          if (i == 3) ifi = lgunit(2)
          call iosave(flg,sout(2:),xv,-ifi,nvario)
          if (i == 1) call fclr('SAVE',ifi)
        endif
      enddo

      end

