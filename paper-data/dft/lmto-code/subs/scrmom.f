      subroutine scrmom(s_ctrl,s_ham,s_bz,s_lat,mode,nbas,nsp,nl,nclass,
     .  nRLc,elind0,pstat,vmad,vsmad,ldv,vintra,vin,vqin,vout,qin,qout)
C- Estimate the self-consistent moments from the dielectric response
C ----------------------------------------------------------------------
Cio Structures
Cio  s_ham  :struct for parameters defining hamiltonian; see structures.h
Ci     Elts read: ldham elind
Co     Stored:    *
Co     Allocated: *
Cio    Elts Passed:iprmb
Cio    Passed to: *
Cio  s_bz   :struct for the Brillouin Zone; see structures.h
Ci     Elts read: zval
Co     Stored:    *
Co     Allocated: *
Cio    Elts Passed:*
Cio    Passed to: *
Cio  s_lat  :struct containing lattice information; see structures.h
Ci     Elts read: vol
Co     Stored:    *
Co     Allocated: *
Cio    Elts Passed:*
Cio    Passed to: *
Ci Inputs
Ci   mode  :1s digit
Ci          0 do nothing
Ci          1 Estimate vsc from vin,vout
Ci          2 Estimate qsc from qin,qout
Ci          3 Estimate qsc from qin,qout,vin,vout
Ci          4 Do both 3 and 2
Ci         :10s digit use model dielectric function
Ci          1 Estimate qsc from qin,qout,vin,vout using model eps
Ci   nbas  :size of basis
Ci   nl    :(global maximum l) + 1
Ci   nclass:number of inequivalent classes
Ci   nRLc  :number of Rl channels in sites 1..nbas
Ci   pstat :static bare response function (available for 10s digit mode = 0)
Ci   vmad  :Madelung matrix, nbasxnbas array
Ci   vsmad :Screened Madelung matrix (commented out now)
Ci   ldv   :leading dimension of vmad and vsmad
Ci   vintra:Intra-atomic screened coulomb interaction, by class
Ci   vin   :input es potential used to make hamiltonian, by class
Ci   vqin  :es potential generated by qin
Ci   qin   :moments used to generate hamiltonian
Cio Inputs/Outputs
Cio  qout  :On input, moments generated by the hamiltonian (output moments)
Cio        :On output, qout is overwritten by :
Cio        :  qin + epsilon^-1 [(qout-qin) - P (Vin -V[qin])]
Cio  vout  :On input, es pot generated by the hamiltonian (output pot)
Cio        :On output, vout is overwritten by :
Cio        :  epsilon+^-1 [Vout-Vin]
Cl Local variables
Cl   eps:  Inverse of q=0 static dielectric matrix, epsilon^-1
Cl   vmada :Madelung matrix (site), including onsite 2*q/rmax
Cl   vmadi :Inverse of vmada
Cl   vbare :vmada expanded into l channels (nRLc repsn), vintra added
Cl   vmadli:vmadi expanded into l channels (nRLc repsn)
Cl         :may also be direct inverse of vbare
Cl   vintr :vintra expanded into l channels (nRLc repsn)
Cb Bugs
Cb   The correction P (Vin -V[qin])] uses the spin-1 P function
Cb   only for now.
Cu Updates
Cu   25 Nov 17 Attempted (unsuccessfully) to replace model epsilon with TF screening
Cu             Re-used old algorithm but cleaned it up
Cu   08 May 13 Complete migration to f90 structures; eliminate s_array
Cu   10 Nov 11 Begin migration to f90 structures
Cu   24 Feb 05 (Jailei Xu) Screening through model dielectric function
Cu   19 Feb 02 dimensions of vmad passed separately to accomodate
Cu             padding sites.
C ----------------------------------------------------------------------
      use structures
      implicit none
C ... Passed parameters
      integer mode,nbas,nclass,nl,nsp,nRLc,ldv
      real(8), target :: pstat(nRLc,nsp,nRLc,nsp)
      double precision elind0,qin(3,nl,nsp,*),qout(3,nl,nsp,*),vin(nclass),vout(nclass),
     .  vmad(ldv,1),vsmad(ldv,1),vintra(nl,nl,nsp,nsp,1),vqin(nclass)
C ... For structures
!      include 'structures.h'
      type(str_ctrl)::  s_ctrl
      type(str_ham)::   s_ham
      type(str_bz)::    s_bz
      type(str_lat)::   s_lat
C ... Dynamically allocated arrays
!     Used in the TF screeing algorithm pscrm9 ... commented out
!     real(8), allocatable :: ql(:,:,:,:,:)
!     real(8), allocatable :: qscr(:,:,:,:)
!     real(8), allocatable :: vsmadb(:,:)
      real(8), allocatable :: dq(:)
      real(8), allocatable :: qwk(:)
      real(8), allocatable :: dqv(:)
      real(8), allocatable :: eps(:,:,:,:)
      real(8), allocatable :: vbare(:,:,:,:)
      real(8), allocatable :: vmada(:)
      real(8), allocatable :: vmadi(:,:)
      real(8), allocatable :: vmadli(:,:,:,:)
      real(8), allocatable :: vintr(:,:,:,:)
      real(8), allocatable :: vtemp(:,:,:,:)
      real(8), allocatable :: epsa(:,:)
      real(8), allocatable :: psta(:,:)
      real(8), allocatable :: pstaa(:)
      real(8), pointer :: pstatl(:,:,:,:)
C ... Local parameters
      double precision qval,vol,pi,fac,elind
      integer ierr,is1,is2,job0,job1,ldham(16),lhdim,nRLc2,stdo
      integer, parameter :: NULLI=-99999
      procedure(integer) :: nglob,isw
      procedure(real(8)) :: dsum

C     Tolerance in deviation in P0 from hermicity
      double precision htol
      parameter (htol=1d-6)
      equivalence (lhdim,ldham(3))
*     integer ib,ic,il

C     call pshpr(60)
      stdo = nglob('stdo')
      pi = 4d0*datan(1d0)
      job0 = mod(mode,10)
      job1 = mod(mode/10,10)
      nRLc2 = nRLc * nsp
C     call prm('pstat',ierr,pstat,nRLc2,nRLc2,nRLc2)

C     Check that P0 is hermitian
      if (job1 == 0) then
        do  is1 = 1, nRLc2
        do  is2 = 1, nRLc2
        if (abs(pstat(is1,1,is2,1)-pstat(is2,1,is1,1)) > htol) then
          call info0(10,1,0,'scrmom (warning) response function is not symmetric')
        endif
        enddo
        enddo
      endif
    3 continue

      ldham = s_ham%ldham

C --- Make vbare, q=0, monopoles = Madelung matrix * 2 + site-diagonal term ---
      allocate(vmada(nbas**2))
      call pscrm3(nbas,s_ctrl%ipc,s_ctrl%rmax,vmad,ldv,0d0,vmada)
C     call prmx('vmada',vmada,nbas,nbas,nbas)

C --- Overwrite vout with estimate for the self-consistent V ---
      if (job0 == 1 .or. job0 >= 3) then

        if (job1 == 1) call rxi('scrmom not implemented, mode',mode)

C   ... epsilon_a = (1 - pstat vbare), contracted over l
        allocate(epsa(nbas,nbas))
        allocate(psta(nbas,nbas)); call dpzero(psta,nbas**2)
        do  is1 = 1, nsp
        do  is2 = 1, nsp
          call plm2pa(pstat(1,is1,1,is2),nbas,nRLc2,lhdim,
     .      s_ham%iprmb,1011,1,psta)
        enddo
        enddo
        call prjrsp(1,1,1,nbas,1,psta)
C        call prmx('contracted pstat',psta,nbas,nbas,nbas)
        call dgemm('N','N',nbas,nbas,nbas,-1d0,psta,nbas,
     .    vmada,nbas,0d0,epsa,nbas)
        call daxpy(nbas,1d0,1d0,0,epsa,nbas+1)

C  --- model dielectric function (not implemented)
c      else if (job0 == 0) then
C         real(8), allocatable :: epsa(:)
C         allocate(epsa(nbas**2))
C
CCC --- diagonalize the vbare matrix ---
CC     ovmadb2 stores the diagonal part of diagonalized matrix,
CC     ovmvec stores the normalized eigenvectors of vbare
CC         real(8), allocatable :: vmadb2(:)
CC         real(8), allocatable :: vmvec(:)
CC         real(8), allocatable :: fv1(:)
CC         real(8), allocatable :: fv2(:)
C         allocate(vmadb2(nbas))
C         allocate(vmvec(nbas**2))
C         allocate(fv1(nbas))
C         allocate(fv2(nbas))
C         call rs(nbas,nbas,vmada,vmadb2,1,vmvec,fv1,fv2,ierr)
C         deallocate(fv1)
C         deallocate(fv2)
CC --- make epsilon_a2 = 1 + elind * vmadb2 ---
C         real(8), allocatable :: epsa2(:)
C         allocate(epsa2(nbas**2))
C         call dpzero(epsa2,nbas**2)
C         call daxpy(nbas,elind,vmadb2,1,epsa2,nbas+1)
C         call daxpy(nbas,1d0,1d0,0,epsa2,nbas+1)
C
CC --- transfer back to original space to get epsilon ---
CC     one option, can use dtrmm.f zgemm.f ztrmm.f in BLAS directory
C         real(8), allocatable :: vdtmp(:)
C         allocate(vdtmp(nbas**2))
C         call dgemm('N','N',nbas,nbas,nbas,1d0,vmvec,nbas,epsa2,
C     .        nbas,0d0,vdtmp,nbas)
C         call dgemm('N','T',nbas,nbas,nbas,1d0,vdtmp,nbas,vmvec,
C     .        nbas,0d0,epsa,nbas)
C         deallocate(epsa2)
C         deallocate(vmadb2)
C         deallocate(vdtmp)
C         deallocate(vmvec)
C         deallocate(epsa)
C      end if

C   ... epsa^-1
        allocate(vtemp(nbas,nbas,1,1))
        call dqinv('n',epsa,nbas,4,nbas,vtemp,nbas,ierr)
        if (ierr /= 0) call rx('scrmom failed to invert epsilon')
        deallocate(vtemp)

C       call prmx('epsa',epsa,nbas,nbas,nbas)
C       call prmx('vin',vin,nclass,nclass,1)
C       call prmx('vout',vout,nclass,nclass,1)

        allocate(vtemp(3,nl*nsp,nbas,1),qwk(3*nl*nsp*nbas))
        call pscrm2(nbas,nclass,s_ctrl%nrc,s_ctrl%ipc,epsa,vin,vout,vtemp,qwk)
        deallocate(epsa,psta,vtemp,qwk)
      end if

C --- Linear response estimate for unscreened dq(Vin - V[nin]) ---
      if (job0 >= 3) then
        if (job1 == 1) call rxi('scrmom not implemented, mode',mode)

        allocate(pstaa(nbas*nRLc*nsp*nsp),qwk(3*nl*nsp*nbas))
        allocate(dqv(nRLc*nsp)); call dpzero(dqv,nRLc*nsp)
        call pscrm5(nbas,nsp,nRLc,lhdim,s_ham%iprmb,s_ctrl%ipc,pstat,pstaa,vin,vqin,qwk,dqv)
        deallocate(pstaa,qwk,dqv)
      endif

      allocate(eps(nRLc,nsp,nRLc,nsp)); call dpzero(eps,nRLc2**2)
      pstatl => pstat

C ... Expand vbare as l-dependent matrix, add vintra
      allocate(vbare(nRLc,nsp,nRLc,nsp)); call dpzero(vbare,nRLc2**2)
      call pa2plm(vmada,nbas,nRLc2,lhdim,s_ham%iprmb,1011,vbare)
      call pscrm4(5,nbas,nl,nsp,s_ctrl%ipc,nRLc,lhdim,s_ham%iprmb,vintra,vbare)
C     call prmx('vbare',vbare,nRLc2,nRLc,nRlc)

C --- Thomas Fermi model for epsilon^-1 ---
C      if (job1 == 1) then
C
C        allocate(ql(nbas,nsp,nl,3,3))
C        call pscrma(0,s_ctrl,nbas,nl,nsp,nclass,lhdim,3,nRLc,s_ham%iprmb,qin,ql(1,1,1,1,1),ql)
C        call pscrma(0,s_ctrl,nbas,nl,nsp,nclass,lhdim,3,nRLc,s_ham%iprmb,qout,ql(1,1,1,1,2),ql)
C        ierr = nbas*nsp*nl
C        call dcopy(ierr*3,ql(1,1,1,1,2),1,ql(1,1,1,1,3),1) ! qout for all three moments
C        call daxpy(ierr,-1d0,ql(1,1,1,1,1),1,ql(1,1,1,1,3),1) ! qout-qin for 0th moment only
C
C        elind = s_ham%elind
C        fac = elind
C        qval = s_bz%zval
C        vol  = s_lat%vol
C        if (elind == 0) elind = -1
C        if (elind < 0d0) elind=-elind*(3*pi**2*qval/vol)**.66666d0
C        call info5(20,0,0,' SCRMOM: screen output rho using model '//
C     .    'response, elind=%,3;3d %?#n#(input elind=%;3d)##',
C     .    elind,isw(elind /= fac),fac,0,0)
C
CC       First attempt : eps from eigenvalues of vbare
C        allocate(epsa(nbas,nbas))
CC       call pscrm9x(s_ctrl,nbas,nl,nsp,lhdim,s_ham%iprmb,elind,vmada,epsa,ql)
C
C        allocate(vsmadb(nbas,nbas))
C        call pscrm3(nbas,s_ctrl%ipc,s_ctrl%rmax,vsmad,ldv,elind,vsmadb)
C
C        call pscrm9(1,nbas,nl,nsp,vmada,vsmadb,epsa,ql)
C
C        if (.false.) then
C          call daxpy(nbas*nsp*nl,1d0,ql(1,1,1,1,1),1,ql(1,1,1,1,3),1)
C          call pscrmb(s_ctrl,nbas,nl,nsp,lhdim,s_ham%iprmb,ql)
C          call pscrma(1,s_ctrl,nbas,nl,nsp,nclass,lhdim,1,nRLc,s_ham%iprmb,qout,ql(1,1,1,1,3),ql)
C          return
C        endif
C
C        allocate(pstatl(nRLc,nsp,nRLc,nsp)); call dpzero(pstatl,size(pstatl))
C        call pa2plm(epsa,nbas,nRLc2,lhdim,s_ham%iprmb,1111,pstatl)
C        if (nsp == 2) then
C          call dmcpy(pstatl,nRLc*2,1,pstatl(1,2,1,2),nRLc*2,1,nRLc,nRLc)
C        endif
C
CC       call prmx('pstatl',pstatl,nRLc2,nRLc,nRlc)
C
C      endif

C --- Eigenvalue model for epsilon^-1 ---
      if (job1 == 1) then
        elind = elind0  ! elind is the parameter used locally. if elind0, elind is set to it.
        qval = s_bz%zval
        vol  = s_lat%vol
        if (elind == 0) elind = -1
        if (elind < 0d0) elind=-elind*(3*pi**2*qval/vol)**.66666d0
        call info5(20,0,0,' SCRMOM: screen output rho using model '//
     .    'response, elind=%,3;3d %?#n#(input elind=%;3d)##',
     .    elind,isw(elind /= elind0),elind0,0,0)

C       vmadi = Inverse of (site) Madelung matrix
C       vmadli = vmadi expanded to nRLc repsn, scaled by fac.
        allocate(vintr(nRLc,nsp,nRLc,nsp)) ! Used as a work array in this block
        allocate(vmadi(nbas,nbas)); call dpzero(vmadi,nbas**2)
        allocate(vmadli(nRLc,nsp,nRLc,nsp)); call dpzero(vmadli,nRLc2**2)
        call dcopy(nbas**2,vmada,1,vmadi,1)
        call dqinv('n',vmadi,nbas,4,nbas,vintr,nbas,ierr)
        if (ierr /= 0) call rx('scrmom failed to invert vmada')
        call pa2plm(vmadi,nbas,nRLc2,lhdim,s_ham%iprmb,1011,vmadli)
        fac = 1d0/(nl*nsp)
        call dscal(size(vmadli),fac,vmadli,1)
        call pscrm4(1,nbas,nl,nsp,s_ctrl%ipc,nRLc,lhdim,s_ham%iprmb,vintra,vmadli)

        deallocate(vmadi)

C       vintr = vintra expanded to nRLc repsn
        call dpzero(vintr,nRLc2**2)
        call pscrm4(5,nbas,nl,nsp,s_ctrl%ipc,nRLc,lhdim,s_ham%iprmb,vintra,vintr)

C       Overwrite vmadli with vmadli/nl * [1 + vintr*vmadli/nl]^-1.  Destroys vintr
        if (dsum(size(vintr),vintr,1) /= 0) then
          allocate(vtemp(nRLc,nsp,nRLc,nsp))

          ierr = 1
C         Replicates algorithm prior to 25 Nov 2017
C          if (nsp == 1) then
C            call dcopy(nRLc2**2,vbare,1,vmadli,1)
C            call dqinv('n',vmadli,nRLc2,4,nRLc2,vtemp,nRLc2,ierr)
C          endif

          if (ierr /= 0) then
            call dpzero(vtemp,nRLc2**2)
            call daxpy(nRLc2,1d0,1d0,0,vtemp,nRLc2+1)
            call dgemm('N','N',nRLc2,nRLc2,nRLc2,1d0,vintr,nRLc2,
     .        vmadli,nRLc2,1d0,vtemp,nRLc2)
            call dqinv('n',vtemp,nRLc2,4,nRLc2,vintr,nRLc2,ierr)
            call dgemm('N','N',nRLc2,nRLc2,nRLc2,1d0,vmadli,
     .        nRLc2,vtemp,nRLc2,0d0,vintr,nRLc2)
            call dcopy(nRLc2**2,vintr,1,vmadli,1)
          endif

          deallocate(vtemp)
        endif
        deallocate(vintr)
C       call prmx('vmadli',vmadli,nRLc2,nRLc2,nRlc2)

        call pscrm7(nRLc,nsp,elind,vbare,vmadli,eps)

C --- epsilon^-1 = (1 - pstat vbare)^-1 ---
       else
         call prjrsp(nsp,nsp,1,nRLc,1,pstatl)
         call pscrm6(nRLc,nsp,pstatl,vbare,eps)
         deallocate(vbare)
       endif

C     call prmx('qin',qin,3*nl*nsp,3*nl*nsp,nclass)
C     call prmx('qout',qout,3*nl*nsp,3*nl*nsp,nclass)

C --- Linear response estimate for self-consistent moments ---
      if (job0 >= 2) then
        allocate(dqv(nRLc*nsp)); call dpzero(dqv,nRLc*nsp)
        allocate(dq(3*nl*nsp*nbas),qwk(3*nl*nsp*nbas))
        call pscrm1(nbas,nl,nsp,nRLc,nclass,s_ctrl%nrc,s_ctrl%ipc,lhdim,
     .    s_ham%iprmb,eps,dqv,dq,qwk,qin,qout)
        deallocate(dq,qwk)
      endif

C     call poppr

C --- Make the inversion of vbare, then make the inversion of (vbare+vintra)
      deallocate(vmada,dqv,eps)
      if (.not. associated(pstatl,pstat)) deallocate(pstatl)

      end

      subroutine pscrm1(nbas,nl,nsp,nRLc,nclass,nrclas,ipc,
     .  lhdim,indxsh,epsi,dqv,dq,dqscr,qin,qout)
C- Linear response estimate for self-consistent moments
C ----------------------------------------------------------------------
Ci Inputs
Ci   nbas  :size of basis
Ci   nl    :(global maximum l) + 1
Ci   nsp   :2 for spin-polarized case, otherwise 1
Ci   nRLc  :number of Rl channels in sites 1..nbas
Ci   nclass:number of inequivalent classes
Ci   nrclas:nrclas(i) = number of atoms in the ith class
Ci   ipc   :class index: site ib belongs to class ipc(ib) (mksym.f)
Ci   lhdim :number of lower+intermediate+higher orbitals
Ci   indxsh:permutations ordering orbitals in l+i+h blocks (makidx.f)
Ci   epsi  :inverse ASA dielectric function, RL repsn
Ci   dqv   :dq(Vin-V[qin])
Ci   dqscr :screend (qout-qin)
Ci   qin   :input moments
Cio Inputs/Outputs
Cio  qout  :On input, actual output moments
Cio        :On output, qin + epsilon^-1 (qout-qin)
Co Outputs
Co   dq    :difference output-input moments
Cl Local variables
Cr Remarks
Cr dq should be dim 3*nl*nsp*nbas to accomodate both functions here
Cu Updates
Cu   20 Nov 17
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer nbas,nl,nsp,nclass,nrclas(*),nRLc,ipc(nbas)
      integer indxsh(*),lhdim
      double precision epsi(nRLc,nsp,nRLc,nsp),qin(3,nl,nsp,1),
     .  dqv(nRLc,2),qout(3,nl,nsp,1),dq(nRLc,nsp,3),dqscr(nRLc,nsp,3)
C ... Local parameters
      double precision rmsdq(2),xx,sum(4)
      integer isp,ib,ic,iprint,lgunit,lp1,lmri,lmrci,li,mi,id,mxorb,nglob,nRLc2,stdo

      mxorb = nglob('mxorb')
      nRLc2 = nRLc * nsp
      stdo = nglob('stdo')

C --- dq = qout - qin (reorder by ib) ---
      rmsdq(1) = 0
      lmrci = 0
      do  ib = 1, nbas
        ic = ipc(ib)
        lmri = mxorb*(ib-1)
        do  li = 0, nl-1
          do  mi = -li, li
          lmri = lmri+1
          id = indxsh(lmri)
          if (id > lhdim .or. mi > -li) cycle
          lmrci = lmrci+1
          do  isp = 1, nsp
            dq(lmrci,isp,1) = qout(1,li+1,isp,ic) - qin(1,li+1,isp,ic)
            dq(lmrci,isp,2) = qout(2,li+1,isp,ic) - qin(2,li+1,isp,ic)
            dq(lmrci,isp,3) = qout(3,li+1,isp,ic) - qin(3,li+1,isp,ic)
            rmsdq(1) = rmsdq(1) + dq(lmrci,isp,1)**2
C       ... Subtract dqv = linear response estimate for dq(Vin-V[qin])
            dq(lmrci,isp,1) = dq(lmrci,isp,1) - dqv(lmrci,isp)
          enddo
          enddo
        enddo
      enddo
      call rxx(lmrci /= nRLc,'pscrm1: index mismatch')
C     call prmx('qout - qin - dqv',dq,nRLc,nRLc,nsp*3)

C --- dqscr = epsilon^-1 dq ---
C ... Copy array, so we can screen only first column
C     call dcopy(nl*nbas*nsp*3,dq,1,dqscr,1)
C ... Use 3*nsp for all moments, 1*nsp for first only
      call dpzero(dqscr, nRLc2*1)
C     call prmx('eps^-1',epsi,nRLc2,nRLc2,nRlc2)
      call dgemm('N','N',nRLc2,1,nRLc2,1d0,epsi,nRLc2,dq,nRLc2,1d0,dqscr,nRLc2)
C     call prmx('dqscr=eps^-1(qout-qin)',dqscr,nRLc,nRLc,nsp*1)

C --- Overwrite qout with qin + epsilon^-1 dq ---
C ... Save old qout in dq for printout; initialize 0th moment of qout
      call dcopy(nl*nclass*nsp*3,qout,1,dq,1)
      do  isp = 1, nsp
        do  ic = 1, nclass
          do  lp1 = 1, nl
            dq(lp1+nl*(ic-1),isp,1) = qout(1,lp1,isp,ic)
            qout(1,lp1,isp,ic) = 0
          enddo
        enddo
      enddo
C ... Accumulate eps^-1 (qout-qin), averaging by classes
      rmsdq(2) = 0
      lmrci = 0
      do  ib = 1, nbas
        ic = ipc(ib)
        lmri = mxorb*(ib-1)
        do  li = 0, nl-1
        do  mi = -li, li
          lmri = lmri+1
          id = indxsh(lmri)
          if (id > lhdim .or. mi > -li) cycle
          lmrci = lmrci+1
          do  isp = 1, nsp
            rmsdq(2) = rmsdq(2) + dqscr(lmrci,isp,1)**2
            qout(1,li+1,isp,ic) = qout(1,li+1,isp,ic) +
     .                            dqscr(lmrci,isp,1)/nrclas(ic)
          enddo
        enddo
        enddo
      enddo
C ... Add qin to qout; if qout is zero, assume unscreened qout??
      do  ic = 1, nclass
        do  isp = 1, nsp
          do  lp1 = 1, nl
            qout(1,lp1,isp,ic) = qout(1,lp1,isp,ic) + qin(1,lp1,isp,ic)
          enddo
        enddo
      enddo

C --- Printout ---
      rmsdq(1) = sqrt(rmsdq(1)/nRLc*nsp)
      rmsdq(2) = sqrt(rmsdq(2)/nRLc*nsp)
      call dpzero(sum,size(sum))
      if (iprint() >= 20) call awrit2(' SCRMOM: unscreened '//
     .  'dq=%1,3;3e  screened dq=%1,3;3e',' ',80,lgunit(1),rmsdq(1),rmsdq(2))
      if (iprint() < 40) return
      write (stdo,1)
    1 format('  ic  l      qin         qout',8x,'qscr',8x,'diff')
      do  isp = 1, nsp
         if (isp == 2) write(stdo,*) ' .... spin 2'
        do  ic = 1, nclass
          do  lp1 = 1, nl
            xx = dq(lp1+nl*(ic-1),isp,1)
            write (stdo,2) ic,lp1-1,qin(1,lp1,isp,ic),xx,
     .        qout(1,lp1,isp,ic),qout(1,lp1,isp,ic)-xx
    2       format(i4,i3,4F12.6)
            sum(1) = sum(1) + qin(1,lp1,isp,ic)
            sum(2) = sum(2) + xx
            sum(3) = sum(3) + qout(1,lp1,isp,ic)
            sum(4) = sum(4) + qout(1,lp1,isp,ic)-xx
          enddo
        enddo
      enddo
      call info5(10,0,0,' sum %;14,6D%;12,6D%;12,6D%;12,6D',sum(1),sum(2),sum(3),sum(4),5)

      end

      subroutine pscrm2(nbas,nclass,nrclas,ipc,epsa,vin,vout,dv,dvscr)
C- Linear response estimate for self-consistent v
C ----------------------------------------------------------------------
Ci Inputs
Ci   nbas  :size of basis
Ci   nclass:number of inequivalent classes
Ci   nrclas:nrclas(i) = number of atoms in the ith class
Ci   ipc   :class index: site ib belongs to class ipc(ib) (mksym.f)
Ci   epsa
Ci   vin
Ci   vout
Co Outputs
Co   dv
Co   dvscr
Cu Updates
C ----------------------------------------------------------------------
      implicit none
      integer nbas,nclass,ipc(nbas),nrclas(nbas)
      double precision vin(*),vout(*),dv(nbas),dvscr(nbas),
     .  epsa(nbas,nbas)
C Local variables
      double precision rmsdv(2)
      integer ib,ic,iprint,lgunit,stdo
      procedure(integer) :: nglob

      stdo = nglob('stdo')

C --- dv = vout - vin ---
      rmsdv(1) = 0
      do  ib = 1, nbas
        ic = ipc(ib)
        dv(ib) = vout(ic) - vin(ic)
        rmsdv(1) = rmsdv(1) + dv(ib)**2
      enddo
*     call prmx('dv',dv,nbas,nbas,1)

C --- Save in vscr : eps^-1 (vout - vin) ---
      call dgemm('T','N',nbas,1,nbas,1d0,epsa,nbas,dv,nbas,0d0,dvscr,nbas)

C --- vscr = vin + eps^-1 (vout - vin) ---
C ... Save old vout in dv for printout
      call dcopy(nclass,vout,1,dv,1)
      call dpzero(vout,nclass)
      rmsdv(2) = 0
      do  ib = 1, nbas
        ic = ipc(ib)
        vout(ic) = vout(ic) + (dvscr(ib) + vin(ic))/nrclas(ic)
        rmsdv(2) = rmsdv(2) + dvscr(ib)**2
      enddo

      if (iprint() >= 20) call awrit2(' SCRMOM: unscreened '//
     .  'dv=%1,3;3e  screened dv=%1,3;3e',' ',80,lgunit(1),
     .  rmsdv(1),rmsdv(2))
       if (iprint() <= 40) return
       write(stdo,'(''  ic      Vin         Vout        Vscr'')')
       do  ic = 1, nclass
         write(stdo,1) ic,vin(ic),dv(ic),vout(ic)
    1    format(i4,3F12.6)
       enddo

      end
      subroutine pscrm3(nbas,ipc,wsr,vmad,ldv,elind,vmadb)
C- Kernel called by scrmom to make unscreened Madelung matrix.
      implicit none
      integer nbas,ipc(*),ldv
      double precision wsr(*),vmad(ldv,ldv),vmadb(nbas,nbas),elind
      integer ib
      double precision y,rmax,xx

C     call prmx('madelung matrix before onsite',vmad,ldv,ldv,ldv)

C ... Madelung potential = Madelung matrix * 2
      call dmscop(vmadb,nbas,vmad,ldv,1,nbas,1,nbas,1,1,2d0)

C ... Add site-diagonal, which is 2/r if elind=0
      if (elind /= 0) then
        do  ib = 1, nbas
          rmax = wsr(ipc(ib))
          y = sqrt(elind)*rmax
          xx  = 6/rmax**3*exp(-y)/y*(y*cosh(y)-sinh(y))/elind
          vmadb(ib,ib) = vmadb(ib,ib) + xx
        enddo
      else
        forall (ib = 1:nbas) vmadb(ib,ib) = vmadb(ib,ib) + 2/wsr(ipc(ib))
      endif

C     call prmx('vmadb',vmadb,nbas,nbas,nbas)

      end

      subroutine pscrm4(mode,nbas,nl,nsp,ipc,nRLc,ldim,indxsh,vintra,vbare)
C- Expand vbare to all spin channels and add vintra to vbare
C ----------------------------------------------------------------------
Ci Inputs
Ci   mode  :0 do nothing
Ci         :1 copy vbare (1,1) to (:,:) in spin channels
Ci         :4 add vintra to vbare
Ci         :5 combination of 1+4
Ci   nbas  :size of basis
Ci   nl    :(global maximum l) + 1
Ci   nsp   :2 for spin-polarized case, otherwise 1
Ci   ipc   :class index: site ib belongs to class ipc(ib) (mksym.f)
Ci   nRLc  :number of Rl channels in sites 1..nbas
Ci   vintra on-site density-density response matrix
Ci   vbare  bare Coulomb matrix with no intra-atomic terms and, not
Ci          spin polarized.
Ci          NB: in the spin polarized case, input vbare is dimensioned
Ci          WITHOUT spin polarization.
Co Outputs
Co   vbare  on-site vintra is added to vbare.
Co          NB: in the spin polarized case, output vbare is dimensioned
Co              WITH spin polarization; see pscrm5.
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer mode,nbas,nl,nsp,nRLc,ldim,ipc(nbas),indxsh(*)
      double precision vintra(nl,nl,nsp,nsp,1),vbare(nRLc,nsp,nRLc,nsp)
C ... Local parameters
      integer ib,ic,idim0,il,ilb,jl,jlb,li,lj,norb,ntorbi,n0,nkap0
      parameter (n0=10,nkap0=4)
      integer isp,jsp,offi,ltab(n0*nkap0),ktab(n0*nkap0),offl(n0*nkap0)

      if (mod(mode,2) == 1 .and. nsp == 2) then
        call dmcpy(vbare,nRLc*2,1,vbare(1,1,1,2),nRLc*2,1,nRLc,nRLc)
        call dmcpy(vbare,nRLc*2,1,vbare(1,2,1,1),nRLc*2,1,nRLc,nRLc)
        call dmcpy(vbare,nRLc*2,1,vbare(1,2,1,2),nRLc*2,1,nRLc,nRLc)
      endif

      if (mod(mode/4,2) == 0) return

      idim0 = 0
      do  ib = 1, nbas
        ic = ipc(ib)
C       uses norb,ltab
        call orbl(ib,0,ldim,indxsh,norb,ltab,ktab,offi,offl,ntorbi)

        ilb = idim0
        do  il = 1, norb
          ilb = ilb+1
          li = ltab(il)+1
          jlb = idim0
          do  jl = 1, norb
            jlb = jlb+1
            lj = ltab(jl)+1

            do  isp = 1, nsp
            do  jsp = 1, nsp
              vbare(ilb,isp,jlb,jsp) = vbare(ilb,isp,jlb,jsp) +
     .                                 vintra(li,lj,isp,jsp,ic)
            enddo
            enddo
          enddo
        enddo
        idim0 = idim0+norb
      enddo

C     print *, 'ok in prscm4'
C     call prmx('vbare incl vintra',vbare,nRLc*nsp,nRLc*nsp,nRLc*nsp)

      end

      subroutine pscrm5(nbas,nsp,nRLc,lhdim,indxsh,ipc,pstat,pstaa,vin,
     .  vqin,dv,dqv)
C- Linear response estimate for unscreened dq(Vin - V[nin])
C ----------------------------------------------------------------------
Ci Inputs
Ci   nbas  :size of basis
Ci   nsp   :2 for spin-polarized case, otherwise 1
Ci   nRLc
Ci   lhdim :number of lower+intermediate+higher orbitals
Ci   indxsh:permutations ordering orbitals in l+i+h blocks (makidx.f)
Ci   ipc   :class index: site ib belongs to class ipc(ib) (mksym.f)
Ci   pstat
Ci   pstaa
Ci   vin
Ci   vqin
Co Outputs
Co   dv
Co   dqv
Cb Bugs?
Cb   Maybe vbare should be diagonal in l?  Then each l is treated independently?
Cs Command-line switches
Cu Updates
C ----------------------------------------------------------------------
      implicit none
      integer nbas,nsp,lhdim,nRLc,ipc(nbas),indxsh(*)
      double precision vin(*),vqin(*),dv(nbas),
     .  pstat(nRLc,nsp,nRLc,nsp),dqv(nRLc,nsp)
      double precision pstaa(nbas,nRLc,nsp,nsp)
C Local variables
      double precision rmsdv(2),dsum,qtot,sump,xx
      integer ib,ic,is1,i,nRLc2

      nRLc2 = nRLc * nsp

C --- dv = vqin - vin ---
      rmsdv(1) = 0
      do  ib = 1, nbas
        ic = ipc(ib)
        dv(ib) = vqin(ic) - vin(ic)
        rmsdv(1) = rmsdv(1) + dv(ib)**2
      enddo

C     call prmx('v[qin]-vin',dv,nbas,nbas,1)

      call dpzero(dqv,nRLc2)

C --- Unscreened dq(Vin - V[nin]) = P (Vin - V[nin]) ---
      do  is1 = 1, nsp

C   ... Collapse one l-sigma index of p, to multiply by V
        call plm2pa(pstat(1,is1,1,1),nbas,nRLc2,lhdim,indxsh,10,
     .    nRLc2,pstaa(1,1,1,is1))

        call dgemm('T','N',nRLc2,1,nbas,-1d0,pstaa(1,1,1,is1),nbas,dv,
     .    nbas,1d0,dqv,nRLc2)

C      call prmx('pstaa',pstaa(1,1,1,is1),nbas,nbas,nRLc2)
C      call prmx('dq(v[qin]-vin before renorm)',dqv,nRLc,nRLc,nsp)

      enddo

C     Ensure charge neutrality --- should do by renorm of pstaa
      qtot = dsum(nRLc2,dqv,1)
      sump = dsum(nRLc2*nbas*nsp,pstaa,1)
      do  is1 = 1, nsp
      do  i = 1, nRLc
        xx = dsum(nbas,pstaa(1,i,is1,1),1)
        if (nsp == 2) xx = xx + dsum(nbas,pstaa(1,i,is1,2),1)
        dqv(i,is1) = dqv(i,is1) - qtot/sump * xx
        enddo
      enddo

C     call prmx('dq(v[qin]-vin)',dqv,nRLc,nRLc,nsp)

      end
      subroutine pscrm6(nRLc,nsp,pstat,vbare,eps)
C- Make epsilon^-1 = (1 - pstat vbare)^-1
C ----------------------------------------------------------------------
Ci Inputs
Ci For debugging, to make eps^-1
Ci   mc -1:24 pstat.nsp=1 vbare+vintra -x -s-1 -+ -i
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer nsp,nRLc
      double precision pstat(nRLc,nsp,nRLc,nsp),vbare(nRLc,nsp,nRLc,nsp)
      double precision eps(nRLc,nsp,nRLc,nsp)
C ... Dynamically allocated local arrays
      real(8), allocatable :: wkr(:)
C ... Local parameters
      integer ierr,nRLc2

      nRLc2 = nRLc * nsp

C --- epsilon = (1 - pstat vbare) ---
      call dgemm('N','N',nRLc2,nRLc2,nRLc2,-1d0,pstat,nRLc2,
     .  vbare,nRLc2,0d0,eps,nRLc2)
      call daxpy(nRLc2,1d0,1d0,0,eps,nRLc2+1)
C     call prm('epsilon',ierr,eps,nRLc2,nRLc2,nRLc2)

C --- epsilon^-1 ---
      allocate(wkr(nRLc2**2))
      call dqinv('n',eps,nRLc2,4,nRLc2,wkr,nRLc2,ierr)
      if (ierr /= 0) call rx('scrmom failed to invert epsilon')
      deallocate(wkr)

C ... debugging
C     call prm('pstat',ierr,pstat,nRLc2,nRLc2,nRLc2)
C     call prm('vbare',ierr,vbare,nRLc2,nRLc2,nRLc2)
C     call prm('epsilon^-1',ierr,eps,nRLc2,nRLc2,nRLc2)

      end

      subroutine pscrm7(nRLc,nsp,elind,vbare,invbar,eps)
C- Make epsilon^-1 using a model aproach without using pstat
C ----------------------------------------------------------------------
Ci Inputs
Ci   nRLc  :number of Rl channels in sites 1..nbas
Ci   nsp   :2 for spin-polarized case, otherwise 1
Ci   elind :Thomas Fermi sceening length
Cl   vbare :Madelung matrx + vintra in nRLc repsn
Cl   invbar:Inverse vbare?
Co Outputs
Co   eps   :model dielectric function
Cl Local variables
Cr Remarks
Cr   First diagonalize vbare to vbare2, and make eps2, then transfer
Cr   the eps2 to the original space to make eps. Finally, make epsilon^-1
Cu Updates
Cu   17 Jun 13 Replace f77 pointers with f90 ones
Cu   24 Feb 05 (Jialei Xu) first created
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer nsp,nRLc
      double precision eps(nRLc,nsp,nRLc,nsp),elind
      double precision vbare(nRLc,nsp,nRLc,nsp),
     .  invbar(nRLc,nsp,nRLc,nsp)
C ... Dynamically allocated local arrays
      real(8), allocatable :: pstat(:),qdtmp(:)
      real(8), allocatable :: fv1(:),fv2(:)
      real(8), allocatable :: vbvec(:),vbar2(:),eps2(:)
C ... Local parameters
      integer ierr,nRLc2

      nRLc2 = nRLc * nsp

C      call prmx('vbare',vbare,nRLc2,nRLc2,nRlc2)
C      call prmx('vbare^-1',invbar,nRLc2,nRLc2,nRlc2)

C --- Diagonalize vbare ---
C     vbar2 stores the diagonal part of diagonalized matrix,
C     vbvec stores the normalized eigenvectors of vbare
      allocate(vbar2(nRLc2),vbvec(nRLc2**2))

      allocate(fv1(nRLc2),fv2(nRLc2))
      call rs(nRLc2,nRLc2,vbare,vbar2,1,vbvec,fv1,fv2,ierr)
      if (ierr /= 0) call rx('scrmom: diagonalization failed')
      deallocate(fv1,fv2)

C --- make epsilon2 = 1 + elind * vbare2 ---
      allocate(eps2(nRLc2**2))
      call dpzero(eps2,nRLc2**2)
      call daxpy(nRLc2,elind,vbar2,1,eps2,nRLc2+1)
      call daxpy(nRLc2,1d0,1d0,0,eps2,nRLc2+1)
      call dvset(eps2,1,1,1d0)

C --- Rotate back to original space to get epsilon ---
C     one option, can use dtrmm.f zgemm.f ztrmm.f in BLAS directory
      allocate(qdtmp(nRLc2**2))
      call dgemm('N','N',nRLc2,nRLc2,nRLc2,1d0,vbvec,nRLc2,eps2,
     .           nRLc2,0d0,qdtmp,nRLc2)
      call dgemm('N','T',nRLc2,nRLc2,nRLc2,1d0,qdtmp,nRLc2,
     .           vbvec,nRLc2,0d0,eps,nRLc2)
c      eps(1,1,1,1) = 1.d0
c      call mdzero(nRLc2,eps)
      deallocate(qdtmp,vbvec,vbar2)

C     Project the response function to conserve the charge
      allocate(pstat(nRLc2**2)); call dpzero(pstat,nRLc2**2)
      call daxpy(nRLc2,-1d0,1d0,0,eps,nRLc2+1)
      call dgemm('N','N',nRLc2,nRLc2,nRLc2,-1d0,eps,nRLc2,invbar,
     .     nRLc2,0d0,pstat,nRLc2)
      call prjrsp(nsp,nsp,1,nRLc,1,pstat)
      call dgemm('N','N',nRLc2,nRLc2,nRLc2,-1d0,pstat,nRLc2,
     .     vbare,nRLc2,0d0,eps,nRLc2)
      call daxpy(nRLc2,1d0,1d0,0,eps,nRLc2+1)

C --- epsilon^-1 ---
      call dqinv('n',eps,nRLc2,4,nRLc2,eps2,nRLc2,ierr)
      if (ierr /= 0) call rx('scrmom failed to invert epsilon')
      deallocate(eps2)

C ... debugging
C      call prm('pstat',ierr,pstat,nRLc2,nRLc2,nRLc2)
C      call prm('vbare',ierr,vbare,nRLc2,nRLc2,nRLc2)
C      call prm('epsilon^-1',ierr,eps,nRLc2,nRLc2,nRLc2)

      deallocate(pstat)
      end

C      subroutine pscrm9(mode,nbas,nl,nsp,vmada,vsmada,epsa,ql)
CC- Make epsilon^-1 using a model for the polarizability
CC ----------------------------------------------------------------------
CCi Inputs
CCi   mode  :0 return epsa, ql
CCi         :1 return in epsa the polarizability P0 = M^-1 - W^-1
CCi   nbas  :size of basis
CCi   nl    :(global maximum l) + 1
CCi   nsp   :2 for spin-polarized case, otherwise 1
CCi   vmada :Madelung matrix including on-site term
CCi   vsmada:Screened Madelung matrix including on-site term
CCi   ql    :ql(:,:,:,:,1) = input charge
CCi         :ql(:,:,:,:,2) = bare output charge
CCo Outputs
CCi   ql    :ql(:,:,:,:,3) = screened output charge
CCl Local variables
CCl   vev   :eigenvalues of the Madelung matrix
CCr Remarks
CCr   Idea:  output - input density = dn
CCr   delta V and delta M are related by dV = M dn
CCr   Then dV_bare = M dn
CCr   Assume screening is by Thomas-Fermi.
CCr   Evaluate screened coulomb W as potential from screened functions exp(-lambda r)/r
CCr   Then dV_scr = W dn; calculate W using screened strux; see smadmat
CCr   To extract dielectric function note that dn_scr = eps^-1 dn_bare
CCr   Then eps^-1 is obtained from:
CCr     dV_scr = W dn
CCr     M dn_scr = W dn
CCr     dn_scr = M^-1 W dn  and so eps^-1 = M^-1 W
CCr   Also polarizability P0 or bare suscptibility chi0
CCr     eps^-1 = (1 - P0 M)^-1 = M^-1 (M^-1 - P0)^-1
CCr   Using the above, we find the usual relation
CCr     P0 = M^-1 - W^-1
CCr
CCr  Problem:
CCr    Without additional information distinguishing l channels, must treat
CCr    each independently.  But, can add With P0 that makes each l distinct =>
CCr    can express epsilon that couples channels.
CCu Updates
CCu   21 Nov 17 First created
CC ----------------------------------------------------------------------
C      implicit none
CC ... Passed parameters
C      integer mode,nbas,nl,nsp
C      double precision vmada(nbas,nbas),vsmada(nbas,nbas),epsa(nbas,nbas)
C      double precision ql(nbas,nsp,nl,3,3)
CC ... Dynamically allocated local arrays
C      real(8), allocatable :: wkr(:,:),dqscr(:,:,:)
CC ... Local parameters
C      integer ierr
C
C      print *, 'mode',mode
C
CC     stdo = nglob('stdo')
C
CC      call prmx('Mbare',vmada,nbas,nbas,nbas)
CC      call prmx('Mscr',vsmada,nbas,nbas,nbas)
C
C      allocate(wkr(nbas,nbas),dqscr(nbas,nbas,2))
C      call dcopy(nbas*nbas,vmada,1,dqscr,1)   ! Invert vmada in temporary array, preserving vmada
C      call dqinv('n',dqscr,nbas,4,nbas,wkr,nbas,ierr)
C
C      if (mode == 1) then
C        call dcopy(nbas*nbas,dqscr,1,epsa,1)
C        call dcopy(nbas*nbas,vsmada,1,dqscr,1) ! Invert vsmada in temporary array, preserving vmada
C        call dqinv('n',dqscr,nbas,4,nbas,wkr,nbas,ierr)
C        call daxpy(nbas*nbas,-1d0,dqscr,1,epsa,1)
CC       call prmx('P0',epsa,nbas,nbas,nbas)
C        deallocate(dqscr,wkr)
C        return
C      endif
C
C      call dgemm('N','N',nbas,nbas,nbas,1d0,dqscr,nbas,vsmada,nbas,0d0,epsa,nbas)
C      call prmx('eps',epsa,nbas,nbas,nbas)
C      deallocate(dqscr,wkr)
C
CC     Overwrite ql(:,:,:,1,3) = dqbare with dqscr
C      allocate(dqscr(nbas,nsp,nl))
CC     call prjrsp(1,1,1,nbas,1,epsa) ! Can't do this ... allows no transfer between l or spin
C      call dgemm('N','N',nbas,nsp*nl,nbas,1d0,epsa,nbas,ql(1,1,1,1,3),nbas,0d0,dqscr,nbas)
CC     call prmx('dqscr by site and l',dqscr,nbas,nbas,nsp*nl)
C      call dcopy(nbas*nsp*nl,dqscr,1,ql(1,1,1,1,3),1)
C      deallocate(dqscr)
C
C      end

C      subroutine pscrm9x(s_ctrl,nbas,nl,nsp,lhdim,iprmb,elind,vmada,epsa,ql)
CC- Make epsilon^-1 using a model for the polarizability
CC ----------------------------------------------------------------------
CCio Structures
CCio  s_ctrl :struct for program flow parameters; see structures.h
CCi     Elts read:  ipc rmax
CCo     Stored:     *
CCo     Allocated:  *
CCio    Elts passed:*
CCio    Passed to:  *
CCi Inputs
CCi   nbas  :size of basis
CCi   nl    :(global maximum l) + 1
CCi   nsp   :2 for spin-polarized case, otherwise 1
CCi   lhdim :number of lower+intermediate+higher orbitals
CCi   iprmb :permutations ordering orbitals in l+i+h blocks (makidx.f)
CCi   elind :Thomas Fermi sceening length
CCi   vmada :Madelung matrix including on-site term
CCi   ql    :ql(:,:,:,:,1) = input charge
CCi         :ql(:,:,:,:,2) = bare output charge
CCo Outputs
CCi   ql    :ql(:,:,:,:,3) = screened output charge
CCl Local variables
CCl   vev   :eigenvalues of the Madelung matrix
CCr Remarks
CCr   Routine assumes Madelung matrix v, when diagonalized,
CCr   corresponds to some plane wave of vector G.
CCr   In the diagonal basis bare v = 1/G^2
CCr   Thomas Fermi screening:  eps = 1 + G0^2/G^2.  Use elind for G0^2.
CCr   Note also eps = 1 - vP.  Then P = -G0^2 = -elind
CCr
CCr   The following relations hold.  Here z are eigenvectors of vmada
CCr   and ~ refers to basis where vmada is diagonal
CCr     M~ = z+T M z  and M~^-1 = z+T M^-1 z
CCr     M = z M~ z^T  and M^-1 = z M~^-1 z+T
CCr     epsi = z epsi~ z^T
CCu Updates
CCu   21 Nov 17 First created
CC ----------------------------------------------------------------------
C      use structures
C      implicit none
CC ... Passed parameters
C      integer nbas,nl,nsp,lhdim
C      integer iprmb(*)
C      double precision vmada(nbas,nbas),epsa(nbas,nbas),elind
C      double precision ql(nbas,nsp,nl,3,3)
CC ... For structures
C!      include 'structures.h'
C      type(str_ctrl)::  s_ctrl
CC ... Dynamically allocated local arrays
C      real(8), allocatable :: wkr(:,:),q(:,:,:,:),dqscr(:,:,:)
C      real(8), allocatable :: fv1(:),fv2(:),epsic(:)
C      real(8), allocatable :: vbvec(:,:),vev(:)
CC ... Local parameters
C      integer isp,ib,ic,lmri,li,mi,id,mxorb,stdo,ierr,ipass
C      double precision avfracq,fracq,qadd,vsph,vol,dqbare,dqscrn,qnow,qtot,dqtot,qnew,P0
C      procedure(integer) :: nglob,lgunit,iprint
C      procedure(real(8)) :: dsum
C
C      print *, 'elind is', elind
C
C      mxorb = nglob('mxorb')
C      stdo = nglob('stdo')
C
CC --- Diagonalize vmada ---
CC     vev stores the eigenvalues, vbvec the eigenvectors
C      allocate(vev(nbas),vbvec(nbas,nbas),wkr(nbas,nbas))
C      allocate(fv1(nbas),fv2(nbas))
C      call dcopy(nbas**2,vmada,1,wkr,1)
CC     call prmx('vmada',vmada,nbas,nbas,nbas)
C      call rs(nbas,nbas,wkr,vev,1,vbvec,fv1,fv2,ierr)
CC     call prmx('vev',vev,nbas,nbas,1)
CC     call prmx('vbvec',vbvec,nbas,nbas,nbas)
C      if (ierr /= 0) call rx('scrmom: diagonalization failed')
C      deallocate(fv1,fv2)
C
CC --- Make epsic = inverse eps = 1/(1 - P0 * vev) in coulomb basis (see Remarks) ---
C      P0 = -elind
C      allocate(epsic(nbas))
C      forall (ib = 1:nbas) epsic(ib) = 1 / (1 - P0 * vev(ib))
C      epsic(1) = 1   ! First eval corresponds roughly to uniform charge (?)
CC     call prmx('epsic (coulomb basis)',epsic,nbas,nbas,1) ! write to epsic
C
CC --- Rotate eps to site basis ---
C!      allocate(epsa(nbas,nbas)); call dpzero(epsa,nbas**2)
C      call dpzero(epsa,nbas**2)
C      forall (ib = 1:nbas) epsa(ib,ib) = epsic(ib)
C      call dgemm('N','N',nbas,nbas,nbas,1d0,vbvec,nbas,epsa,nbas,0d0,wkr,nbas)
C      call dgemm('N','T',nbas,nbas,nbas,1d0,wkr,nbas,vbvec,nbas,0d0,epsa,nbas)
CC     call prmx('epsia, site basis',epsa,nbas,nbas,nbas) ! write to epsia
C
CC     Tests:
CC     mc vmada -p -p -evl -tog -evc -tog -v2dia -x -tog -p -evc -x -- -px
CC     mc vmada -p -p -evl -tog -evc  vbvec -- -px
CC     Show z^T vmada z = v
CC     mc vmada -p -evl -a v -evc -a z z -t vmada z -x -x v -v2dia -- -px
CC     show z^-1 = z^T
CC     mc vmada -p -evl -a v -evc -a z  z -i z -t -- -px
CC     ok
CC     mc vmada -a vmada vmada -evl -a v vmada -evc -a z vmada z  z -t dq -x -x -x vmada dq -x --
CC     This one gives dv in rotated basis, in different ways
CC     mc vmada -a vmada vmada -evl -a v vmada -evc -a z z -t vmada z  z -t dq -x -x -x -x z -t vmada dq -x -x -ccat v -v2dia z -t dq -x -x -ccat vbvec -t dq -x vev -xe -ccat
C
CCC --- delta Vscr = dvcoul delta Vext ---
CCC     where dvcoul = P0 vev/(1- P0 vev)
CC      P0 = -elind
CC      allocate(dvcoul(nbas))
CC      forall (ib = 1:nbas) dvcoul(ib) = P0*vev(ib) / (1 - P0 * vev(ib))
C
CC      call prmx('dq by site and l',ql(1,1,1,1,3),nbas,nbas,nsp*nl*3)
C
CC --- dq = qout - qin (reorder by ib) ---
CC      rmsdq(1) = 0
CC      lmrci = 0
CCC     dqa(:,i,j) or dva(:,i,j): i=   0  1   2     3    4
CCC                              j=1  dq qin qout dqscr qscr   in atom basis
CCC                              j=2  dq qin qout dqscr qscr   in coulomb basis
CC      allocate(dq(nbas,nsp,nl,3),dqa(nbas,0:4,2),dva(nbas,0:4,2))
CC      call dpzero(dq,size(dq))
CC      call dpzero(dqa,size(dqa))
CC      call info0(30,1,0,'%13fqin%10fqout%8fdq%11fvin%9fvout%9fdv')
CC      do  ib = 1, nbas
CC        ic = s_ctrl%ipc(ib)
CC        lmri = mxorb*(ib-1)
CC        do  li = 0, nl-1
CC          do  mi = -li, li
CC          lmri = lmri+1
CC          id = iprmb(lmri)
CC          if (id > lhdim .or. mi > -li) cycle
CC          lmrci = lmrci+1
CC          do  isp = 1, nsp
CC            dq(ib,isp,li+1,1:3) = qout(1:3,li+1,isp,ic) - qin(1:3,li+1,isp,ic)
CC            rmsdq(1) = rmsdq(1) + dq(ib,isp,li+1,1)**2
CC            dqa(ib,0,1) = dqa(ib,0,1) + dq(ib,isp,li+1,1)
CC            dqa(ib,1,1) = dqa(ib,1,1) + qin(1,li+1,isp,ic)
CC            dqa(ib,2,1) = dqa(ib,2,1) + qout(1,li+1,isp,ic)
CC          enddo
CC          enddo
CC          dva(ib,0,1) = vout(ic)-vin(ic)
CC          dva(ib,1,1) = vin(ic)
CC          dva(ib,2,1) = vout(ic)
CC        enddo
CC        call info8(10,0,0,' %,4i %;14,6D%;12,6D%;12,6D %;12,6D%;12,6D%;12,6D',
CC     .    ib,dqa(ib,1,1),dqa(ib,2,1),dqa(ib,0,1),dva(ib,1,1),dva(ib,2,1),dva(ib,0,1),8)
CC      enddo
CC      call prmx('dq by site and l',dq,nbas,nbas,nsp*nl*3)
CC      call rxx(lmrci /= nRLc,'pscrm1: index mismatch')
C
CCC     dq in eigenfunction basis of vmada
CC      call dgemm('T','N',nbas,3,nbas,1d0,vbvec,nbas,dqa,nbas,0d0,dqa(1,0,2),nbas)
CC      call dgemm('T','N',nbas,3,nbas,1d0,vbvec,nbas,dva,nbas,0d0,dva(1,0,2),nbas)
CCC      call prmx('dqa',dqa,nbas,nbas,10)   ! save in file dqa
CCC      call prmx('dva',dva,nbas,nbas,10)   ! save in file dva
CCC
CCC     mc vbvec -t dva -coll 1 -x dva -coll 6 --
CCC     mc -f6f12.6 dva -coll 1:3,6:8 dva-sc -coll 1:3,6:8 --
CCC     mc vbvec dqa -coll 6 -x dqa -coll 1 --
CC
CC
CCC     Input, output, screened, sc potentials in ~ basis
CCC     mc dva-sc -coll 7 -a vsc dva -coll 7 -a vin dva -coll 6 -a dv vin dv -+ -a vout vin dv epsic -xe -+ -a vscr vin vout vscr vsc -ccat -ccat -ccat -ccat
CC
CCC     dqa(:,0:4,1) dq, qin, qout, dqscr, qscr in atom basis ... ditto for dva
CCC     dqa(:,0:4,2) dq, qin, qout, dqscr, qscr in coulomb basis ... ditto for dva
CC
CCC     Debugging: make screened potential shift
CCC     screened potential shift in diagonal basis
CC      forall (ib = 1:nbas) dva(ib,3,2) = epsic(ib) * dva(ib,0,2)  ! screening charge
CC      forall (ib = 1:nbas) dva(ib,4,2) = dva(ib,1,2) + dva(ib,3,2)  ! screened charge
CCC     call prmx('dvscr, vscr(e)',dva(1,3,2),nbas,nbas,2)  ! copy to file vscre
CCC     Test: Rotate screened charge in coulomb basis to atom basis
CC      call dgemm('N','N',nbas,2,nbas,1d0,vbvec,nbas,dva(1,3,2),nbas,0d0,dva(1,3,1),nbas)
CC      forall (ib = 1:nbas) dva(ib,4,1) = dva(ib,1,1) + dva(ib,3,1)
CCC     call prmx('dvscr, vscr(a)',dva(1,3,1),nbas,nbas,2)  ! copy to file vscra
CCC     Compute screening potential from eps in atom basis
CC      call dgemm('N','N',nbas,2,nbas,1d0,epsa,nbas,dva(1,0,1),nbas,0d0,dva(1,3,1),nbas)
CCC     call prmx('dvscr, vscr(a)',dva(1,3,1),nbas,nbas,2)  ! copy to file vscra
CC
CCC     Compute screening change from eps in atom basis
CC      call dgemm('N','N',nbas,1,nbas,1d0,epsa,nbas,dqa(1,0,1),nbas,0d0,dqa(1,3,1),nbas)
CCC     call prmx('dqscr(a)',dqa(1,3,1),nbas,nbas,1) ! copy to file dqscra
C
CC     Overwrite ql(:,:,:,1,3) = dqbare with dqscr
C      allocate(dqscr(nbas,nsp,nl))
CC     call prjrsp(1,1,1,nbas,1,epsa) ! Can't do this ... allows no transfer between l or spin
C      call dgemm('N','N',nbas,nsp*nl,nbas,1d0,epsa,nbas,ql(1,1,1,1,3),nbas,0d0,dqscr,nbas)
CC     call prmx('dqscr by site and l',dqscr,nbas,nbas,nsp*nl)
C      call dcopy(nbas*nsp*nl,dqscr,1,ql(1,1,1,1,3),1)
C      deallocate(dqscr)
C
C      end

C      subroutine pscrma(mode,s_ctrl,nbas,nl,nsp,nclass,lhdim,nmom,nRLc,iprmb,qmom,qsite1,qsite2)
CC- Copy classed moments to/from site-based array
CC ----------------------------------------------------------------------
CCi Inputs
CCi   mode  :1s digit (see Remarks)
CCi         :0 copy qmom -> qsite1 or qsite2
CCi         :1 copy qsite1 or qsite2 -> qmom
CCi         :10s digit
CCi         :0 copy to/from qsite1
CCi         :1 copy to/from qsite2
CCi   nbas  :size of basis
CCi   nl    :(global maximum l) + 1
CCi   nsp   :2 for spin-polarized case, otherwise 1
CCi   nclass:number of inequivalent classes
CCi   lhdim :number of lower+intermediate+higher orbitals
CCi   nmom  :number of energy moments to copy
CCi   nRLc  :If nonzero, number of Rl channels in sites 1..nbas
CCi         :nRLc is used only as a sanity check
CCi   iprmb :permutations ordering orbitals in l+i+h blocks (makidx.f)
CCio Inputs/Outputs
CCi   qmom  :ASA multipole moments of on-site densities, by class
CCi   qsite1:ASA multipole moments of on-site densities, by site with (nbas,nsp,l) ordering
CCi   qsite2:ASA multipole moments of on-site densities, by site with (l,nbas,nsp) ordering
CCr Remarks
CCr   If 1s digit mode is 0, qmom is copied to qsite1 or qsite2
CCr   If 1s digit mode is 1, qmom is copied from qsite1 or qsite2
CCr   If 10s digit mode is 0, qmom is copied from/to qsite1
CCr   If 10s digit mode is 1, qmom is copied from/to qsite2
CCu Updates
CCu   21 Nov 17 First created
CC ----------------------------------------------------------------------
C      use structures
C      implicit none
CC ... Passed parameters
C      integer mode,nbas,nl,nsp,nclass,lhdim,nmom,nRLc,iprmb(*)
C      real(8) :: qsite1(nbas,nsp,nl,nmom),qsite2(nl,nbas,nsp,nmom)
C      double precision qmom(3,nl,nsp,nclass)
CC ... For structures
C      type(str_ctrl)::  s_ctrl
CC ... Local parameters
C      integer ib,ic,lmri,lmrci,li,mi,id,mxorb,mod0,mod1,is
C      procedure(integer) :: nglob
C
C      mxorb = nglob('mxorb')
C      mod0 = mod(mode,10)
C      mod1 = mod(mode/10,10)
C
C      if (mod0 > 0) then
C        forall (li=1:nl, is=1:nsp, ic=1:nclass) qmom(1:nmom,li,is,ic) = 0
C      elseif (mod1 == 0) then
C        call dpzero(qsite1,size(qsite1))
C      else
C        call dpzero(qsite2,size(qsite2))
C      endif
C
C      lmrci = 0
C      do  ib = 1, nbas
C        ic = s_ctrl%ipc(ib)
C        lmri = mxorb*(ib-1)
C        do  li = 0, nl-1
C          do  mi = -li, li
C            lmri = lmri+1
C            id = iprmb(lmri)
C            if (id > lhdim .or. mi > -li) cycle
C            lmrci = lmrci+1
C            if (mod1 == 0) then
C              if (mod0 == 0) then
C                forall (is=1:nsp) qsite1(ib,is,li+1,1:nmom) = qmom(1:nmom,li+1,is,ic)
C              else
C                forall (is=1:nsp) qmom(1:nmom,li+1,is,ic) = qmom(1:nmom,li+1,is,ic) +
C     .                            qsite1(ib,is,li+1,1:nmom)/s_ctrl%nrc(ic)
C              endif
C            else
C              if (mod0 == 0) then
C                forall (is=1:nsp) qsite2(li+1,ib,is,1:nmom) = qmom(1:nmom,li+1,is,ic)
C              else
C                forall (is=1:nsp) qmom(1:nmom,li+1,is,ic) = qmom(1:nmom,li+1,is,ic) +
C     .                            qsite2(li+1,ib,is,1:nmom)/s_ctrl%nrc(ic)
C              endif
C            endif
C          enddo
C        enddo
C      enddo
C
C      if (nRLc > 0 .and. lmrci /= nRLc) call rx('pscrma: unexpected number of channels')
C
CC     call prmx('q by site and l',qsite1,nbas,nbas,nsp*nl*3)
C
CC     print *, '1112', sum(qsite1(:,:,:,1)),sum(qmom(1:1,:,:,:))
C
C      end
C
C      subroutine pscrmb(s_ctrl,nbas,nl,nsp,lhdim,iprmb,ql)
CC- Renormalize charge so as to conserve charge neutrality
CC ----------------------------------------------------------------------
CCio Structures
CCio  s_ctrl :struct for program flow parameters; see structures.h
CCi     Elts read:  ipc rmax
CCo     Stored:     *
CCo     Allocated:  *
CCio    Elts passed:*
CCio    Passed to:  *
CCi Inputs
CCi   nbas  :size of basis
CCi   nl    :(global maximum l) + 1
CCi   nsp   :2 for spin-polarized case, otherwise 1
CCi   lhdim :number of lower+intermediate+higher orbitals
CCi   iprmb :permutations ordering orbitals in l+i+h blocks (makidx.f)
CCi   ql    :ql(:,:,:,:,1) = input charge
CCi         :ql(:,:,:,:,2) = bare output charge
CCo Outputs
CCi   ql    :ql(:,:,:,:,3) = screened output charge scaled so as to conserve output charge
CCl Local variables
CCr Remarks
CCu Updates
CCu   21 Nov 17 First created
CC ----------------------------------------------------------------------
C      use structures
C      implicit none
CC ... Passed parameters
C      integer nbas,nl,nsp,lhdim
C      integer iprmb(*)
C      double precision ql(nbas,nsp,nl,3,3)
CC ... For structures
C      type(str_ctrl)::  s_ctrl
CC ... Dynamically allocated local arrays
C      real(8), allocatable :: q(:,:,:)
CC ... Local parameters
C      integer isp,ib,ic,lmri,li,mi,id,mxorb,ipass,lmrci
C      double precision avfracq,fracq,qadd,vsph,vol,dqbare,dqscrn,qnow,qtot,dqtot,qnew,rmsdq(2)
C      procedure(integer) :: nglob,lgunit,iprint
C      procedure(real(8)) :: dsum
C
C      vol = 0; avfracq = 1; qtot = 0; dqbare = 0; dqscrn = 0; qnew = 0
C      allocate(q(nbas,nsp,nl)); call dpzero(q,size(q))
CC     First pass: compute total volume; zero qscr for l>lmxb, make screened d
C      lmrci = 0; mxorb = nglob('mxorb')
C      do  ipass = 1, 2
C      do  ib = 1, nbas
C        ic = s_ctrl%ipc(ib)
C        vsph = 4.1887902d0*s_ctrl%rmax(ic)**3
C        if (ipass == 1) then
C          vol = vol + vsph
C          lmri = mxorb*(ib-1)
C          do  li = 0, nl-1
C          do  mi = -li, li
C            lmri = lmri+1
C            id = iprmb(lmri)
C            if (mi > -li) cycle
C            if (id > lhdim) ql(ib,isp,li+1,1,3) = 0
C            if (id > lhdim .or. mi > -li) cycle
C            lmrci = lmrci+1
C
C            do  isp = 1, nsp
C              qtot   = qtot + ql(ib,isp,li+1,1,1)
C              dqbare = dqbare + ql(ib,isp,li+1,1,2)-ql(ib,isp,li+1,1,1)
C              dqscrn = dqscrn + ql(ib,isp,li+1,1,3)-ql(ib,isp,li+1,1,1)
C              rmsdq(1) = rmsdq(1) + (ql(ib,isp,li+1,1,2)-ql(ib,isp,li+1,1,1))**2
C              rmsdq(2) = rmsdq(2) + (ql(ib,isp,li+1,1,3)-ql(ib,isp,li+1,1,1))**2
C              q(ib,isp,li+1) = ql(ib,isp,li+1,1,3)
C            enddo
C
C          enddo
C          enddo
C        else
C          fracq = vsph/vol
C          qadd = fracq*dqtot
C          qnow = dsum(nl*nsp,q(ib,1,1),nbas)
C          fracq = (qnow+qadd)/qnow
C          avfracq = avfracq * fracq
C          call dscal(nl*nsp,fracq,q(ib,1,1),nbas)
C          qnew = qnew + dsum(nl*nsp,q(ib,1,1),nbas)
C        endif
C      enddo
C      if (ipass == 1) then
C        dqtot = dqbare-dqscrn
C      endif
C      enddo
C      rmsdq(1) = sqrt(rmsdq(1)/lmrci); rmsdq(2) = sqrt(rmsdq(2)/lmrci)
C
C      call info5(10,0,0,' SCRMOM: unscreened dq=%1,3;3e  screened dq=%1,3;3e  qadd=%1,4;4g',rmsdq(1),rmsdq(2),dqtot,4,5)
C
CC      call info5(10,0,0,
CC     .  ' dq, rms dq (bare) : %2:1,6;6d  dq, rms dq (scr) : %2:1,6;6d  qadd = %,6;6d  qscr = %,6;6d',
CC     .  [dqbare,rmsdq(1)],[dqscrn,rmsdq(2)],dqtot,qnew,5)
C      call dcopy(nbas*nsp*nl,q,1,ql(1,1,1,1,3),1)
CC     call prmx('q after screening ...',ql(1,1,1,1,3),nbas,nbas,nsp*nl)
C      deallocate(q)
C
C      end
C
C      subroutine mcomp(n, A, B, ires)
C      integer n,i
C      double precision A(n),B(n),error,etmp,atmp
C      error = 0d0
C      ires = 1
C      do 10, i = 1,n
C         etmp = abs(A(i)-B(i))
C         if (etmp > 1e-4) then
C            print *, etmp, B(i),A(i)
C         end if
C 10   continue
C
CC      if (error > 1e-1) ires = 0
CCc      print * , 'matrix A and B differ, the error = ',error,' A= ',atmp
CC
C      end
C      subroutine diaprint(n,A)
C      integer n, i
C      double precision A(n,n)
C      do, i = 1, n
C         print *, A(i,i)
C      end do
C
C      end
C
