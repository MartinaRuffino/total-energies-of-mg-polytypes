C#define AWRITE
      subroutine gvlist(alat,plat,tau,n1,n2,n3,gmax,job,ngmx,ng,kv,gv,igv,igv2)
C- Create a list of G vectors for a specified uniform mesh and cutoff
C ----------------------------------------------------------------------
Ci Inputs
Ci   alat     Lattice constant
Ci   plat     Real-space primitive lattice vectors
Ci   tau      offset subtracted from gv to measure length
Ci            Used only if 100s digit job is nonzero
Ci            tau is +/- q, depending on 100s digit job.
Ci   n1..n3   no. divisions along the three lattice vectors
Ci   job      1s digit
Ci              0 return ng only
Ci              1 return kv and igv
Ci              2 return kv and igv2
Ci              4 return kv and gv
Ci              8 return kv and gv, and sort list
Ci                any combination of 1,2,4,8 is allowed
Ci            100s digit
Ci              0 specify cutoff as |G|<Gmax
Ci              1 specify cutoff as |G+tau|<Gmax, return G in gv
Ci              2 specify cutoff as |G-tau|<Gmax, return G in gv
Ci              5 same as 1, but return G+tau in gv
Ci              6 same as 2, but return G-tau in gv
Ci            1000s digit
Ci              0 Return gv shortened
Ci              1 Return gv not shortened
Ci              2 Add 2 to suppress checking against gmax
Ci   gmax     Energy cutoff
Ci   ngmx     Leading dimension of gv,kv,igv; must be at least ng
Ci            if any of these are to be generated.
Co Outputs (which quantities are ouptut depends on job)
Co   ng       Number of lattice vectors
Co   gv       list of reciprocal lattice vectors G,
Co            or G +/- tau if 100s digit job >= 5.
Co   kv       indices for gather/scatter operations.
Co            kv(ig,i=1,2,3) for vector ig=1..ng points to which entry
Co            on the mesh (i1,i2,i3) vector ig belongs:
Co              1<=i1<=n1; 1<=i2<=n2;  1<=i3<=n3
Co   igv      list of reciprocal lattice vectors G, represented as
Co            three integers (multiples of qlat).
Co            gv and igv are related by:
Co              gv(1:ng,1:3) = 2*pi/alat * (qlat * igv(1:ng))
Co   igv2     same as igv except first and second columns are permuted
Cr Remarks
Cr   Collects a list of q + reciprocal lattice vectors (G+q) out of
Cr   a uniform 3D mesh lie within a cutoff gmax.  Sorted by length.
Cr   Criterion for cutoff is |(gv-tau)|<gmax
Cr   Use with the following:
Cr     call gvgetf(ng,1,kv,k1,k2,k3,c,c0)
Cr       to collect elements into list c0 from 3D array c
Cr     call gvputf(ng,1,kv,k1,k2,k3,c0,c)
Cr       to poke elements from list c0 into 3D array c
Cr     call gvaddf(ng,kv,k1,k2,k3,c0,c)
Cr       to add elements from list c0 into 3D array c
Cr
Cr   The following routines are designed to work either with a
Cr   specified uniform mesh of G vectors, specified by primitive
Cr   lattice vectors and numbers of divisions n1,n2,n3 (gvcutof,
Cr   gvlist) or without it (gvlst2).
Cr
Cr     gvctof takes as input a uniform mesh of points n1..n3. gvctof
Cr            generates an appropriate energy cutoff gmax, and counts
Cr            the number of G vectors within the cutoff.  The list of
Cr            vectors is generated by looping over all points
Cr            0..n1,0..n2,0..n3, shortens each vector, and retaining
Cr            those for which G<Gmax.  Because only points on the
Cr            specified mesh are considered, there is no guarantee
Cr            that all vectors G<Gmax will be included in the list.
Cr
Cr     gvlist takes as input uniform mesh of G vectors specified by
Cr            n1..n3 and an energy cutoff Gmax, and creates a list of
Cr            G-vectors that lie within Gmax.  gvlist operates in the
Cr            same way as gvctof, and generates the same list of
Cr            vectors.  The list of vectors is sorted by increasing
Cr            length.
Cr
Cr     gvlst2 is designed to work without any constraint that the list
Cr            of vectors map onto a specified mesh n1..n3.  It takes
Cr            as input an energy cutoff Gmax, and returns a list of
Cr            all G vectors whose length G is G<Gmax.  There is no
Cr            shortening of vectors; the number of divisions n1..n3
Cr            needed to encompass all vectors cannot be specified, but
Cr            is output by gvlst2.  Thus, this routine is only
Cr            suitable in cases where there is no need for the vectors
Cr            to map onto a specified mesh.  Offset q in gvlst2
Cr            corresponds to -tau in gvlist.
Cr
Cu Updates
Cu   11 Feb 13 Rearranged to better handle shortening of G vectors
Cu             (modified with sugvec.f, gvlst2.f)
Cu   20 Jul 02 Bug fix for nonzero tau
Cu   31 May 01 gvlist was significantly altered.  See ogvlst for
Cu             original version.
Cu   07 Feb 01 changed gmax tolerance to be consistent with gvlst2
Cu   10 Jun 00 added extra argument to gvgetf and gvputf
Cu    2 Sep 98 Adapted from nfp gvlist.f
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer job,n1,n2,n3,ng,ngmx,kv(ngmx,3),igv(ngmx,3),igv2(3,*)
      double precision alat,gmax,gv(ngmx,3),plat(3,3),tau(3)
C ... Local parameters
      logical ligv,ligv2,lgv,lsort,lgpq,ltmp,noshort,nocheckg
C#ifdefC DEBUG
C      logical lok
C#endif
      integer m,ig,j1,j2,j3,stdo,job0
      double precision qlat(3,3),plat1(3,3),qlat1(3,3),qpg(3),gs(3),pi,
     .  tpiba,tol,gg,vol,gmax2,q(3),qm(3),s1,s2,s3
      character*256 outs
      integer, parameter :: PRTG=30, PRTG2=70
      procedure(logical) :: isanrg
      procedure(real(8)) :: ddot
      procedure(integer) :: nglob,isw,iprint
C ... External calls
      external awrit0,awrit4,awrit6,dinv33,dpcopy,dpzero,gvlstp,gvlsts,
     .         rx,shorbz

C ... Setup
      stdo = nglob('stdo')
      job0  = mod(job,100)
      ligv  = mod(job0,2) /= 0
      ligv2 = mod(job0/2,2) /= 0
      lgv   = mod(job0/4,4) /= 0
      lsort = mod(job0/8,2) /= 0
      pi = 4d0*datan(1d0)
      call dinv33(plat,1,qlat,vol)
      tpiba = 2*pi/alat
      tol = 1d-8
      m = mod(mod(job/100,10),4)
      lgpq = mod(job/100,10) > 4
      noshort = mod(job/1000,2) /= 0
      nocheckg = mod(job/1000,10) >= 2
      ltmp = isanrg(job0,0,11,'gvlist','1+10s digit job',.true.)
      ltmp = isanrg(m,0,2,'gvlist','100s digit job',.true.)
      call dpzero(q,3); call dpzero(qm,3)
      if (m == 1) then
        call dpcopy(tau,q,1,3,1d0)
      elseif (m == 2) then
        call dpcopy(tau,q,1,3,-1d0)
      endif
      if (.not. lgpq) qm = q

C ... Basis vectors for real-space mesh and recip-space supercell
      do  m = 1, 3
        plat1(m,1) = plat(m,1)/n1
        plat1(m,2) = plat(m,2)/n2
        plat1(m,3) = plat(m,3)/n3
        qlat1(m,1) = qlat(m,1)*n1
        qlat1(m,2) = qlat(m,2)*n2
        qlat1(m,3) = qlat(m,3)*n3
      enddo

C --- Loop through g vectors, shorten, count and keep if within gmax ---
      ig = 0
      gmax2 = (gmax-tol)**2/tpiba**2
      do  j1 = 0, n1-1
      do  j2 = 0, n2-1
      do  j3 = 0, n3-1
        qpg(1) = j1*qlat(1,1) + j2*qlat(1,2) + j3*qlat(1,3) + q(1)
        qpg(2) = j1*qlat(2,1) + j2*qlat(2,2) + j3*qlat(2,3) + q(2)
        qpg(3) = j1*qlat(3,1) + j2*qlat(3,2) + j3*qlat(3,3) + q(3)
        call shorbz(qpg,gs,qlat1,plat1)  ! gs = shortened q+g
        gg = (gs(1)**2+gs(2)**2+gs(3)**2)
        if (gg <= gmax2 .or. nocheckg) then
          ig = ig+1

          if (noshort) gs = qpg
C         print 333, gs(1)+tau(1),gs(2)+tau(2),gs(3)+tau(3),j1,j2,j3
C          print 333, ig,gs(1),gs(2),gs(3),j1+1,j2+1,j3+1
C  333     format(i4,3f12.6,3i4)

          if (job0 /= 0) then

          if (ig > ngmx) call rx('gvlist: ng exceeds ngmx')

          kv(ig,1) = j1+1
          kv(ig,2) = j2+1
          kv(ig,3) = j3+1

C     ... Copy lattice vectors to gv,igv,igv2, depending on job
          s1 = (gs(1)-q(1))*plat(1,1)
     .       + (gs(2)-q(2))*plat(2,1)
     .       + (gs(3)-q(3))*plat(3,1)
          s2 = (gs(1)-q(1))*plat(1,2)
     .       + (gs(2)-q(2))*plat(2,2)
     .       + (gs(3)-q(3))*plat(3,2)
          s3 = (gs(1)-q(1))*plat(1,3)
     .       + (gs(2)-q(2))*plat(2,3)
     .       + (gs(3)-q(3))*plat(3,3)


          if ((nint(s1)-s1)**2+(nint(s2)-s2)**2+(nint(s3)-s3)**2
     . > 1d-12) call rx('bug in gvlist')

          if (ligv) then
            igv(ig,1) = nint(s1)
            igv(ig,2) = nint(s2)
            igv(ig,3) = nint(s3)
          endif
          if (ligv2) then
            igv2(1,ig) = nint(s1)
            igv2(2,ig) = nint(s2)
            igv2(3,ig) = nint(s3)
          endif

          if (lgv) then
C            if (lgpq) then
C              gv(ig,1) = gs(1)
C              gv(ig,2) = gs(2)
C              gv(ig,3) = gs(3)
C            else
              gv(ig,1) = gs(1) - qm(1)
              gv(ig,2) = gs(2) - qm(2)
              gv(ig,3) = gs(3) - qm(3)
C            endif
          endif

        endif
      endif
      enddo
      enddo
      enddo
      ng = ig

C ... Printout
      if (iprint() >= PRTG) then
C#ifdef AWRITE
        s1 = alat*sqrt(ddot(3,plat(1,1),1,plat(1,1),1))/n1
        s2 = alat*sqrt(ddot(3,plat(1,2),1,plat(1,2),1))/n2
        s3 = alat*sqrt(ddot(3,plat(1,3),1,plat(1,3),1))/n3
        call awrit4('%x%N GVLIST: gmax = %,1;4g'//
     .    ' a.u. created %i vectors of %i (%i%%)',
     .    outs,len(outs),0,gmax,ng,n1*n2*n3,(ng*100)/(n1*n2*n3))
        call awrit6('%a%N%9fmesh has %i x %i x %i'//
     .    ' divisions; length %,3;3d, %,3;3d, %,3;3d',outs,
     .    len(outs),0,n1,n2,n3,s1,s2,s3)
        call awrit0('%a',outs,len(outs),-stdo)
C#elseC
C      if (iprint() >= PRTG) print 861, gmax,ng,n1*n2*n3
C  861 format(/' gvlist: cutoff radius ',f7.3,' gives',i7,
C     .  '   recips of max',i7)
C#endif
      endif

C ... Sort the list of vectors
!      qpg = q                   ! Used as work array here
!      if (lgpq) call dpzero(qpg,3)
      if (lsort) then
C       call prmx('glist',gv,ngmx,ng,3)
        call gvlsts(isw(ligv),isw(ligv2),ngmx,ng,qm,gv,kv,igv,igv2)
      endif
      if (job0 /= 0 .and. iprint() >= PRTG2) then
        call gvlstp(isw(ligv),isw(ligv2),alat,qlat,ngmx,ng,q,qm,gv,kv,igv,igv2)
      endif

C#ifdefC DEBUG
C      if (ligv) then
C        do  ig = 1, ng
C          lok = .true.
C          lok = lok .and. mod(igv(ig,1)+n1,n1)+1 == kv(ig,1)
C          lok = lok .and. mod(igv(ig,2)+n2,n2)+1 == kv(ig,2)
C          lok = lok .and. mod(igv(ig,3)+n3,n3)+1 == kv(ig,3)
C          if (.not. lok) then
C            call rx('bug in gvlist')
C          endif
C        enddo
C      endif
C#endif

      end
C      subroutine pvglst(gg,kk,iwk,p,ngmx,ng,ligv,ligv2,gv,kv,igv,igv2)
CC- Kernel called by gvlist to sort gv and kv
CC ----------------------------------------------------------------------
CCi Inputs
CCi   gg    :double precision work array of length ng
CCi   kk    :integer work array of length ng
CCi   iwk   :integer work array of length ng : returns permutation of gg
CCi   p     :offset subtracted from g to measure length
CCi   ngmx  :dimensions gv,kv,igv
CCi   ng    :number of G-vectors
CCi   ng    :number of group operations
CCi   ligv  :sort igv also
CCi   ligv2 :sort igv2 also
CCio Inputs/Outputs
CCi         :the following arrays are sorted:
CCi   gv    :list of reciprocal lattice vectors G (gvlist.f)
CCi   kv    :indices for gather/scatter operations (gvlist.f)
CCi   igv   :G vectors in integer format
CCi   igv2  :like igv, but array dimensions inverted
CCr Remarks
CCr
CCu Updates
CCu   20 Jul 02 Bug fix for nonzero tau
CCu   01 Jun 01  Added igv,igv2
CC ----------------------------------------------------------------------
C      implicit none
C      logical ligv,ligv2
C      integer ngmx,ng,kk(ng),iwk(ng),kv(ngmx,3),igv(ngmx,3),igv2(3,*)
C      double precision gv(ngmx,3),gg(ng),p(3)
CC Local variables
C      integer ig,m,jg,PRTG,iprint
C      parameter (PRTG=10)
CC ... External calls
C      external dvshel
C
C      do  ig = 1, ng
C        gg(ig) =(gv(ig,1)+p(1))**2+(gv(ig,2)+p(2))**2+(gv(ig,3)+p(3))**2
C      enddo
C
CC     dvshel seems to work a little faster for vectors this size
C      call dvshel(1,ng,gg,iwk,1)
CC     call dvheap(1,ng,gg,iwk,0d0,11)
C
CC ... Rearrange gv,kv,igv,igv2
C      do  m = 1, 3
C        do  ig = 1, ng
C          jg = iwk(ig)+1
C          gg(ig) = gv(jg,m)
C          kk(ig) = kv(jg,m)
C        enddo
C        do  ig = 1, ng
C          gv(ig,m) = gg(ig)
C          kv(ig,m) = kk(ig)
C        enddo
C        if (ligv) then
C          do  ig = 1, ng
C            jg = iwk(ig)+1
C            kk(ig) = igv(jg,m)
C          enddo
C          do  ig = 1, ng
C            gv(ig,m) = gg(ig)
C            igv(ig,m) = kk(ig)
C          enddo
C        endif
C        if (ligv2) then
C          do  ig = 1, ng
C            jg = iwk(ig)+1
C            kk(ig) = igv2(m,jg)
C          enddo
C          do  ig = 1, ng
C            gv(ig,m) = gg(ig)
C            igv2(m,ig) = kk(ig)
C          enddo
C        endif
C      enddo
C
C      if (iprint() >= PRTG) then
C        print 1,p
C    1   format(' gvlist: G vectors after sorting: q=',3F12.6/
C     .    '   ig',17x,'G',25x,'kv',12x,'|G|',12x,'ig')
C        do  ig = 1, min(ng,50)
C         gg(ig)=(gv(ig,1)+p(1))**2+(gv(ig,2)+p(2))**2+(gv(ig,3)+p(3))**2
CC        print 550, ig,gv(ig,1)+p(1),gv(ig,2)+p(2),gv(ig,3)+p(3),
C         if (ligv) then
C           print 2, ig,gv(ig,1),gv(ig,2),gv(ig,3),
C     .       kv(ig,1),kv(ig,2),kv(ig,3),sqrt(gg(ig)),
C     .       igv(ig,1),igv(ig,2),igv(ig,3)
C         else
C           print 2, ig,gv(ig,1),gv(ig,2),gv(ig,3),
C     .       kv(ig,1),kv(ig,2),kv(ig,3),sqrt(gg(ig))
C         endif
C    2    format(i5,3f11.5,3i6,f11.5:3i6)
C       enddo
C      endif
C
C      end

      subroutine gvgetf(ng,n,kv,k1,k2,k3,c,c0)
C- Gathers Fourier coefficients from 3D array c into list c0.
      implicit none
      integer ng,n,k1,k2,k3,kv(ng,3)
      double complex c0(ng,n),c(k1,k2,k3,n)
      integer ig,i,j1,j2,j3

      do  i = 1, n
        do  ig = 1, ng
        j1 = kv(ig,1)
        j2 = kv(ig,2)
        j3 = kv(ig,3)
        c0(ig,i) = c(j1,j2,j3,i)
        enddo
      enddo
      end
      subroutine gvputf(ng,n,kv,k1,k2,k3,c0,c)
C- Pokes Fourier coefficients from gathered list c0 into 3D array c.
      implicit none
      integer ng,n,k1,k2,k3,kv(ng,3)
      double complex c0(ng,n),c(k1,k2,k3,n)
      integer ig,i,j1,j2,j3

      call dpzero(c,2*k1*k2*k3*n)
      do  i = 1, n
        do  ig = 1, ng
        j1 = kv(ig,1)
        j2 = kv(ig,2)
        j3 = kv(ig,3)
        c(j1,j2,j3,i) = c0(ig,i)
        enddo
      enddo
      end
      subroutine gvaddf(ng,kv,k1,k2,k3,c0,c)
c  Adds Fourier coefficients from gathered list c0 into 3D array c.
      implicit none
      integer ng,k1,k2,k3,kv(ng,3)
      double complex c0(ng),c(k1,k2,k3)
      integer ig,j1,j2,j3
      do  ig = 1, ng
        j1 = kv(ig,1)
        j2 = kv(ig,2)
        j3 = kv(ig,3)
        c(j1,j2,j3) = c(j1,j2,j3) + c0(ig)
      enddo
      end

C      subroutine gvlstp(p,ng,gv,sgv)
CC- Adds offset to lattice vectors, and resorts by increasing length
CC ---------------------------------------------------------------
CCi Inputs:
CCi  gv,ng:  lattice vectors, and number
CCi  p:      vector to subtract from gv
CCo  sgv:    lattice vectors, sorted by increasing (p-gv)**2
CCr Remarks
CCr  Shell sorting is apparently faster than heap sorting,
CCr  because the starting vectors are approximately sorted already.
CC ---------------------------------------------------------------
C      implicit none
C      integer ng
C      double precision p(3),gv(3,ng),sgv(3,ng)
C      integer ir,oiwk
C
C      do  10  ir = 1, ng
C   10 sgv(ir,1) =
C     .  (p(1)-gv(1,ir))**2 + (p(2)-gv(2,ir))**2 + (p(3)-gv(3,ir))**2
C      call defi(oiwk, ng*3)
C      call dvshel(1,ng,sgv,w(oiwk),1)
C      call dvperm(3,ng,gv,sgv,w(oiwk),.false.)
C      call rlse(oiwk)
C
C      end
C      subroutine rx(string)
C      character *(*) string
C      print *, string
C      stop
C      end
