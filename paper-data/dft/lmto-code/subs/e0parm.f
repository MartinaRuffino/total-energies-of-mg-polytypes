      subroutine e0parm(s_spec,mode,nl,ekap,tolke,rsmh,c01)
C- Parameters fixing potential-independent shape of envelope fns
C ----------------------------------------------------------------------
Cio Structures
Cio  s_spec :struct for species-specific data; see structures.h
Ci     Elts read:  lmxb hcr rmt hsfitp
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:*
Cio    Passed to:  *
Ci Inputs
Ci   mode  :governs how c01 making up envelope function e0 are generated.
Ci         :c01 is generated by minimizing objective function
Ci         :f = int_rmin^infty dr [ (D(h(r)+c0*g0(r)+c1*g1(r)) - Dh0(r))^2 * wt(r) ]
Ci         :subject to possible constraints.  See Remarks for details.
Ci         :1s digit determines what function and what constraints are to be used.
Ci         :0  e0(rsm,eh;r) = hsm(rsm,eh;r).  There is one e0 for each l.
Ci             No fitting is done; c01 is assigned to 0 and routine exits.
Ci         :1  e0(rsm,eh;r) = hsm(r) + c01(0,l)*g0l(r)
Ci             c01 is determined by minimizing an integral f; see cgmin below
Ci         :2  e0(rsm,eh;r) = hsm(r) + c01(0,l)*g0l(r) + c01(1,l)*g1l(r)
Ci             f is minimized as in (1), while constrained to match etarg at rmtl
Ci         :3  e0(rsm,eh;r) = hsm(r) + c01(0,l)*g0l(r) + c01(1,l)*g1l(r)
Ci             f is minimized as in (1), while constrained to match ttarg at rmtl
Ci         :4  Same as mode2, except f includes a term related to K.E. at rMT.
Ci             Modes 2 and 5 are limiting cases of mode 4. See Remarks in cgmin.
Ci         :5  e0(rsm,eh;r) = hsm + c01(0)*g0l + c01(1)*g1l
Ci             Satisfies both constraints e0=etarg and nabla e0 = ttarg * e0
Ci             Constraints completely determine c01.  Still rsm can be modified.
Ci        :10s digit governs what is varied in the fitting procedure
Ci             0 => printout fitting conditions
Ci             1 => printout only; c01 not altered
Ci             2 => alter c01 only; rsml is not modified from input
Ci             3 => additionally adjust rsml so K.E. deviation matches tolke
Ci        :100s digit governs wt(r) defining function f
Ci             0 => wt(r) = 1/hunsm^2(r)
Ci             1 => wt(r) = 1/hunsm^2(rmtl)  (recommended)
Ci             2 => wt(r) = 1
Ci        :1000s digit governs what radius rmtl is used for ...
Ci             0 rmtl = hcrl
Ci             1 rmtl = rmt
Ci   nl    :dimensions rsmh,c01
Ci   ekap  :energy of smoothed Hankel defining envelope
Ci   tolke :RMS error in K.E. deviation from asymptote at large-r; see e0prms
Co Outputs
Co   rsmh  :smoothing radii for envelopes
Co   c01   :Gaussian coefficients for generalized envelope functions
Cl Local variables
Cl   rmtl  :vector of l-dependent radii that match ...
Cl   etarg :(mode=2,3) function e0 constrained so that e0(rmtl)=etarg
Cl   fitp  :fitp(1) = rmin = K.E.lower bound of integral to minimize difference
Cl         :between actual and asymptotic kinetic energy; see e0prms
Cr Remarks
Cr   Coefficients are made for each species
Cu Updates
Cu   10 Apr 15 New mode=3
Cu   20 Sep 11 First created
C ----------------------------------------------------------------------
      use structures
      implicit none
C ... Passed parameters
      integer mode,nl
      double precision ekap,tolke
      double precision rsmh(0:nl-1,*),c01(0:1,0:nl-1,*)
C ... For structures
!      include 'structures.h'
      type(str_spec)::  s_spec(*)
C ... Local parameters
      integer is,nspec,lmxh,l,n0,iprint,stdo,mode2,mode3
      parameter (n0=10)
      double precision fitp(2),hcrl(0:n0),rmtl(0:n0),ttarg(0:n0),xx
      double precision xi(0:n0),cl(0:n0),etarg(0:n0),aj(0:n0),ak(0:n0)
      double precision gkl(0:2,0:n0)
      procedure(integer) :: nglob

      stdo = nglob('stdo')
      mode2 = mod(mode/100,10)
      mode3 = mod(mode/1000,10)

      call info2(30,1,0,' Envelopes for sm Hankels ... generating parameters'//
     .  '%?#(n<50)#%N  spec l   hcrl    rmtl    rsml     c0      c1##',iprint(),0)

      nspec = nglob('nspec')
      do  is = 1, nspec
        lmxh = s_spec(is)%lmxb
        hcrl(0:lmxh) = s_spec(is)%hcr(1:1+lmxh)
        if (mode3 == 0) then
          rmtl(0:lmxh)  = hcrl(0:lmxh)
        else
          rmtl(0:lmxh)  = s_spec(is)%rmt
        endif
        fitp(1) = s_spec(is)%hsfitp(1)*rmtl(0)
        fitp(2) = s_spec(is)%hsfitp(2)
        do  l = lmxh, 0, -1
          call radkj(ekap,hcrl(l),l,ak,aj,xi,xi,0)
          cl(l) = ak(l)/aj(l)    ! Ratio of Hankel to Bessel at HCR
          call radkj(ekap,rmtl(l),l,ak,aj,xi,xi,0)
          etarg(l) = cl(l)*aj(l) ! h(HCR)/j(HCR)*j(rmt) ? why not ust h(HCR) ?
          ttarg(l) = ekap
        enddo
        xx = 0
        call e0prms(mode,lmxh,ekap,tolke,[xx],fitp,rmtl,etarg,ttarg,rsmh(0,is),c01(0,0,is))

C       Debugging
        if (iprint() >= 60) then
          call info0(0,0,0,' verify E0 - cl*J vanishes at rmtl')
          do  l = lmxh, 0, -1
            call hanszd(0,rmtl(l),ekap,rsmh(0,is),l,xi,xx,xx,xx,xx,xx)
            call radgkg(0,rmtl(l),rsmh(0,is),1,l,2,gkl,0d0,0d0)
          enddo
          write(stdo,"(10f16.10)")
     .      xi(0:lmxh) + c01(0,0:lmxh,is)*gkl(0,0:lmxh)
     .                 + c01(1,0:lmxh,is)*gkl(1,0:lmxh)
     .                 - cl(0:lmxh)*aj(0:lmxh)
        endif

        if (iprint() < 50) then
          do  l = 0, lmxh
            call info8(30,0,0,'%j%?#(n==0)#%-2j%,4i#%-1j%4f#'//
     .        ' %,3i%;8,4D%;8,4D%;8,4D%;8,4D%;8,4D',is,l,
     .        hcrl(l),rmtl(l),rsmh(l,is),c01(0,l,is),c01(1,l,is),0)
          enddo
        endif
      enddo

      end

      subroutine e0prms(mode,lmxh,eh,tolke,rsminl,fitp,rmtl,etarg,ttarg,rsml,c01)
C- Parameters fixing shape of envelope e0(rsm,eh;r,c01) for one sphere
C ----------------------------------------------------------------------
Ci Inputs
Ci   mode  :governs how c01 making up envelope function e0 are generated.
Ci         :c01 is generated by minimizing objective function
Ci         :f = int_rmin^infty dr [ (D(h(r)+c0*g0(r)+c1*g1(r)) - Dh0(r))^2 * wt(r) ]
Ci         :subject to possible constraints.  See Remarks for details.
Ci         :1s digit determines what function and what constraints are to be used.
Ci         :0  e0(rsm,eh;r) = hsm(rsm,eh;r).  There is one e0 for each l.
Ci             No fitting is done; c01 is assigned to 0 and routine exits.
Ci         :1  e0(rsm,eh;r) = hsm(r) + c01(0,l)*g0l(r)
Ci             c01 is determined by minimizing an integral f; see cgmin below
Ci         :2  e0(rsm,eh;r) = hsm(r) + c01(0,l)*g0l(r) + c01(1,l)*g1l(r)
Ci             f is minimized as in (1), while constrained to match etarg at rmtl
Ci         :3  e0(rsm,eh;r) = hsm(r) + c01(0,l)*g0l(r) + c01(1,l)*g1l(r)
Ci             f is minimized as in (1), while constrained to match ttarg at rmtl
Ci         :4  Same as mode2, except f includes a term related to K.E. at rMT.
Ci             Modes 2 and 5 are limiting cases of mode 4. See Remarks in cgmin.
Ci         :5  e0(rsm,eh;r) = hsm + c01(0)*g0l + c01(1)*g1l
Ci             Satisfies both constraints e0=etarg and nabla e0 = ttarg * e0
Ci             Constraints completely determine c01.  Still rsm can be modified.
Ci        :10s digit governs what is varied in the fitting procedure
Ci             0 => printout fitting conditions
Ci             1 => printout only; c01 not altered
Ci             2 => alter c01 only; rsml is not modified from input
Ci             3 => additionally adjust rsml so K.E. deviation matches tolke
Ci        :100s digit governs wt(r) defining function f
Ci             0 => wt(r) = 1/hunsm^2(r)
Ci             1 => wt(r) = 1/hunsm^2(rmtl)  (recommended)
Ci             2 => wt(r) = 1
Ci   lmxh  :c01 fit for l=0..lmxh
Ci   eh    :energy of smoothed Hankel defining envelope
Ci   tolke :(used if 10s digit mode >= 2)
Ci         :desired error in the kinetic energy.
Ci   fitp  :Parameters to function to be minimized; see Remarks in cgmin.
Ci         :fitp(1) lower bound of integral f that is minimized subject to constraints.
Ci         :fitp(2) (1s digit mode=4 only) is relative weighting in min (f + fitp(2)*t)
Ci         :Function to be minimized is where f + fitp(2)*t = f - lambda2*t
Ci         :See Remarks.  Note fitp(2) = -lambda2
Ci   rmtl  :(used if 10s digit mode >= 2)
Ci         :vector of l-dependent matching radii where sm function is fit to etarg.
Ci         :  EITHER must be specified for 0..lmxh
Ci         :  OR     rmtl(0) < 0. Implies rmtl(l) = -rmtl(0) for all l
Ci   etarg :(mode=2,3) function e0 constrained so that e0(rmtl)=etarg
Ci   ttarg :(mode=3,4) function e0 constrained so that lap e0(rmtl)=ttarg
Cio Inputs/Outputs
Cio  rsml  :vector of l-dependent smoothing radii for e0
Cio        :input  if 10s's digit mode is <= 1
Cio        :optimized if 10s's digit mode is > 1
Co Outputs
Co   c01   :(1s digit mode=1 or 2) vector of coefficients defining envelope e0
Co         :see Remarks
Cl Local variables
Cl  irl(l) :l-dependent iteration parameter for rfalsi
Cr Remarks
Cr   This routine determines parameters for envelope functions e0(l)
Cr   that best satisfy one or more of these desirable properties:
Cr     1. rapid transition to nabla^a e0 -> -eh e0 as r increases
Cr     2. e0(rmtl) = specified value.
Cr     3. Maximum smoothness
Cr   Envelope function is defined for a particular l as
Cr     e0(c01,rsm,eh;r) = hsm + c01(0)*g0l + c01(1)*g1l
Cr
Cr   Routine proceeds in two steps:
Cr
Cr   Step 1 -- Determine c01 according to 1s digit mode
Cr   1s digit mode 1: c01(1)=0.  Finds c01(0) that minimizes
Cr                    f(c01) = int_rmin^infty (nabla^2 e0(r)/h(rsm=0,r)-eh)^2
Cr            mode 2: finds c01(0:1) that minimizes f defined in mode 1
Cr                    while satisfying constraint e0(rsm,eh;hcr) = etarg
Cr            mode 3: finds c01(0:1) that minimizes f defined in mode 1
Cr                    while satisfying constraint nabla e0(rsm,eh;hcr) = ttarg
Cr            mode 4: Similar to mode 3, but ttarg is included in the objective function
Cr                    Modes 2 and 5 are limiting cases of mode 4. See Remarks in cgmin.
Cr            mode 5: finds c01(0:1) that minimizes f defined in mode 1
Cr                    while satisfying both constraints of mode2 and mode3.
Cr                    Note two constraints determine two parameters c01.
Cr
Cr   Step 2 -- Determine rsm according to 10s digit mode
Cr   10s digit mode 1 : no second step; rsm is fixed.
Cr                  2 : rsm is iterated by a root-finding search to make f = tolke
Cu Updates
Cu   10 Apr 15 New mode=3,4.  mode 5 not working yet
Cu   17 Sep 11 Redesigned from rsfit
Cu   11 Aug 11 First created
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer mode,lmxh
      double precision fitp(2),eh,tolke
      double precision rmtl(0:lmxh),rsml(0:lmxh),etarg(0:lmxh),ttarg(0:lmxh),rsminl(0:lmxh),c01(0:1,0:lmxh)
C ... Local parameters
      logical lcontl(0:lmxh),lcont
      integer l,iter,mode0,mode1,mode3,maxit,irl(0:lmxh),iprint
      double precision rsm0,resi,tol,reske(0:lmxh),ttargl(0:lmxh),wk(12,0:lmxh)
      parameter (tol=1d-12)

C ... Nothing to fit; just print out
      if (mod(mode,10) == 0) then
        call cgmin(mode,lmxh,rsml,eh,fitp,rmtl,etarg,ttarg,c01,reske)
        return
      endif
      mode0 = mod(mode,10)
      mode1 = mod(mode/10,10)
      mode3 = mod(mode/1000,10)

C ... Initial guess for rsm is HCR/2
      if (mode1 > 2) then
        if (rmtl(0) < 0) then
          call dvset(rsml,1,1+lmxh,-rmtl(0)/2)
        else
          call dpcopy(rmtl,rsml,1,1+lmxh,.5d0)
        endif
      endif

C ... Iterate to find rsml
      maxit = 0
      if (mode1 > 2) maxit = 30
      call ivset(irl,1,1+lmxh,0)
      lcontl = .true.   ! lcontl(l) = .false. when l converges
      lcont = .false.   ! should be .false. if maxit is zero
      ttargl = ttarg
      call pshpr(iprint()-30)
      do  iter = 1, maxit
        lcont = .false. ! remains .false. when all l are converged
        call cgmin(mode,lmxh,rsml,eh,fitp,rmtl,etarg,ttargl,c01,reske)
        do  l = 0, lmxh
          resi = reske(l)-tolke
          if (lcontl(l)) then
            rsm0 = rsml(l)
            call rfalsi(rsml(l),resi,1d-10,0d0,1d-10,.3d0,10,wk(1,l),irl(l))
C           Decrement rsml first iteration, when resi>0
            if (irl(l) == -1 .and. resi > 0) rsml(l) = 2*rsm0-rsml(l)
C           Case this l is converged: no need to continue it
            if (irl(l) == 0 .or. irl(l) == 1 .or. irl(l) == 3) lcontl(l) = .false.
          endif
          lcont = lcont .or. lcontl(l)
        enddo
        call info5(110,0,0,' e0prms iter %,3i lcont %l  %n:1,3i',iter,lcont,1+lmxh,irl,0)
        if (.not. lcont) exit
      enddo
      if (mode3 /= 0) then
        do  l = 0, lmxh
          rsml(l) = max(rsml(l),rsminl(l))
        enddo
      endif

      call poppr

C ... Printout
C     call pshpr(iprint())
      call cgmin(mode,lmxh,rsml,eh,fitp,rmtl,etarg,ttarg,c01,reske)
C     call poppr

      if (lcont) call rx2('e0prms failed to locate all roots, ir=%n:1i',1+lmxh,irl)

      end

      subroutine cgmin(mode,lmxh,rsml,eh,fitp,rmtl,etarg,ttarg,c01,reske)
C- Find c01 that minimizes an objective function
C ----------------------------------------------------------------------
Ci Inputs
Ci   mode  :governs how c01 making up envelope function e0 are generated.
Ci         :c01 is generated by minimizing objective function
Ci         :f = int_rmin^infty dr [ (D(h(r)+c0*g0(r)+c1*g1(r)) - Dh0(r))^2 * wt(r) ]
Ci         :subject to possible constraints.  See Remarks for details.
Ci         :1s digit determines what function and what constraints are to be used.
Ci         :0  e0(rsm,eh;r) = hsm(rsm,eh;r)
Ci             c01 is 0
Ci         :1  e0(rsm,eh;r) = hsm(rsm,eh;r) + c01(0)*g0l(rsm;r)
Ci             c01 is determined by minimization; see Remarks
Ci         :2  e0(rsm,eh;r) = hsm + c01(0)*g0l + c01(1)*g1l
Ci             c01(0:2) chosen to minimize deviation in KE and
Ci             simultaneously satisfy constraint e0(rmtl)=etarg
Ci         :3  e0(rsm,eh;r) = hsm + c01(0)*g0l + c01(1)*g1l
Ci             c01(0:2) chosen to minimize deviation in KE and
Ci             simultaneously satisfy constraint nabla e0(rmtl)=ttarg
Ci         :4  e0(rsm,eh;r) = hsm + c01(0)*g0l + c01(1)*g1l
Ci             -nabla e0(rmtl)+ttarg*e0(rmtl) is not a constraint, but added to min.
Ci             This mode encompasses modes 2 and 5 as limiting cases. See Remarks.
Ci         :5  e0(rsm,eh;r) = hsm + c01(0)*g0l + c01(1)*g1l
Ci             Satisfies two constraints e0(rmtl)=etarg and -nabla e0(rmtl)=ttarg*e0(rmtl)
Ci             Constraints completely determine c01.
Ci             Procedure still performed as a minimization to keep code uniform.
Ci        :10s digit governs what is varied in the fitting procedure
Ci             0 => printout fitting conditions
Ci             1 => printout only; c01 not altered
Ci             2 => alter c01 only; rsml is not modified from input
Ci             3 => additionally adjust rsml so K.E. deviation matches tolke
Ci        :100s digit governs wt(r) defining function f
Ci             0 => wt(r) = 1/hunsm^2(r)
Ci             1 => wt(r) = 1/hunsm^2(rmtl)  (recommended)
Ci             2 => wt(r) = 1
Ci   lmxh  :c01 fit for l=0..lmxh
Ci   rsml  :vector of l-dependent smoothing radii for envelope function
Ci   eh    :energy of smoothed Hankel
Ci   fitp  :Parameters to function to be minimized; see Remarks
Ci         :fitp(1) lower bound of integral f that is minimized subject to constraints.
Ci         :fitp(2) (1s digit mode=4 only) is relative weighting in min (f + fitp(2)*t)
Ci         :Function to be minimized is where f + fitp(2)*t = f - lambda2*t
Ci         :See Remarks.  Note fitp(2) = -lambda2
Ci   rmtl  :(used if 10s digit mode >= 2)
Ci         :vector of l-dependent matching radii where sm function is fit to etarg.
Ci         :  EITHER must be specified for 0..lmxh
Ci         :  OR     rmtl(0) < 0. Implies rmtl(l) = -rmtl(0) for all l
Ci   etarg :(mode=2,4,5) function e0 constrained so that e0(rmtl) = etarg
Ci   ttarg :(mode=3,5) function e0 constrained so that -nabla e0(rmtl) = ttarg*e0(rmtl)
Ci         :(mode=4) (nabla e0(rmtl) + ttarg*e0(rmtl))^2 fitp(2) is added to objective
Co Outputs
Co   c01   :l-dep vector of coefficients defining envelope e0
Co         :NB: 10s digit 0 or 1 => c01 is not altered
Co   reske :RMS deviation of function that is minimized.
Cr Remarks
Cr   Note that there is a separate e0 for each l.
Cr   Modes 1: envelope function is defined:
Cr     e0(rsm,eh;r) = hsm(rsm,eh;r) + c01(0)*g0(rsm;r)
Cr   Modes 2 through 5: envelope function is defined for a particular l
Cr     e0(rsm,eh;r) = hsm(rsm,eh;r) + c01(0)*g0(rsm;r) + c01(1)*g1(rsm;r)
Cr   with possible constraints:
Cr     g = (h+c0*g0+c1*g1) - etarg)|r=rMT  Used in mode 2,5
Cr     t = (nabla (h+c0*g0+c1*g1) + ttarg*(h+c0*g0+c1*g1))|r=rMT  Used in mode 3,4,5
Cr   mode 1:  finds c01(0) that minimizes :
Cr       f(c0,c1) = int_rmin^infty wt(r) * [nabla (e0(r) - h(rsm=0,r))^2]
Cr       wt(r) = 1/h(rsm=0,r))^2   if 100s digit mode is 0
Cr             = 1/h(rsm=0,rmt))^2 if 100s digit mode is 1 (recommended)
Cr             = 1                 if 100s digit mode is 2
Cr   mode 2:  finds c01(0:2) that minimizes f as in mode 1 but matches e0 to target at rMT:
Cr            it satisfies constraint g=0
Cr   mode 3:  finds c01(0:2) that minimizes f as in mode 1 but also nabla e0 to target at rMT:
Cr            it satisfies constraint t=0
Cr   mode 4:  Similar mode 2, but the function minimized is  f + fitp(2)*t^2
Cr            It should be apparent that mode4 encompasses both modes 2 and 5
Cr            If fitp(2) = 0, mode 4 reduces to mode 2
Cr            If fitp(2) -> infinity, mode 4 reduces to mode 5
Cr   mode 5:  Constraints of both mode2 and mode3 are imposed.
Cr
Cr   To evaluate functions:
Cr   hsm(rsm,eh,r) = smooth Hankel; see hanszd
Cr   g0(rsm,r),g1(rsm;r) = gaussian and its Laplacian; see radgkg
Cr   nabla g0 = g1 ; nabla g1 = g2
Cu Updates
Cu   10 Apr 15 New mode=3
Cu   16 Sep 11 Redesigned, with new mode 2
Cu   11 Aug 11 First created
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer mode,lmxh
      double precision fitp(2),eh,reske(0:lmxh),rmtl(0:lmxh)
      double precision rsml(0:lmxh),etarg(0:lmxh),ttarg(0:lmxh),c01(0:1,0:lmxh)
C ... Local parameters
      integer nrmsh,ip,l,iprint,mode0,mode1,mode2,ierr
      parameter (nrmsh=5)
      double precision hsm(0:lmxh),dhsm(0:lmxh),ddhsm(0:lmxh)
C     double precision hsp(0:lmxh),dhsp(0:lmxh),ddhsp(0:lmxh)
      double precision gkl(0:2,0:lmxh),dgkl(0:2,0:lmxh),ddgkl(0:2,0:lmxh)
      double precision ak(0:lmxh),aj(0:lmxh),dk(0:lmxh),dj(0:lmxh)
      double precision h0(0:lmxh,nrmsh),h(0:lmxh,nrmsh),hlap(0:lmxh,nrmsh)
      double precision g0(0:lmxh,nrmsh),g1(0:lmxh,nrmsh),g2(0:lmxh,nrmsh)
      double precision p(nrmsh),wp(nrmsh)
      double precision xx,ke,res1,res2,g1g1,g1g2,g2g2,hcr,hsx,tol,resmx,wt,DTg0,DTg1
      double precision L3(3,3),lhsi(3,3),rhs(4),resi(2),L4(4,4),wk(4,4),wk2(4,5)
      logical consthcr
      parameter (tol=1d-14)

      mode0 = mod(mode,10)
      mode1 = mod(mode/10,10)
      mode2 = mod(mode/100,10)

C ... Get function values on numerical quadrature for radial integral
      call gausq(nrmsh,fitp,rsml(0),p,wp,10,0)
      do  ip = 1, nrmsh
        xx = p(ip)
        call hanszd(2,xx,eh,rsml,lmxh,hsm,dhsm,ddhsm,0,0,0)
        call radkj(eh,xx,lmxh,ak,aj,dk,dj,0)
        call radgkg(0,xx,rsml,2,lmxh,2,gkl,dgkl,ddgkl)
        h0(0:lmxh,ip)   = ak(0:lmxh)
        h(0:lmxh,ip)    = hsm(0:lmxh)
        hlap(0:lmxh,ip) = ddhsm(0:lmxh)
        g0(0:lmxh,ip)   = gkl(0,0:lmxh)
        g1(0:lmxh,ip)   = gkl(1,0:lmxh)
        g2(0:lmxh,ip)   = gkl(2,0:lmxh)
      enddo

      if (mode0 == 0) c01 = 0
      if (mode0 == 0 .or. mode1 == 0 .or. mode1 == 1) goto 10

C ... Evaluate functions composing e0 at rmtl
      if (mode0 >= 2) then
        consthcr = rmtl(0) < 0
        hcr = dabs(rmtl(0))
        hsx = -9999
C       Loop in reverse order so that if hcr doesn't change call need not be repeated
        do  l = lmxh, 0, -1
          if (.not. consthcr) hcr = dabs(rmtl(l))
          if (dabs(hcr-hsx) > tol) then
            hsx = hcr
            call hanszd(2,hcr,eh,rsml,l,hsm,dhsm,ddhsm,0,0,0)
            call radkj(eh,hcr,l,ak,aj,dk,dj,0)
            call radgkg(0,hcr,rsml,2,l,2,gkl,dgkl,ddgkl)
          endif
        enddo
      endif

C ... For each l, calculate c01(:,l)
      call dpzero(c01,2*(1+lmxh))
      if (mode0 == 0) goto 10
      do  l = 0, lmxh
        resi(1) = 0
        resi(2) = 0
C       Make matrix for linear equations in c0, c1, lambda
        call dpzero(L3,9)
C       Minimize f w possible constraints g,t  Let D = laplacian. See 100's digit mode for wt.
C       f = int_rmin^infty dr [ (D(h(r)+c0*g0(r)+c1*g1(r)) - Dh0(r))^2 * wt(r) ]
C       g = (h+c0*g0+c1*g1) - etarg)|r=rMT  Used in mode 2,5
C       t = (D(h+c0*g0+c1*g1) - ttarg*(h+c0*g0+c1*g1))|r=rMT  Used in mode 3,4,5
C
C      *Mode 2:  define vector v of 3 variables (c0, c1, lambda)
C       Minimize fbar = f - lambda*g
C       grad_v fbar = 0 implies 3 simultaneous equations
C       dfbar/dv1 = int D(h+c0*g0+c1*g1) + eh*h0) Dg0 * wt - lambda g0(rmt)
C       dfbar/dv2 = int D(h+c0*g0+c1*g1) + eh*h0) Dg1 * wt - lambda g1(rmt)
C       dfbar/dv3 = -g = -(h+c0*g0+c1*g1)|r=rMT - etarg
C       Write dfbar/dv as 3x3 matrix in v.  Let R=rmt and I[...] = integral [...]^2
C       ( I[D(g0)D(g0)*wt]  I[D(g1)D(g0)*wt]  -g0(R))   (I[(Dh+eh*h0)*Dg0*wt] )
C       ( I[D(g1)D(g0)*wt]  I[D(g1)D(g1)*wt]  -g1(R)) + (I[(Dh+eh*h0)*Dg1*wt] ) = 0
C       ( -g0(R)            -g1(R)             0    )   (-h|rmt + etarg       )
C       Write 3x3 matrix as L3 and column vector as R3.  Solve L3 v = -R3
C
C      *Mode 3: define vector v of 3 variables (c0, c1, lambda2)
C       Minimize  fbar = f - lambda2*t
C       Like mode 2 but constraint is different.  Let T=ttarg
C            ( I[D(g0)D(g0)*wt]  I[D(g1)D(g0)*wt] -Dg0(R)+Tg0(R))       (I[(Dh+eh*h0)*Dg0*wt] )
C       L3 = ( I[D(g1)D(g0)*wt]  I[D(g1)D(g1)*wt] -Dg1(R)+Tg1(R))  R3 = (I[(Dh+eh*h0)*Dg1*wt] )
C            ( -Dg0(R)+Tg0(R)    -Dg1(R)+Tg1(R)    0            )       (-(Dh+Th)|rmt         )
C
C      *Mode 4: Same as Mode5, except that lambda2*t^2 is added to f rather than a constraint.
C       Minimize  (f - lambda2*t^2) - lambda*g   with lambda2=-fitp(2) given as input
C                                 ( (D+T)(g0(R))(D+T)(g0(R))  (D+T)(g1(R))(D+T)(g0(R)) 0 )
C       L3 = L3(Mode 3) + fitp(2)*( (D+T)(g1(R))(D+T)(g0(R))  (D+T)(g1(R))(D+T)(g1(R)) 0 )
C                                 ( 0                 0                0 )
C
C                                 ( ((D+T)h(R) * (D+T)g0(R) )
C       R3 = R3(Mode 3) + fitp(2)*( ((D+T)h(R) * (D+T)g1(R) )
C                                 ( 0                       )
C
C      *Mode 5: define vector v of 4 variables (c0, c1, lambda, lambda2)
C       Minimize  fbar = f - lambda*g - lambda2*t
C       dfbar/dv4 = -t = (-D(h+c0*g0+c1*g1)+ T*(h+c0*g0+c1*g1))|r=rMT
C       Define vector v of 4 variables (c0, c1, lambda, lambda2) => 4x4 matrix
C            (                         -dg0(R))        (                )
C       L4 = (          L3             -dg1(R))   R4 = (     R3         )
C            (                                  )        (                )
C            ( -Dg0(R) -Dg1(R)   0    0     )        (-Dh|rmt + ttarg )

       do  ip = 1, nrmsh
          select case (mode2)
            case (0); wt = 1/h0(l,ip)**2;
            case (1); wt = 1/ak(l)**2;
            case (2); wt = 1
          end select
          res1 = (hlap(l,ip)+eh*h0(l,ip))*g1(l,ip)*wt ! [D(h-hunsm) * D(g0)]*wt
          res2 = (hlap(l,ip)+eh*h0(l,ip))*g2(l,ip)*wt ! [D(h-hunsm) * D(g1)]*wt
          g1g1 = g1(l,ip)**2*wt       ! [ D(g0) D(g0) * wt]^2
          g1g2 = g1(l,ip)*g2(l,ip)*wt ! [ D(g0) D(g1) * wt]
          g2g2 = g2(l,ip)**2*wt       ! [ D(g1) D(g1) * wt]^2
          resi(1) = resi(1) + res1*wp(ip)
          resi(2) = resi(2) + res2*wp(ip)
          L3(1,1) = L3(1,1) + g1g1*wp(ip)
          L3(1,2) = L3(1,2) + g1g2*wp(ip)
          L3(2,1) = L3(2,1) + g1g2*wp(ip)
          L3(2,2) = L3(2,2) + g2g2*wp(ip)
        enddo
C       mode 1: minimize without constraint
        c01(1,l) = 0
        c01(0,l) = -resi(1)/L3(1,1)
        if (mode0 == 1) cycle

C       mode 2:5: Set up L3 and R3
        L3(3,1) = -gkl(0,l)  ! Default: constraint g=0
        L3(1,3) = -gkl(0,l)
        L3(3,2) = -gkl(1,l)
        L3(2,3) = -gkl(1,l)
        rhs(1)  = -resi(1)
        rhs(2)  = -resi(2)
        rhs(3)  = hsm(l) - etarg(l)
        if (mode0 == 3) then
          L3(3,1) = -gkl(1,l) - ttarg(l)*gkl(0,l)  ! Replace with constraint t=0
          L3(1,3) = -gkl(1,l) - ttarg(l)*gkl(0,l)
          L3(3,2) = -gkl(2,l) - ttarg(l)*gkl(1,l)
          L3(2,3) = -gkl(2,l) - ttarg(l)*gkl(1,l)
          rhs(3)  =  ddhsm(l) + ttarg(l)*hsm(l)
        elseif (mode0 == 4) then
          DTg0 = gkl(1,l) + ttarg(l)*gkl(0,l)  ! Add fitp(2)*t^2 to f
          DTg1 = gkl(2,l) + ttarg(l)*gkl(1,l)
          res1 = (ddhsm(l) + ttarg(l)*hsm(l))*DTg0 ! [(Dh+Th) * (Dg0+Tg0)]
          res2 = (ddhsm(l) + ttarg(l)*hsm(l))*DTg1 ! [(Dh+Th) * (Dg1+Tg1)]
          g1g1 = DTg0*DTg0
          g1g2 = DTg0*DTg1
          g2g2 = DTg1*DTg1

          L3(1,1) = L3(1,1) + g1g1*2*fitp(2)
          L3(1,2) = L3(1,2) + g1g2*2*fitp(2)
          L3(2,1) = L3(2,1) + g1g2*2*fitp(2)
          L3(2,2) = L3(2,2) + g2g2*2*fitp(2)
          rhs(1)  = rhs(1) - res1*2*fitp(2)
          rhs(2)  = rhs(2) - res2*2*fitp(2)

        endif
        if (mode0 == 2 .or. mode0 == 3 .or. mode0 == 4) then
C         call prmx('L3',L3,3,3,3)
C         call prmx('rhs',rhs,3,3,1)
C         call dqinvb('s',L3,3,0,3,3,wk,3,wk2,rhs,3,ierr)
C         if (ierr /= 0) call rx('cgmin: failed to solve eqns')
          call dinv33(L3,0,lhsi,xx)
          c01(0,l) = lhsi(1,1)*rhs(1)+lhsi(1,2)*rhs(2)+lhsi(1,3)*rhs(3)
          c01(1,l) = lhsi(2,1)*rhs(1)+lhsi(2,2)*rhs(2)+lhsi(2,3)*rhs(3)
C         xx = hsm(l)+c01(0,l)*gkl(0,l)+c01(1,l)*gkl(1,l)
C         print *, xx-etarg(l)
C         print *, (ddhsm(l)+c01(0,l)*gkl(1,l)+c01(1,l)*gkl(2,l)) + ttarg(l)*xx
        else if (mode0 == 5) then
          call dpzero(L4,16)
          L4(1:3,1:3) = L3(1:3,1:3)
          L4(4,1) = -gkl(1,l) - ttarg(l)*gkl(0,l)
          L4(1,4) = -gkl(1,l) - ttarg(l)*gkl(0,l)
          L4(4,2) = -gkl(2,l) - ttarg(l)*gkl(1,l)
          L4(2,4) = -gkl(2,l) - ttarg(l)*gkl(1,l)
          rhs(4)  =  ddhsm(l) + ttarg(l)*hsm(l)

C          call prmx('L4',L4,4,4,4)
C          call prmx('rhs',rhs,4,4,1)
          call dqinvb('s',L4,4,0,4,1,wk,4,wk2,rhs,4,ierr)
          if (ierr /= 0) call rx('cgmin: failed to solve eqns')
          c01(0,l) = rhs(1)
          c01(1,l) = rhs(2)
C         xx = hsm(l)+c01(0,l)*gkl(0,l)+c01(1,l)*gkl(1,l)
C         print *, xx-etarg(l)
C         print *, (ddhsm(l)+c01(0,l)*gkl(1,l)+c01(1,l)*gkl(2,l)) + ttarg(l)*xx
        else
          call rx('cgmin: bad mode')
        endif
      enddo

C ... Calculate f = residual in K.E.
   10 continue
      resmx = 0
      do  l = 0, lmxh
        reske(l) = 0
        do  ip = 1, nrmsh
          ke = -(hlap(l,ip)+c01(0,l)*g1(l,ip)+c01(1,l)*g2(l,ip))/
     .          (h(l,ip)+c01(0,l)*g0(l,ip)+c01(1,l)*g1(l,ip))
          reske(l) = reske(l) + (ke-eh)**2 * wp(ip)
        enddo
        reske(l) = dsqrt(reske(l))
        resmx = max(resmx,reske(l))
      enddo

C ... Printout
C     Print out fitting conditions
      call info5(51,0,0,' cgmin: e0 = '//
     .  '%?#(n==0)#hsm##%-1j'//
     .  '%?#(n==1)#hsm+c0*g0##%-1j'//
     .  '%?#(n>=2&n<=5)#hsm+c0*g0+c1*g1##%-1j'//
     .  '%j  eh=%,4d%-2j  '//
     .  'cnstr(%i%-1j): '//
     .  '%?#(n==0|n==1)#*,##%-1j'//
     .  '%?#(n==2|n==4)#h|rmt,##%-1j'//
     .  '%?#(n==3)#t|rmt,##%-1j'//
     .  '%?#(n==5)#h,t|rmt,##%-1j'//
     .  '%b  %2jfit rmin=%,3d'//
     .  '%?#(n==4)# wtR=%,3d##',
     .  mode0,eh,fitp,mode0,fitp(2))
      if (mode1 == 0) return

C     Print out fitting results
      if (iprint() < 50) return
      call info2(30,0,0,' %n;8,4D  rsml',1+lmxh,rsml)
      call info2(30,0,0,' %n;8,4D  c0',1+lmxh,c01(0,0:lmxh))
      if (mode0 >= 2) then
        call info2(30,0,0,' %n;8,4D  c1',1+lmxh,c01(1,0:lmxh))
      endif

      ak(0:lmxh) =   (hsm(0:lmxh) +c01(0,:lmxh)*gkl(0,:lmxh)
     .                            +c01(1,:lmxh)*gkl(1,:lmxh))
      call info5(30,0,0,' %n;8,4D  val  at rmt  (%,3d)',1+lmxh,ak,abs(rmtl(0)),0,0)
      ak(0:lmxh) = -(ddhsm(0:lmxh)+c01(0,:lmxh)*gkl(1,:lmxh)
     .                            +c01(1,:lmxh)*gkl(2,:lmxh))/
     .               (hsm(0:lmxh) +c01(0,:lmxh)*gkl(0,:lmxh)
     .                            +c01(1,:lmxh)*gkl(1,:lmxh))
      call info2(30,0,0,' %n;8,4D  K.E. at rmt',1+lmxh,ak)

      if (iprint() < 51) return
      call hanszd(2,fitp,eh,rsml,lmxh,hsm,dhsm,ddhsm,0,0,0)
      call radgkg(0,fitp,rsml,2,lmxh,2,gkl,dgkl,ddgkl)
      ak(0:lmxh) =   (hsm(0:lmxh) +c01(0,:lmxh)*gkl(0,:lmxh)
     .                            +c01(1,:lmxh)*gkl(1,:lmxh))
      call info5(30,0,0,' %n;8,4D  val  at rmin (%,3d)',1+lmxh,ak,fitp,0,0)
      ak(0:lmxh) = -(ddhsm(0:lmxh)+c01(0,:lmxh)*gkl(1,:lmxh)
     .                            +c01(1,:lmxh)*gkl(2,:lmxh))/
     .               (hsm(0:lmxh) +c01(0,:lmxh)*gkl(0,:lmxh)
     .                            +c01(1,:lmxh)*gkl(1,:lmxh))
      call info2(30,0,0,' %n;8,4D  K.E. at rmin',1+lmxh,ak)
      call info2(30,0,0,' %n;8,4D  RMS (K.E.-eh)',1+lmxh,reske)

      end
