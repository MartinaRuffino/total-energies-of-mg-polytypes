      subroutine asalsq(iscr,s_ctrl,s_lat,s_spec,s_ham,s_bz,s_pot,elind,vrl,qin,qnu)
C- Linear response, estimate of self-consistent density, ASA
C ----------------------------------------------------------------------
Cio Structures
Cio  s_ctrl :struct for program flow parameters; see structures.h
Ci     Elts read:  nbasp nbas nclass nl nspin nclasp nspec lpgf lmet
Ci                 zbak npadl npadr ldlm nccomp ipcp nrc ips ipc rmax
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:nrc ipc rmax ics ncomp lasa ipcp dclabl idcc ips
Cio    Passed to:  asamad asavqm asaqmp
Cio  s_lat  :struct containing lattice information; see structures.h
Ci     Elts read:  alat plat as tol vol nkdmx nkqmx platl platr qlat
Ci                 awald nkd nkq nsgrp
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:vol pos cg jcg indxcg qlv dlv symgr ag
Cio    Passed to:  asamad asavqm asaqmp scrmom
Cio  s_spec :struct for species-specific data; see structures.h
Ci     Elts read:  lmxa z coreh coreq name lmxl lmxf
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:*
Cio    Passed to:  asamad getq gtpcor dlmq asavqm
Cio  s_ham  :struct for parameters defining hamiltonian; see structures.h
Ci     Elts read:  ldham elind
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:iprmb
Cio    Passed to:  scrmom
Cio  s_bz   :struct for the Brillouin Zone; see structures.h
Ci     Elts read:  zval
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:*
Cio    Passed to:  scrmom
C
Cio  s_pot  :struct for information about the potential; see structures.h
Ci     Elts read:  vconst qpp vmtz0
Co     Stored:     vconst
Co     Allocated:  *
Cio    Elts passed:ves pnu mad vintr vrmax gibbs qc qpp pmpol
Cio    Passed to:  asamad asavqm asaqmp
Ci Inputs
Ci   iscr  :0,1 do nothing
Ci         :2,3 read static q=0 response function psta from disk to
Ci         :    make eps and screen output q and ves
Ci         :4,5 Construct model q=0 response function
Ci         :6,7 like 2, but estimate self-consistent ves only
Ci         (NB: 1s bit reserved for making psta)
Ci   qin   :energy-weighted moments of the sphere charges which were
Ci         :used to generate the input potential
Ci   elind :If not NULL, use this value for elind instead of s_ham%elind
Ci         :If 0 and model dielectric (iscr = 4 or 5) routine does nothing
Ci   vrl   :(pgf) difference in potential between left- and right- leads,
Ci         :      either because leads are different or because of
Ci         :      a bias across the device; see lmasa-gf.f
Cio Inputs/Outputs
Cio  qnu   :On input, moments generated by the hamiltonian (output moments)
Cio        :On output, qnu is overwritten by :
Cio        :  qin + epsilon^-1 [(qout-qin) - P (Vin -V[qin])]
Cr Remarks
Cr
Cu Updates
Cu   08 May 13 Complete migration to f90 structures; eliminate s_array
Cu   10 Nov 11 Begin migration to f90 structures
Cu   21 Jul 07 (pgf) vne->vrl (for inequivalent left- and right- end layeers)
Cu   24 Feb 05 (Jailei Xu) Screening through model dielectric function
Cu   10 Feb 04 (S.Faleev) vrl added to argument list; passed
Cu              to asamad for non-equilibrium mode
Cu   26 Apr 03 Added MPI calls
Cu   19 Feb 02 Adapted to padded basis as found in layer GF code
C ----------------------------------------------------------------------
      use structures
      implicit none
C ... Passed parameters
      integer iscr
      double precision qin(*),qnu(*),vrl,elind
C ... For structures
!      include 'structures.h'
      type(str_ctrl)::  s_ctrl
      type(str_lat)::   s_lat
      type(str_spec)::  s_spec(*)
      type(str_ham)::   s_ham
      type(str_bz)::    s_bz
      type(str_pot)::   s_pot
C ... Dynamically allocated local arrays
      complex(8), allocatable :: psta(:)
      real(8),allocatable :: vold(:),veold(:),etrms(:,:),smad(:,:)
C      real(8),allocatable :: z(:),Mz(:)
C ... Local parameters
      integer i,ifi,iscr1,ldham(16),lihdim,nRLc,nbas,nbasp,nbaspp,
     .  nclasp,nclass,nclspp,nl,nsp,nspc
      integer mpipid,procid
      equivalence (lihdim,ldham(3)),(nspc,ldham(4))
      double precision emad,trumad,vmtz(2)
!     double complex hsm(1),hsmp(1)
!     real(8) :: xx,rsm,Y0
!     integer, parameter :: NULLI=-99999
      real(8),parameter :: pi = 4d0*datan(1d0)
      procedure(integer) :: nnrl,fopn

      iscr1 = mod(iscr,10)/2
      if (iscr1 == 0) return
C     Skip if no screening
      if ((mod(iscr,10) == 4 .or. mod(iscr,10) == 5) .and. elind == 0) return

C ... Unpack local variables
      nbasp = s_ctrl%nbasp
      nbas = s_ctrl%nbas
      nbaspp = 2*nbasp-nbas
      nclass = s_ctrl%nclass
      nl = s_ctrl%nl
      nsp = s_ctrl%nspin
      nclasp = s_ctrl%nclasp
      nclspp = 2*nclasp-nclass
      ldham = s_ham%ldham
      nRLc = nnrl(1,1,nbasp,s_ham%iprmb,lihdim)

      if (mod(iscr,10) == 4) then
C        Y0 = sqrt(1d0/4/pi)
C        allocate(smad(nbaspp,nbaspp))
C
CC        elind = 1d-02; print *, '!! 119', elind
CC        elind = 1d0; print *, '!! 119', elind
C
CC        elind = .001d0; print *, '!! 119', elind
CC        rsm = .1d0
CC        call hsmbl([0d0,0d0,0d0],rsm,-elind,[0d0,0d0,0d0],0,s_lat%cy,s_lat,hsm,hsmp)
CC        call hansmr(0d0,-elind,1/rsm,xx,0)
CC        print *, dble(hsm/Y0),xx,dble(hsm(1)/Y0 - xx)
CC        rsm = .01d0
CC        call hsmbl([0d0,0d0,0d0],rsm,-elind,[0d0,0d0,0d0],0,s_lat%cy,s_lat,hsm,hsmp)
CC        call hansmr(0d0,-elind,1/rsm,xx,0)
CC        print *, dble(hsm/Y0),xx,dble(hsm(1)/Y0 - xx)
CC        elind = .0001d0; print *, '!! 119', elind
CC
CC        rsm = .1d0
CC        call hsmbl([0d0,0d0,0d0],rsm,-elind,[0d0,0d0,0d0],0,s_lat%cy,s_lat,hsm,hsmp)
CC        call hansmr(0d0,-elind,1/rsm,xx,0)
CC        print *, dble(hsm/Y0),xx,dble(hsm(1)/Y0 - xx),dble(hsm(1)/Y0 - xx - 4*pi/s_lat%vol/elind)
CC
CC        elind = .00001d0; print *, '!! 119', elind
CC
CC        rsm = .1d0
CC        call hsmbl([0d0,0d0,0d0],rsm,-elind,[0d0,0d0,0d0],0,s_lat%cy,s_lat,hsm,hsmp)
CC        call hansmr(0d0,-elind,1/rsm,xx,0)
CC        print *, dble(hsm/Y0),xx,dble(hsm(1)/Y0 - xx),dble(hsm(1)/Y0 - xx - 4*pi/s_lat%vol/elind)
CC
CC        elind = .000001d0; print *, '!! 119', elind
CC
CC        rsm = .1d0
CC        call hsmbl([0d0,0d0,0d0],rsm,-elind,[0d0,0d0,0d0],0,s_lat%cy,s_lat,hsm,hsmp)
CC        call hansmr(0d0,-elind,1/rsm,xx,0)
CC        print *, dble(hsm/Y0),xx,dble(hsm(1)/Y0 - xx),dble(hsm(1)/Y0 - xx - 4*pi/s_lat%vol/elind)
CC
C        call smadmat(nbasp,s_lat%pos,-elind,s_lat%awald,s_lat%alat,abs(s_lat%vol),
C     .    s_lat%dlv,s_lat%nkd,s_lat%qlv,s_lat%nkq,s_lat%cg,s_lat%indxcg,s_lat%jcg,smad)
        allocate(smad(1,1))
      else
        allocate(smad(1,1))
      endif
C ... MPI: only master does screened mixing
      procid = mpipid(1)
      if (procid == 0) then

      if (iscr1 == 2) then
        allocate(psta(1))
      else
        allocate(psta(nRLc*nRLc*nsp*nspc))
        call dpzero(psta,2*nRLc*nRLc*nsp*nspc)
      endif

C     Always couple spins?
      nspc = nsp

C ... Read in static response matrix
      if (iscr1 == 1 .or. iscr1 == 3) then
         ifi = fopn('PSTA')
         call iores(nRLc,nsp,nspc,ifi,psta)
C     call prjrsp(nsp,nspc,1,nRLc,1,psta)
      end if

C ... ves[output q]
C     print *, '!!'
      call pshpr(40*0+1)
      allocate(vold(nclspp))
      call dcopy(nclspp,s_pot%ves,1,vold,1)
      allocate(etrms(22,nclasp))
      call asamad(s_ctrl,s_pot,s_lat,s_spec,100,
     .  s_pot%pnu,qnu,vrl,s_pot%ves,emad,trumad,vmtz,etrms)
C ... ves[input q]
      allocate(veold(nclspp))
      call asamad(s_ctrl,s_pot,s_lat,s_spec,100,
     .  s_pot%pnu,qin,vrl,veold,emad,trumad,vmtz,etrms)
      call poppr
      deallocate(etrms)
C ... screened ves and emom
      i = 4
      if (iscr1 == 2) i = 12
      if (iscr1 == 3) i = 1
      call scrmom(s_ctrl,s_ham,s_bz,s_lat,i,nbasp,nsp,nl,nclasp,nRLc,
     .  elind,psta,s_pot%mad,smad,nbaspp,s_pot%vintr,vold,veold,s_pot%ves,qin,qnu)
      deallocate(psta,vold,veold)

      endif
      call mpibc1(qnu,3*nl*nsp*nclasp,4,.false.,'asalsq','qnu')
      deallocate(smad)

      end
