      subroutine strck(nds,iat,ixi,rtab,e,ikap,nkap,nbas,alpha,halp,
     .  iax,ntab,s,b,nitab,ips,nl,rsmh,c01,xmrp,la,iopt,slk,slj,gslk,gslj)
C- Screened Hankels and their one-center expansion for testing
C ----------------------------------------------------------------
Ci Inputs
Ci   nds   :Leading dimensions of s and alpha
Ci   iat   :Site R for which screened Hankel functions are calculated
Ci   ixi   :Indicates site R' for one-center expansion.  ixi is index
Ci         :to pair table relative to start of cluster at iat
Ci         :Thus ixi=1 points to head; ixi=2 points to 1st neighbor, etc
Ci         :ixi is used in two contexts:
Ci         :- point xmrp is defined as position relative to site R'
Ci         :- One-center expansion is to be evaluated around R'
Ci   nbas  :Size of basis
Ci   rtab  :Site positions corresponding to entries in iax table (ppair9)
Ci   e     :Energies of Hankel functions
Ci   ikap,nkap: number of Hankel functions in expansion and which
Ci          function is to be evaluated
Ci   alpha :tight-binding screening parameters.   See Remarks
Ci   halp  :inverse of head value functions;see makalp io=4 and Remarks
Ci   iax   :neighbor table containing pair information (pairc.f)
Ci         :iax(9,i) = (lmx+1)**2 for basis atom iax(2,i) (mkiaxd)
Ci   ntab  :ntab(ib)=offset to neighbor table for cluster ib (pairc.f)
Ci   s     :Real-space structure constant matrix:
Ci         :H^alpha_RL = H_R'L' S_R'L',RL
Ci   b     :Coffs to 1-center expansion; see hanb2s for connection to s
Ci   nitab :Total number of inequivalent pairs in iax table (strscr.f)
Ci         :(not needed for anything)
Ci   ips   :Species table: site ib belongs to species ips(ib)
Ci   nl    :Dimensions rsmh,c01
Ci   rsmh  :Smoothing radii for generalized envelope functions
Ci         :Used when 1000's digit iopt is nonzero.
Ci   c01   :Gaussian coefficients for generalized envelope functions
Ci   xmrp  :x-R'
Ci   la    :the l quantum number to which bessel is evaluated
Ci   iopt  :a sequence of digits, each with independent meaning:
Ci         :   1s  >0 use OKA conventions when calculating H,J
Ci         :          strck generates only partial results in this case
Ci         :  10s  >0 make gslk,gslj
Ci         : 100s  >0 => S corresponds to (u0,u1); see Remarks.
Ci         :1000s   1 => Replace H with generalized functions (sole0g)
Co Outputs
Co   slk(L):H^a_(ikap,RL) at x-R'
Co         :If 1000s == 1, H^a is replaced by generalized functions (sole0g)
Co   slj(L):1-C expansion of UNSCREENED H^a_(ikap,RL) at x-R', expanded about R'
Co   gslk  :grad slk (returned only when 10s digit iopt > 0)
Cl Local variables
Cl  nlmb   :Number of L channels at iat = R
Cl  nlmix  :Number of L channels at R"
Cl  nlma   :Number of L channels at R'
Cb Bugs
Cb  1. nlmb,nlmix,nlma need to be sorted out
Cb  2. slj should be consistent with slk for generalized functions
Cr Remarks
Cr   Evaluates screened envelope function H_mRL at a point x-R'
Cr   The function is defined as
Cr     H^a_mRL(x) = sum_m"R"L" H_R"L" * S_m"R"L",mRL
Cr   where H_R"(x) is the ordinary Hankel function H(x-R")
Cr
Cr   The same function has a one-center expansion about site R' as
Cr     H^a_mRL = (head term) *delta_m'R'L',mRL + B_m'R'L',mRL *
Cr               [J^a_m'R'L'(x) - H^a_m'R'L'(x) alpha_m'R'L',m]
Cr
Cr   The head term depends on whether S corresponds to linear
Cr   combinations of H^a_mRL(x) that match the unscreened H_mRL(x)
Cr   on the surface of the head sphere for m=1,2, or if they
Cr   are 'value-slope' functions u0 and u1 which have the property
Cr   that u0 is 1 and u1 is zero, and u0' is zero, u1'=1 on the
Cr   surface of the sphere.  They are related by matrix halp,
Cr   generated by makalp.f, io=4.
Cr
Cr   Note: 2nd generation strux (once called "Salpha") are -B^alpha here.
Cr   Quantity [..] = [J^a_m'R'L'(x) - H^a_m'R'L'(x) alpha_m'R'L',m]
Cr   should vanish on the surface of R' for all L' by construction
Cr   In the 2-kappa case, the slope of [..] should also vanish.
Cu Updates
Cu   06 Apr 15 Some bug fixes
Cu   21 Sep 11 Optionally substitues generalized functions for h
Cu   14 Sep 11 Optionally returns gradients of slk and slj
Cu   23 Jul 08 (S Lozovoi) Adapted to species-dependent lmax
Cu   05 Aug 06 Updated to handle multiple-kappa strux
Cu   19 May 04 Rewritten in preparation for NMTO
Cu   Original code written for double-kappa basis.
C ----------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer iat,ixi,ikap,la,nbas,nds,niax,nitab,nkap,iopt,nl
      parameter (niax=10)
      integer iax(niax,*),ntab(nbas+1),ips(nbas)
      double precision rtab(3,*),e(nkap),
     .  b(nds,nds,nkap,nkap,nitab),s(nds,nds,nkap,nkap,nitab),
     .  alpha(nds,nbas,nkap,nkap),halp(nds,nbas,nkap,nkap),
     .  xmrp(3),slj(25),slk(25),gslk(3,25),gslj(3,25)
C     Parameters for generalized functions (sole0g)
      double precision rsmh(0:nl-1,nbas),c01(0:1,0:nl-1,nbas)
C ... Local parameters
      integer j,jj,k,nclus,nlma,nlmix,offR,offRp,iatRp,nlb,ik,ll,lb,
     .  loka,lhalp,lgslk,lhsm,getdig,is,iatRpp,n0
      parameter (n0=10)
      double precision ddot,hl(49,nkap),bl(49,nkap),xmrpp(3) !,radius
      double precision ghl(3,49,nkap),gbl(3,49,nkap)
      double precision el(0:n0-1,nkap)

      loka = getdig(iopt,0,10)
      lgslk = getdig(iopt,1,10) ! Make gradients
      lhalp = getdig(iopt,2,10) ! Functions correspond to (val,slo)
      lhsm  = getdig(iopt,3,10) ! Generalized functions (sole0g)
C     Offset to iax table for cluster connected to R
      offR  = ntab(iat)
      nclus = ntab(iat+1) - ntab(iat)
C     Offset to iax table for site R'
      offRp = ixi-1 + offR
C     Basis index for site R'
      iatRp = iax(2,offR+ixi)
      nlma  = (la+1)**2
      nlb   = nds*nbas
      call dpzero(slj,nlma)
      call dpzero(slk,nlma)
      call dpzero(gslk,3*nlma)
      call dpzero(gslj,3*nlma)
      do  ik = 1, nkap
        call dvset(el(0,ik),1,n0,e(ik))
      enddo

C     Scale 2nd gen strux outside this routine for consistency
C     facb = 1
C     if (loka == 1) facb = -1
C     radius = dsqrt(ddot(3,xmrp,1,xmrp,1))

C --- H^alpha = sum_R" H(x - R") * S_R"L", RL ---
C     If lhsm==1, each H(x - R") is replaced by a generalized screened function (sole0g)
      do  j = 1, nclus
        jj = iax(8,offR+j) ! jj points to (R",R) pair in strux
        nlmix  = iax(9,offR+j) ! Number of L channels at R"
        lb = ll(nlmix)
        iatRpp = iax(2,offR+j) ! Atom type at R''
        is = ips(iatRpp) ! Species type at R''

C       Use x - R" =  (x-R') + R' - R"
        do  k = 1, 3
          xmrpp(k) = xmrp(k) + rtab(k,offRp+1) - rtab(k,offR+j)
        enddo

        do  ik = 1, nkap
          if (lhsm == 1) then
            k = 2
            if (lgslk == 1) k = 12
            call sole0g(xmrpp,rsmh(0,is),el(0,ik),lb,k,0,
     .        c01(0,0,is),hl(1,ik),ghl(1,1,ik))
          else
            call soldhj(xmrpp,e(ik),loka,lb,hl(1,ik),bl(1,ik))
          endif

C         Warning!  nlma here need not be nlmix of R'
C         But until B is expanded, it should be that nlma=nlmix(R')
C         Contract over L"=1..nlmix (orbitals at R")
          call dgemm('T','N',nlma,1,nlmix,1d0,
     .      s(1,1,ik,ikap,jj),nds,hl(1,ik),nlmix,1d0,slk,nlma)

          if (lgslk /= 0 .and. loka == 0) then ! Make gradients
            if (lhsm == 0) then
              call solhjg(xmrpp,e(ik),lb,hl(1,ik),bl(1,ik),ghl(1,1,ik),gbl(1,1,ik))
            endif
            call dgemm('T','N',nlma,1,nlmix,1d0,s(1,1,ik,ikap,jj),
     .        nds,ghl(1,1:nlmix,ik),nlmix,1d0,gslk(1,1:nlma),nlma)
            call dgemm('T','N',nlma,1,nlmix,1d0,s(1,1,ik,ikap,jj),
     .        nds,ghl(2,1:nlmix,ik),nlmix,1d0,gslk(2,1:nlma),nlma)
            call dgemm('T','N',nlma,1,nlmix,1d0,s(1,1,ik,ikap,jj),
     .        nds,ghl(3,1:nlmix,ik),nlmix,1d0,gslk(3,1:nlma),nlma)
          endif
        enddo
      enddo

C --- H^alpha = sum_R" H(x - R") * (1 - alpha * B^alpha)_R"L", RL ---
C     This accomplishes the same as above, without using S.
C      do  j = 1, nclus
CC       jj points to (R",R) pair
CC       jj = offR+j
C        jj = iax(8,offR+j)
C        nlmix  = iax(9,jj)
C        lb = ll(nlmix)
C
CC       Use x - R" =  (x-R') + (R'-R) - (R"-R)
C        do  k = 1, 3
C          xmrpp(k) = xmrp(k) - rtab(k,offR+j) + rtab(k,offRp+1)
C        enddo
CC       print *, '|xmrpp|=',j,dsqrt(ddot(3,xmrpp,1,xmrpp,1))
C
CC   ... Diagonal term delta_R",R
C        if (j == 1) call soldhj(xmrpp,e(ikap),loka,lb,slk,bl)
C
CC   ... Term H * alpha * B^alpha
C        do  ik = 1, nkap
C          call soldhj(xmrpp,e(ik),loka,lb,hl(1,ik),bl(1,ik))
C        enddo
CC       print 555, 'kalp', hl(1,1),hl(1,2)
C        iatRpp = iax(2,jj)
C        do  ik = 1, nkap
CC       Store tmp bl_L : -sum_(jk) H_(jk)L * alpha_(jk)L,(ik)L
C        do  L = 1, nlmix
C          bl(L,ik) = -ddot(nkap,hl(L,1),49,alpha(L,iatRpp,1,ik),nlb)
C        enddo
CC       Add  into slk : sum_L' tmp_(ik)L' * B_(ik)L',(ikap)L
CC       Warning!  nlma here need not be nlmix of R'
CC       But until B is expanded, it should be that nlma=nlmix(R')
C        call addsb(nlmix,nlma,b(1,1,ik,ikap,offR+j),bl(1,ik),slk)
CC        call dgemm('T','N',nlmix,1,nlma,1d0,
CC     .    s(1,1,ik,ikap,offR+j),nds,bl(1,ik),nlma,1d0,slk,nlmix)
C        enddo
C      enddo

C --- slj = unscreened 1-C expansion: H*1 + (J - H alpha) B^alpha at R' ---
C     ib    = iax(1,offRp+1)
      nlmix  = iax(9,offRp+1)
      lb  = ll(nlmix)
C     Warning! alpha should be zero for ilma>nlmix(R')
      do  ik = 1, nkap
        if (lgslk /= 0 .and. loka == 0) then
          call solhjg(xmrp,e(ik),lb,hl(1,ik),bl(1,ik),ghl(1,1,ik),gbl(1,1,ik))
        else
          call soldhj(xmrp,e(ik),loka,lb,hl(1,ik),bl(1,ik))
        endif
      enddo
      do  ik = 1, nkap
        do  j = 1, nlmix
          bl(j,ik) = bl(j,ik) - ddot(nkap,hl(j,1),49,alpha(j,iatRp,1,ik),nlb)
        enddo
        if (lgslk /= 0 .and. loka == 0) then
        do  k = 1, 3
          do  j = 1, nlmix
            gbl(k,j,ik) = gbl(k,j,ik) - ddot(nkap,ghl(k,j,1),3*49,alpha(j,iatRp,1,ik),nlb)
          enddo
        enddo
        endif

C       Add to slj: sum_L' (J - H alpha)' B_L'L
C       Warning!  nlma here need not be nlmix
C       But until B is expanded, it should be that nlma=nlmix(R')
        call dgemm('T','N',nlma,1,nlmix,1d0,
     .    b(1,1,ik,ikap,offRp+1),nds,bl(1,ik),nlmix,1d0,slj,nlma)

        if (lgslk /= 0 .and. loka == 0) then
        do  k = 1, 3
          call dgemm('T','N',nlma,1,nlmix,1d0,b(1,1,ik,ikap,offRp+1),
     .      nds,gbl(k,1:nlmix,ik),nlmix,1d0,gslj(k,1:nlma),nlma)
        enddo
        endif

      enddo

C     Add on-site term: either unity, or rotated if (u0,u1)
      if (ixi == 1) then
C       u_ikap = h1*halp(1,ikap) + h2*halp(2,ikap)
        if (lhalp == 1) then
          do  j = 1, nlmix
            hl(j,ikap) = ddot(nkap,hl(j,1),49,halp(j,iatRp,1,ikap),nlb)
          enddo
          if (lgslk /= 0 .and. loka == 0) then
            do  k = 1, 3
            do  j = 1, nlmix
              ghl(k,j,ikap) = ddot(nkap,ghl(k,j,1),3*49,halp(j,iatRp,1,ikap),nlb)
            enddo
            enddo
          endif
        endif
        call daxpy(nlma,1d0,hl(1,ikap),1,slj,1)
        if (lgslk /= 0 .and. loka == 0) then
          do  k = 1, 3
            call daxpy(nlma,1d0,ghl(k,1,ikap),3,gslj(k,1),3)
          enddo
        endif
      endif

      end

C      subroutine addsb(nlmb,nlma,b,jl,sl)
CC- Add sum_La jl(La)*b(La,Lb) into sl(Lb)
CC ----------------------------------------------------------------
CCi Inputs
CCi
CCo Outputs
CCo
CCr Remarks
CCr   jl*b is added into sl
CC ----------------------------------------------------------------
C      implicit none
CC Passed parameters
C      integer nlma,nlmb
C      double precision b(nlma,nlmb),jl(*),sl(*)
CC Local parameters
C      integer ilm,klm
C      double precision sum
C
C      do  10  ilm = 1, nlmb
C        sum = sl(ilm)
C        do  11  klm = 1, nlma
C   11   sum = sum + jl(klm)*b(klm,ilm)
C        sl(ilm) = sum
C   10 continue
C      end
