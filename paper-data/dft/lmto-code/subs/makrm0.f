      subroutine makrm0(opt,nspec,nbas,alat,plat,pos,slabl,ips,modep,lock,z,rmt)
C- Estimate muffin-tin radii overlapping atomic potentials
C ----------------------------------------------------------------------
Ci Inputs
Ci   opt  :specifies options in makrm0.
Ci         :
Ci         :1s digit : prescription for constructing potential
Ci         :  The only option is mode 1 (see Remarks):
Ci         :  set 1's digit opt=1.
Ci         :
Ci         :10s digit : quantity to overlap
Ci         :  0 overlap electrostatic atomic potentials
Ci         :  1 overlap estat atomic potentials + add total xc potential
Ci         :    This option tends to produce slightly more uniform radii.
Ci         :  2 overlap total atomic potentials
Ci         :    This option probably doesn't make sense.
Ci         :
Ci         :100s digit specifies what MT radii are returned.
Ci         :Initially MT radii are generated by site.
Ci         :  0 return MT radii by site:
Ci              rmt(i) corresponds to radius for site i
Ci         :  1 average MT radii by species:
Ci              rmt(i) corresponds to radius for species i
Ci         :  2 smallest MT radii of this species
Ci              rmt(i) corresponds to radius for species i
Ci         :
Ci         :1000s digit specifies whether nspec,slabl,ips refer to
Ci                species or classes (used for printout only)
Ci         :  0 quantities refer to species
Ci         :  1 quantities refer to classes
Ci   nspec :number of species (or classes)
Ci   nbas  :size of basis
Ci   alat  :length scale of lattice and basis vectors, a.u.
Ci   plat  :primitive lattice vectors, in units of alat
Ci   pos   :basis vectors, in units of alat
Ci   slabl :vector of species (or class) labels
Ci   ips   :species (or class) table: site ib belongs to species ips(ib)
Ci   modep :integer vector of length 3 governing how lattice vectors
Ci         :are shortened (shorps).  In particular,
Ci         :0 suppresses shifts along plat(j)
Ci         :2 shifts to minimize length of pos
Ci   z     :table of nuclear charges by species (or class)
Co Outputs
Co   rmt
Cl Local variables
Cl         :
Cr Remarks
Cr   makrm0 attempts to determine an optimal set of muffin-tin radii so
Cr   that the errors due to the muffin-tin approxiation are minimized.
Cr   Inside the MT-spheres the potential should be as spherical as
Cr   posssible, and the potential should be as constant as possible.
Cr
Cr   At present there is only one prescription (mode 1).
Cr   This routine follows the methodology of the Stuttgart code potmax.
Cr
Cr   mode 1 : rmt are chosen as follows:
Cr   1. The free-atom potential is constructed for all species.
Cr   For each atom:
Cr   2. A neighbor table is made for the atom.
Cr   3. The connecting vectors to each neighbor make up a group
Cr         of direction vectors stellating from that atom.
Cr   4. The first occurence of a maximum in the potential along any
Cr         of these vectors determines rmt for the atom
Cr
Cr   Finally, rmt may be averaged over species (or classes).
Cu Updates
Cu   04 Apr 18 bugfix for --getwsr spin polarised
Cu   05 Jul 13 Replace f77 pointers with f90 ones
Cu   21 Apr 02 First created.
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      character*8 slabl(*)
      integer opt,nspec,nbas,ips(nbas),modep(3),lock(*)
      double precision z(nspec),alat,plat(9),pos(3,nbas),rmt(*)
C ... Dynamically allocated local arrays
      real(8), allocatable :: excx(:)
      real(8), allocatable :: excc(:)
      real(8), allocatable :: vxcx(:)
      real(8), allocatable :: vxcc(:)
C ... Local parameters
      character*8 spid,strn*80
      integer nrmx,nxi0,n0,niax,mxcsiz,npmx,pass
      parameter (nrmx=5001,nxi0=10,n0=10,niax=10,mxcsiz=400,npmx=mxcsiz)
      integer nglob,nsp,nxi,nrmix(2),lxcfun,is,opt0,opt1,opt2,opt3
      integer idmod(n0),lmxa,nrmt,nr,ib,nttab,k,ir,np,ipr,stdo,lgunit,nrspec
      integer ntab(nbas+1),iax(niax,mxcsiz),ipa(nbas)
      double precision qc,ccof,ceh,rmtl(nspec),rfoca,rsmfa,qcor(2),
     .  sumec,sumtc,eref,fac,ddot,fpi,etot,basopt(15)
      double precision a(nspec),b(nspec),xx(5)
      double precision pnu(n0,2),pnz(n0,2),qat(n0,2)
      double precision hfc(nxi0,2),exi(nxi0),hfct(nxi0,2)
      double precision rtab(n0,2),etab(n0,2)
      double precision v(nrmx,nspec+1),rho(nrmx,nspec+1),
     .  rhoc(nrmx,nspec+1),rofi(nrmx*2),range(nbas),rmti(nbas)
      double precision vp(npmx,0:2),xp(3,npmx),rp(npmx),
     .  vxcp(npmx),excp(npmx),pnuopt(n0),pzopt(n0)
C     Sets scale for neighbor table
      double precision facr,facri
      parameter (facr=2d0,facri=1.02d0)
C     Relative positions
      double precision rpos(3,mxcsiz),ri,rbar,rmin,vrmax,cur,slo,di,gtop(2)
C     character*1 sym(2)
C ... External calls
      external daxpy,dcopy,defpq,defwsr,dpcopy,dpzero,dscal,evxcv,
     .  freats,getpr,iinit,info,isanrg,pairc,poiss0,poppr,pshpr,psymr0,
     .  rxi,sumsro
C     data sym /' ','*'/

C --- Setup ---
      opt0 = mod(opt,10)
      opt1 = mod(opt/10,10)
      opt2 = mod(opt/100,10)
      opt3 = mod(opt/1000,10)
      call sanrg(.true.,opt0,1,1,'makrm0:','1s digit opt')
      call sanrg(.true.,opt1,0,2,'makrm0:','10s digit opt')
      call sanrg(.true.,opt2,0,1,'makrm0:','100s digit opt')
      call sanrg(.true.,opt3,0,1,'makrm0:','1000s digit opt')
      nsp = nglob('nsp')
      stdo = lgunit(1)
      call getpr(ipr)
      call dpzero(rpos,3*mxcsiz)
      call dpzero(v,nrmx*nspec)
      call dpzero(rho,nrmx*nspec)
      call dpzero(rhoc,nrmx*nspec)
      call dpzero(vp,npmx*3)
      fpi = 16d0*datan(1d0)

C --- Densities and potentials for each species ---
      exi(1) = -1
      exi(2) = -2
      exi(3) = -4
      exi(4) = -6
      exi(5) = -9
      exi(6) = -15
      nxi = 6
      gtop(1) = 0
      gtop(2) = 0
      call dpzero(hfct,2*nxi0)
      nrmix(1) = 80
      nrmix(2) = 2
      lxcfun = 1
      do  is = 1, nspec

C       nrspec(is) = iabs(iclbsj(is,ips,-nbas,nbas))
        spid = slabl(is)
        rsmfa = 1
        rfoca = 1
        qcor(1) = 0
        qcor(2) = 0
        a(is) = .025d0
        call defwsr(rmtl(is),z(is))
C       Patch for Li
C       if (nint(z(is)) == 3) rmtl(is) = 1.75d0*rmtl(is)
        rsmfa = rmtl(is)/2
        rfoca = rmtl(is)/2
        lmxa = 3
        call dpzero(pnu,2*n0)
        call dpzero(pnz,2*n0)
        call dpzero(qat,2*n0)
        call iinit(idmod,n0)
        call dpzero(basopt,10)
        call defpq(0,z(is),lmxa,nsp,pnu,qat)

        !JJ on entry to freats, qat(2) is interpreted as spin
        !difference, not q(spin 2).  Reformulate here:
        if (nsp == 2) call dsumdf(n0,1.d0,qat,0,1,qat,n0,1)

        eref = 0
        nrmt = 0
        call pshpr(ipr-20)
        call freats(spid,is,nxi0,nxi,exi,rfoca,rsmfa,0,-1,qcor,0,nrmix,0,
     .    lxcfun,z(is),rmtl(is),a(is),nrmt,pnu,pnz,qat,[0d0],0d0,0d0,
     .    0d0,idmod,lmxa,eref,basopt,0,rtab,etab,hfc,hfct,nr,rofi,rho(1,is),
     .    rhoc(1,is),qc,ccof,ceh,sumec,sumtc,v(1,is),etot,pnuopt,pzopt,gtop)
        call poppr
        b(is) = rmtl(is)/(dexp(a(is)*(nrmt-1)) - 1d0)
C       Restore 4*pi*r**2*(total density) in array rho
        call daxpy(nrmx*nsp,1d0,rhoc(1,is),1,rho(1,is),1)

C       Use estat potential: overwrite v with estat
        if (opt1 <= 1) then
C         call prrmsh('vtot',rofi,v(1,is),nr,nr,1)
          vrmax = 0
          call poiss0(z(is),a(is),b(is),rofi,rho(1,is),nr,vrmax,v(1,is),
     .      xx(2),xx(4),nsp)
C         call prrmsh('ves',rofi,v(1,is),nr,nr,1)
        endif

C       Overwrite v,rho with proper spherical potential and density
        do  ir = 2, nr
          v(ir,is) = v(ir,is) - 2*z(is)/rofi(ir)
          rho(ir,is) = rho(ir,is)/(fpi*rofi(ir)**2)
        enddo
C       call prrmsh('rho',rofi,rho(1,is),nr,nr,1)
C       call prrmsh('v',rofi,v(1,is),nr,nr,1)
      enddo
C

C ... Sets range for neighbor table
      do  ib = 1, nbas
        is = ips(ib)
        range(ib) = facr * rmtl(is)
      enddo

C --- For each site, find rmti = initial estimate for rmtl ---
      do  ib = 1, nbas

        is = ips(ib)
        spid = slabl(is)

C   ... Neighbor table connecting sites to this one
        nttab = mxcsiz
        call pairc(ib,ib,nbas,modep,20,0,alat,plat,pos,pos,range,-1,1,
     .    nttab,ntab,iax,rpos,k)
        if (nttab > mxcsiz)
     .    call rxi('makrm0 : increase mxcsiz: need',nttab)

C   ... Maximum in potential ( mode 1)
C       Find first maximum along all direction vectors
C       which are proportional to rpos, excluding self (first site).
C       As a conservative choice, choose initial radius = rmtl/4.
        np = nttab-1
        if (nttab > npmx) call rxi('makrm0 : increase npmx: need',nttab)
        call dpzero(xp,3*nttab)
        ri = rmtl(is)/4
        if (z(is) == 0) then
          rmti(ib) = rmtl(is)
          goto 31
        endif

C       Re-entry for loop until maximum in potential found
        pass = 0
   30   continue
C       Make nttab-1 connecting vectors of radius ri
        do  k = 2, nttab
          fac = ri/dsqrt(ddot(3,rpos(1,k),1,rpos(1,k),1))
          call dpcopy(rpos(1,k),xp(1,k-1),1,3,fac)
        enddo

C       Add into vp(1,2) superposition of potentials for each connecting vector
        call sumsro(xp,np,ips,a,b,v,nttab,iax,rpos,vp(1,2))

C       Add vxc[superposition of densities] for each vector
        if (opt1 == 1) then
          call sumsro(xp,np,ips,a,b,rho,nttab,iax,rpos,rp)
          allocate(excx(np),excc(np),vxcx(np),vxcc(np))
          call evxcv(rp,rp,np,1,lxcfun,excp,excx,excc,vxcp,vxcx,vxcc)
          call daxpy(np,1d0,vxcp,1,vp(1,2),1)
          deallocate(excx,excc,vxcx,vxcc)
        endif

C       Check against prior point.  Skip if nothing yet to compare
        if (pass > 0) then
          do  k = 1, nttab-1
C           This loop executes if a maximum is found
            if (vp(k,1) > vp(k,2)) then
C             It shouldn't happen already at the first point
              if (pass == 1) then
                call rx('makrm0: starting r is too small.  Check geometry')
              endif
              rmti(ib) = ri/dsqrt(facri)
              if (pass > 1) then
                cur = vp(k,2) + vp(k,0) - 2*vp(k,1)
                slo = (vp(k,2) - vp(k,0))/2
                di = -slo/cur
                if (dabs(di) < 1) then
C                 print *, pass, di, ri, (ri/facri)*dexp(di*(facri-1))
                  rmti(ib) = (ri/facri)*dexp(di*(facri-1))
                endif
              endif
              goto 31
            endif
          enddo
        endif

C       Copy vp(*,2) to vp(*,1), and increment pass
        call dcopy(npmx,vp(1,1),1,vp(1,0),1)
        call dcopy(npmx,vp(1,2),1,vp(1,1),1)
        pass = pass+1
        ri = ri * facri
        if (ri > 10d0) call rx('makrm0: failed to find maximum in potential')
        goto 30

C       Loop exit: radius rmti(ib) has been found
   31   continue

C       This is the connecting vectory along which the maximum was found
C       iconn = iax(2,k+1)

      enddo

C --- Copy appropriate rmti to final result, depending on opt2 ---
      strn = 'estat'
      if (opt1 == 1) strn = 'LDA'
      if (opt1 == 2) strn = 'sum-of-atomic'
      call info(30,1,0,' makrm0: initial MT radii from first '//
     .  strn(1:20)//'%a potential maximum',0,0)
      call info(30,0,0,'  site   spec%12frmt'//
     .  '%7frmt-%7frmt-%7frold%3flock%N%34f<spec avg>  spec-min',0,0)

C ... First loop for printout only, so can hang on to original rmt
      do  ib = 1, nbas
        is = ips(ib)

        spid = slabl(is)
        call psymr0(-2,-is,nbas,ips,xx,xx,ipa,nrspec)
        rbar = 0
        rmin = 9999
        do  k = 1, nrspec
          rbar = rbar + rmti(ipa(k))/nrspec
          rmin = min(rmin,rmti(ipa(k)))
        enddo
C       Index where to poke rnew
        k = ib
        if (opt2 >= 1) k = is

C        if (ipr >= 30) then
C          write(stdo,344) ib,is,spid,rmti(ib),rmti(ib)-rbar,
C     .      rmti(ib)-rmin,rmt(k), sym(1+mod(lock(k)/2,2))
C  344     format(i5,2x,i3,':',a,4f11.4,3x,a)
C        endif

        call info8(30,0,0,'%,5i%,5i:'//spid//'%;11,4D%;11,4D%;11,4D%;11,4D%?#n#   *##',
     .    ib,is,rmti(ib),rmti(ib)-rbar,rmti(ib)-rmin,rmt(k),mod(lock(k)/2,2),0)
      enddo

C     print *, rmt

      do  ib = 1, nbas
        is = ips(ib)

        spid = slabl(is)
        call psymr0(-2,-is,nbas,ips,xx,xx,ipa,nrspec)
        rbar = 0
        rmin = 9999
        do  k = 1, nrspec
          rbar = rbar + rmti(ipa(k))/nrspec
          rmin = min(rmin,rmti(ipa(k)))
        enddo
C       Index where to poke rnew
        k = ib
        if (opt2 >= 1) k = is

        if (lock(k) /= 2) then
          if (opt2 == 0) rmt(ib) = rmti(ib)
          if (opt2 == 1) rmt(is) = rbar
          if (opt2 == 2) rmt(is) = rmin
        endif
      enddo

      end
