      subroutine rdsigm(mode,nbas,nsp,nlmto,s_ctrl,s_spec,s_lat,s_ham,s_bz,s_gw,ifis,lwsig)
C- Read sigm(k) from file and generate sigm(R)
C ----------------------------------------------------------------------
Cio Structures
Cio  s_ctrl :struct for program flow parameters; see structures.h
Ci     Elts read:  *
Co     Stored:     *
Co     Allocated:  *
Cio    Elts passed:spid
Cio    Passed to:  siged
Cio  s_spec :struct for species-specific data; see structures.h
Ci     Elts read:  idxdn lmxb lmxa ncomp
Co     Stored:     idxdn
Co     Allocated:  *
Cio    Elts passed:*
Cio    Passed to:  siged makidx nscpa
Cio  s_lat  :struct containing lattice information; see structures.h
Ci     Elts read:  plat nsgrp alat pos
Co     Stored:    *
Co     Allocated: *
Cio    Elts passed:plat symgr nsgrp alat pos ag istab
Cio    Passed to:  siged
Cio  s_ham  :struct for parameters defining hamiltonian; see structures.h
Ci     Elts read:  rsrnge ldham sigp rsstol nprs qsig offH
Co     Stored:     ndhrs eseavr nqsig iaxs
Co     Allocated:  nprs iaxs hrs qsig
Cio    Elts passed:iprmb nprs iaxs hrs qsig offH rsrnge
Cio    Passed to:  hft2rs siged
Cio  s_bz   :struct for the Brillouin Zone; see structures.h
Ci     Elts read: nkabc lshft nkp qp
Co     Stored:    *
Co     Allocated: *
Cio    Elts Passed:*
Cio    Passed to: *
Cio  s_gw  :struct for gw-related parameters
Ci     Elts read:  nkabc eseavr lshft
Co     Stored:     eseavr
Co     Allocated:  *
Cio    Elts passed:*
Cio    Passed to:  siged
Ci Inputs
Ci   mode  :1s digit
Ci         :0 do not read self-energy; just exit
Ci         :1 read and FT sigma(k) to make sigma(T)
Ci         :2 symmetrize sigma(T)
Ci         :4 take the real part of sigma(T) only
Ci         :10s digit (used here only for printout)
Ci         :0 Simple bloch sum of sigma
Ci         :1 approx high- and low-energy sigma with diagonal
Ci         :2 perturbation approach, diagonalizing exactly only
Ci         :  the first kappa block.
Ci         :3 Linear interpolation of sigma from neighboring p
Ci         :  sig(q) = sum_i wt_i A+_i sig(qpi) A_i
Ci         :  where A_i = z^LDA_qi (z_q^LDA)^-1
Ci         :100s digit specifies number of interpolation points
Ci         :    for interpolation mode 3.
Ci         :  0 -> use default (4 points)
Ci         :1000s digit specifies ASA conventions:
Ci         :      poke sigm(k)_RL,R'L' -> sigm(T)_RL,R'L'
Ci         :      (10000s digit of hft2rs)
Ci         :10000s digit
Ci         :  1 specifies file sigm stored with no group operations
Ci         :    sigm is stored at k-points in the full BZ.
Ci         :    Equivalent to --rsig:fbz
Ci         :  2 do not force R.S. neighbor table to conform to symmetry
Ci         :  4 do not force file qp to match those generated by bzmesh.
Ci              Use qp from bzmesh.
Ci   nbas  :size of basis
Ci   nsp   :2 for spin-polarized case, otherwise 1
Ci   nlmto :Number of LMTOs in basis
Ci   ifis  :File logical unit for sigma file (q-space only)
Co Outputs:
Co   lwsig :0    No special transformations of sigma
Co         :-1   Mode transforms sigm from LDA to orbital basis
Co         :     (Inverse operation of lwsig=1 or lwsig=2).
Co         :     This mode requires both sigma and LDA eigenvectors go be
Co         :     stored on disk in files 'sigm' and 'evec'
Co         :     rdsigm generates and stores transformation in file 'sigm3'.
Co         :     rdsigm does not return to calling program.
Co         :LW1  Intended to transform sigma from orbital into LDA basis.
Co         :     Returns lwsig=LW1 to flag calling program, which should
Co         :     generate and store transformed sigma.
Co         :LW2  Similar to lwsig=LW1, except low- and high- energy blocks
Co               replaced by diagonal parts.
Co         :LW3  Intended to modify sigm as in mode 2 with low- and high-
Co         :     energy blocks replaced by diagonal parts.  It differs from LW2
Co         :     in that sigm is rotated back to the orbital basis before saving.
Co         :     Returns lwsig=LW3 to flag calling program.
Co         :LW4  Intended to generate LDA eigenvalues and eigenvectors.
Co               Returns lwsig=LW4 to flag calling program, which should
Co         :     generate and store LDA eigenvalues and eigenvectors.
Co         :     No attempt to read the sigm file.
Co         :LW5  Intended to generate QSGW eigenvalues and eigenvectors.
Co               Returns lwsig=LW5 to flag calling program, which should
Co         :     generate and store QSGW eigenvalues and eigenvectors.
Co         :LW6  Similar to LW5, but occupation numbers are also saved.
Co               Designed to extract Hubbard U from self energy.
Co               Returns lwsig=LW6 to flag calling program, which should
Co         :     generate and store these quantities.
Co         :LW7  Reserved (see bndfp.f)
Co         :LW18 (use with lmfgwd)
Co         :     Read vxc from vxc file and write in sigm format, sigm k-point order
Co         :LWU  Makes effective U from Sigma, evecs, occupation numbers
Cl Local variables
Cl   sigp  :parameters for approximating self-energy sigma.  sigma
Cl         :is approximated by its diagonal part sigii for energies
Cl         :below a low-energy cutoff (specified nmin or emin) and
Cl         :above a low-energy cutoff (specified nmax or emax).
Cl         : arg 1: specifies how to set diagonal part sigii
Cl         :        for states above the high-energy cutoff nmax or emax
Cl         :        0 constrain sigii to be > asig+bsig*e
Cl         :        1 constrain sigii to be = asig+bsig*e
Cl         :        2 constrain sigii to be > asig and < bsig
Cl         :        3 constraint same as case 1.
Cl         :          arg1=3 differs in that the least-squares fit to
Cl         :          sigii (for informational purposes only, to help
Cl         :          estimate asig and bsig) is done for states between
Cl         :          efit and nmax or emax
Cl         :        4 fix sigii to given eseavr.  No fitting.
Cl         : arg 2: nmin : sigma for states 1..nmin are approximated by sigii
Cl         : arg 3: emin : (used only if nmin<0)
Cl         :             : sigma for levels e<emin are approximated by sigii
Cl         : arg 4: nmax : sigma for levels i>nmax are approximated by
Cl         :               sigii AND constrained according to mode
Cl         : arg 5: emax : (used only if nmax<=0)
Cl         :             : sigma for levels e<emax are approximated by
Cl         :               sigii AND constrained according to mode
Cl         : arg 6: asig : constraint used to approximate
Cl         :               sigii = asig + E * bsig  or
Cl         :               asig < sigii < bsig
Cl         : arg 7: bsig : constraint used to approximate
Cl         :               sigii = asig + E * bsig  or
Cl         :               asig < sigii < bsig
Cl         : arg 8: efit : (mode 3) energy minimium
Cl                         for fitting asig and bsig (not used here)
Cl   Note  :sigp takes a similar, but slightly different meaning when
Cl         :used in conjunction with sigm(LDA)->sigm(orbital), i.e. lwsig=-1
Cl         :In this case, sigp applies to the new basis, whose
Cl         :eigenvalues and eigenvectors are stored in 'evec.'
Cl         :Arguments are used in rotevs, with the following relations:
Cl         : arg1 (mode) has same meaning as before
Cl         : arg2 (nmin) takes meaning of lcore.
Cl         :       nmin>0 => sigm does not contain this block,  but the
Cl         :                 new basis does.  Use in emin (arg3) in
Cl         :                 place of sigm for this block .
Cl         :       nmin<0 => new basis does not contain this block
Cl         : arg3 (emin) If nmin>0, use emin for diag. sigma, this block
Cl         : arg4, arg5 (nmax,emax) could play the role of lhigh in
Cl         :       rotevs.  However, they are not used.  lhigh is
Cl         :       determined from constraint ndims+lccore+lhigh = ndimz
Cl
Cl   hreal : 0 allow sigm(R) to be complex
Cl         : 1 assume sigm(R) is real
Cl  ltrans :specifies indexing of sigm(T)_RL,R'L'L
Cl         : ltrans = F taken from sigm(k)_RL,R'L'
Cl         : ltrans = T taken from sigm(k)_RL,R'L'
Cl  lrsig  : 1s digit mode
Cl  lrdsig : switches to modify sigm at read time
Cl         : 1 Do not read sigm file; create a template with zero sigm
Cl         : 2 DMFT double counting mode 1  (not used now)
Cl         : 4 DMFT double counting mode 1, spin channel only (commented out now)
Cl  lascii :2, File I/O in ASCII mode
Cl         :OLD 10 No sigm file exists; create a template with zero sigm
Cl  lrsrs  : flag to read sigm in real space
Cl  kcplx  :0 sigm(k) has real, imaginary separated
Cl         :1 sigm(k) is in complex*16 format:
Cl         :2 sigm(k) has real, imaginary separated by columns
Cl  lphase :T if phase convention phi = q * [(g R_j + a) - R_i]
Cl         :  for rotations should be scaled by -1
Cl  lssym  :10000s digit mode
Cl  lfbzin :flags whether input self-energy file has suppressed symops
Cl  nscnts :compound of switches containing file contents of sigma
Cl  qoffi  :k-mesh offset for input sigma file
Cl  qoffo  :k-mesh offset for generated sigma file
Cl  rsrnge :maximum length for connecting vectors in sigma(R)
Cs Command-line switches
Cs   --mixsig= : For self-energy; see Command-line-options.html
Cs   --mlog    : (MPI) write MPI commands to log file
Cs   --rsig    : For reading the self-energy; see Command-line-options.html
Cs   --wsig    : For writing the self-energy; see Command-line-options.html
Cr Remarks
Cr   general hamiltonian may have dimensioning ndham different
Cr   from nlmto.  This routine has no facility to keep them distinct
Cr   so ndham is kept as a local variable, and synchronized with nlmto
Cb Bugs
Cb   Routine should be able to accomodate offset qp case (ifac<>0)
Cb   Routine should be able to accomodate case when a different
Cb   list of irreducible qp is used than the one generated by
Cb   bzmesh.
Cu Updates
Cu   16 Mar 18 Adapt iosigh to include nspc, ndham
Cu   07 Aug 17 Revise to include AFM symmetrization
Cu   09 Dec 15 New --rsig:spinav
Cu   16 Aug 13 New --rsig:rs and --wsig:rs and --symsig
Cu             Large revisions to siged
Cu   22 Jul 13 Large revisions to siged and new --rsig:null
Cu   08 May 13 Initial revisions of siged
Cu   22 Apr 13 First attempt at generating effective W
Cu   01 Dec 11 Enabled (partial) I/O of sigma files in ascii format
Cu   10 Nov 11 Begin migration to f90 structures
Cu   26 Aug 11 Bug fix: when spins are split (lsplts=T)
Cu             eseavr(1) is copied to eseavr(2)
Cu   17 Mar 11 Incorporate eseavr from QSGW output
Cu   27 Jun 08 Redesigned transformation of sigma to new basis
Cu   15 May 07 Parallelized symmetrizer
Cu   24 Jan 07 New option --wsig:onesp
Cu   20 Jan 07 Bug fix, --mixsig, spin polarized case
Cu   16 Jan 07 New option lwsig=-1; updated iosigh
Cu   24 Jul 06 MPI broadcast of sigma
Cu   24 Feb 05 Rotation of sigma matrix now in hrs
Cu             Switch lwsig to flag transformed sigm to be generated
Cu   27 Jan 05 New 40000s digit mode (allow qp mismatch)
Cu   20 Dec 04 New --wsig:rot and --wsig:phase switches
Cu             New 10000s digit mode
Cu   22 Nov 04 New --wsig:newkp switch
Cu   25 Sep 04 rdsigm can read sigm(q) file for offset q-mesh
Cu             rdsigm can write sigm(q) for mesh sbz->nkabc
Cu    5 Apr 04 bug fix for --wsig switch.  New --mixsig switch
Cu   15 Feb 04 Enable rdsigm to read a linear combination of
Cu             data from file ifis and data from file 'sigm1'
Cu    4 Jan 04 rdsigm checks bloch sum against ham->rsstol
Cu   10 Oct 03 rdsigm can spin-split a non-spin-polarized sigma
Cu   23 Sep 03 rdsigm can now read sigm fit to ASA hamiltonian
Cu   11 Jul 03 enable write of sigma to full BZ
Cu   24 May 03 Redesigned switches in accord with new interpolation
Cu   09 May 03 Added symmetrization of sigma
Cu   10 Jan 03 Some adaptations for Sergey's interpolation
Cu   14 Aug 02 Added option to orthogonalize sigm.
Cu   27 Jul 02 first created
C ------------------------------------------------------------
      use structures
      implicit none
C ... Passed parameters
      integer mode,nbas,ifis,nlmto,lwsig
C ... For structures
!      include 'structures.h'
      type(str_ctrl)::  s_ctrl
      type(str_spec)::  s_spec(*)
      type(str_lat)::   s_lat
      type(str_ham)::   s_ham
      type(str_bz)::    s_bz
      type(str_gw)::    s_gw
C ... Dynamically allocated local arrays
      integer,allocatable::  igstar(:),ipq(:),istb2(:,:)
      real(8),allocatable:: evls(:),evlz(:),sigii(:),hrss(:)
      real(8),allocatable:: occnum(:),wtkp(:),delT(:)
      real(8),pointer::  qpgw(:,:)
      complex(8),allocatable:: siglda(:,:),z(:,:),sigo(:,:),sfz(:)
C     complex(8),allocatable:: sibz(:,:,:),vxibz(:,:,:)
      complex(8),allocatable:: sigm(:,:),sigm2(:,:),sigmwk(:),weff(:,:)
C ... Local parameters
      logical llshft(3),ltrans,lphase,lsplts,lnwmsh,
     .  lfbzin,lfbzout,ltmp,isanrg,lsumk,lrsrs,lrsw,qpmismatchok
C     logical DMFTdc
      character outs*150,out2*80,dc*1,rots*120,fn*10
      integer parg,isw,lonesp,lrdsig,lascii
      integer hreal,i,ifis2,ifiz,iprint,iq,iq1,isp,ix,j,j1,k1,k2,
     .  k3,kcplx,lcore,ledit,lhigh,lrot,lrsig,lssym,moditp,modsgp,mxkp,
     .  mxorb,ndhrs,ndims,ndimz,nk1,nk2,nk3,nl,nmax,nmin,nqp,
     .  nqps,nqsig,nscnts,nsgrp,nsgrps,nsp,nspc,nttabs,stdo,nsafm,ndham
      integer ldham(16),n123(4),nkxyz(3)
      integer, parameter :: niax=10
      integer, parameter :: LW1=1,LW2=2,LW3=3,LW4=4,LW5=5,LW6=6,LW18=18,LWU=10
      equivalence (nk1,nkxyz(1)),(nk2,nkxyz(2)),(nk3,nkxyz(3))
      double precision tmp(3),eseavr(2),eseavr2(2),rsrnge
      integer, parameter :: NULLI=-99999
C     For offset q mesh
      integer is(3),lshft(3),ifac(3),lqoffo
      double precision rb(3,3),qb(3,3),qoffi(3),qoffo(3)
      procedure(logical) :: cmdopt,latvec
      procedure(integer) :: nglob,fopna,fopnx,fxst,idalloc,allocvb
      procedure(real(8)) :: dlength
C ... for MPI
      logical mlog
      integer procid,mpipid,master
C ... for mixing sigma files: Use alf1*sigm + alf2*sigm1
C     double complex cxx
      double precision alf(2)
      double precision plat(3,3),qp(3),tolq,rsstol,sigp(10),xx(2)
      double precision emin,emax,asig,bsig,efit,qoff(3),rotm(3,3),ddot
      double precision sfuzz ! tolerance in site positions mismatch
      equivalence (emin,sigp(3)),(emax,sigp(5))
      equivalence (asig,sigp(6)),(bsig,sigp(7)),(efit,sigp(8))
C Given (j1,j2,j3) of ipq, q_k(j1,j2,j3) =  sum_i (j_i*ifac(i)-1)*qb(k,i)
      double precision qk
      integer jj1,jj2,jj3,k
C ... Heap
      qk(k,jj1,jj2,jj3) = (jj1*ifac(1)-1)*qb(k,1) +
     .                    (jj2*ifac(2)-1)*qb(k,2) +
     .                    (jj3*ifac(3)-1)*qb(k,3)

C --- Setup and printout ---
      procid = mpipid(1)
      master = 0
      mlog = cmdopt('--mlog',6,0,outs)
      nullify(qpgw)

      tolq = 1d-6  ! allowed fuzz in qp
      sfuzz = 1d-6 ! allowed fuzz in site positions when reading sigrs
      stdo = nglob('stdo')
      ledit = 0
      lrsig = mod(mode,10)
      if (mod(lrsig,4) >= 2) lrsig = lrsig + 1 - IAND(lrsig,1)
      if (cmdopt('--symsig',8,0,outs)) then
        lrsig = lrsig + 2 - IAND(lrsig,2)
        if (cmdopt('--symsig=no',10,0,outs)) lrsig = lrsig-2
      endif

      lwsig = 0
      lsumk = .false.
      moditp = mod(mode/10,10)
      alf(1) = 1
      alf(2) = 0
      nscnts = 0
      lqoffo = 0
      lfbzout = .false.
      rsrnge = s_ham%rsrnge

C     Switch flagging whether input file has symops or not
      hreal = 0
      if (lrsig >= 4) hreal = 1
      if (lrsig == 0) return

      ltrans = mod(mode/1000,10) == 0
      kcplx = 1
      if (mod(mode/1000,10) == 1) kcplx = 0
      lphase = mod(mode/1000,10) == 0
      lssym = mod(mode/10000,10)
      ltmp = isanrg(lssym,0,7,'rdsigm:','10000s digit mode',.true.)

C ... Command-line switches for input sigma and defaults
      call sigflg(' ','rsig',' ',ix,ix,ix,lfbzin,ltmp,lonesp,lrdsig,lascii,
     .  lrsrs,lsumk,qpmismatchok,qoffi,rots,sfuzz)
      if (cmdopt('--rsig',6,0,outs)) then
        out2 = outs(7:)
        dc = out2(1:1)
        call sigflg(dc,'rsig',out2,ix,ix,ix,lfbzin,ltmp,lonesp,lrdsig,lascii,
     .    lrsrs,lsumk,qpmismatchok,qoffi,rots,sfuzz)
C        if (lfbzin .and. mod(lssym,2) == 0) then
C          lssym = lssym+1
C        endif
      endif
      lfbzin = lfbzin .or. mod(lssym,2) /= 0
      if (qpmismatchok) lssym = mod(lssym,4) + 4
C     DMFTdc = lrdsig == 4

      if (cmdopt('--mixsig=',9,0,outs)) then
C       if (DMFTdc) call rx('DMFT modes cannot be used with --mixsig')
        j = 0
        i = parg('--mixsig=',4,outs,j,len(outs),', ',2,2,ifac,alf)
        if (i /= 1 .and. i /= 2) call rx
     .    ('rdsigm: failed to parse arguments to --mixsig=')
      endif

C ... Printout information pertaining to how sigma is read or used
      if (lrsrs) then
        call info5(10,1,0,' RDSIGM: '//
     .    '%?#n==1#create null#read#%-1j file '//
     .    '%?#n==2#sigma(R) (ascii)#sigm(R)# ...',lrdsig,lascii,hreal,0,0)
      else
        i = NULLI ! When compiled with checks, MPI mode will barf unless i is initialized
        if (procid == master) then
          i = fopnx(outs,194,0,ifis) ! This is the file name
        endif
        call mpibc1(i,1,2,mlog,'rdsigm','ifi')
        call mpibc1(ifis,1,2,mlog,'rdsigm','ifi')
        if (i /= 0) call rxi('rdsigm: no name associated with file logical unit',ifis)
        call info5(10,1,0,' RDSIGM: '//
     .    '%?#n==1#create null#read# file '//
     .    '%?#n==2#sigma (ascii)#'//trim(outs)//'#'//
     .    '%?#n==4# removing DMFT magnetic double counting##'//
     .    ' and create %?#n#REAL#COMPLEX# sigma(R) by FT ...',lrdsig,lascii,hreal,0,0)
        if (procid == master) then
          i = fxst(trim(outs)) ! 0 if file does not exist
        endif
        call mpibc1(i,1,2,mlog,'rdsigm','ifi')
        if (i == 0) then
          call info0(10,0,0,' (warning) no sigm file ... LDA calculation only')
          mode = 0
          return
        endif
        if (procid == master) ifis = fopna('sigm',ifis,4)

      endif
C      if (lrdsig == 4) then  ! This branch has been commented out
C        call info2(10,0,0,'%?#n==4#%9premove magnetic double counting (requires vxcsig)##',lrdsig,0)
C      endif
      ldham = s_ham%ldham
      sigp = s_ham%sigp
      rsstol = s_ham%rsstol
      modsgp = nint(sigp(1))
      nmin   = nint(sigp(2))
      nmax   = nint(sigp(4))
      call info2(30,0,0,
     .  '%9fSigm will be approximated by:  '//
     .  '%?#(n==0)#Simple bloch sum##%-1j'//
     .  '%?#(n==1)#diagonal Sigma for high and low states##%-1j'//
     .  '%?#(n==2)#Perturbation for higher kappa blocks##%-1j'//
     .  '%?#(n==3)#Interpolation from known points##%-1j'//
     .  ' ',moditp,0)
      if (moditp == 1 .or. moditp == 2) then
        call info5(30,0,0,
     .    '%9fApproximate sigma '//
     .    '%?#(n<0)#for energies E(lda)<%d; and %-2j#%-1j#'//
     .    '%?#(n>0)#for states up to %-1jn=%i; and ##%j'//
     .    '%?#(n<=0)#for energies E(lda)>%d%-1j#%-1j#'//
     .    '%?#(n>0)#for states above %-1jn=%i##%j',
     .    nmin,emin,nmax,emax,0)
        call info5(30,0,0,'%9fFor high states '//
     .    '%?#(n==0)#Sigii > %,3;4d + %,3;4d * E(lda)%-2j##%-1j'//
     .    '%?#(n==1)#Sigii = %,3;4d + %,3;4d * E(lda)%-2j##%-1j'//
     .    '%?#(n==3)#Sigii = %,3;4d + %,3;4d * E(lda)%-2j##%-1j'//
     .    '%?#(n==4)#read constant sigii from sigm file##%-1j'//
     .    '%?#(n==2)#%,3;4d < Sigii < %,3;4d%-1j##%-1j'//
     .    ' ',modsgp,asig,bsig,0,0)
        if (nmax > 0 .and. modsgp < 4) call info5(30,0,0,
     .    '%9fLinear fit to diagonal sigma for E(lda)>%d'//
     .    '%?#(n==3)# and n<%i'//
     .    ' ',efit,modsgp,nmax,0,0)
        if (nmax == 0 .and. modsgp < 4) call info5(30,0,0,
     .    '%9fLinear fit to diagonal sigma for E(lda)>%d'//
     .    '%?#(n==3)# and E(lda)<%d'//
     .    ' ',efit,modsgp,emax,0,0)
        ltmp = isanrg(modsgp,0,4,'rdsigm:','sig fit mode',.true.)
      endif
      if (lfbzin .or. ddot(3,qoffi,1,qoffi,1) /= 0) then
        call info5(30,0,0,
     .  '%?#(n==1)#%9fFile sigm in saved in FBZ: '//
     .  'symmetrization suppressed##'//
     .  '%?#(n==1)#%N%9fFile k-mesh is offset by:%3:2g#%j#'//
     .  ' ',isw(lfbzin),isw(ddot(3,qoffi,1,qoffi,1) /= 0),qoffi,0,0)
        endif
      if (alf(1) /= 1 .or. alf(2) /= 0) then
        call info5(30,0,0,
     .    '%9fUse for sigma: %d*(file sigm)%?#n# + '//
     .    '%d*(file sigm1)',alf(1),isw(alf(2) /= 0),alf(2),0,0)
      endif

C ... Setup for sigm transformation modes
      if (cmdopt('--wsig',6,0,outs) .or. cmdopt('-wsig',5,0,outs)) then
      if (procid == master) then
        out2 = outs(7:)
        if (outs(1:5) == '-wsig') out2 = outs(6:)
        dc = out2(1:1)
        call sigflg(dc,'wsig',out2,ledit,lwsig,lrot,lfbzout,lnwmsh,
     .    lonesp,ix,i,lrsw,lsumk,qpmismatchok,qoffo,rots,sfuzz)
        lqoffo = isw(ddot(3,qoffo,1,qoffo,1) /= 0)
        if (lwsig == LW6 .and. lqoffo /= 0) call rx('offset q not allowed with trans=6')

C       Setup, sigm transformation modes
        if (lwsig /= 0) then

          call info5(10,0,0,
     .      '%9ftrans=%i:%19p'//
     .      '%?#(n==-1)#transform sigm, LDA -> orbital basis (file sigm3)##%-1j'//
     .      '%?#(n==1|n==2)#transform sigm, orbital -> LDA basis (file sigm2)##%-1j'//
     .      '%?#(n==3)#transform sigm, orbital -> orbital basis (file sigm2)##%-1j'//
     .      '%?#(n==2|n==3)#%N%19fhigh-energy block approximated by a diagonal matrix##%-1j'//
     .      '%?#(n==4)#make LDA eigenvalues, eigenvectors##%-1j'//
     .      '%?#(n==5)#make eigenvalues, eigenvectors##%-1j'//
     .      '%?#(n==6)#make QSGW evals, evecs, dmat##%-1j'//
     .      '%?#(n==18)#read vxc and write in vxssig##%-1j'//
     .      '%?#(n==10)#transform sigm to effective U, '//
     .      'orbital basis (file weff)##%-1j'//
     .      '%j%?#(n==1)#%N%19fshift k-mesh by%3:2g#%j#'//
     .      '%?#(n==1)#%N%19fsigma in FBZ##'//
     .      ' ',lwsig,lwsig,lqoffo,qoffo,isw(lfbzout))

          call rxx(i /= 0,'this mode may not be used with "ascii"')

C     ... Transform sigm(orbital) -> U(orbital)
          if (lwsig == LWU) then

C           Read dimension of hamiltonian in evec file
C           Check that evec file contains LDA eigenvectors
            call info0(30,0,0,'%9fchecking compatibility between sigm, evec files ...')
            ifiz = fopna('evec',-1,4)
            rewind ifiz
            call iosigh(2,6,i,k,ndimz,ndimz,nk1,nk2,nk3,nqp,iq,lshft(1),lshft(2),lshft(3),ifiz,xx)
            ltmp = isanrg(i,nsp,nsp,'rdsigm','file nsp (evec)',.true.)
            ltmp = isanrg(k,nspc,nspc,'rdsigm','file nspc (evec)',.true.)
            call iosigh(3,0,nsp,nspc,ndimz,ndimz,nk1,nk2,nk3,nqp,iq,lshft(1),lshft(2),lshft(3),ifis,eseavr)
            allocate(sigo(ndimz,ndimz),weff(ndimz,ndimz),z(ndimz,ndimz))
            allocate(sigmwk(ndimz*ndimz))
            allocate(occnum(ndimz))
C
C           Write header for weff
            ifis2 = fopna('weff',-1,4)
            call iosigh(0,10,nsp,nspc,ndimz,ndimz,nk1,nk2,nk3,nqp,0,lshft(1),lshft(2),lshft(3),-ifis2,eseavr)
            ndims = ndimz

C           For each qp, do transformation
            do  iq = 1, nqp
C             Sanity check: qp must match
              read(ifis) qp
              read(ifiz) tmp
              if (dlength(3,qp-tmp,1) > tolq) then
                print 456, iq,tmp,qp
                call rx(' incompatible q-mesh')
              endif
              call dpdump(sigmwk,ndims**2*2,ifis)
              call dpdump(occnum,ndimz,ifiz) ! Skip over evals
              call dpdump(occnum,ndimz,ifiz) ! Occupation numbers
              call dpdump(z,ndimz**2*2,ifiz)

C             call zprm('Z',2,z,ndimz,ndimz,ndimz)
C             call zprm('sigm',2,sigmwk,ndimz,ndimz,ndimz)
C             sig^PQ stored temporarily in sigo.  weff =  work array
              call phmbls(1,ndimz,ndimz,xx,xx,weff,sigmwk,z,z,sigo)
C             Scale by U = x Sigm + Sigm x, x = (1/2 - n)^-1
              call rotevs(5,ndimz,ndimz,0,0,occnum,sigo,xx,xx,sigmwk)
C             call zprm('1/(1-2/n)*sigm(QP)',2,sigmwk,nlmto,nlmto,nlmto)
C             Invert eigenvectors
              call phmbls(32,ndimz,ndimz,xx,xx,sigo,xx,z,z,xx)
C             Rotate to orbital basis, store in weff
              call phmbls(1,ndimz,ndimz,xx,xx,sigo,sigmwk,z,z,weff)
              write(ifis2) qp, dble(NULLI)
              call dpdump(weff,ndimz**2*2,-ifis2)
              call info5(30,0,0,' rdsigm:  kpt %i of %i, k=%3:2,5;5d',iq,nqp,qp,0,0)
            enddo
            deallocate(sigo,weff,z,sigmwk,occnum)
            call rx0('RDSIGM:  Effective W saved in file weff')
          endif

C     ... Transform sigm(lda)->sigm(orbital)
          if (lwsig == -1) then

C         Read dimension of hamiltonian in evec file
C         Check that evec file contains LDA eigenvectors
          call info0(30,0,0,'%9fchecking compatibility between sigm2, evec files ...')
          ifiz = fopna('evec',-1,4)
          rewind ifiz
          call iosigh(2,LW4,i,k,ndimz,ndimz,nk1,nk2,nk3,nqp,iq,lshft(1),lshft(2),lshft(3),ifiz,xx)
C         Verify that sigm2 file contains sigm(LDA); read dimension
          ifis = fopna('sigm2',-1,4)
          call iosigh(0,nscnts,i,k,ndims,ndims,nk1,nk2,nk3,nqp,iq,lshft(1),lshft(2),lshft(3),ifis,eseavr)
          if (nscnts /= 1 .and. nscnts /= 2)
     .      call rx1('File sigm2 (trans=%i) does not contain sigm(LDA): create with trans=1 or 2',nscnts)
C         Check that evec file matches (nsp,nqp)
          rewind ifiz
          if (lfbzin) nqp = nk1*nk2*nk3
          call iosigh(3,LW4,i,k,ndimz,ndimz,nk1,nk2,nk3,nqp,iq,lshft(1),lshft(2),lshft(3),ifiz,xx)

          allocate(evls(ndims),evlz(ndimz),sigii(ndimz))
          allocate(siglda(ndims,ndims),z(ndimz,ndimz),sigo(ndimz,ndimz))

C         Write header for sigm3
          ifis2 = fopna('sigm3',-1,4)
          call iosigh(0,0,nsp,nspc,ndimz,ndimz,nk1,nk2,nk3,nqp,0,lshft(1),lshft(2),lshft(3),-ifis2,eseavr)

C         For each qp, rotate sigm(lda)->sigm(orb)
          do  iq = 1, nqp
C         Check that qp match
          read(ifis) qp
          read(ifiz) tmp
          call daxpy(3,-1d0,qp,1,tmp,1)
          if (ddot(3,tmp,1,tmp,1) > 1d-9) call rx('rdsigm : qp mismatch, files sigm and evec')
          call dpdump(evls,nlmto,ifis)
          call dpdump(siglda,ndims**2*2,ifis)
          call dpdump(evlz,ndimz,ifiz)
          call dpdump(z,ndimz**2*2,ifiz)
          call info5(30,0,0,' rdsigm:  kpt %i of %i, k=%3:2,5;5d',iq,nqp,qp,0,0)
          write(stdo,542)
  542     format(8x,'Elda(evec)   Elda(sig)    diff       sig_ii',
     .      '      a+b*Elda')
          do  i = 1, ndimz
            write(stdo,543) i,evlz(i),evls(i),evlz(i)-evls(i),dble(siglda(i,i)),asig+bsig*evlz(i)
  543       format(i5,5f12.6)
          enddo

C          print *, '!!'; sigp(2) = 2

C         Determine lhigh = ndimz - ndims - lcore
C         sigp(4) = nmax = ndimz - lhigh = ndims + lcore
          sigp(4) = ndims + sigp(2)

C          print *, '!!'; ndimz = ndimz+5
C          deallocate(evlz,sigii)
C          allocate(evlz(ndimz),sigii(ndimz))
C          evlz = evls(ndims)+1
C          evlz(1:2) = -99
C          evlz(1+2:ndims+2) = evls(1:ndims)
C          evlz(ndimz) = 11

          call dpzero(sigii,ndimz)
          call psigd(1,ndimz,tmp,evlz,sigp,n123,sigii)
          lcore = nint(sigp(2))
          lhigh = ndimz - ndims - lcore
          call rotevs(1,ndimz,ndims,lcore,lhigh,xx,siglda,sigii,z,sigo)
          ifis2 = fopna('sigm3',-1,4)
          write(ifis2) qp, dble(NULLI)
          call dpdump(sigo,nlmto**2*2,-ifis2)
          enddo

          deallocate(evls,evlz,sigii)
          deallocate(siglda,z,sigo)

          call rx0('RDSIGM:  sigm(orbital basis) saved in file sigm3')

          endif

C         No sigma for LDA eigenvectors; early exit
          if (lwsig == LW4) return

        endif
      endif
      endif

      call tcn('rdsigm')

C --- Read sigma(orbital basis) from file ---

C ... Read k-mesh parameters
      if (procid == master) then
        if (lrdsig == 1) then ! create NULL sigm with contents 0
          nkxyz = s_gw%nkabc
          lshft = 0
          nscnts = 0
          i = nsp
          call bzmshp(' RDSIGM',-1,nkxyz,lshft,s_lat%plat,s_lat%symgr,
     .      s_lat%nsgrp,s_lat%nsgrp,lfbzin,0,0,qb,nqp,tmp,tmp,tmp,tmp)
          eseavr(1) = 0
        else
C          if (lrsrs .and. lascii == 2) then
C            ifis = fopna('sigmars',-1,0)
C          elseif (lrsrs) then
C            ifis = fopna('sigmrs',-1,4)
C          elseif (lascii == 2) then
C            ifis = fopna('sigma',-1,0)
C          endif
C         Initial read of header contents
          call iosigh(lascii*10,nscnts,i,k,j1,j,nk1,nk2,nk3,nqp,iq,lshft(1),lshft(2),lshft(3),ifis,xx)
C         Cases when file must be binary
          if (lrsrs .neqv. mod(nscnts/100,10) /= 0) call rx('unexpected file format (RS or k)')
          if (lrsrs) then
            if (mod(nscnts,100) /= 0) call rx('R.S. format applicable only to sigma at present')
          else
            if (nscnts /= 0 .and. mod(nscnts,10) /= LW3) then
            call rxx(lascii /= 0,'mode may not be used with "ascii"')
C           Require that file contains sigm(orbital basis)
            call iosigh(2,0,i,k,j1,j,nk1,nk2,nk3,nqp,iq,lshft(1),lshft(2),lshft(3),ifis,xx)
            endif
          endif
        endif
      endif

      call mpibc1(i,1,2,.false.,'rdsigm','nsp')
      call mpibc1(nkxyz,3,2,mlog,'rdsigm','nkxyz')
      call mpibc1(nqp,1,2,mlog,'rdsigm','nqp')
      call mpibc1(lshft,3,2,mlog,'rdsigm','lshft')
      if (i == nsp) then
        lsplts = .false.
      elseif (i > nsp) then
        call rx('rdsigm: sigm file spin polarized but calculation is not')
      else
        lsplts = .true.
      endif

C ... Check for consistency in remaining nlmto, nqp, read eseavr
C     and set file sigma file pointer past header.  ndham not used now
      if (procid == master .and. lrdsig /= 1) then
        rewind ifis
        if (lfbzin) nqp = nk1*nk2*nk3
        ndham = nlmto
        call iosigh(lascii*10+3,nscnts,i,k,ndham,nlmto,nk1,nk2,nk3,nqp,iq,lshft(1),lshft(2),lshft(3),ifis,eseavr)
        if (lsplts) eseavr(2) = eseavr(1)
        if (alf(2) /= 0 .and. eseavr(1) /= NULLI) then
          call rxx(lrsrs,'mixsigm not ready with RS format')
          ifis2 = fopna('sigm1',-1,4)
          rewind ifis2
          ndham = nlmto
          call iosigh(3,0,i,k,ndham,nlmto,nk1,nk2,nk3,nqp,iq,lshft(1),lshft(2),lshft(3),ifis2,eseavr2)
          if (lsplts) eseavr2(2) = eseavr2(1)
          if (eseavr2(1) == NULLI) then
            call info0(30,0,0,'%9f(warning) sigm1 missing average SE ... set to NULL')
            eseavr(1) = NULLI
            eseavr(2) = NULLI
          else
          endif
        else
          eseavr2(1) = 0
          eseavr2(2) = 0
        endif
        if ((alf(1) /= 1 .or. alf(2) /= 0) .and. eseavr(1) /= NULLI)then
          call info2(30,0,0,'%9faverage SE read from sigm file:  '//
     .      '%?#(n==1)# %,6;6d#%2:1,6;6d#',nsp,eseavr)
          call info2(30,0,0,'%9faverage SE read from sigm1 file: '//
     .      '%?#(n==1)# %,6;6d#%2:1,6;6d#',nsp,eseavr2)
          do  i = 1, nsp
            eseavr(i) = alf(1)*eseavr(i) + alf(2)*eseavr2(i)
          enddo
        endif
      endif
      call mpibc1(nkxyz,3,2,mlog,'rdsigm','nkxyz')
      call mpibc1(nqp,1,2,mlog,'rdsigm','nqp')
      call mpibc1(lshft,3,2,mlog,'rdsigm','lshft')
      call mpibc1(eseavr,nsp,4,mlog,'rdsigm','eseavr')
      call info5(30,0,0,'%9fsigm file has %i irreducible QP: nk ='//
     .    ' ( %i %i %i )  shift=%3:1l',nqp,nk1,nk2,nk3,lshft)
      call info2(30,0,0,'%9faverage SE read from sigm file:  %?#(n==1)# %,6;6d#%2:1,6;6d#',nsp,eseavr)
C      call info2(30,0,0,'%9fsigm file '//
C     .  '%?#(n==0)#contains# does not contain#%-1j average SE'//
C     .  '%?#(n==0)# = %,6;6d##',isw(eseavr(1) == NULLI),eseavr)
C     Sanity checks
C     call rxx(modsgp == 4,'rdsigm: average SE missing from sigm file:'
C    .  //' cannot use SIGP_MODE=4')
      if (lsplts) call info0(30,0,0,'%9f(warning) sigm file not spin pol .. splitting spins')

C --- Setup for r.s. hamiltonian ---
      plat = s_lat%plat
      nsgrp = s_lat%nsgrp
C     Get leading dimension of hrs
      call offsHp(s_ham%iprmb,1,nbas,2,0,nlmto,0,ndhrs)
C     Setup for FFT
      call fftz30(nk1,nk2,nk3,k1,k2,k3)
      if (nk1 /= k1 .or. nk2 /= k2 .or. nk3 /= k3) call rx(
     .  'rdsigm: not ready for FFT w/ dimensions ne no div.')
C ... Number of group operations for input file sigma
      if (mod(lssym,2) == 0) nsgrps = nsgrp
      if (mod(lssym,2) == 1) nsgrps = 1
      if (lfbzin) nsgrps = 1
C ... Make is,ifac,qb,qlat,qoff
      do  i = 1, 3
        llshft(i) = lshft(i) /= 0
      enddo
      call pshpr(1)
      call bzmsh0(plat,llshft,0,nk1,nk2,nk3,is,ifac,rb,qb)
      call poppr
      do  i = 1, 3
        qoff(i) = qk(i,1,1,1) + qoffi(i)
      enddo

C ... Case read sigm directly in r.s.
      if (lrsrs) then
C       Get hreal,nttabs; pointer returned to top of R.S. header
        if (procid == master) then
          allocate(s_ham%nprs(1),s_ham%iaxs(1),s_ham%hrs(1)); nttabs = 0 ! Avoid compiler complaints
          call iosigrs(lascii*10+1,i,sfuzz,hreal,nsp,nbas,ndhrs,nttabs,
     .      s_lat%alat,plat,s_lat%pos,s_ham%nprs,s_ham%iaxs,s_ham%hrs,ifis)
          deallocate(s_ham%nprs,s_ham%iaxs,s_ham%hrs)
        endif
        call mpibc1(hreal,1,2,.false.,'rdsigm','hreal')
        call mpibc1(nttabs,1,2,.false.,'rdsigm','nttabs')

C       Allocate arrays for R.S. sigma
        s_ham%ndhrs = ndhrs
        s_ham%eseavr = eseavr
        call ptr_ham(s_ham,1,'nprs',nbas+1,0,xx)
        call ptr_ham(s_ham,1,'iaxs',niax*nttabs,0,xx)
        i = 2; if (hreal == 1) i = 1
        call ptr_ham(s_ham,1,'hrs',i*ndhrs**2*nttabs*nsp,0,xx)

C       Check for consistency with other file data
C     call iosigrs(-(lascii*10+7),0,sfuzz,hreal,nsp,nbas,ndhrs,nttabs,
C     .    s_lat%alat,plat,s_lat%pos,s_ham%nprs,s_ham%iaxs,
C     .    s_ham%hrs,ifis)
C        call iosigrs(lascii*10+8,0,sfuzz,hreal,nsp,nbas,ndhrs,nttabs,
C     .    s_lat%alat,plat,s_lat%pos,s_ham%nprs,s_ham%iaxs,
C     .    s_ham%hrs,ifis)
C       stop

C       Check for consistency in remaining parameters; read nprs,iax,hrs
        if (procid == master) then
        call iosigrs(lascii*10+0,100,sfuzz,hreal,nsp,nbas,ndhrs,nttabs,
     .      s_lat%alat,plat,s_lat%pos,s_ham%nprs,s_ham%iaxs,s_ham%hrs,ifis)
        if (alf(1) /= 1) call dscal(size(s_ham%hrs),alf,s_ham%hrs,1)
        call fclose(ifis)
        endif
        call mpibc1(s_ham%nprs,nbas+1,2,mlog,'rdsigm','ntabs')
        call mpibc1(s_ham%iaxs,niax*nttabs,2,mlog,'rdsigm','iaxs')
        i = ndhrs**2*nttabs*nsp; if (hreal == 0) i = i*2
        call mpibc1(s_ham%hrs,i,4,mlog,'rdsigm','hrs')
        if (alf(2) /= 0) call rx('cannot read second sigma with --rs option')
        goto 50 ! bypass k-space read and FT
      endif

C ... Setup for r.s. hamiltonian: allocate and create iax,ntab; allocate hrs
      i = 1000 + 10*hreal + 0
C      print *, '!!'; i = 1000*0 + 10*hreal + 0
      if (mod(lssym,4) >= 2) i = 10*hreal + 0
      if (ltrans) i = i + 10000
      call ptr_ham(s_ham,8+1,'nprs',nbas+1,0,xx)
      call hft2rs(i,s_ham,nk1,nk2,nk3,k1,k2,k3,qoff,1,nsp,nbas,s_lat%symgr,
     .  s_lat%ag,nsgrp,rsrnge,1,nbas,nlmto,nlmto,xx,plat,s_lat%pos,ndhrs,xx)
      nttabs = s_ham%nprs(nbas+1)
C     Allocate memory for hrs
      if (hreal == 1) then
        call ptr_ham(s_ham,8+1,'hrs',ndhrs**2*nttabs*nsp,0,xx)
      else
        call ptr_ham(s_ham,8+1,'hrs',2*ndhrs**2*nttabs*nsp,0,xx)
      endif

C --- Get list of irreducible k-points, and ipq and gstar arrays ---
      mxkp = nk1*nk2*nk3
      call ptr_ham(s_ham,1,'qsig',3,mxkp,xx)
      allocate(qpgw(3,mxkp))
      allocate(igstar(mxkp+1))
      call iinit(igstar,mxkp+1); igstar(1) = -2
      allocate(ipq(mxkp),wtkp(mxkp)); wtkp(1)=0
      call info(20,1,0,' q-points in full BZ where sigma calculable ...',0,0)
      call bzmesh(plat,qb,nk1,nk2,nk3,llshft,xx,0,ipq,s_ham%qsig,wtkp,nqsig,mxkp,0,0)
      s_ham%nqsig = nqsig
      call dpzero(wtkp,mxkp)
      call info2(20,0,0,' Irr. qp for which sigma is calculated ...',0,0)
      call bzmesh(plat,qb,nk1,nk2,nk3,llshft,s_lat%symgr,nsgrps,ipq,
     .  qpgw,wtkp,nqps,mxkp,igstar,0)
      ltmp = isanrg(nqp,nqps,nqps,'rdsigm','file sigm nqp',.true.)
C     call prmx('q for which sigma is read',qpgw,3,3,nqp)
      call info2(30,0,0,'%?#(n==1)#%1fFile sigm has k-offset=%3:2g '//
     .  'relative to the above#%j# ',isw(ddot(3,qoffi,1,qoffi,1) /= 0),qoffi)
      deallocate(wtkp)

C --- Remove magnetic part of sigma ---
C      if (DMFTdc) then
C        if (lsplts) call rx('RDSIGM: dmfts1 not compatible with lsplts')
C        if (nsp == 1) call rx('RDSIGM: dmfts1 specified but calculation has no spin')
CC       allocate(sigm2(nlmto**2),sibz(nlmto**2,nqps,nsp))
C        allocate(sigm(2),sibz(nlmto**2,nqps,nsp),vxibz(nlmto**2,nqps,nsp))
C        call rxx(lrsrs,'DMFTdc not ready with RS format')
C        ifis2 = fopna('vxcsig',-1,4)
C        rewind ifis2
C        ndham = nlmto
C        call iosigh(3,8,nsp,nspc,ndham,nlmto,nk1,nk2,nk3,nqp,i,lshft(1),lshft(2),lshft(3),ifis2,eseavr2)
C        i = nlmto**2*2
C        do  isp = 1, nsp
C          do  iq1 = 1, nqps
C            read(ifis) qp
C            read(ifis2) tmp
C            if (dlength(3,qp-tmp,1) > 1d-6) call rx('sigm and vxcsig mismatch')
C            call dpdump(sibz(1,iq1,isp),i,ifis)
C            call dpdump(vxibz(1,iq1,isp),i,ifis2)
CC            call dpdump(sigm2,i,ifis2)
CC            call daxpy(i,1d0,sigm2,1,sibz(1,iq1,isp),1)
C          enddo
C        enddo
CC       Massage QSGW sigma
C        do  iq1 = 1, nqps
C        do  i = 1, nlmto**2
C          sigm(1:2) = sibz(i,iq1,1:2) + vxibz(i,iq1,1:2) ! QSGW sigma
C          cxx = (sigm(1) + sigm(2))/2 ! Spin averaged sigma
C          if (lrdsig == 4) then
C            sigm(1:2) = cxx
C          endif
C          sibz(i,iq1,1:2) = vxibz(i,iq1,1:2) ! vxc^LDA
CC         sibz(i,iq1,1:2) = sigm(1:2) - vxibz(i,iq1,1:2) ! sigma^QSGW-vxc^LDA
C        enddo
C        enddo
C        deallocate(sigm,vxibz)
C
CCC       (sig+,sig-) -> (sig+ + sig-, sig+ - sig-)
CC        call dsumdf(i*nqps,1d0,sibz(1,1,1),0,1,sibz(1,1,2),0,1)
CCC       Zero out sig+ - sig-
CC        call dpzero(sibz(1,1,2),i*nqps)
CCC       (sig+ + sig-, sig+ - sig-) -> (sig+,sig-)
CC        call dsumdf(i*nqps,.5d0,sibz(1,1,1),0,1,sibz(1,1,2),0,1)
CC
CCC       Subtract spin polarized vxc
CC        rewind ifis2
CC        ndham = nlmto
CC        call iosigh(3,8,nsp,nspc,ndham,nlmto,nk1,nk2,nk3,nqp,iq1,lshft(1),lshft(2),lshft(3),ifis2,eseavr2)
CC        do  isp = 1, nsp
CC          do  iq1 = 1, nqps
CC            read(ifis2) tmp
CC            call dpdump(sigm2,i,ifis2)
CC            call daxpy(i,-1d0,sigm2,1,sibz(1,iq1,isp),1)
CC          enddo
CC        enddo
CC        deallocate(sigm2)
C
C      endif

C --- Generate hrs = sigma(T) from file sigma(k) ---
C ... Loop over spins, keeping sig in full BZ for only one spin
      if (procid == master) then
      allocate(sigm(nlmto,nlmto))
      do  isp = 1, nsp

C     If sigma file not spin polarized, use sigma from spin 1
      if (isp == 2 .and. lsplts) then
        call rxx(lascii /= 0,'this mode may not be used with "ascii"')
        call iosigh(3,0,1,1,nlmto,nlmto,nk1,nk2,nk3,nqp,iq1,lshft(1),lshft(2),lshft(3),ifis,xx)
        if (alf(2) /= 0) then
        call iosigh(3,0,1,1,nlmto,nlmto,nk1,nk2,nk3,nqp,iq1,lshft(1),lshft(2),lshft(3),ifis2,xx)
        endif
      endif

C ... File sigma in irr BZ -> sigma in full BZ by rotations
      allocate(sfz(k1*k2*k3*nlmto**2))
      allocate(sigmwk(nlmto**2))
      nl = nglob('nl')
      nspc = 1
      do  iq1 = 1, nqps
C        if (lrdsig == 4) then  ! copy sibz
C          call dcopy(nlmto**2*2,sibz(1,iq1,isp),1,sigm,1)
C          goto 500
C        endif
        if (lrdsig == 1) then
          qp(:) = qpgw(:,iq1)
        elseif (lascii == 2) then
          read(ifis,"(3e20.13)") qp
        else
          read(ifis) qp
        endif
        call info5(50,0,0,' rdsigm:  read kpt %i of %i, k=%3;9,5D',iq1,nqp,qp,0,0)
        call dpscop(qp,tmp,3,1,1,1d0)
        call dpsadd(tmp,qpgw,3,1,3*iq1-2,-1d0)
        call dpsadd(tmp,qoffi,3,1,1,-1d0)
        if (.not. latvec(1,tolq,plat,tmp)) then
          call dpscop(qpgw,tmp,3,3*iq1-2,1,1d0)
          if (lssym >= 4) then
            call info5(20,0,0,' rdsigm (warning) qp %i : '//
     .        'expected%3;8,4D read%3;8,4D',iq1,tmp,qp,0,0)
            call dpscop(tmp,qp,3,1,1,1d0)
          else
            print 456, iq1,'sigm',tmp,qp
  456       format(' rdsigm: error on reading qp no',i4,' (file ',a,')'/
     .           ' Expected qp=',3f12.6/
     .           '     File qp=',3f12.6)
          call rx('incompatible q-mesh')
        endif
        endif
C       File read sigma
        if (mod(nscnts,10) == LW3) call dpdump(tmp,1,ifis) ! Dummy read eval if file is mode LW3
        if (lrdsig == 1) then
          call dpzero(sigm,nlmto**2*2)
        elseif (lascii == 2) then
          call dfdump(sigm,nlmto**2*2,ifis)
        else
          call dpdump(sigm,nlmto**2*2,ifis)
        endif
C        if (isp == 2) then
C          print *, iq1,isp,sngl(qp)
C          call zprm('sigm',2,sigm,nlmto,nlmto,nlmto)
C        endif
        if (alf(1) /= 1d0) call dscal(nlmto**2*2,alf(1),sigm,1)
        if (alf(2) /= 0d0) then
          read(ifis2) qp
          if (dlength(3,qp(:)-qpgw(:,iq1)-qoffi(:),1) > tolq) then
            if (lssym >= 4) then
              call info5(20,0,0,' rdsigm (warning) qp %i : '//
     .          'expected%3;8,4D read%3;8,4D (file sigm1)',iq1,qpgw(1,iq1),qp,0,0)
            else
              print 456, iq1,'sigm1',qpgw(:,iq1),qp
              call rx('incompatible q-mesh')
            endif
          endif
C         call dpsadd(qp,qpgw,3,1,3*iq1-2,1d0)
          allocate(sigm2(nlmto,nlmto))
          call dpdump(sigm2,nlmto**2*2,ifis2)
          call daxpy(nlmto**2*2,alf(2),sigm2,1,sigm,1)
          deallocate(sigm2)
        endif
C 500   continue                ! Re-entry point for DMFT dc
C       call zprm('sigm',2,sigm,nlmto,nlmto,nlmto)

        if (cmdopt('--zhblock',9,0,outs)) then
          call zhblock(outs(10:),nlmto,110+isp,sigm,sigm)
        endif

        i = 100*kcplx + 00
        if (lphase) i = i+40
        call hamfb3(nbas,nl,s_ham%offH,s_ham%iprmb,i,s_lat%pos,iq1,nk1,
     .    nk2,nk3,k1,k2,k3,ipq,s_lat%istab,s_lat%symgr,s_lat%ag,igstar,
     .    ifac,nlmto,nlmto,nlmto,nspc,qb,sigm,sigmwk,sigmwk,sfz)

      enddo
      deallocate(sigmwk)

C      print *, 'one element of sigma(k)'
C      call pvtrod(sfz,k1,k2,k3,nlmto)

C ... FT sfz and copy sfz(T) to hrs
      i = 10*hreal + 1
      if (ltrans) i = i + 10000
      call hft2rs(i,s_ham,nk1,nk2,nk3,k1,k2,k3,qoff,isp,nsp,nbas,s_lat%symgr,s_lat%ag,nsgrps,
     .  rsrnge,1,nbas,nlmto,nlmto,sfz,plat,s_lat%pos,ndhrs,s_ham%hrs)

C      print *, 'print out sigma(T)'
C      call pvtrof(s_ham%hrs,ndhrs,nsp,nk1,nk2,nk3,s_ham%iaxs,1,
C     .  nttabs,sfz,nlmto)
C      stop

      deallocate(sfz)
      enddo  ! loop over spins
      deallocate(sigm)
      endif  ! MPI master block
      deallocate(igstar,ipq)
      s_ham%ndhrs = ndhrs; s_ham%eseavr = eseavr

C ... Check that FT replicates sigma(k) at file qp to tolerance rsstol
C     rsstol = 1d-6
C     if (alf(1) /= 1 .or. alf(2) /= 0 .or. lrdsig == 1 .or. DMFTdc) then
      if (alf(1) /= 1 .or. alf(2) /= 0 .or. lrdsig == 1 .or. cmdopt('--zhblock',9,0,outs)) then
        call info0(20,0,0,' skipping check of Bloch summed sigma')
      else
        j1 = 0
        if (lssym >= 4) j1 = 2
        if (procid == master) then
          call dpzero(tmp,3)
          call chksgr(j1,ltrans,lascii,kcplx,plat,nsp,nlmto,ifis,
     .      hreal,s_ham%iprmb,nttabs,s_ham%iaxs,s_ham%hrs,ndhrs,
     .      rsstol,i,qpgw,nbas,0,rotm,xx)
        endif
      endif

      if (.not. (cmdopt('--wsig',6,0,outs).or.cmdopt('-wsig',5,0,outs))) deallocate(qpgw)

C ... Broadcast R.S. sigma before symmetrization
      i = ndhrs**2*nttabs*nsp; if (hreal == 0) i = i*2
      call mpibc1(s_ham%hrs,i,4,mlog,'rdsigm','hrs')

C --- Spin average hrs ---
   50 continue ! re-entry point for direct read of R.S. sigma
      if (mod(lrdsig,4) == 2) then
        call info0(20,0,0,' replace sigma with spin average ...')
        if (nsp == 1) call rx('onesp option nonsensical: sigma file has nsp=1')
        eseavr(1) = eseavr(1)/2+eseavr(2)/2
        call siged(2,' ',s_ctrl,s_spec,s_lat,s_ham,s_gw,nsp,ndhrs,nlmto,
     .    s_ham%iprmb,hreal,s_ham%nprs,s_ham%iaxs,s_ham%hrs,lrsw)
      endif

C --- Symmetrize hrs ---
C     Best to use nsgrp here instead of nsgrps.
C     However, neighbor table was generated for nsgrps, and may be
C     increase if nsgrp>nsgrps.  This branch will fail in that case.
      if (mod(lrsig,4) >= 2 .and. nsgrp > 1) then

C       Allocate memory for hrs
        i = ndhrs**2*nttabs*nsp; if (hreal == 0) i = i*2
        allocate(hrss(i))
        call dcopy(i,s_ham%hrs,1,hrss,1)
        i = idalloc('hrss',allocvb()+2,i,1)
        mxorb = nglob('mxorb')
C       10s digit distributes ri-rj pairs to avg (ri-rj),(rj-ri) pairs
C       Use 10*2 for hermitian matrices, 10*1 for symmetric ones
        i = 1-hreal + 10*2 + 100*(1-hreal) + 100000
        nsafm = iabs(s_lat%nsafm)
        allocate(istb2(nbas,max(nsgrp,nsafm)))
        call istbpm(s_lat%istab,nbas,nsgrp,nsafm,istb2)

        nl = nglob('nl')
        call rsmsym(i,plat,mxorb,s_ham%iprmb,nlmto,nbas,s_lat%pos,nl,nsp,1,
     .    nttabs,s_ham%nprs,s_ham%iaxs,s_lat%symgr,istb2,nsgrp,0,ndhrs,hrss,s_ham%hrs)
        if (nsafm > 0) then
          tmp(1) = eseavr(1)/2 + eseavr(nsp)/2
          call info2(20,0,0,' Impose AFM symmetry: change in eseavr: %,4;4g',tmp(1)-eseavr(1),2)
          eseavr(1) = tmp(1); eseavr(nsp) = tmp(1)
          call dcopy(size(hrss),s_ham%hrs,1,hrss,1)
          call rsmsym(i+1000,plat,mxorb,s_ham%iprmb,nlmto,nbas,s_lat%pos,nl,nsp,1,
     .      nttabs,s_ham%nprs,s_ham%iaxs,s_lat%symgr,istb2,2,nsafm,ndhrs,hrss,s_ham%hrs)
        endif
        i = idalloc('hrss',allocvb()+3,0,0)
        deallocate(istb2,hrss)

C        Debugging
C        ifis2 = fopna('out',-1,0)
C        print *, 'hello',ndhrs,nttabs
C        call ywrm(0,'sig',2,ifis2,'(9f20.10)',s_ham%hrs,1,ndhrs**2,
C     .    ndhrs**2,nttabs*nsp)
C        call rx0('done')

C   ... Check how well symmetrized FT replicates sigma(k) at file qp
        if (procid == master .and. .not. lrsrs) then
          rsstol = 0
          if (alf(1) /= 1 .or. alf(2) /= 0) then ! .or. DMFTdc) then
            call info0(20,0,0,' skipping check of symmetrized sigma (sigma scaled) ')
          elseif (lrdsig /= 1) then
            call chksgr(0,ltrans,lascii,kcplx,plat,nsp,nlmto,ifis,hreal,
     .        s_ham%iprmb,nttabs,s_ham%iaxs,s_ham%hrs,ndhrs,rsstol,i,0,
     .        nbas,0,rotm,xx)
          endif
        endif

C   ... Broadcast R.S. sigma after symmetrization
        if (hreal == 1) then
          i = ndhrs**2*nttabs*nsp
        else
          i = 2*ndhrs**2*nttabs*nsp
        endif
        call mpibc1(s_ham%hrs,i,4,mlog,'rdsigm','hrs')

      endif
      s_gw%eseavr = eseavr

C --- lwsig=0 modes that internally transform sigma, save and stop ---
      if (lwsig == 0) then
      if (cmdopt('--wsig',6,0,outs)) then
      if (procid == master) then
        rsstol = 0
        out2 = outs(7:)
        dc = out2(1:1)
        call sigflg(dc,'wsig',out2,ledit,lwsig,lrot,lfbzout,lnwmsh,
     .    lonesp,lrdsig,lascii,lrsw,lsumk,qpmismatchok,qoffo,rots,sfuzz)
        if (lrsrs .and. .not. lfbzout) lnwmsh = .true. ! qp mesh needs allocating

        if (lonesp == 1) then
          call info0(20,0,0,' Averaging spin-dependent sigma, save non spin polarized sigm on disk')
          if (nsp == 1) call rx('onesp option nonsensical: sigma file has nsp=1')
          eseavr(1) = eseavr(1)/2+eseavr(2)/2
          call siged(1,outs(7:),s_ctrl,s_spec,s_lat,s_ham,s_gw,nsp,ndhrs,nlmto,
     .      s_ham%iprmb,hreal,s_ham%nprs,s_ham%iaxs,s_ham%hrs,lrsw)
        endif

        if (ledit == 1) then
          call siged(0,outs(7:),s_ctrl,s_spec,s_lat,s_ham,s_gw,nsp,ndhrs,nlmto,
     .      s_ham%iprmb,hreal,s_ham%nprs,s_ham%iaxs,s_ham%hrs,lrsw)
          nttabs = s_ham%nprs(nbas+1) ! This may have changed
          eseavr = s_gw%eseavr        ! This may have changed
        endif

C       Open output file
        if (lascii == 2 .and. lrsw) then
          fn = 'sigmars'; i = 0
        else if (lascii == 2) then
          fn = 'sigma'; i = 0
        else if (lrsw) then
          fn = 'sigm2rs'; i = 4
        else
          fn = 'sigm2'; i = 4
        endif
        ifis2 = fopna(trim(fn),-1,i)

C       Handle case q-mesh for file output differs from file input
C       ltmp = true in cases where file symops artificially reduced
        if (lnwmsh) then
          nkxyz = s_gw%nkabc
          lshft = s_gw%lshft

          mxkp = nk1*nk2*nk3
          allocate(qpgw(3,mxkp),igstar(mxkp+1))
          call iinit(igstar,mxkp+1); igstar(1) = -2
          do  i = 1, 3
            llshft(i) = lshft(i) /= 0
          enddo
C         if (allocated(ipq)) deallocate(ipq)
          allocate(ipq(mxkp),wtkp(mxkp)); wtkp(1)=0
          if (lfbzout) then
            call info0(20,1,0,
     .        ' Creating sigma for new mesh, full BZ (file sigm2) ...')
            call bzmesh(plat,qb,nk1,nk2,nk3,llshft,xx,0,ipq,
     .        qpgw,wtkp,nqp,mxkp,0,0)
          else
            call info0(20,1,0,
     .        ' Creating sigma for new mesh (file sigm2) ...')
            call bzmesh(plat,qb,nk1,nk2,nk3,llshft,s_lat%symgr,nsgrp,
     .        ipq,qpgw,wtkp,nqp,mxkp,igstar,0)
          endif
          deallocate(ipq,wtkp,igstar)

        elseif (lfbzout) then
          qpgw => s_ham%qsig
C         oqp = oqsig
          nqp = nqsig
          call info2(20,1,0,
     .      ' Creating sigma for full BZ, %i qp (file sigm2) ...',nqp,0)
        elseif (lrsw) then
          call info2(20,0,0,
     .     ' Writing R.S. sigma, %i pairs, range = %,1d ',nttabs,rsrnge)
        else
          call info2(20,0,0,' Writing sigma for irr BZ, %i qp '//
     .      '(file %?#(n==2)#sigma#sigm2#) ...',nqp,lascii)
        endif

C   ... Setup rotation matrix
        if (rots /= ' ') then
          call a2rotm(rots,.false.,0,rotm)
          if (iprint() >= 20) then
            call info0(20,0,0,' Rotate sigma by rotation matrix:')
            write (stdo,350) ((rotm(i,j),j=1,3),i=1,3)
  350       format(3f11.6)
          endif
          lrot = lrot + 1
        endif

C   ... Setup phase matrix
        if (lrot >= 2) then
          allocate(delT(3*nbas)); call dpzero(delT,3*nbas)
          call info0(0,0,0,' Phase shift of sigma.  '//
     .      'Translation vectors from shorps file:')
          call iopos(.false.,-1,'phase',nbas,delT,xx)
        endif
C       call prmx('q for which sigm is written',qpgw,3,3,nqp)

        nscnts = 0
        if (lrsw) nscnts = 100
        call iosigh(lascii*10+0,nscnts,nsp,1,nlmto,nlmto,nk1,nk2,nk3,nqp,nqp,
     .    lshft(1),lshft(2),lshft(3),-ifis2,eseavr)
        if (lrsw) then ! Write header for sigrs
          call iosigrs(lascii*10+0,100,sfuzz,hreal,nsp,nbas,ndhrs,nttabs,
     .      s_lat%alat,plat,s_lat%pos,s_ham%nprs,s_ham%iaxs,s_ham%hrs,-ifis2)
          call rx0('done writing rs sigma, file '//trim(fn))
        endif

        if (lqoffo /= 0) then
C         call prmx('qp',qpgw,3,3,nqp)
          do  i = 1, nqp
            call dmsadd(qpgw,1,qoffo,1,1,3,1,1,3*i-2,1,1d0)
          enddo
C         call prmx('qp',qpgw,3,3,nqp)
        endif
        j = 1; if (lsumk) j = 3
        if (j > 0 .and. .not. associated(qpgw)) call rx('rdsigm bug: qpgw not allocated')
        call chksgr(j,ltrans,lascii,kcplx,plat,nsp,nlmto,ifis2,hreal,
     .    s_ham%iprmb,nttabs,s_ham%iaxs,s_ham%hrs,ndhrs,rsstol,nqp,
     .    qpgw,nbas,lrot,rotm,delT)
        call fclose(ifis2)
        if (lrot >= 2) deallocate(delT)
        call rx0('done writing sigma, file '//trim(fn))
C      elseif (lwsig == LW1 .or. lwsig == 2) then
C        if (lfbzout) call info0(20,0,0,' ')
C        if (lfbzout) goto 99
      endif
      endif
      endif

C     Broadcast entire sham structure (shouldn't be needed)
C     call mpibc1(sham,i,4,mlog,'rdsigm','sham')
C     Broadcast neighbor table (shouldn't be needed)
C     call mpibc1(s_ham%nprs,nbas+1,2,mlog,'rdsigm','ntabs')
C     call mpibc1(s_ham%iaxs,niax*nttabs,2,mlog,'rdsigm','iaxs')

C ... Transformations done by caller: write qp list to disk
   99 continue
      if (lwsig /= 0) then

      call info0(30,0,0,' ')

      if (lnwmsh) then
        nkxyz = s_bz%nkabc
        lshft = s_bz%lshft
        nqp = s_bz%nkp
        qpgw => s_bz%qp
        call info2(20,0,0,
     .    ' Transform sigma on new k-mesh:  nk=%3:1i  shft=%3:1l',nkxyz,lshft)
        call rxx(lwsig == LW6,'trans=6 may now be used with new k-mesh')
      endif

      if (lfbzout) then
        mxkp = nk1*nk2*nk3
        allocate(qpgw(3,mxkp))
        call info(20,0,0,' rdsigm: use full BZ (%i q-points)...',mxkp,0)
        call bzmshp(' RDSIGM',1,nkxyz,lshft,plat,s_lat%symgr,1,1,
     .    .true.,0,0,qb,nqp,qpgw,xx,xx,xx)
      endif

C ... Write points to disk, shifting by qoffo
      if (lqoffo /= 0) then
C       call prmx('qp',qpgw,3,3,nqp)
        do  i = 1, nqp
          call dmsadd(qpgw,1,qoffo,1,1,3,1,1,3*i-2,1,1d0)
        enddo
C       call prmx('qp',qpgw,3,3,nqp)
      endif

      if (lwsig /= LW6) then
        call info0(30,0,0,' RDSIGM: writing data to file QPTS ...')
        ifiz = fopna('qpts',-1,0)
        call getqp(1,-ifiz,nqp,nkxyz,lshft,0,qpgw,xx,xx)
      endif

      endif

  999 continue
      call tcx('rdsigm')

      end

      subroutine iosigh(optio,mode,nsp,nspc,ndham,nlmto,nk1,nk2,nk3,nqp,nqpx,lshft1,lshft2,lshft3,ifi,eseavr)
C- Read/write header information in sigma file
C ----------------------------------------------------------------------
Ci Inputs
Ci   optio :1s digit (read only)
Ci         :0 read header data into
Ci            nsp,nspc,ndham,nlmto,nk1,nk2,nk3,nqp,lshft1,lshft2,lshft3, [eseavr]
Ci            eseavr is set to NULLI if not present
Ci         :1 File data must passed matched value for
Ci            nsp,nspc,ndham,nlmto,nk1,nk2,nk3,nqp,lshft1,lshft2,lshft3
Ci            eseavr is also read, if it is present
Ci         :2 file mode must passed matched value
Ci         :These digits may be taken in any combination
Ci         :10s digit
Ci         :2 file is I/O in ascii format
Ci         :otherwise, file in binary format
Ci   ifi   :File logical unit: ifi>0 for read; ifi<0 for write
Cio Inputs/Outputs
Cio  mode  : switches with information about the contents of sigma
Cio        :... 1-10s digit, file contains:
Cio        :0    sigma in the orbital basis
Cio        :1    sigma in the LDA basis, and LDA eigenvalues
Cio        :2    sigma in the lda basis (high energy parts replaced),
Cio              and LDA eigenvalues
Cio        :3    sigma in the orbital basis (high energy parts replaced)
Cio        :LW4  LDA eigenvalues and eigenvectors
Cio        :LW5  LDA eigenvalues and eigenvectors
Cio        :LW6  LDA eigenvalues and eigenvectors
Cio        :LW7      eigenvalues and eigenvectors
Cio        :LW8      eigenvalues and eigenvectors
Cio        :LW9  LDA vxc in the orbital basis
Cio        :10   exchange sigma_x in the orbital basis
Cio        :20   U matrix in the orbital basis
Cio        :... 100s digit, file contains:
Cio        :0    sigma (or object) in k-space
Cio        :1    sigma (or object) in R.S., as inverse Bloch sum
Cio  nsp   :2 for spin-polarized case, otherwise 1
Cio  nspc  :2 for noncollinear case, otherwise 1
Cio  ndham :maximum dimension of hamiltonian
Cio  nlmto :dimension of LMTO part of hamiltonian
Cio  nk1..nk3 : number of divisions in 1st,2nd,3rd Qlat
Cio  nqp   :number of k-points in the file.
Cio        :Usually, not not necessarily, the number of irreducible k-points.
Cio  nqpx  :number of k-points in the file.
Cio        :The total number of qp written to file (read/written only if ivsn>3).
Cio  lshft1:1 if offset BZ in Qlat(1), otherwise 0
Cio  lshft2:1 if offset BZ in Qlat(2), otherwise 0
Cio  lshft3:1 if offset BZ in Qlat(3), otherwise 0
Cio  eseavr:average value of self-energy for high-lying states
Cio        :on file READ (optio 0 only)
Cio        :if it is present in the header, it is returned.
Cio        :If it is not present, it is returned as NULLI
Cl Local variables
Cr Remarks
Cr   Reads or writes header file for sigma, with sanity checks
Cr   header contents:
Cr    1.  header, 2 records
Cr        record 1: 0, version-number, modef  (missing in early version)
Cr        record 2: nsp,nspc,ndham,nlmto,nk1,nk2,nk3,nqp,lshft1,lshft2,lshft3
Cr    2.  qp offset (version 2 and later)
Cr   Body contents depend on mode.
Cr    ... 3..6 are repeated for nqp points (nqp is contained in header)
Cr    foreach iq, do
Cr    foreach isp, do
Cr       recrd   mode    mode-dependent record
Cr    3.  qp     all      5    qp(1:3) ndimhx nev
Cr    4.  eval   1-8    1-4,8  eval(nev); else no eval written
Cr    5.  occnum  6       6    dmatk(ndimhx)
Cr    6.  sigm   all      0    sigm(nlmto,nlmto)
Cr                       1-6   sigma or evec(ndimhx,ndimhx)
Cr                       7,8   sigma or evec(ndimhx,nev)
Cr    enddo
Cr    enddo
Cu Updates
Cu   16 Mar 18 iosigh v3: reads/writes nspc,ndham
Cu   14 Nov 12 Workaround to using backspace, to work on pgf compiler
Cu   27 Jun 08 Revised mode, and input checking.  Old optio=1 -> optio=3
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer nsp,nspc,ndham,nlmto,nk1,nk2,nk3,nqp,nqpx,lshft1,lshft2,lshft3,ifi,optio,mode
      double precision eseavr(2)
C ... Local parameters
      logical ltmp,isanrg
      integer jfi,i1,i1x,i2x,i2,i3,i4,i5,i6,i6x,i7,i8,i9,ivsn,modef,optio0,lascii
C     double precision xx
      integer NULLI
      procedure(logical) :: iosigh2
      parameter (NULLI=-99999)

      optio0 = mod(optio,10)
      lascii = mod(optio/10,10)

      if (ifi < 0) then
        ivsn = 3 ; if (nqp < nqpx) ivsn = 4
        jfi = -ifi
        rewind jfi
C       Write 0 => file contains version number (versions 1 and later)
        if (lascii == 2) then
          write(jfi,"('# header version mode')")
          write(jfi,"(i6,2i7)") 0,ivsn,mode
          if (ivsn > 3) then
            call rx('iosigh not ready for ascii ivsn>3')
          endif
          write(jfi,"('# nsp nspc ndham nlmto   -nkabc-    nqp  -lshft-     eseavr ...')")
          write(jfi,"(i4,i5,2i6,3i4,i6,3i3,4x,1p,2e20.13)")
     .      nsp,nspc,ndham,nlmto,nk1,nk2,nk3,nqp,lshft1,lshft2,lshft3,eseavr(1:nsp)
          write(jfi,"('# header end')")
        else
          if (ivsn /= 0) write(jfi) 0, ivsn, mode
          if (ivsn > 3) then
            write(jfi) nsp,nspc,ndham,nlmto,nk1,nk2,nk3,nqp,nqpx,lshft1,lshft2,lshft3,eseavr(1:nsp)
          else
            write(jfi) nsp,nspc,ndham,nlmto,nk1,nk2,nk3,nqp,lshft1,lshft2,lshft3,eseavr(1:nsp)
          endif
        endif
      else
        rewind ifi
C       Read version, checking whether header is pre- version 1
        if (lascii == 2) then
          read(ifi,*)
          read(ifi,*,err=99,end=99) i1,ivsn,modef
        else
          read(ifi,err=99,end=99) i1,ivsn,modef
        endif
C       File header is pre-version 1; set version to zero
        if (i1 /= 0) then
          ivsn = 0; modef = 0; rewind ifi
        endif

C       Assign mode or check with file correspondence
        if (mod(optio0/2,2) /= 0) then
          ltmp=isanrg(modef,mode,mode,'iosigh:','file''s mode',.true.)
        else
          mode = modef
        endif

C   ... Read header parameters or check with file correspondence
        if (mod(optio0,2) /= 0) then
          if (.not. iosigh2(ivsn,lascii,i1,i1x,i2x,i2,i3,i4,i5,i6,i6x,i7,i8,i9,eseavr,ifi)) goto 99
         ltmp=isanrg(i1,nsp,nsp,'iosigh:','file''s nsp',.true.)
         ltmp=isanrg(i1x,nspc,nspc,'iosigh:','file''s nspc',.true.)
         ltmp=isanrg(i2x,ndham,ndham,'iosigh:','file''s ndham',.true.)
         ltmp=isanrg(i2,nlmto,nlmto,'iosigh:','file''s nlmto',.true.)
         ltmp=isanrg(i3,nk1,nk1,'iosigh:','file''s nk1',.true.)
         ltmp=isanrg(i4,nk2,nk2,'iosigh:','file''s nk2',.true.)
         ltmp=isanrg(i5,nk3,nk3,'iosigh:','file''s nk3',.true.)
         ltmp=isanrg(i6,nqp,nqp,'iosigh:','file''s nqp',.true.)
         ltmp=isanrg(i7,lshft1,lshft1,'iosigh:','file''s lshft1',.true.)
         ltmp=isanrg(i8,lshft2,lshft2,'iosigh:','file''s lshft2',.true.)
         ltmp=isanrg(i9,lshft3,lshft3,'iosigh:','file''s lshft3',.true.)
        else
          if (.not. iosigh2(ivsn,lascii,nsp,nspc,ndham,nlmto,nk1,nk2,nk3,nqp,nqpx,
     .      lshft1,lshft2,lshft3,eseavr,ifi)) goto 99
        endif
      endif
      return

   99 continue
      call rx('iosigh: failed to read header from file')
      end

      logical function iosigh2(ivsn,lascii,nsp,nspc,ndham,nlmto,nk1,nk2,nk3,nqp,nqpx,
     .  lshft1,lshft2,lshft3,eseavr,ifi)
C- Read 2nd line of header file
C ----------------------------------------------------------------------
Ci Inputs
Ci  lascii :2, File I/O in ASCII mode
Ci   ivsn  :version number
Ci   ifi   :File logical unit: ifi>0 for read; ifi<0 for write
Co Outputs
Co  nsp   :2 for spin-polarized case, otherwise 1
Co  nspc  :2 for noncollinear case, otherwise 1
Co  ndham :maximum dimension of hamiltonian
Co  nlmto :dimension of LMTO hamiltonian
Co  nk1..nk3 : number of divisions in 1st,2nd,3rd Qlat
Co  nqp   :number of irr. k-points in file
Co  nqpx  :total number of k-points in file (read only if ivsn>3)
Co  lshft1:1 if offset BZ in Qlat(1), otherwise 0
Co  lshft2:1 if offset BZ in Qlat(2), otherwise 0
Co  lshft3:1 if offset BZ in Qlat(3), otherwise 0
Co  eseavr:average value of self-energy for high-lying states
Co        :if it is present in the header, it is returned.
Co        :If it is not present, it is returned as NULLI
Cl Local variables
Cr Remarks
Cr   This is a kernel called by iosigh
Cr   Versions prior to version 2 do not contain nspc or ndham
C    In this case, nspc is set to 1, ndham to nlmto
Cu Updates
Cu   14 Nov 12  Passes ivsn to work around using backspace after file read
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer ivsn,lascii,nsp,nspc,ndham,nlmto,nk1,nk2,nk3,nqp,nqpx,ifi,
     .  lshft1,lshft2,lshft3
      double precision eseavr(2)
C ... Local parameters
      integer k
      integer NULLI
      parameter (NULLI=-99999)

C     get spin index to determine the number of eseavr to read
      if (lascii == 2) then
        read(ifi,*,err=99,end=99)
        read(ifi,*,err=99,end=99) nsp
      else
        read(ifi,err=99,end=99) nsp
      endif

C     Read 2nd line of header
      iosigh2 = .true.
      backspace ifi
      eseavr(1:nsp) = NULLI

      if (ivsn > 1) call sanrg(.true.,ivsn,1,4,'iosigh:','version')
      if (ivsn > 3 .and.  lascii == 2) then
        read(ifi,*,err=99,end=99)
     .  k,nspc,ndham,nlmto,nk1,nk2,nk3,nqp,nqpx,lshft1,lshft2,lshft3,eseavr(1:nsp)
        read(ifi,*,err=99,end=99) ! Line marking end of header
      elseif (ivsn > 2 .and.  lascii == 2) then
        read(ifi,*,err=99,end=99)
     .  k,nspc,ndham,nlmto,nk1,nk2,nk3,nqp,lshft1,lshft2,lshft3,eseavr(1:nsp)
        read(ifi,*,err=99,end=99) ! Line marking end of header
      elseif (lascii == 2) then
        read(ifi,*,err=99,end=99)
     .  k,nlmto,nk1,nk2,nk3,nqp,lshft1,lshft2,lshft3,eseavr(1:nsp)
        read(ifi,*,err=99,end=99) ! Line marking end of header
        ndham = nlmto; nspc = 1
      elseif (ivsn > 3) then
        read(ifi,err=11,end=11)
     .    k,nspc,ndham,nlmto,nk1,nk2,nk3,nqp,nqpx,lshft1,lshft2,lshft3,eseavr(1:nsp)
      elseif (ivsn > 2) then
        read(ifi,err=11,end=11)
     .    k,nspc,ndham,nlmto,nk1,nk2,nk3,nqp,lshft1,lshft2,lshft3,eseavr(1:nsp)
      else
        read(ifi,err=11,end=11)
     .  k,nlmto,nk1,nk2,nk3,nqp,lshft1,lshft2,lshft3,eseavr(1:nsp)
        ndham = nlmto; nspc = 1
      endif
      if (ivsn <= 3) nqpx = nqp

      return

C     Attempt to read data without ndham,nspc or eseavr, for backward compatibility
   11 continue
      eseavr = NULLI
C     Avoid using backspace ... doesn't work on pgf compiler
      rewind ifi
      if (ivsn > 0) read(ifi) k
C     backspace ifi
      if (ivsn > 3) then
        read(ifi,err=99,end=99) nsp,nlmto,nk1,nk2,nk3,nqp,nqpx,lshft1,lshft2,lshft3
      else
        read(ifi,err=99,end=99) nsp,nlmto,nk1,nk2,nk3,nqp,lshft1,lshft2,lshft3
        nqpx = nqp
      endif
      ndham = nlmto; nspc = 1
      return

   99 continue
      iosigh2 = .false.
      end

      subroutine iosigrs(optio,mode,sfuzz,hreal,nsp,nbas,ndhrs,nttabs,
     .  alat,plat,pos,ntab,iax,hrs,ifi)
C- File I/O of body of R.S. sigma
C ----------------------------------------------------------------------
Ci Inputs
Ci   optio :1s digit (read only)
Ci         : 0 Dimensioning info assumed to be already read;
Ci         :   File pointer should located at the first record after header
Ci         :   iosigrs checks all input dimensioning parameters against
Ci         :   file data, then reads potential arrays
Ci         :>0 read some of all of header and structural data; sigma not read
Ci         : 1 iosigrs reads these dimensioning parameters only:
Ci         :     mode,hreal,nttabs
Ci         :-1 iosigrs checks the following against file values only:
Ci         :     mode,hreal,nttabs
Ci         : 2 iosigrs reads these dimensioning parameters only:
Ci         :     nsp,nbas,ndhrs
Ci         :-2 iosigrs checks the following against file values only:
Ci         :     nsp,nbas,ndhrs
Ci         : +/-3 combination of +/-(1+2)
Ci         : File pointer on exit:
Ci         : |optio| == 1 =>  rewound to start of R.S. header;
Ci         : 1<|optio| <= 3 => set to start of structural data
Ci         :
Ci         : 4 iosigrs reads structural data:
Ci         :    alat, plat pos
Ci         :-4 iosigrs checks structural data against file:
Ci         :    alat*plat pos
Ci         : File pointer on exit: start of potential arrays
Ci         :
Ci         : 8 iosigrs reads potential and pair arrays:
Ci         :   ntab,iax,hrs
Ci         : File pointer on exit: end of file.
Ci         :
Ci         : File pointer on entry:
Ci         : Next recrod should whatever is to be read next, i.e.
Ci         :   mod(abs(optio),10)   file pointer
Ci         :        8               start of potential arrays
Ci         :        4               start of structural data
Ci         :        otherwise       start of R.S. header
Ci         :
Ci         :10s digit
Ci         :2 file is I/O in ascii format
Ci         :otherwise, file in binary format
Ci   mode  :not used now
Ci   nbas  :size of basis
Ci   nttabs:total number of pairs in neighbor and iax (pairc.f)
Ci   ndhrs :leading dimensions of hrs: must be at least as large as
Ci         :the total number of orbitals of any atom.
Ci   nsp   :2 for spin-polarized case, otherwise 1
Ci   ifi   :File logical unit: ifi>0 for read; ifi<0 for write
Cio Inputs/Outputs
Cio  ... The following data is read from, or written to disk
Cio  alat  :length scale of lattice and basis vectors, a.u.
Cio  plat  :primitive lattice vectors, in units of alat
Cio  pos   :basis vectors
Cio  ntab  :ntab(ib)=offset to neighbor table for cluster ib (pairc.f)
Cio  iax   :neighbor table containing pair information (pairc.f)
Cio  hrs   :R.S. sigma (double precision or double complex)
Cs Command-line switches
Cl Local variables
Cl         :
Cr Remarks
Cr
Cu Updates
Cu   20 Sep 13 New sfuzz
Cu   29 Jul 13 First created
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer optio,mode,nsp,ndhrs,nttabs,hreal,nbas,ifi
      integer n0,nkap0,n0H,niax
      parameter (n0=10,nkap0=4,n0H=5,niax=10)
      integer iax(niax,nttabs),ntab(nbas+1)
      double precision sfuzz,alat,plat(3,3),pos(3,nbas)
C     double precision hrs(ndhrs,ndhrs,nsp,nttabs)
      double complex hrs(ndhrs,ndhrs,nsp,nttabs)
      real(8),allocatable:: pos0(:,:),wk(:,:)
      complex(8),allocatable:: hrs1(:,:,:)
C ... Local parameters
      integer optio0,lascii,ivsn,modef,i1,i2,i3,i4,i5,jfi,nspfil
      logical ltmp,isanrg
      double precision alat0,plat0(3,3),tol,dlength,xx,rotm(3,3)
      parameter (tol=1d-6)
      character strn*120

      optio0 = mod(optio,10)
      lascii = mod(iabs(optio/10),10)

C ... File WRITE
      if (ifi < 0) then
        ivsn = 2
        jfi = -ifi

        if (lascii == 2) then
          write(jfi,100)
  100     format('# R.S.      hreal nsp   nbas  ndhrs  nttabs')
          write(jfi,101) ivsn,mode,hreal,nsp,nbas,ndhrs,nttabs
  101     format(4i5,2i7,i9)
          write(jfi,"('# alat, plat,  pos')")
          write(jfi,102) alat
  102     format(f13.7)
          write(jfi,103) plat
  103     format(3f13.7)
          write(jfi,103) pos
          write(jfi,"('# R.S. header end')")
          write(jfi,"('# --- ntab --- ')")
          write(jfi,"(20i8)") ntab
          write(jfi,"('# --- iax --- ')")
          write(jfi,"(10i8)") iax
          write(jfi,"('# --- hrs --- ')")
          if (hreal == 0) call dfdump(hrs,2*ndhrs*ndhrs*nsp*nttabs,ifi)
          if (hreal == 1) call dfdump(hrs,ndhrs*ndhrs*nsp*nttabs,ifi)
        else
          write(jfi) ivsn,mode,hreal,nsp,nbas,ndhrs,nttabs
          write(jfi) alat
          write(jfi) plat
          write(jfi) pos
          write(jfi) ntab
          write(jfi) iax
          if (hreal == 0) call dpdump(hrs,2*ndhrs*ndhrs*nsp*nttabs,ifi)
          if (hreal == 1) call dfdump(hrs,ndhrs*ndhrs*nsp*nttabs,ifi)
        endif

C ... File READ
      else
        nspfil = nsp
        if (iabs(optio0) == 4) goto 40 ! directly to start of start of strux data
        if (optio0 == 8) goto 80 ! directly to potential arrays
        if (lascii == 2) then
          read(ifi,*,err=99,end=99) strn ! R.S. header line
          read(ifi,*,err=99,end=99) ivsn,modef,i1,nspfil,i3,i4,i5
        else
          read(ifi,err=99,end=99) ivsn,modef,i1,nspfil,i3,i4,i5
        endif
        if (ivsn /= 2) call rx('iosigrs: incompatible versions')
        if (mod(optio0,2) > 0) then
          mode = modef
          hreal = i1
          nttabs = i5
        else
         ltmp=isanrg(modef,mode,mode,'iosigrs:','file''s mode',.true.)
         ltmp=isanrg(i1,hreal,hreal,'iosigrs:','file''s hreal',.true.)
         ltmp=isanrg(i5,nttabs,nttabs,'iosigrs:',"file's nttabs",.true.)
        endif
        if (abs(optio0) == 1) then  ! Read or check only mode,hread,nttabs
          backspace ifi !restore pointer to start of header
          if (lascii == 2) then
            backspace ifi
          endif
          return
        endif
        if (mod(optio0/2,2) > 0) then
          nsp = nspfil
          nbas = i3
          ndhrs = i4
        else
C         ltmp=isanrg(nspfil,nsp,nsp,'iosigrs:','file''s nsp',.true.)
          ltmp=isanrg(i3,nbas,nbas,'iosigrs:','file''s nbas',.true.)
          ltmp=isanrg(i4,ndhrs,ndhrs,'iosigrs:','file''s ndhrs',.true.)
        endif
        if (abs(optio0) > 0 .and. abs(optio0) < 4) return
C       End of dimensioning parameters

C   ... Read structural data
   40   continue
        allocate(pos0(3,nbas))
        if (lascii == 2) then
          read(ifi,*,err=99,end=99) strn ! R.S. alat header line
          read(ifi,*,err=99,end=99) alat0,plat0
          read(ifi,*,err=99,end=99) pos0
        else
          read(ifi,err=99,end=99) alat0
          read(ifi,err=99,end=99) plat0
          read(ifi,err=99,end=99) pos0
        endif
        if (mod(optio0/4,2) > 0) then
          alat = alat0
          plat = plat0
          call dcopy(3*nbas,pos0,1,pos,1)
        else
          if (dlength(9,alat*plat-alat0*plat0,1) > tol) then
            allocate(wk(3,max(nbas,3)))
            call dinv33(alat0*plat0,0,wk,xx)
            call dgemm('N','N',3,3,3,1d0,alat*plat,3,wk,3,0d0,rotm,3)
            call dinv33(rotm,0,wk,xx)
            if (dabs(xx-1) < 1d-10) then
              call rm2eua(rotm,wk(1,1),wk(2,1),wk(3,1))
              call info2(10,0,0,
     .        "%9foops!  plat rotated relative to file : euler angles %3:1;6d",wk,0)
            endif
            deallocate(wk)
C           hrs must be rotated, too.  Just abort for now.
C           call dcopy(3*nbas,pos0,1,wk,1)
C           call dgemm('N','N',3,nbas,3,1d0,rotm,3,wk,3,0d0,pos0,3)
            call rx("iosigrs:  mismatch with file's alat or plat")
          endif
          call daxpy(3*nbas,-1d0,pos,1,pos0,1)
          xx = dlength(3*nbas,pos0,1)
          if (xx > tol) then
            call info2(30,0,0,'%9f(warning) mismatch with file '//
     .        'positions, deviation = %d',xx,0)
          endif
          if (xx > sfuzz)
     .      call rx1('iosigrs:  mismatch exceeds tolerance %g',sfuzz)
        endif
        if (lascii == 2) then
        read(ifi,*,err=99,end=99) strn ! Line marking end of R.S. strux data
        endif
        if (abs(optio0) > 0) return  ! Done with header and strux data

C   ... Read hamiltonian arrays
   80   continue
        i1 = 0
        if (hreal == 0) i1 = 2*ndhrs*ndhrs*nspfil*nttabs
        if (hreal == 1) i1 =   ndhrs*ndhrs*nspfil*nttabs
        if (i1 == 0) call rx('something wrong with iors')
        if (nspfil > nsp) call rx('iosigrs: file sigma is spin polarized but setup is not')
        if (lascii == 2) then
          read(ifi,*,err=99,end=99) strn ! Line marking ntab
          read(ifi,*,err=99,end=99) ntab
          read(ifi,*,err=99,end=99) strn ! Line marking iax
          read(ifi,*,err=99,end=99) iax
          read(ifi,*,err=99,end=99) strn ! Line marking hrs
          call dfdump(hrs,i1,ifi)
        else
          read(ifi,err=99,end=99) ntab
          read(ifi,err=99,end=99) iax
          call dpdump(hrs,i1,ifi)
        endif
        if (nspfil < nsp) then
          call info0(30,0,0,'%9f(warning) sigmrs not spin pol .. splitting spins')
          if (hreal == 1) call rx('iors not setup to split real rs sig')
          allocate(hrs1(ndhrs,ndhrs,nttabs))
          call dcopy(i1,hrs,1,hrs1,1)
          forall (i1=1:ndhrs,i2=1:ndhrs,i3=1:nttabs) hrs(i1,i2,1,i3) = hrs1(i1,i2,i3)
          forall (i1=1:ndhrs,i2=1:ndhrs,i3=1:nttabs) hrs(i1,i2,2,i3) = hrs1(i1,i2,i3)
          deallocate(hrs1)
        endif

      endif

      return
   99 continue
      call rx('iosigrs: failed to read parameters from file')

      end

      subroutine chksgr(opt,ltrans,lascii,kcplx,plat,nsp,nlmto,ifis,hreal,
     .  iprmb,nttabs,iaxs,hrs,ndhrs,tols,nqp,qplst,nbas,lrot,rotm,delT)
C- Compare Bloch summed sigma against file sigma(k), or write sigma to file
C ----------------------------------------------------------------------
Ci Inputs
Ci   opt   :1s digit
Ci         :0 calculate sigma at list of qp in file,
Ci         :  compare against file sigma
Ci         :1 calculate sigma at list of qp, write to file sigma
Ci         :  NB: caller must write header to sigma file before
Ci         :  calling chksgr!
Ci         :2 like opt=0, but use qplst instead of qp
Ci         :3 Same as opt=1, but average sigma over k
Ci   plat  :primitive lattice vectors, in units of alat
Ci   nsp   :2 for spin-polarized case, otherwise 1
Ci   nlmto :dimension of hamiltonian
Ci   ifis  :file logical unit for sigma
Ci   hreal :0 sigm(R) is complex
Ci         :1 sigm(R) is real
Ci   iprmb :permutations ordering orbitals in l+i+h blocks (makidx.f)
Ci   nttabs:number of site pairs in sigm(R)
Ci   iaxs  :neighbor table for sigm(R)
Ci   hrs   :sigm(R)
Ci   ndhrs :leading dimensions of hrs
Ci   tols  :deviations in sigma > tols causes chksgr to abort
Ci         :tols=0 -> chksgr never aborts
Ci   qplst :(opt=0,2) not used
Ci         :(opt=1,3) list of qp at which to make sigma
Ci   lrot  :(opt=0,2,3) not used
Ci         :(opt=1) 0 -> do not rotate sigma matrix
Ci         :        1 -> rotate sigma matrix by rotm
Ci         :        2 -> additionally scale sigma matrix by phase
Ci         :             owing to change in shortening of basis
Ci         :             vectors
Ci   rotm  :(opt=0) not used
Ci         :(opt=1) list of qp at which to make sigma
Ci   delT  :(only used if lrot=2)
Ci         :change in lattice translation vectors on rotation
Ci         :to add phase shift to sigm.
Cio Inputs/Outputs
Cio  nqp   :Input (opt=1 or 3):  number of qp for which sigma is evaluated
Cio        :Used in conjunction with qplst
Cio        :Output (opt=0 or 2):  number of qp for which sigma is evaluated
Cio        :In this context nqp is read from file
Cio  (opt=1) sigma written to logical unit ifis
Cl Local variables
Cl   sq    :(opt=0) file's contents of sigma, for comparison
Cl         :(opt=1) temporary array in rotating sigma
Cl   sq1   :bloch-summed sigma
Cr Remarks
Cr
Cu Updates
Cu   15 Jul 13 Option to write sigma summed over k
Cu   20 Dec 04 enable rotation of sigma before writing
Cu   11 Jul 03 enable write of sigma
Cu   09 May 03 First created
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer opt,kcplx,hreal,ifis,nlmto,nsp,nttabs,ndhrs,nqp,lrot
      integer niax,n0,nkap0
      parameter (niax=10, n0=10, nkap0=4)
      integer iprmb(*),iaxs(niax,*),nbas
      double precision plat(3,3),tols,qplst(3,nqp),rotm(3,3),delT(3,nbas)
      double complex hrs(ndhrs,ndhrs,nsp,nttabs)
      logical ltrans
      integer lascii
C ... Dynamically allocated local arrays
      complex(8),allocatable:: sq(:,:),sq1(:,:),uz(:,:)
C     complex(8),allocatable:: h(:,:),s(:,:)
C ... Local parameters
      logical lsplts
      integer i,j,k,isp,stdo,iq1,nl,mxorb,ipr,opt0,opt01,nscnts
      integer ib,jb,is,norb,ltab(n0*nkap0),ktab(n0*nkap0),offl(n0*nkap0)
C     these are read by sigma header
      integer nk1,nk2,nk3,lshft(3),offh(nbas),ndim(nbas),offi,offj,
     .  ndi,ndj
C     integer os
      double precision qp(3),errmxx,errmx,err,qpr(3),xx(2)
      double complex hwk(ndhrs,ndhrs)
      integer NULLI
      parameter (NULLI=-99999)
      integer ii,jj
      integer LW3,LW4,LW5
      parameter (LW3=3,LW4=4,LW5=5)
      procedure(integer) :: nglob,lgunit,isw

      call tcn('chksgr')
      call getpr(ipr)
      stdo = lgunit(1)
      nl = nglob('nl')
      mxorb = nglob('mxorb')
      opt01 = mod(mod(opt,10),2)  ! 1 if opt is odd
      opt0  = mod(opt,10)
      nscnts = 0

      allocate(sq(nlmto,nlmto),sq1(nlmto,nlmto))

C --- Rotate hrs if lrot switch set ---
      if (opt01 /= 0 .and. mod(lrot,2) /= 0) then
        allocate(uz(nlmto,nlmto))
        call rothrm(2,0,nlmto,iprmb,rotm,1,nbas,nlmto,uz,uz)
C       call zprm('Uz',2,uz,nlmto,nlmto,nlmto)
C       Table of hamiltonian offsets and site dimensions
        do  ib = 1, nbas
          call orbl(ib,0,nlmto,iprmb,norb,ltab,ktab,j,offl,ndim(ib))
          offh(ib) = j+1
        enddo

C       For each pair and spin, rotate hrs to U(ib) hrs U(jb)+
        do  is = 1, nttabs
          ib = iaxs(1,is)
          jb = iaxs(2,is)
          offi = offh(ib)
          offj = offh(jb)
          ndi = ndim(ib)
          ndj = ndim(jb)

          do  isp = 1, nsp

C           U1 sigm(unrotated) U2+
            if (ltrans) then
C             ltrans: use (U1 h+ U2+)+ = (U1 (U2 h)+)+ = U2 h U1+
              call zgemm('N','N',ndj,ndi,ndj,(1D0,0D0),Uz(offj,offj),
     .        nlmto,hrs(1,1,isp,is),ndhrs,(0D0,0D0),hwk,ndhrs)
C              call zprm('U S',2,hwk,ndhrs,ndj,ndi)
C             U sigm(unrotated) U+
              call zgemm('N','C',ndj,ndi,ndi,(1D0,0D0),hwk,ndhrs,
     .          Uz(offi,offi),nlmto,(0D0,0D0),hrs(1,1,isp,is),ndhrs)
C              call zprm('U S U+',2,hrs(1,1,isp,is),ndhrs,ndhrs,ndhrs)
            else
C             Make U1 h U2+
              call zgemm('N','N',ndi,ndj,ndi,(1D0,0D0),Uz(offi,offi),
     .        nlmto,hrs(1,1,isp,is),ndhrs,(0D0,0D0),hwk,ndhrs)
C             call zprm('U S',2,hwk,ndhrs,ndi,ndj)
C             U sigm(unrotated) U+
              call zgemm('N','C',ndi,ndj,ndj,(1D0,0D0),hwk,ndhrs,
     .          Uz(offj,offj),nlmto,(0D0,0D0),hrs(1,1,isp,is),ndhrs)
C             call zprm('U S U+',2,hrs(1,1,isp,is),ndhrs,ndhrs,ndhrs)
            endif

          enddo
        enddo
      endif

C ... Read header data (chksgr does not use or need eseavr)
      lsplts = .false.
      if (opt01 == 0) then  ! opt is 1 or 3
        call iosigh(lascii*10+0,nscnts,i,k,nlmto,nlmto,nk1,nk2,nk3,nqp,iq1,
     .    lshft(1),lshft(2),lshft(3),ifis,xx)
        if (nscnts /= 0 .and. mod(nscnts,10) /= LW3) then
          call rxx(lascii /= 0,'this mode may not be used with "ascii"')
          call iosigh(2,0,i,k,nlmto,nlmto,nk1,nk2,nk3,nqp,iq1,lshft(1),lshft(2),lshft(3),ifis,xx)
        endif

        if (i == nsp) then
          lsplts = .false.
        elseif (i > nsp) then
          call rx(
     .      'rdsigm: sigm file spin polarized but calculation is not')
        else
          lsplts = .true.
        endif
      endif

      do  isp = 1, nsp
      errmxx = 0
      call dpzero(sq,2*nlmto*nlmto)

C     If sigma file not spin polarized, use sigma from spin 1
      if (isp == 2 .and. lsplts) then
        call iosigh(1,nscnts,1,1,nlmto,nlmto,nk1,nk2,nk3,nqp,iq1,lshft(1),lshft(2),lshft(3),ifis,xx)
      endif

C ... For each q, compare Bloch sum of hrs against file's s(q)
C     or write to file
      do  iq1 = 1, nqp

C       print *, 'starting iq=',iq1

        if (opt01 == 0) then
C         Read file qp if opt0 = 0 or 2. Discarded if opt0=2.
          if (lascii == 2) then
            read(ifis,"(3e20.13)") qp
          else
            read(ifis) qp
          endif
          if (opt0 == 2) call dcopy(3,qplst(1,iq1),1,qp,1)
          if (mod(nscnts,10) == LW3) call dpdump(xx,1,ifis)
          if (lascii == 2) then
            call dfdump(sq,nlmto**2*2,ifis)
          else
            call dpdump(sq,nlmto**2*2,ifis)
          endif
          call ztoyy(sq,nlmto,nlmto,nlmto,nlmto,kcplx,1)
C           print *, iq1
C           call zprm('sq',2,sq,nlmto,nlmto,nlmto)
        else  ! opt0 is 1 or 3
          call dcopy(3,qplst(1,iq1),1,qp,1)
        endif

C   ... Evaluate bloch sum of hrs
C       Call bloch : 104010=perm orb, transpose, c*16
        i = 100000 + 4000 + 40*(1-hreal) + 10
        if (.not. ltrans) i = i - 4000
        call bloch(i,qp,nl,plat,mxorb,iprmb,1,nttabs,iaxs,hrs,ndhrs,
     .    isp,nsp,nlmto,nlmto,0,nlmto,0,nlmto,0,sq1,xx,xx)
C       print *, 'iq,isp=',iq1,isp,'  qp=',sngl(qp)
C       call zprm('sigm',2,sq1,nlmto,nlmto,nlmto)
        errmx = 0

C       Compare Bloch sum of hrs against file's s(q)
        if (opt01 == 0) then
        ii = 1
        jj = 1
        do  j = 1, nlmto
          do  i = 1, nlmto
            err = abs(sq(i,j)-sq1(i,j))
            if (err > errmx) then
              ii = i
              jj = j
              if (err > tols .and. tols > 0) then
                write(stdo,357) i,j, sngl(err),sq1(i,j),sq(i,j)
  357           format(/' Oops!  Bloch sum deviates more than specified tolerance:'/
     .            '   i   j',6x,'diff',14x,'bloch sum',16x,'file value'/
     .            2i4,f12.6,2x,2f12.6,2x,2f12.6
     .            /' Try increasing HAM_RSRNGE or HAM_RSSTOL')
                call rx1('rdsigm: Bloch sum deviates more than'//
     .            ' tolerance (tol=%g).',tols)
            endif
            endif
            errmx = max(errmx,err)
          enddo
        enddo
        if (ipr >= 45) write(stdo,332) iq1,errmx,ii,jj
  332   format(' comparing s(iq) to interpolated sq for iq=',i4,
     .    '  errmx=',1pe8.1:' at i,j=',2i4)
        errmxx = max(errmxx,errmx)

C   ... Accumulate sum_k s(k)
        elseif (opt0 == 3) then

          call daxpy(2*nlmto*nlmto,1d0/nqp,sq1,1,sq,1)

C   ... Write to s(q)
        else

C     ...  Rotation of sigma(k) (no longer needed, because hrs(T) was rotated)
C          if (mod(lrot,2) /= 0) then
C
CC           call zprm('unrotated S',2,sq1,nlmto,nlmto,nlmto)
C
CC           U sigm(unrotated)
C            call zgemm('N','N',nlmto,nlmto,nlmto,(1D0,0D0),
C     .        Uz,nlmto,sq1,nlmto,(0D0,0D0),sq,nlmto)
CC           call zprm('U S',2,sq,nlmto,nlmto,nlmto)
CC           U sigm(unrotated) U+
C            call zgemm('N','C',nlmto,nlmto,nlmto,(1D0,0D0),
C     .        sq,nlmto,Uz,nlmto,(0D0,0D0),sq1,nlmto)
C            call zprm('U S U+',2,sq1,nlmto,nlmto,nlmto)
C
C          endif

C         Additional scaling by phase shifts
          if (lrot >= 2) then
C           call zprm('unscaled S',2,sq1,nlmto,nlmto,nlmto)
            call dgemm('T','N',3,1,3,1d0,plat,3,qp,3,0d0,qpr,3)
C           call prmx('q in units of qlat',qpr,3,3,1)
            call rothph(02,qpr,delT,nlmto,iprmb,1,nbas,nlmto,sq1)
C            print *, 'iq=',iq1,'qp=',sngl(qp)
C            call zprm('S scaled by phase',2,sq1,nlmto,nlmto,nlmto)
          endif

C         Rotate qp to new coordinate system
          if (mod(lrot,2) /= 0) then

C           In-line multiply avoids bug in DEC fort compiler
            do  i = 1, 3
              qpr(i) = rotm(i,1)*qp(1) +
     .                 rotm(i,2)*qp(2) +
     .                 rotm(i,3)*qp(3)
            enddo
            call dcopy(3,qpr,1,qp,1)
          endif

C         Write qp, sigm for this qp
          if (lascii == 2) then
            write(ifis,"(1p,3e20.13,0p,f12.0)") qp, dble(NULLI)
            call dfdump(sq1,nlmto**2*2,-ifis)
          else
            write(ifis) qp, dble(NULLI)
            call dpdump(sq1,nlmto**2*2,-ifis)
          endif
C         call zprm('sigm',2,sq1,nlmto,nlmto,nlmto)
        endif
      enddo  ! Loop over iq

      if (opt0 == 3) then
        call rxx(lrot /= 0,
     .    'rdsigm: sumk and lrot cannot be used together')
        do  iq1 = 1, nqp
          call dcopy(3,qplst(1,iq1),1,qp,1)
C         Write qp, sigm for this qp
          if (lascii == 2) then
            write(ifis,"(1p,3e20.13,0p,f12.0)") qp, dble(NULLI)
            call dfdump(sq,nlmto**2*2,-ifis)
          else
            write(ifis) qp, dble(NULLI)
            call dpdump(sq,nlmto**2*2,-ifis)
          endif
C         call zprm('sigm',2,sq1,nlmto,nlmto,nlmto)
        enddo ! Loop over iq
      endif

      if (opt01 == 0)
     .  call info5(20,0,0,' check FT s(R) against s(q) ... '//
     .  'maximum error = %;2g%?#n>0# < tol (%;2g)#%j#%?#n==2# spin 2##',
     .  errmxx,isw(tols /= 0),tols,isp,0)

      enddo ! Loop over spins

      deallocate(sq,sq1)
      if (opt01 /= 0 .and. mod(lrot,2) /= 0) then
        deallocate(uz)
      endif

      call tcx('chksgr')

      end

      subroutine sigfileunit(fn,ifi,lxst)
C- Return results from possible --rsig switch: whether real space or ascii file
      implicit none
C ... Passed parameters
      character fn*(*)
      integer ifi
      logical lxst
C ... Local parameters
      character outs*120,out2*120,dc*1
      integer ledit,lwsig,lrot,lonesp,lrdsig,lascii,i
      logical lfbz,lnwmsh,lsumk,lrs,qpmismatchok
      double precision qpoff(3),sfuzz
      procedure(logical) :: cmdopt
      procedure(integer) :: fadd,fxst,fopna

      lascii = 0; lrs = .false.
      if (cmdopt('--rsig',6,0,outs)) then
        out2 = outs(7:)
        dc = out2(1:1)
        call sigflg(dc,'rsig',out2,ledit,lwsig,lrot,lfbz,lnwmsh,lonesp,
     .  lrdsig,lascii,lrs,lsumk,qpmismatchok,qpoff,fn,sfuzz)
      endif
      if (lascii == 2 .and. lrs) then
        fn = 'sigmars'; i = 0
      else if (lascii == 2) then
        fn = 'sigma'; i = 0
      else if (lrs) then
        fn = 'sigmrs'; i = 4
      else
        fn = 'sigm'; i = 4
      endif
      ifi = fadd(trim(fn),-1,i)
      lxst = fxst(trim(fn)) /= 0
      if (.not. lxst) return
      ifi = fopna(trim(fn),-1,i)

      end

      subroutine sigflg(dc,sio,strn,ledit,lwsig,lrot,lfbz,lnwmsh,lonesp,
     .  lrdsig,lascii,lrs,lsumk,qpmismatchok,qpoff,rots,sfuzz)
C- Reads flags for Sigma IO
C ----------------------------------------------------------------------
Ci Inputs
Ci   dc    :separator for switches
Ci  sio    :a string, specifies whether switches pertain to read or write:
Ci         'rsig' --- parse parameters (from strn) for reading sigma
Ci                may affect: lfbz qpoff ascii lrs null
Ci         'wsig' --- parse parameters (from strn) for writing a new sigma
Ci                may affect: ledit lwsig lrot lfbz lnwmsh lonesp qpoff rots
Ci  strn   :character string setting flags for options that modify
Ci         :how sigma is read, altered for writing, or if some other
Ci         :operation is to be done:
Ci         'edit'     (w) invoke the sigma editor
Ci         'spinav'   (r) average spin channels in spin-polarized sigma;
Ci         'onesp'    (w) average spin channels in spin-polarized sigma;
Ci         'ascii'    (r/w) read or write sigma in ASCII format
Ci         'null'     (r) read null sigma (used to make a templates)
Ci         'dmft1'    (r) Modify sigm to eliminate DMFT double counting, mode 1
Ci         'dmfts1'   (r) Modify sigm to eliminate DMFT double counting, mode 1
Ci                        spin channel only
Ci         'rlxkp'    (r) flag to allow k-point mismatch
Ci         'rot=strn' (w) rotate sigma matrix.  See a2rotm for syntax.
Ci         'trans=#'  (w) # specifies how sigma is to be modified, or if
Ci                        some other object is to be made instead of sig.
Ci                        # is stored in lwsig; see below different choices of lwsig
Ci         'phase'    (w) Add phase shift to sigma
Ci         'fbz'      (r/w) sigma should contain qp for entire BZ
Ci         'newkp'    (w) generate sigma on a new k-mesh
Ci         'sumk'     (w) sum sigma over k.  Implies fbz
Ci         'shftq='   (r/w) add qp offset to qp where sigma is made
Ci         'wvxcf'    (w) read vxc file and write as vxcsig (used by lmfgwd)
Co Outputs
Co   ledit :(wsig only)
Co         :1  flag requesting sigma editor
Co   lwsig :(wsig only)
Co         :0    normal exit
Co         :1    transformation of sigm from orbital to LDA basis
Co         :-1   transformation of sigm from LDA to orbital basis
Co         :LW2  Same as LW1, but high,low parts of sigm replaced by diagonal
Co         :LW3  Proceeds like LW2, but sigm(orbital) -> sigm(orbital) before writing
Co         :LW4  Write evals,evecs of LDA hamiltonian to file
Co         :LW5  Write evals,evecs of total hamiltonian to file
Co         :LW6  Write evals,evecs,occ num of hamiltonian to file
Co         :LW18 Read vxc from file vxc and write as vxcsig (sigm format and k-point order)
Co         :     (use with lmfgwd, extension of LW8, which does the same but calculates vxc.
Co         :10   Transform sigma to U = (1/2-n)^-1 Sigma^c
Co         :     where n is the density matrix
Co         :     Both n-1/2 and correlation sigma  (or sigma and sigma_x)
Co         :     must reside on disk.
Co   lrdsig:(rsig only) transformation modes at read time
Co         :1    make NULL sigm array
Co         :2    spin average sigm
Co         :4    subtract double counting for DMFT (not implemented)
Co   lrot  :(wsig only)
Co         :nonzero, flag to rotate sigma matrix
Co   lfbz  :(rdsig and wsig)
Co         :T, write sigma for qp in entire BZ
Co   lnwmsh:(wsig only)
Co         :T, write sigm for qp on new mesh
Co   lonesp:if nonzero then:
Co         :(r) replace sig+, sig- with sig+/2+sig-/2; remains spin pol
Co         :(w) replace sig+, sig- with sig+/2+sig-/2; nsp turned to 1
Co   lascii:0 if file is in binary format
Co         :2 if file in in ascii format
Co         :10 if to make a null
Co   lrs   :T read/write sigma in real space format
Co   lsumk :(wsig only)
Co         :T generate sum_k sigm(k) to make k-independent form of sigma
Co   qpoff :(rdsig and wsig)
Co         :k-point offset to be added to uniform mesh
Co   rots  :(wsig only)
Co         :string containing rotation matrix for sigma
Co   sig2u :(wsig only)
Co         :Transform correlation part of sigma to U; same as lwsig=20 above.
Cl Local variables
Cl         :
Cr Remarks
Cu Updates
Cu   20 Sep 13  New fuzz
Cu   15 Jan 07  First created
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      character dc*1,sio*(4)
      character strn*(*),rots*(*)
      integer ledit,lwsig,lrot,lonesp,lrdsig,lascii
      logical lfbz,lnwmsh,lsumk,lrs,qpmismatchok
      double precision qpoff(3)
      double precision sfuzz
C ... Local parameters
      integer parg
      integer i,j,j1,j2,iv(10)
      logical lio,isanrg,ltmp
      integer, parameter :: LW1=1,LW2=2,LW3=3,LW4=4,LW5=5,LW6=6,LWU=10,LW18=18

      lio = sio == 'wsig'
      if (.not. lio) then
        if (sio /= 'rsig') call rx('sigflg: bad argument '//sio)
      endif
      if (lio) then
        ledit = 0
        lwsig = 0
        lrot = 0
        lfbz = .false.
        lrs = .false.
        qpmismatchok = .false.
        lnwmsh = .false.
        lonesp = 0
        lascii = 0
        rots = ' '
        call dpzero(qpoff,3)
      else
        lrdsig = 0
        lfbz = .false.
        lonesp = 0
        lrs = .false.
        qpmismatchok = .false.
        lascii = 0
        call dpzero(qpoff,3)
      endif

      if (dc /= ' ') then
C   ... Return here to resume parsing for arguments
        j2 = 0
   50   continue
        j2 = j2+1
        if (strn(j2:j2) == dc) goto 50
        j1 = min(len(strn),j2)
        call nwordg(strn,0,dc//' ',1,j1,j2)
        if (j2 >= j1) then
          if (.false.) then
          elseif (strn(j1:j1+3) == 'edit' .and. lio) then
            ledit = 1
            return  ! edit mode => no further parsing
          elseif (strn(j1:j1+5) == 'spinav' .and. .not. lio) then
            lrdsig = 2
          elseif (strn(j1:j1+4) == 'onesp' .and. lio) then
            lonesp = 1
          elseif (strn(j1:j1+4) == 'ascii') then
            lascii = 2
          elseif (strn(j1:j1+4) == 'null' .and. .not. lio) then
            lrdsig = 1
          elseif (strn(j1:j1+4) == 'rlxkp'.and. .not. lio) then
            qpmismatchok = .true.
C          Commented out for now
C          elseif (strn(j1:j1+6) == 'dmfts1' .and. .not. lio) then
C            lrdsig = 4
          elseif ((strn(j1:j1+3) == 'rot=' .or. strn(j1:j1+3) == 'ROT=') .and. lio) then
            rots = strn(j1+4:j2)
          elseif (strn(j1:j1+6) == 'wvxcf' .and. lio) then
            lwsig = LW18
          elseif (strn(j1:j1+5) == 'trans=' .and. lio) then
            j = 0
            if (parg('trans=',2,strn(j1:),j,len(strn(j1:)),
     .        dc//' ',1,1,i,lwsig) < 0) goto 999
            ltmp = isanrg(mod(lwsig,10),-1,6,'SIGFLG:','trans',.true.)
            if (lwsig > 6 .and. lwsig /= 10)
     .        call rxi('rdsigm: nonsensical trans',lwsig)
          elseif (strn(j1:j1+4) == 'sig2u'.and. lio) then
            lwsig = LWU
          elseif (strn(j1:j1+4) == 'phase'.and. lio) then
            lrot = 2
          elseif (strn(j1:j1+1) == 'rs') then
            lrs = .true.
            if (strn(j1+2:j1+2) == ',') then
              j = 0
              if (parg('rs,',4,strn(j1:),j,len(strn(j1:)),
     .          ', '//dc,2,1,iv,sfuzz) < 0) goto 999
            endif
          elseif (strn(j1:j1+2) == 'fbz') then
            lfbz = .true.
          elseif (strn(j1:j1+4) == 'newkp'.and. lio) then
            lnwmsh = .true.
          elseif (strn(j1:j1+4) == 'sumk'.and. lio) then
            lsumk = .true.; lfbz = .true.
          elseif (strn(j1:j1+5) == 'shftq=') then
            j = 0
            if (parg('shftq=',4,strn(j1:),j,len(strn(j1:)),
     .        ', '//dc,2,3,iv,qpoff) < 0) goto 999
          elseif (strn(j1:j1+4) == 'shftq') then
            qpoff(1) = 4d0/4096
            qpoff(2) = 5d0/4096
            qpoff(3) = 7d0/4096
          else
            goto 59
          endif
          goto 50
   59     continue
  999     call rxs('rdsigm: failed to parse wsig option', strn)
        endif
      endif

      end

      subroutine psigd(mode,ndimh,sig,eval,sigp,n123,sigd)
C- Approximate sigma for low,higher energies with diagonal part,
C- and further add constraints for the higher energies
C ----------------------------------------------------------------------
Ci Inputs
Ci   mode  :0 sig is a complex square matrix; poke sig(i,i)
Ci         :  sigd is not used
Ci         :1 sigd is a real diagonal matrix; poke sigd(i)
Ci         :  for those elements that satisfy constraints.
Ci         :  sig is not used
Ci   ndimh :dimension of hamiltonian, and number of energies
Ci   eval  :list of (LDA) eigenvalues
Ci   sigp  :parameters for approximating self-energy sigma.  sigma
Ci         :is approximated by its diagonal part sigii for energies
Ci         :below a low-energy cutoff (specified nmin or emin) and
Ci         :above a low-energy cutoff (specified nmax or emax).
Ci         : arg 1: (mode) specifies how to set diagonal part sigii
Ci         :        for states above the high-energy cutoff nmax or emax
Ci         :        0 constrain sigii to be > asig+bsig*e
Ci         :        1 constrain sigii to be = asig+bsig*e
Ci         :        2 constrain sigii to be > asig and < bsig
Ci         :        3 constraint same as case 1; for this routine, there
Ci         :          is no difference.  Elsewhere,
Ci         :          arg1=3 differs in that the least-squares fit to
Ci         :          sigii (for informational purposes only, to help
Ci         :          estimate asig and bsig) is done for states between
Ci         :          efit and nmax or emax
Ci         :        4 constrain sigii to be asig
Ci         : arg 2: nmin : nmin=0 => not used
Ci         :               nmin<0 => use emin in place of nmin
Ci         :               Usage depends on whether mode is 0 or 1
Ci         :               mode = 0: for states 1..nmin, off-diagonal
Ci         :               parts of sig(1:nmin,1:nmin) are zeroed out.
Ci         :               mode = 1: sigd(1..nmin) is filled with emin
Ci         : arg 3: emin : (used only if nmin<0)
Ci         :               Usage depends on whether mode is 0 or 1
Ci         :               mode = 0: for states e_i<emin, off-diagonal
Ci         :               parts of sig(1:i,1:i) are zeroed out.
Ci         :               mode = 1: sigd(1..nmin) is filled with emin
Ci         : arg 4: nmax : sigma for levels i>nmax are approximated by
Ci         :               sigii AND constrained according to mode, arg 1
Ci         : arg 5: emax : (used only if nmax<=0)
Ci         :             : sigma for levels e<emax are approximated by
Ci         :               sigii AND constrained according to mode, arg 1
Ci         : arg 6: asig : constraint used to approximate
Ci         :               sigii = asig + E * bsig  or
Ci         :               asig < sigii < bsig
Ci         : arg 7: bsig : constraint used to approximate
Ci         :               sigii = asig + E * bsig  or
Ci         :               asig < sigii < bsig
Ci         : arg 8: efit : fit sigii between efit and emax (mode 3)
Cio Inputs/Outputs
Cio  sig   :sigma, in LDA representation
Cio        :On output:
Cio        : *high and low states are replaced by diagonal part
Cio        :  of sigma
Cio        : *diagonal part may be altered to satisfy constraints
Co Outputs
Co   n123  :blocks sigma into lower, middle, high parts
Co         :n123(1) = 0
Co         :n123(2) = index to highest orbital in 'low' block
Co         :n123(3) = index to highest orbital in 'middle' block
Co         :n123(4) = ndimh
Cl Local variables
Cl   llow  :T if this eigenvalue is below minimum cutoff
Cl   lhigh :T if this eigenvalue is below above max cutoff
Cr Remarks
Cr
Cu Updates
Cu   16 Jul 13 Site local sigma
Cu   16 Jun 13 Can make Supercell
Cu   19 May 03 First created
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer mode,ndimh,n123(4)
      double precision eval(ndimh),sigp(10),sigd(ndimh)
      double complex sig(ndimh,ndimh)
C ... Local parameters
      logical llow,lhigh,isanrg,ltmp
      integer i,stdo,lgunit,ipr,nmin,nmax,modsgp,PRTE
      double precision emin,emax,asig,bsig,tol,siglin
      double complex zer,sigii
      parameter (zer=(0d0,0d0),tol=1d-7,PRTE=45)

      call getpr(ipr)
      stdo = lgunit(1)
      call ivset(n123,1,3,0)
      n123(4) = ndimh

      modsgp = nint(sigp(1))
      nmin   = nint(sigp(2))
      emin   = sigp(3)
      nmax   = nint(sigp(4))
      emax   = sigp(5)
      asig   = sigp(6)
      bsig   = sigp(7)
      if (modsgp == 4) bsig = 0
      if (modsgp == 3 .or. modsgp == 4) modsgp = 1

      if (mode == 0) then
        call info5(PRTE,1,0,
     .  ' hambls: approximate sigma'//
     .  '%?#(n<0)# for energies E(lda)<%d; and%-2j#%-1j#'//
     .  '%?#(n>0)# for states %-1jn=%i and below; and##%j'//
     .  '%?#(n<=0)# for energies E(lda)>%d%-2j#%-1j#'//
     .  '%?#(n>0)# for states above %-1jn=%i##%j'//
     .  '%N  state    E(lda)%8fsig_ii%4fconstraint%6fuse',
     .  nmin,emin,nmax,emax,0)
      elseif (mode == 1) then
        call info5(PRTE,1,0,
     .  ' hambls: new diagonal sigma for:'//
     .  ' %?#(n>0)#%-1j %i DEEP states (E=%d)#%jno DEEP states# and'//
     .  ' %?#(n>0)#%-1j %i#no# HIGH states'//
     .    ' ',nmin,emin,ndimh-nmax,0,0)
        if (nmin <= 0 .and. nmax >= ndimh) return
        call info0(PRTE,0,0,'  state    E(lda)%8fsig_ii')
        stop 'for now'
      else
        call rxi('psigd: bad mode ',mode)
      endif

      do  i = 1, ndimh

C       Require evals to be ordered
        if (eval(i) < eval(max(i-1,1))-tol)
     .    call rxi('psigd: eval %i not ordered',i)

C       Decide whether this eval is in low, middle, or high block
        llow  = (nmin < 0 .and. eval(i) < emin) .or.
     .          (nmin >= 0 .and. i <= nmin)
        lhigh = (nmax <= 0 .and. eval(i) > emax) .or.
     .          (nmax > 0 .and. i > nmax)
        if (mode == 1) llow = i <= nmin
        if (llow) n123(2) = i
        if (.not. lhigh) n123(3) = i

C       Calculate new diagonal sigma that satisfies constraints
        sigii = 0
        if (mode == 0) then
          sigii = sig(i,i)
        elseif (mode == 1 .and. llow) then
          sigii = emin
        endif
        siglin = asig + bsig*eval(i)
        if (lhigh) then
          if (modsgp == 0) then
            if (dble(sigii) < siglin) sigii = siglin
          elseif (modsgp == 1) then
            sigii = siglin
          elseif (modsgp == 2) then
            if (dble(sigii) < asig) sigii = asig
            if (dble(sigii) > bsig) sigii = bsig
          else
            ltmp = isanrg(modsgp,0,2,'hambls:','sig fit mode',.true.)
          endif
        endif

C       Printout
        if (mode == 1) then
        if (ipr >= PRTE .and. (llow.or.lhigh)) then
          write(stdo,331) i,eval(i),dble(sigii)
  331     format(i6,f12.6,2x,f12.6)
          endif
        else
          if (ipr >= PRTE .and. lhigh .and. modsgp == 2) then
            write(stdo,332)
     .        i,eval(i),dble(sig(i,i)),asig,bsig,dble(sigii)
  332       format(i6,f12.6,2x,f12.6,f7.2,',',f5.2,f12.6)
          elseif (ipr >= PRTE .and. lhigh) then
            write(stdo,333) i,eval(i),dble(sig(i,i)),siglin,dble(sigii)
  333       format(i6,f12.6,2x,2f12.6,f13.6)
          elseif (ipr >= PRTE) then
            write(stdo,334) i,eval(i),dble(sig(i,i)),dble(sigii)
  334       format(i6,f12.6,2x,f12.6,12x,f13.6)
          endif
        endif

C       Overwrite full sigma with diagonal matrix, or write to sigd
        if (llow .or. lhigh) then
          if (mode == 0) then
            call zscal(ndimh,zer,sig(1,i),1)
            call zscal(ndimh,zer,sig(i,1),ndimh)
            sig(i,i) = sigii
          else
            sigd(i) = sigii
          endif
        endif

      enddo

      end
