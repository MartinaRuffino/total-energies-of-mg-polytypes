      subroutine sugvec(s_lat,job,qp,Gmin,Gmax,ngabc,ngmx,ng)
C- Create list of G vectors
C ----------------------------------------------------------------------
Cio Structures
Cio  s_lat  :struct containing lattice information; see structures.h
Ci     Elts read: alat plat qlat kv kv2
Co     Stored:    *
Co     Allocated: gv kv igv kv2 igv2
Cio    Elts Passed:gv igv igv2
Cio    Passed to: *
Ci Inputs
Ci   job      1+10+100s digit
Ci              0 return ng only
Ci              1 return kv and igv
Ci              2 return kv2 and igv2
Ci              4 return kv and gv
Ci              8 return kv and gv, and sort list
Ci             16 Use gvlst2 to find list
Ci                Any combination of 1,2,4,8,16 is allowed
Ci                except do not combine 1s digit with 2s digit
Ci             32 Use gvlst2 to find list, return ngabc from Gmax
Ci                via gvlstn (See Remarks)
Ci                In this mode, nothing else is returned.
Ci             64 Leave ngabc untouched.  Use with 16 or 32
Ci            128 Same as 32, but ngabc determined from actual max
Ci                values encountered; see gvlst2
Ci            1000s digit (for calls to gvlist only)
Ci              0 specify cutoff as |G|<Gmax
Ci              1 specify cutoff as |G+tau|<Gmax
Ci              2 specify cutoff as |G-tau|<Gmax
Ci              5 same as 1, but return G+tau in gv
Ci              6 same as 2, but return G-tau in gv
Ci            10000s digit
Ci              1 s_lat%gv,s_lat%kv,s_lat%igv,s_lat%igv2 have been dimensioned externally
Ci                In this case ngmx must be > 0
Ci            100000s digit (only applies when calling gvlst2)
Ci              1 call gvlst2 with shortened q; patch gv,igv,igv2
Ci   qp    :k-point
Ci   Gmin  :lower bound of G vector (used only with gvlst2; see Remarks)
Ci   Gmax  :upper bound of G vector
Ci   ngmx  :Case ngmx>0:  leading dimension of arrays gv,kv,igv.
Ci         :In this case ngmx must be at least ng.
Ci         :Case ngmx<=0: ngmx is not touched.
Ci         :gv,kv,igv are dimensioned to ng
Ci Inputs/Outputs
Cio  ngabc :max # G vectors along the three directions.
Cio        :ngabc is input UNLESS job=32,128 (ngabc is output) or 64
Co Outputs
Co   ng    :number of G-vectors
Co  ... the following arays are allocated if 1000s digit job is set
Co      and generated (depending on 1s digit job).
Co      s_lat%gv, s_lat%kv, s_lat%igv, s_lat%kv2, s_lat%igv2
Cs Command-line switches
Cl Local variables
Cl   ngmxl  :Leading dimension of gv,kv,igv.
Cl          :ngmxl is ngmx, if ngmx is given; else ngmxl=ng
Cr Remarks
Cr   Lists are generated by either gvlist or gvlst2.
Cr   gvlist and gvlst2 perform the same function, but their
Cr   their purposes are slightly different, with gvlst2 aimed at
Cr   making quantities for APW basis functions, and gvlist aimed at
Cr   quantities for a fixed mesh of G vectors.  Differences:
Cr   1. the box of G vectors to search is generated differently
Cr      gvlist uses a fixed box of G vectors specified by ngabc,
Cr      gvlst2 can do this, but can generate its own box internally,
Cr      Then ngabc is not used (input must be (0,0,0))
Cr   2. gvlist shortens G within superlattice qlat*ngabc;
Cr      gvlst2 does not
Cr   3. gvlist returns either G vectors in gv or G+q depending on job;
Cr      gvlst2 returns G+q
Cr   4. gvlst2 allows user to specify both Gmin and Gmax
Cr   5. gvlist offers some choice whether G or G+/-q is used to
Cr      define length
Cu Updates
Cu   10 Feb 13  Option 10000s digit job (qp shortening)
Cu   28 Jun 12  Option job=64
Cu   04 May 12  First created
C ----------------------------------------------------------------------
      use structures
      implicit none
C ... Passed parameters
      integer job,ngabc(3),ngmx,ng
      double precision qp(3),Gmin,Gmax
C ... For structures
!      include 'structures.h'
      type(str_lat)::   s_lat
C ... Dynamically allocated arrays
      integer,pointer :: p_kv(:,:), igv(:,:)
C ... Local parameters
      double precision alat,plat(3,3),qlat(3,3),xx,t(3),qs(3),dlength
      integer jobg,job0,job16,job32,job64,jobl,job3,job4,job5,job128
      integer i,ngmxl,iprint,idq(3),igvl(3)
      integer,target :: igv0(1,1) ! a dummy array so sugvec passes bounds check
      integer n123(3),NULLI,PRTG
      parameter (NULLI=-99999,PRTG=80)
      double precision tol
      parameter (tol=1d-8)

      call tcn('sugvec')

      job0 = mod(job,1000)
      job16 = mod(job0/16,2)
      job32 = mod(job0/32,2)
      job64 = mod(job0/64,2)
      job128 = mod(job0/128,2)

      job3 = mod(job/1000,10)
      job4 = mod(job/10000,10)
      job5 = mod(job/100000,10)

      alat = s_lat%alat
      plat = s_lat%plat
      qlat = s_lat%qlat
      qs = qp

C --- Find ng = number of G vectors ---
      jobl = mod(job0,16)
      if (jobl /= 0 .and. job32+job128 == 0) call pshpr(1)

C     Case call gvlst2
      if (job16+job32+job128 /= 0) then
C       If gvlst2 should receive n123=0 as input
        if (job32+job64+job128 /= 0) then
          n123 = 0
          jobg = 100
          if (job128 /= 0) jobg = 200
        else
          n123 = ngabc
          jobg = 0
        endif
C       if (job5 /= 0) call shorbz(qp,qs,s_lat%qlat,s_lat%plat)
        if (job5 /= 0) call shorps(1,s_lat%qlat,(/2,2,2/),qp,qs)
        call gvlst2(alat,plat,qs,n123(1),n123(2),n123(3),Gmin,Gmax,
     .    0,jobg,0,ng,xx,xx,xx,xx)
        if (job64 == 0) ngabc = n123  ! Do not touch ngabc if job64

C     Case call gvlist
      else
        call gvlist(alat,plat,qp,ngabc(1),ngabc(2),ngabc(3),Gmax,
     .    100*job3,0,ng,xx,xx,xx,xx)
      endif
C ... If nothing more is sought, exit
      if (jobl == 0 .or. job32+job128 /= 0) then
        call tcx('sugvec')
        return
      endif
      call poppr

C --- Generate quantities specified by job ---
      if (job4 > 0) call sanrg(.true.,ngmx,1,NULLI,'sugvec','ngmx')
      if (ngmx <= 0) then
        ngmxl = ng
      else
        ngmxl = ngmx
      endif
      call sanrg(.true.,ngmxl,ng,NULLI,'sugvec','ngmx')

      if (jobl >= 4) then
        if (job4 == 0) call ptr_lat(s_lat,1,'gv',ngmxl,3,0,xx)
      endif
      if (mod(jobl,2) /= 0 .or. jobl >= 4) then
        if (job4 == 0) then
          call ptr_lat(s_lat,1,'kv',ngmxl,3,0,xx)
          p_kv => s_lat%kv
        endif
      endif
      if (mod(jobl,2) /= 0) then
        if (job4 == 0) call ptr_lat(s_lat,1,'igv',ngmxl,3,0,xx)
      endif
      if (mod(jobl/2,2) /= 0) then
        if (job4 == 0) call ptr_lat(s_lat,1,'kv2',ngmxl,3,0,xx)
        if (job4 == 0) call ptr_lat(s_lat,1,'igv2',3,ngmxl,0,xx)
          p_kv => s_lat%kv2
      endif

      if (job16 /= 0) then
C       job16 => n123 holds local copy of ngabc (see above)
        call pshpr(1)
        if (associated(s_lat%igv)) then
          igv => s_lat%igv
        else
          igv => igv0 ! dummy array enabling sugvec to pass bounds check
        endif
        call gvlst2(alat,plat,qs,n123(1),n123(2),n123(3),Gmin,Gmax,
     .    0,jobl,ngmxl,ng,p_kv,s_lat%gv,igv,s_lat%igv2)
        call poppr
C   ... Undo shortening of qp
        if (dlength(3,qp-qs,1) > tol) then
          do  i = 1, 3
C           xx is projection of qs-qp along qlat
            xx = (qs(1)-qp(1))*s_lat%plat(1,i) +
     .           (qs(2)-qp(2))*s_lat%plat(2,i) +
     .           (qs(3)-qp(3))*s_lat%plat(3,i)
            idq(i) = idnint(xx) ! should be integer multiples of qlat
            if (abs(idq(i)-xx) > tol) call rx('sugvec: bug in shorbz')
          enddo
          do  i = 1, ngmxl
            if (mod(jobl,2) /= 0) then
              igvl(:) = s_lat%igv(i,:) + idq(:)
            elseif (mod(jobl/2,2) /= 0) then
              igvl(:) = s_lat%igv2(:,i) + idq(:)
            endif
            if (mod(jobl,2) /= 0) s_lat%igv(i,:) = igvl(:)
            if (mod(jobl/2,2) /= 0) s_lat%igv2(:,i) = igvl(:)
            p_kv(i,1) = mod(igvl(1)+n123(1),n123(1))+1
            p_kv(i,2) = mod(igvl(2)+n123(2),n123(2))+1
            p_kv(i,3) = mod(igvl(3)+n123(3),n123(3))+1
          enddo
        endif
C       call pshpr(110)
        if (iprint() >= PRTG) then
          call dpzero(t,3)
          call gvlstp(mod(job0,2),mod(job0/2,2),alat,qlat,ngmxl,ng,qp,t,
     .      s_lat%gv,p_kv,s_lat%igv,s_lat%igv2)
        endif
C       call poppr

      else
        if (associated(s_lat%igv)) then
          igv => s_lat%igv
        else
          igv => igv0 ! dummy array enabling sugvec to pass bounds check
        endif
        call gvlist(alat,plat,qp,ngabc(1),ngabc(2),ngabc(3),Gmax,
     .    100*job3+jobl,ngmxl,ng,p_kv,s_lat%gv,igv,s_lat%igv2)
      endif
      call tcx('sugvec')

      end

      subroutine sugvec0(s_lat)
C- Set up G vectors and related quantities for q=0
C ----------------------------------------------------------------------
Cio Structures
Cio  s_lat  :struct containing lattice information; see structures.h
Ci     Elts read: nabc gmax alat plat qlat kv kv2
Co     Stored:    ng gmax nabc
Co     Allocated: gv kv igv kv2 igv2
Cio    Elts Passed:gv igv igv2
Cio    Passed to: sugvec
Ci Inputs
Cr Remarks
Cb Bugs
Cb   Should be a special set of arrays assigned to q=0
Cu Updates
Cu   21 Oct 12 First created
C ----------------------------------------------------------------------
      use structures
      implicit none
C ... Passed parameters
C ... For structures
!      include 'structures.h'
      type(str_lat)::   s_lat
C ... Local parameters
      integer ng,ngabc(3),n1,n2,n3
      double precision gmax,qp(3)
      equivalence (n1,ngabc(1)),(n2,ngabc(2)),(n3,ngabc(3))

      call dpzero(qp,3)
      ngabc = s_lat%nabc
      gmax = s_lat%gmax
      call sugvec(s_lat,8,qp,0d0,gmax,ngabc,0,ng)
      s_lat%ng = ng
      s_lat%gmax = gmax  ! This may have been updated
      s_lat%nabc = ngabc ! This may have been updated

      end
