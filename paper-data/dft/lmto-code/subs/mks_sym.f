      integer function mks_sym(mode,plat,g,ag,nsgrp,nbas,pos,nl,s_sym)
C- Given space group data (ng,g,ag) fill out symmetry group structure
C ----------------------------------------------------------------------
Cio Structures
Cio  s_sym  :struct containing space group info; see structures.h
Ci     Elts read: rg ag inv prg
Co     Stored:    prg pag mib tib inv ag
Cr              : rg is identical to g in Remarks
Cr              : prg is identical to G in Remarks
Cr              : pag is identical to A in Remarks
Cr              : inv is the index to the inverse of the present group op
Cr              : mib(ib) atom ib is mapped to mib(ib) under grp op ig
Cr              : Equivalent to istab(ib,ig) generated by symtbl for mode=0
Cr              : tib(ib): translation needed to shift rotated ib to mib(ib):
Cr              : tib(:,ib) = [g(ig) pos(:,ib) + ag(ig)] - pos(:,mib(ib)))
Co     Allocated: *
Cio    Elts Passed:rg ag
Cio    Passed to: *
Ci Inputs
Ci   mode  :1s digit
Ci         :0 do nothing
Ci         :1 g,ag are given; fill out s_sym
Ci         :10s digit
Ci         :1 attempt to make translation part a rational number
Ci         :100s digit
Ci         :1 For each group op g, append to s_sym new operation I*g,
Ci         :  if the inversion is not found among g.
Ci         :  NB: it is the caller's responsibility to dimension
Ci         :  s_sym with at least 2*nsgrp elements.
Ci         :1000s digit
Ci         :0 s_sym%mib, s_sym%tib are not touched
Ci         :1 Allocate and generate mib, tib
Ci         :10000s digit
Ci         :0 Do not make matrices for rotating Y_lm
Ci         :1 Make matrices for rotating Y_lm, real form of spherical harmonics
Ci         :2 Make matrices for rotating Y_lm, true spherical harmonics
Ci   g     :point group operations
Ci   ag    :translation part of space group
Ci   nsgrp :number of space group operations
Ci   nbas  :size of basis (needed only if 1000s digit mode is set)
Ci   pos   :basis vectors (needed only if 1000s digit mode is set)
Co Outputs
Co   mks_sym: index to which the inversion operation, if it is among
Co            the given group operations; else 0.
Cl Local variables
Cl  invrs  :index to which element of g is inversion
Cl         :0 => no inversion operation
Cr Remarks
Cr  *If g is a point group operation in cartesian coordinates
Cr   and b is some vector, then g rotates b into b':
Cr     b' = g b + a
Cr   a is the translation part
Cr   If B and B' are the corresponding vectors in units of P
Cr     b = P B; b' = P B'
Cr   Then
Cr     P B' = g P B + a
Cr     B' = P^-1 g P B + P^-1 a = G B + A where
Cr     G = P^-1 g P  and A = P^-1 a
Cr
Cr  *Inverse operation
Cr     b' = g b + a => b = g^-1 b' - g^-1 a
Cr   Note that if gi = g^-1 then Gi = P^-1 gi P = G^-1 since:
Cr     G^-1 = [P^-1 g P]^-1 = P^-1 g^-1 P = P^-1 gi P
Cr
Cr  *Relation between inverse and transpose.
Cr   If g is a proper or improper rotation, g+ = g^-1, or g = g+^-1
Cr
Cr   Note that the relation is modified for G = P^-1 g P .
Cr   Let gi = g^-1 => gi = g+, and G = P^-1 g P and Gi = P^-1 gi P
Cr   Then :
Cr     g = gi+ = [P Gi P^-1]+ = P+^-1 Gi+ P+
Cr     G = P^-1 g P = P^-1 P+^-1 Gi+ P+ P = (P+P)^-1 Gi+ (P+P)
Cr   Thus only if P+ = P^-1 (a rotation) does G+ = Gi
Cr
Cr  *Group operations on reciprocal lattice vectors K
Cr     Let K_j and T_k be recip and real lattice vectors
Cr     Let K and T be matrix forms of K_j and T_k.
Cr     Let Mjk = K_j . T_k = K+ . T
Cr     Insert point operation R:
Cr       M = K+ (R^-1 R) T = (R+^-1 K)+ (R T)
Cr     K is then rotated to R+^-1 K.
Cr     If R+^-1 = R (see above) this reduces to (R K) (R T)
Cr     So for g in cartesian coordinates, T and K rotated by the same R
Cr     When G is in coordinates of P, K is rotated by R+^-1.
Cu Updates
Cu   22 Jun 13 Bug fix, case supercell and > 1 translation vector per g
Cu   01 Feb 13 mib,tib,rotylm optionally generated
Cu   02 May 12 First created
C ----------------------------------------------------------------------
      use pointers
      use structures
      implicit none
C ... Passed parameters
      integer mode,nsgrp,nbas,nl
      real(8) :: g(3,3,nsgrp), ag(3,nsgrp), plat(3,3), pos(3,nbas)
C ... For structures
!      include 'structures.h'

      type(str_symops)::  s_sym(nsgrp)
C ... Local parameters
      integer ib,ig,jg,i,j,k,mode0,mode1,mode2,mode3,mode4,morder
      integer nl2,invrs,npgrp,NULLI
C     integer ib,jb,i1,i2,i3
      double precision tol,xx,roundp
      double precision plati(3,3),wk1(3,3),wk2(3,3),qlat(3,3) !,tran(3)
      logical lifinv
      integer,allocatable:: istab(:,:)
      real(8),allocatable:: trtab(:,:,:),wk(:,:)
      parameter (tol=1d-6,NULLI=-99999)
C     double precision yl(nl*nl)
C      double precision xv(3)
C      integer ixv(3)
      procedure(logical) :: latvec

      mode0 = mod(mode,10)
      mode1 = mod(mode/10,10)
      mode2 = mod(mode/100,10)
      mode3 = mod(mode/1000,10)
      mode4 = mod(mode/10000,10)
      call lmorder(0,morder,[0],[0])

C      print *, '!!'
CC      ag(:,2) = ag(:,2) + plat(:,3)
CC      ag(:,4) = ag(:,4) + plat(:,3)
C       ag(:,2) = ag(:,2) + plat(:,1) + plat(:,2)
C       ag(:,3) = ag(:,3) + plat(:,1) + plat(:,3)
C       ag(:,4) = ag(:,4) + plat(:,2)
C       ag(:,6) = ag(:,6) + plat(:,3)
C       ag(:,10) = ag(:,10) + plat(:,1)
C       ag(:,11) = ag(:,11) + plat(:,1) + plat(:,2)
C       ag(:,12) = ag(:,12) + plat(:,2)

C    ... debugging Te case
C       q= 0.33333333333333331,0.19245008972987532,0.14671361502347421
C     ->q=-0.33333333333333331,0.19245008972987532,0.14671361502347421
c       under R3Z
C      call ropyln(1,1d0/3d0,0.19245008972987532d0,
C     .  0.14671361502347421d0,nl-1,1,yl,xx)
C      call prmx('yl(q)',yl,nl**2,nl**2,1)
C      call ropyln(1,-1d0/3d0,0.19245008972987532d0,
C     .  0.14671361502347421d0,nl-1,1,yl,xx)
C      call prmx('yl(Rq)',yl,nl**2,nl**2,1)

      invrs = 0
      if (mode0 == 0) goto 99

C     call prmx('plat',plat,3,3,3)
C     call prmx('g',g(1,1,4),3,3,3)

C     plati = (plat)^-1
      call dinv33(plat,0,plati,wk1)
      call dinv33(plat,1,qlat,wk1)

C --- For each group operation, do ---
      do  ig = 1, nsgrp

C  ...  Copy g, ag into structure
        call dcopy(9,g(1,1,ig),1,s_sym(ig)%rg,1)
        call dcopy(3,ag(1,ig),1,s_sym(ig)%ag,1)

C  ...  Make symop G = P^-1 g P
        call dgemm('N','N',3,3,3,1d0,plati,3,g(1,1,ig),3,0d0,wk1,3)
        call dgemm('N','N',3,3,3,1d0,wk1,3,plat,3,0d0,wk2,3)  ! G = P^-1 g P
C       Check that it is an integer array
        lifinv = .true. ! assume it's the inversion
        do  i = 1, 3
          do  j = 1, 3
            k = nint(wk2(i,j))
            if (abs(k-wk2(i,j)) > tol) call rx1
     .      ('mks_sym: symop %i is not consistent with lattice vectors',
     .        ig)
            s_sym(ig)%prg(i,j) = k
            if (i == j .and. k /= -1) lifinv = .false.
            if (i /= j .and. k /= 0) lifinv = .false.
          enddo
        enddo
C       Set flag if this operation is the inversion
        if (lifinv) invrs = ig

C  ...  Make translation part A = P^-1 ag
        call dgemm('N','N',3,1,3,1d0,plati,3,ag(1,ig),3,0d0,wk1,3)
        do  i = 1, 3
          if (mode1 == 0) then
            xx = wk1(i,1)
          else
            xx = roundp(wk1(i,1),tol)
          endif
          s_sym(ig)%pag(i) = xx
        enddo
      enddo

C     call prmi('pg',s_sym(4)%prg,3,3,3)

C --- For each group op, find its inverse.  Possibly generate mib,tib ---
      do  ig = 1, nsgrp

C       wk2 = rotation part; wk1(:,2) = Translation part -g^-1 ag of inverse
        call dinv33(g(1,1,ig),0,wk2,xx)
        call dgemm('N','N',3,1,3,-1d0,wk2,3,ag(1,ig),3,0d0,wk1(1,2),3)

        do  jg = 1, nsgrp
          do  i = 1, 3
            do  j = 1, 3
              if (abs(wk2(i,j)-s_sym(jg)%rg(i,j)) > tol) goto 10
            enddo
          enddo
C         Point group matches; next check translation part
          wk1(1:3,1) = wk1(1:3,2) - s_sym(jg)%ag
          if (latvec(1,tol,qlat,wk1)) then  ! Same, up to a lattice vector
            s_sym(ig)%inv = jg
C           Substitute given translation with actual inverse?
C           s_sym(jg)%ag = wk1(1:3,2)
            goto 20
          endif
   10     continue  ! jg and ig are not inverses of each other
        enddo
C       No jg matched inverse to ig => abort
        call rx1('mks_sym: inverse to group op %i not found',ig)
   20   continue

      enddo ! loop over ig

C ... Permutation and translation tables
      if (mode3 /= 0) then
C       call prmx('pos',pos,3,3,nbas)
        allocate(istab(nbas,nsgrp+1),trtab(3,nbas,nsgrp+1))
        call symtbl(20,tol,nbas,xx,pos,g,ag,nsgrp,qlat,istab,trtab)
C       Allocate and fill mib,tib.  Adapted from symtbl
        do  ig = 1, nsgrp
          allocate(p_i1(nbas)); s_sym(ig)%mib => p_i1
          allocate(p_d2(3,nbas)); s_sym(ig)%tib => p_d2
          do  ib = 1, nbas
            s_sym(ig)%mib(ib) = istab(ib,ig)
            s_sym(ig)%tib(:,ib) = trtab(:,ib,ig)
          enddo
C         Debugging check
C          call info0(1,0,0,' check relation'//
C     .      ' bas(mib(ibs,ig)) + tib(ib,ig) = matmul(symop(ig),bas(ib)) + delta(ig)')
C          do  ib = 1, nbas
C            tran = matmul(g(:,:,ig),pos(:,ib)) + ag(:,ig)
C            tran = tran - (pos(:,s_sym(ig)%mib(ib)) + s_sym(ig)%tib(:,ib))  ! This should be zero
C            print 555, ib, tran + pos(:,s_sym(ig)%mib(ib)), tran
C  555       format(i4,3f12.6,2x,3f12.6)
C            if (sqrt(tran(1)**2+tran(2)**2+tran(3)**2) .gt. 1d-6) call rx('oops')
C          enddo
        enddo
        deallocate(istab,trtab)
      else
        do  ig = 1, nsgrp
          nullify(s_sym(ig)%mib,s_sym(ig)%tib)
        enddo
      endif

C ... Matrices that rotate spherical harmonics
      if (mode4 /= 0 .and. nl > 0) then
        nl2 = nl*nl
        do  ig = 1, nsgrp
          allocate(p_d2(nl2,nl2))
          if (mode4 == 2) then
            allocate(p_d2(nl2,nl2*2)); s_sym(ig)%rotylm => p_d2
            allocate(wk(nl2,nl2))
            call ylmrtg(nl2,s_sym(ig)%rg,wk)
            call s2sph(2+100*morder,nl,nl,wk,nl2,nl2,nl2,nl2,s_sym(ig)%rotylm)
C           print *, 'ig',ig
C           call yprm('rmat',4,s_sym(ig)%rotylm,nl2**2,nl2,nl2,nl2)
            call ztoyy(s_sym(ig)%rotylm,nl2,nl2,nl2,nl2,2,1)
C           call yprm('rmat',3,s_sym(ig)%rotylm,1,nl2,nl2,nl2)
            deallocate(wk)
          else
            allocate(p_d2(nl2,nl2)); s_sym(ig)%rotylm => p_d2
            call ylmrtg(nl2,s_sym(ig)%rg,s_sym(ig)%rotylm)
C            print *, 'ig',ig
C            call prmx('rmat',s_sym(ig)%rotylm,nl2,nl2,nl2)
          endif
        enddo
      endif

C --- Append inversion to space group ---
      npgrp = nsgrp
      if (mode2 /= 0 .and. invrs == 0) then
        do  ig = 1, nsgrp
          jg = ig+nsgrp
          s_sym(jg)%rg  = -s_sym(ig)%rg
          s_sym(jg)%ag  =  NULLI ! This is not meaningful
          s_sym(jg)%inv =  s_sym(ig)%inv + nsgrp
          s_sym(jg)%prg = -s_sym(ig)%prg
          s_sym(jg)%pag =  NULLI ! This is not meaningful
        enddo
        npgrp = 2*nsgrp
      endif

C     Sanity checks (should not be needed)
      do  ig = 1, npgrp
        jg = s_sym(ig)%inv
C       if jg is inverse of ig, ig should be inverse of jg
        if (s_sym(jg)%inv /= ig) call rx('mks_sym: bug')
C       Verify that g^-1 = g+
        do  i = 1, 3
          do  j = 1, 3
C           This is not in general true; see Remarks
C           if (abs(s_sym(ig)%prg(i,j)-s_sym(jg)%prg(j,i)) > tol)
            if (abs(s_sym(ig)%rg(i,j)-s_sym(jg)%rg(j,i)) > tol)
     .        call rx('mks_sym: bug')
          enddo
        enddo

C   ... debugging printout (for check against kotani)
C        write(*,2) s_sym(ig)%ag
C    2   format('  Obtained translation operation=',3d12.4)
C        do  ib = 1, nbas
C          call dmpy31(10,qlat,s_sym(ig)%tib(1,ib),xv)
C          ixv = nint(xv)
C          write(*,3) ib, s_sym(ig)%mib(ib),s_sym(ig)%tib(:,ib), ixv
C    3     format(' ibas=',i3,' miat=',i3,' tiat=',3f11.4,' i1i2i3=',3i3)
C        enddo

      enddo

C     Exeunt
   99 continue
      mks_sym = invrs

      end
C Notes.  Kotani wrote a similar routine mptauof; see ltests.  To test compatibility
C uncomment call to mptauof in mksym and make lmf with this:
C make SUBS='mksym.o mptauof.o shoist.o mks_sym.o' lmf
C Look at output.  In detail use debugging points
C stop at "mptauof.f":46; run  te -vminx=0 --rs=0,1 -vnk=3 -vnit=20 -vlf1=4 -vlmxl=4 -vnk=3 -vngd=20 -vkmx=3 -vconv=1d-4 --iactiv -vles=t --shorten=no; c; p ig ; stop at "mptauof.f":86; stop at "mptauof.f":119
C stop at "mptauof.f":119; stop at "mptauof.f":124
C
C make 'SUBS=iprint.o wkdbg.o prmx.o sugw.o mks_sym.o xx.o symtbl.o grpfnd.o' lmfgwd
C Look at output.  In detail use debugging points
C si symtbl; run te --rs=0,1 -vnk=3 -vnit=20 -vlf1=4 -vlmxl=4 -vnk=3 -vngd=20 -vkmx=3 -vconv=1d-4 --iactiv -vles=t --shorten=no; c ; stop at "symtbl.f":64; c; c
